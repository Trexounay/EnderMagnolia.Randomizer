#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Zion

#include "Basic.hpp"

#include "Zion_classes.hpp"
#include "Zion_parameters.hpp"


namespace SDK
{

// Function Zion.AbilityEffect.OnInitialize_BP
// (Event, Protected, BlueprintEvent)

void UAbilityEffect::OnInitialize_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEffect", "OnInitialize_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.AbilityEffect.GetAbilityForward
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAbilityEffect::GetAbilityForward() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEffect", "GetAbilityForward");

	Params::AbilityEffect_GetAbilityForward Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AbilityEffect.GetAbilityLocation
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAbilityEffect::GetAbilityLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEffect", "GetAbilityLocation");

	Params::AbilityEffect_GetAbilityLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AbilityEffect.GetSource
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAbilityEffect::GetSource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEffect", "GetSource");

	Params::AbilityEffect_GetSource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AbilityEffect.GetSourceLocation
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAbilityEffect::GetSourceLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEffect", "GetSourceLocation");

	Params::AbilityEffect_GetSourceLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AbilityEffect.GetTarget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAbilityEffect::GetTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEffect", "GetTarget");

	Params::AbilityEffect_GetTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AbilityEffect.GetTargetForward
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAbilityEffect::GetTargetForward() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEffect", "GetTargetForward");

	Params::AbilityEffect_GetTargetForward Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AbilityEffect.GetTargetLocation
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAbilityEffect::GetTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEffect", "GetTargetLocation");

	Params::AbilityEffect_GetTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AbilityEffect.GetToTargetDirection
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDirectionSource                        DirectionSource                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Axis                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAbilityEffect::GetToTargetDirection(EDirectionSource DirectionSource, const struct FVector& Axis) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEffect", "GetToTargetDirection");

	Params::AbilityEffect_GetToTargetDirection Parms{};

	Parms.DirectionSource = DirectionSource;
	Parms.Axis = std::move(Axis);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AbilityEffect.IsFrontalAbility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilityEffect::IsFrontalAbility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEffect", "IsFrontalAbility");

	Params::AbilityEffect_IsFrontalAbility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AbilityEffectInstant.OnApplyEffect
// (Native, Event, Protected, BlueprintEvent)

void UAbilityEffectInstant::OnApplyEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEffectInstant", "OnApplyEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EventAction_OpenUI.OnWidgetDestruct
// (Final, Native, Private)

void UEventAction_OpenUI::OnWidgetDestruct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventAction_OpenUI", "OnWidgetDestruct");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AbilityEffectTimed.OnStart
// (Native, Event, Protected, BlueprintEvent)

void UAbilityEffectTimed::OnStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEffectTimed", "OnStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AbilityEffectTimed.OnUpdate
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  out_ConsumedDeltaTime                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilityEffectTimed::OnUpdate(float DeltaTime, float* out_ConsumedDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEffectTimed", "OnUpdate");

	Params::AbilityEffectTimed_OnUpdate Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ConsumedDeltaTime != nullptr)
		*out_ConsumedDeltaTime = Parms.out_ConsumedDeltaTime;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossBaseComponent.BossActivation
// (Native, Protected)
// Parameters:
// class AEnemySpawner*                    EnemySpawner                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URecollectionBossBaseComponent::BossActivation(class AEnemySpawner* EnemySpawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "BossActivation");

	Params::RecollectionBossBaseComponent_BossActivation Parms{};

	Parms.EnemySpawner = EnemySpawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.BossDeathEnd
// (Native, Protected)
// Parameters:
// class AEnemySpawner*                    EnemySpawner                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URecollectionBossBaseComponent::BossDeathEnd(class AEnemySpawner* EnemySpawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "BossDeathEnd");

	Params::RecollectionBossBaseComponent_BossDeathEnd Parms{};

	Parms.EnemySpawner = EnemySpawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.BossDeathEndPostDelay
// (Native, Protected)

void URecollectionBossBaseComponent::BossDeathEndPostDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "BossDeathEndPostDelay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.BossDeathStart
// (Native, Protected)
// Parameters:
// class AEnemySpawner*                    EnemySpawner                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URecollectionBossBaseComponent::BossDeathStart(class AEnemySpawner* EnemySpawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "BossDeathStart");

	Params::RecollectionBossBaseComponent_BossDeathStart Parms{};

	Parms.EnemySpawner = EnemySpawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.ExitRecollectionMode
// (Native, Protected, BlueprintCallable)

void URecollectionBossBaseComponent::ExitRecollectionMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "ExitRecollectionMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.ExitRecollectionMode_PostFadeOut
// (Final, Native, Protected)

void URecollectionBossBaseComponent::ExitRecollectionMode_PostFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "ExitRecollectionMode_PostFadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.Finish
// (Native, Public, BlueprintCallable)

void URecollectionBossBaseComponent::Finish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "Finish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.GameMapChange
// (Native, Protected)

void URecollectionBossBaseComponent::GameMapChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "GameMapChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.InstantiateRetryDialog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URecollectionBossBaseComponent::InstantiateRetryDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "InstantiateRetryDialog");

	Params::RecollectionBossBaseComponent_InstantiateRetryDialog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossBaseComponent.OnDialogClosed
// (Final, Native, Protected)

void URecollectionBossBaseComponent::OnDialogClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "OnDialogClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.OnRetryDialogNo
// (Native, Protected)

void URecollectionBossBaseComponent::OnRetryDialogNo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "OnRetryDialogNo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.OnRetryDialogYes
// (Native, Protected)

void URecollectionBossBaseComponent::OnRetryDialogYes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "OnRetryDialogYes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.RetryRecollectionMode
// (Native, Protected, BlueprintCallable)

void URecollectionBossBaseComponent::RetryRecollectionMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "RetryRecollectionMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.RetryRecollectionMode_PostFadeOut
// (Final, Native, Protected)

void URecollectionBossBaseComponent::RetryRecollectionMode_PostFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "RetryRecollectionMode_PostFadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.SetNewGameGenerationOverride
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   GenerationOverride                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URecollectionBossBaseComponent::SetNewGameGenerationOverride(int32 GenerationOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "SetNewGameGenerationOverride");

	Params::RecollectionBossBaseComponent_SetNewGameGenerationOverride Parms{};

	Parms.GenerationOverride = GenerationOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.Start
// (Native, Public, BlueprintCallable)

void URecollectionBossBaseComponent::Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossBaseComponent.CanLeaveRecollectionBoss
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URecollectionBossBaseComponent::CanLeaveRecollectionBoss() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "CanLeaveRecollectionBoss");

	Params::RecollectionBossBaseComponent_CanLeaveRecollectionBoss Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossBaseComponent.GetCachedEnemySpawner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEnemySpawner*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEnemySpawner* URecollectionBossBaseComponent::GetCachedEnemySpawner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "GetCachedEnemySpawner");

	Params::RecollectionBossBaseComponent_GetCachedEnemySpawner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossBaseComponent.GetNewGameGenerationOverride
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URecollectionBossBaseComponent::GetNewGameGenerationOverride() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "GetNewGameGenerationOverride");

	Params::RecollectionBossBaseComponent_GetNewGameGenerationOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossBaseComponent.IsStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URecollectionBossBaseComponent::IsStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossBaseComponent", "IsStarted");

	Params::RecollectionBossBaseComponent_IsStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossRushComponent.ClearBossRush
// (Final, Native, Public, BlueprintCallable)

void URecollectionBossRushComponent::ClearBossRush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "ClearBossRush");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossRushComponent.GameMapChangePostFade
// (Final, Native, Protected)

void URecollectionBossRushComponent::GameMapChangePostFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "GameMapChangePostFade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossRushComponent.GetMaxBossesDefeatedCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URecollectionBossRushComponent::GetMaxBossesDefeatedCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "GetMaxBossesDefeatedCount");

	Params::RecollectionBossRushComponent_GetMaxBossesDefeatedCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossRushComponent.GetRecordData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             RecordIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRecollectionBossRushRecordData  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRecollectionBossRushRecordData URecollectionBossRushComponent::GetRecordData(const int32 RecordIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "GetRecordData");

	Params::RecollectionBossRushComponent_GetRecordData Parms{};

	Parms.RecordIndex = RecordIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossRushComponent.GoToNextBoss
// (Final, Native, Public, BlueprintCallable)

void URecollectionBossRushComponent::GoToNextBoss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "GoToNextBoss");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossRushComponent.OnClearBossRush
// (Event, Public, BlueprintEvent)

void URecollectionBossRushComponent::OnClearBossRush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "OnClearBossRush");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.RecollectionBossRushComponent.OnEndBossRush
// (Event, Public, BlueprintEvent)

void URecollectionBossRushComponent::OnEndBossRush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "OnEndBossRush");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.RecollectionBossRushComponent.OnGameMapChanged
// (Event, Protected, BlueprintEvent)

void URecollectionBossRushComponent::OnGameMapChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "OnGameMapChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.RecollectionBossRushComponent.OnGameMapChangedPostFade
// (Event, Protected, BlueprintEvent)

void URecollectionBossRushComponent::OnGameMapChangedPostFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "OnGameMapChangedPostFade");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.RecollectionBossRushComponent.OnSetTimerPaused
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsPaused                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URecollectionBossRushComponent::OnSetTimerPaused(bool bIsPaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "OnSetTimerPaused");

	Params::RecollectionBossRushComponent_OnSetTimerPaused Parms{};

	Parms.bIsPaused = bIsPaused;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.RecollectionBossRushComponent.OnStartBossRush
// (Event, Public, BlueprintEvent)

void URecollectionBossRushComponent::OnStartBossRush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "OnStartBossRush");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.RecollectionBossRushComponent.ResetCurrentRecords
// (Final, Native, Public, BlueprintCallable)

void URecollectionBossRushComponent::ResetCurrentRecords()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "ResetCurrentRecords");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RecollectionBossRushComponent.SetTimerPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsPaused                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URecollectionBossRushComponent::SetTimerPaused(bool bIsPaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "SetTimerPaused");

	Params::RecollectionBossRushComponent_SetTimerPaused Parms{};

	Parms.bIsPaused = bIsPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossRushComponent.TryAddNewRecord
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRecollectionBossRushRecordData&NewRecordData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URecollectionBossRushComponent::TryAddNewRecord(const struct FRecollectionBossRushRecordData& NewRecordData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "TryAddNewRecord");

	Params::RecollectionBossRushComponent_TryAddNewRecord Parms{};

	Parms.NewRecordData = std::move(NewRecordData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossRushComponent.CanUpdateTime
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URecollectionBossRushComponent::CanUpdateTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "CanUpdateTime");

	Params::RecollectionBossRushComponent_CanUpdateTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossRushComponent.GetBossRushDifficultyPreset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDifficultyPreset                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDifficultyPreset URecollectionBossRushComponent::GetBossRushDifficultyPreset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "GetBossRushDifficultyPreset");

	Params::RecollectionBossRushComponent_GetBossRushDifficultyPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossRushComponent.GetBossRushTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URecollectionBossRushComponent::GetBossRushTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "GetBossRushTime");

	Params::RecollectionBossRushComponent_GetBossRushTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossRushComponent.GetCurrentBossIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URecollectionBossRushComponent::GetCurrentBossIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "GetCurrentBossIndex");

	Params::RecollectionBossRushComponent_GetCurrentBossIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossRushComponent.IsTimerPaused
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URecollectionBossRushComponent::IsTimerPaused() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "IsTimerPaused");

	Params::RecollectionBossRushComponent_IsTimerPaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RecollectionBossRushComponent.ShouldDisplayRecollectionBossRush
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URecollectionBossRushComponent::ShouldDisplayRecollectionBossRush() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecollectionBossRushComponent", "ShouldDisplayRecollectionBossRush");

	Params::RecollectionBossRushComponent_ShouldDisplayRecollectionBossRush Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CommandModule.OnFinish
// (Native, Event, Protected, BlueprintEvent)

void UCommandModule::OnFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandModule", "OnFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CommandModule.OnInitialize
// (Native, Event, Protected, BlueprintEvent)

void UCommandModule::OnInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandModule", "OnInitialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CommandModule.OnReset
// (Native, Event, Protected, BlueprintEvent)

void UCommandModule::OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandModule", "OnReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CommandModule.OnStart
// (Native, Event, Protected, BlueprintEvent)

void UCommandModule::OnStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandModule", "OnStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CommandModule.GetCharacter
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UCommandModule::GetCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandModule", "GetCharacter");

	Params::CommandModule_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CommandModule.GetCommand
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCommand*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommand* UCommandModule::GetCommand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandModule", "GetCommand");

	Params::CommandModule_GetCommand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CommandModule.GetExecutionTime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCommandModule::GetExecutionTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandModule", "GetExecutionTime");

	Params::CommandModule_GetExecutionTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.OrientFromFloorComponent.OnFacingChange
// (Final, Native, Private)

void UOrientFromFloorComponent::OnFacingChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrientFromFloorComponent", "OnFacingChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Ability.OnInitialize_BP
// (Event, Protected, BlueprintEvent)

void AAbility::OnInitialize_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability", "OnInitialize_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.Ability.OnLaunch_BP
// (Event, Protected, BlueprintEvent)

void AAbility::OnLaunch_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability", "OnLaunch_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.Ability.OnReset_BP
// (Event, Protected, BlueprintEvent)

void AAbility::OnReset_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability", "OnReset_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.Ability.OnSourceDeath
// (Final, Native, Private)

void AAbility::OnSourceDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability", "OnSourceDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Ability.OnStop_BP
// (Event, Protected, BlueprintEvent)

void AAbility::OnStop_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability", "OnStop_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.Ability.RequestAbort
// (Final, Native, Public, BlueprintCallable)

void AAbility::RequestAbort()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability", "RequestAbort");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Ability.RequestStop
// (Final, Native, Public, BlueprintCallable)

void AAbility::RequestStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability", "RequestStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Ability.GetExecutionTime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AAbility::GetExecutionTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability", "GetExecutionTime");

	Params::Ability_GetExecutionTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Ability.GetSource
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AAbility::GetSource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability", "GetSource");

	Params::Ability_GetSource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Ability.GetWeightCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAbilityWeightCategory                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAbilityWeightCategory AAbility::GetWeightCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability", "GetWeightCategory");

	Params::Ability_GetWeightCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Command.OnCanBeStarted
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommand::OnCanBeStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "OnCanBeStarted");

	Params::Command_OnCanBeStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Command.OnFinish
// (Event, Protected, BlueprintEvent)
// Parameters:
// ECommandFinishType                      FinishType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommand::OnFinish(ECommandFinishType FinishType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "OnFinish");

	Params::Command_OnFinish Parms{};

	Parms.FinishType = FinishType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.Command.OnInitialize
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                            PawnOwner                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommand::OnInitialize(class APawn* PawnOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "OnInitialize");

	Params::Command_OnInitialize Parms{};

	Parms.PawnOwner = PawnOwner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.Command.OnPreStart
// (Event, Protected, BlueprintEvent)

void UCommand::OnPreStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "OnPreStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.Command.OnReset
// (Event, Protected, BlueprintEvent)

void UCommand::OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "OnReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.Command.OnStart
// (Event, Protected, BlueprintEvent)

void UCommand::OnStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "OnStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.Command.GetCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UCommand::GetCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "GetCharacter");

	Params::Command_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Command.GetCommandCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECommandCategory                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECommandCategory UCommand::GetCommandCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "GetCommandCategory");

	Params::Command_GetCommandCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Command.GetCommandLayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECommandLayerType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECommandLayerType UCommand::GetCommandLayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "GetCommandLayer");

	Params::Command_GetCommandLayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Command.GetExecutionTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCommand::GetExecutionTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "GetExecutionTime");

	Params::Command_GetExecutionTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Command.GetInputSnapshot
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FInputSnapshot             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FInputSnapshot UCommand::GetInputSnapshot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "GetInputSnapshot");

	Params::Command_GetInputSnapshot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Command.GetInvokedInputAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UInputAction*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UInputAction* UCommand::GetInvokedInputAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "GetInvokedInputAction");

	Params::Command_GetInvokedInputAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Command.GetModule
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UCommandModule>       CommandModuleClass                                     (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnsureIfMissing                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCommandModule*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommandModule* UCommand::GetModule(TSubclassOf<class UCommandModule> CommandModuleClass, bool bEnsureIfMissing) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "GetModule");

	Params::Command_GetModule Parms{};

	Parms.CommandModuleClass = CommandModuleClass;
	Parms.bEnsureIfMissing = bEnsureIfMissing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Command.GetMovementComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMovementComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMovementComponent* UCommand::GetMovementComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "GetMovementComponent");

	Params::Command_GetMovementComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Command.GetPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UCommand::GetPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "GetPawn");

	Params::Command_GetPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Command.GetSourceCommandSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UCommandSet*                ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UCommandSet* UCommand::GetSourceCommandSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "GetSourceCommandSet");

	Params::Command_GetSourceCommandSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Command.IsInvokedInputPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommand::IsInvokedInputPressed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command", "IsInvokedInputPressed");

	Params::Command_IsInvokedInputPressed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatusEffect.GetDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStatusEffect::GetDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetDuration");

	Params::StatusEffect_GetDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatusEffect.GetStatusEffectType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EStatusEffectType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStatusEffectType UStatusEffect::GetStatusEffectType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetStatusEffectType");

	Params::StatusEffect_GetStatusEffectType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AbilityHitboxTarget.GetTarget
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AAbilityHitboxTarget::GetTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityHitboxTarget", "GetTarget");

	Params::AbilityHitboxTarget_GetTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameStatsComponent.SetPause
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameStatsComponent::SetPause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStatsComponent", "SetPause");

	Params::GameStatsComponent_SetPause Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameStatsComponent.UnsetPause
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameStatsComponent::UnsetPause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStatsComponent", "UnsetPause");

	Params::GameStatsComponent_UnsetPause Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameStatsComponent.GetPlayTimeAsString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGameStatsComponent::GetPlayTimeAsString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStatsComponent", "GetPlayTimeAsString");

	Params::GameStatsComponent_GetPlayTimeAsString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DeathProcess.Destroy
// (Native, Event, Public, BlueprintEvent)

void UDeathProcess::Destroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathProcess", "Destroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DeathProcess.FinishProcess
// (Final, Native, Protected, BlueprintCallable)

void UDeathProcess::FinishProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathProcess", "FinishProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DeathProcess.Initialize
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeathProcess::Initialize(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathProcess", "Initialize");

	Params::DeathProcess_Initialize Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DeathProcess.Launch
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeathProcess::Launch(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathProcess", "Launch");

	Params::DeathProcess_Launch Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DeathProcess.OnFinish
// (Native, Event, Public, BlueprintEvent)

void UDeathProcess::OnFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathProcess", "OnFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DeathProcess.Update
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeathProcess::Update(class AActor* Actor, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathProcess", "Update");

	Params::DeathProcess_Update Parms{};

	Parms.Actor = Actor;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DeathProcess_Animation.OnDeathAnimationFinished
// (Final, Native, Private)

void UDeathProcess_Animation::OnDeathAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathProcess_Animation", "OnDeathAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CommandCondition.OnInitialize
// (Native, Event, Protected, BlueprintEvent)

void UCommandCondition::OnInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandCondition", "OnInitialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CommandCondition.GetCharacter
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UCommandCondition::GetCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandCondition", "GetCharacter");

	Params::CommandCondition_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CommandCondition.GetCommand
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCommand*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommand* UCommandCondition::GetCommand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandCondition", "GetCommand");

	Params::CommandCondition_GetCommand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CommandCondition.OnCheckCondition
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommandCondition::OnCheckCondition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandCondition", "OnCheckCondition");

	Params::CommandCondition_OnCheckCondition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.ChangeExplanationText
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const class FText&                      InExplanationText                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidgetZion::ChangeExplanationText(const class FText& InExplanationText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "ChangeExplanationText");

	Params::UserWidgetZion_ChangeExplanationText Parms{};

	Parms.InExplanationText = std::move(InExplanationText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetZion.OnChildFocused
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UNativeWidgetHost*                FocusedWidgetHost                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFocusEvent&               FocusEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidgetZion::OnChildFocused(class UNativeWidgetHost* FocusedWidgetHost, const struct FFocusEvent& FocusEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnChildFocused");

	Params::UserWidgetZion_OnChildFocused Parms{};

	Parms.FocusedWidgetHost = FocusedWidgetHost;
	Parms.FocusEvent = std::move(FocusEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetZion.OnDownLeft
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnDownLeft(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnDownLeft");

	Params::UserWidgetZion_OnDownLeft Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnDownNext
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnDownNext(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnDownNext");

	Params::UserWidgetZion_OnDownNext Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnDownNextAlt
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnDownNextAlt(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnDownNextAlt");

	Params::UserWidgetZion_OnDownNextAlt Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnDownPrevious
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnDownPrevious(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnDownPrevious");

	Params::UserWidgetZion_OnDownPrevious Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnDownPreviousAlt
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnDownPreviousAlt(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnDownPreviousAlt");

	Params::UserWidgetZion_OnDownPreviousAlt Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnDownRight
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnDownRight(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnDownRight");

	Params::UserWidgetZion_OnDownRight Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnPressCancel
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnPressCancel(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnPressCancel");

	Params::UserWidgetZion_OnPressCancel Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnPressConfirm
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnPressConfirm(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnPressConfirm");

	Params::UserWidgetZion_OnPressConfirm Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnPressContext
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnPressContext(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnPressContext");

	Params::UserWidgetZion_OnPressContext Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnPressContextAlt
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnPressContextAlt(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnPressContextAlt");

	Params::UserWidgetZion_OnPressContextAlt Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnPressDown
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnPressDown(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnPressDown");

	Params::UserWidgetZion_OnPressDown Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnPressLeft
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnPressLeft(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnPressLeft");

	Params::UserWidgetZion_OnPressLeft Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnPressNext
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnPressNext(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnPressNext");

	Params::UserWidgetZion_OnPressNext Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnPressNextAlt
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnPressNextAlt(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnPressNextAlt");

	Params::UserWidgetZion_OnPressNextAlt Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnPressPrevious
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnPressPrevious(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnPressPrevious");

	Params::UserWidgetZion_OnPressPrevious Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnPressPreviousAlt
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnPressPreviousAlt(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnPressPreviousAlt");

	Params::UserWidgetZion_OnPressPreviousAlt Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnPressRight
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnPressRight(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnPressRight");

	Params::UserWidgetZion_OnPressRight Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnPressUp
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidgetZion::OnPressUp(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnPressUp");

	Params::UserWidgetZion_OnPressUp Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.OnSetIsEnabled
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInIsEnabled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetZion::OnSetIsEnabled(bool bInIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "OnSetIsEnabled");

	Params::UserWidgetZion_OnSetIsEnabled Parms{};

	Parms.bInIsEnabled = bInIsEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetZion.ResetLastFocusedChild
// (Final, Native, Protected, BlueprintCallable)

void UUserWidgetZion::ResetLastFocusedChild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "ResetLastFocusedChild");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetZion.SetFocusToLastFocusedChild
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UWidget*                          FallbackWidget                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetZion::SetFocusToLastFocusedChild(class UWidget* FallbackWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "SetFocusToLastFocusedChild");

	Params::UserWidgetZion_SetFocusToLastFocusedChild Parms{};

	Parms.FallbackWidget = FallbackWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetZion.IsFocusedFromMouse
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetZion::IsFocusedFromMouse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "IsFocusedFromMouse");

	Params::UserWidgetZion_IsFocusedFromMouse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.IsOnFocusPath
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetZion::IsOnFocusPath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "IsOnFocusPath");

	Params::UserWidgetZion_IsOnFocusPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetZion.PlaySoundEvent
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class UFMODEvent*                       SoundEffect                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetZion::PlaySoundEvent(class UFMODEvent* SoundEffect) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZion", "PlaySoundEvent");

	Params::UserWidgetZion_PlaySoundEvent Parms{};

	Parms.SoundEffect = SoundEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExplanation.SetExplanationText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FText&                      Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FRichTextInputElement>&InputElements                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class FString>&            StringElements                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidgetExplanation::SetExplanationText(const class FText& Text, const TArray<struct FRichTextInputElement>& InputElements, const TArray<class FString>& StringElements)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExplanation", "SetExplanationText");

	Params::UserWidgetExplanation_SetExplanationText Parms{};

	Parms.Text = std::move(Text);
	Parms.InputElements = std::move(InputElements);
	Parms.StringElements = std::move(StringElements);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Collectable.Collect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CollectActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::Collect(class AActor* CollectActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Collect");

	Params::Collectable_Collect Parms{};

	Parms.CollectActor = CollectActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Collectable.OnPostSwitchZone
// (Final, Native, Protected)
// Parameters:
// const class AStaticVolume_Zone*         ActiveZone                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::OnPostSwitchZone(const class AStaticVolume_Zone* ActiveZone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnPostSwitchZone");

	Params::Collectable_OnPostSwitchZone Parms{};

	Parms.ActiveZone = ActiveZone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Collectable.OnTargetOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACollectable::OnTargetOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnTargetOverlapBegin");

	Params::Collectable_OnTargetOverlapBegin Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Collectable.SetActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSetActive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::SetActive(bool bSetActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "SetActive");

	Params::Collectable_SetActive Parms{};

	Parms.bSetActive = bSetActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Collectable.GetCollectingActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ACollectable::GetCollectingActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetCollectingActor");

	Params::Collectable_GetCollectingActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Collectable.GetTargetDetectionRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACollectable::GetTargetDetectionRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetTargetDetectionRange");

	Params::Collectable_GetTargetDetectionRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Collectable.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsActive");

	Params::Collectable_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RenderStateComponent.SetNewBounds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URenderStateComponent::SetNewBounds(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RenderStateComponent", "SetNewBounds");

	Params::RenderStateComponent_SetNewBounds Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RenderStateComponent.SetVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URenderStateComponent::SetVisible(bool bIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RenderStateComponent", "SetVisible");

	Params::RenderStateComponent_SetVisible Parms{};

	Parms.bIsVisible = bIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RenderStateComponent.IsVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URenderStateComponent::IsVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RenderStateComponent", "IsVisible");

	Params::RenderStateComponent_IsVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DebugDisplayComponent.OnAnimationEnd
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      Entry                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugDisplayComponent::OnAnimationEnd(class UTrackEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugDisplayComponent", "OnAnimationEnd");

	Params::DebugDisplayComponent_OnAnimationEnd Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DebugDisplayComponent.OnAnimationStart
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      Entry                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugDisplayComponent::OnAnimationStart(class UTrackEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugDisplayComponent", "OnAnimationStart");

	Params::DebugDisplayComponent_OnAnimationStart Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DebugDisplayComponent.OnCommandFinished
// (Final, Native, Private)
// Parameters:
// const class UCommand*                   Command                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommandFinishType                      FinishType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugDisplayComponent::OnCommandFinished(const class UCommand* Command, ECommandFinishType FinishType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugDisplayComponent", "OnCommandFinished");

	Params::DebugDisplayComponent_OnCommandFinished Parms{};

	Parms.Command = Command;
	Parms.FinishType = FinishType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DebugDisplayComponent.OnCommandLevelChanged
// (Final, Native, Private)

void UDebugDisplayComponent::OnCommandLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugDisplayComponent", "OnCommandLevelChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DebugDisplayComponent.OnCommandStart
// (Final, Native, Private)
// Parameters:
// const class UCommand*                   Command                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugDisplayComponent::OnCommandStart(const class UCommand* Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugDisplayComponent", "OnCommandStart");

	Params::DebugDisplayComponent_OnCommandStart Parms{};

	Parms.Command = Command;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DebugDisplayComponent.OnHPValueChanged
// (Final, Native, Private)

void UDebugDisplayComponent::OnHPValueChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugDisplayComponent", "OnHPValueChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DebugDisplayComponent.OnMovementModeChanged
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugDisplayComponent::OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugDisplayComponent", "OnMovementModeChanged");

	Params::DebugDisplayComponent_OnMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DebugDisplayComponent.OnTickLevel
// (Final, Native, Private)

void UDebugDisplayComponent::OnTickLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugDisplayComponent", "OnTickLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DebugDisplayComponent.OnTickSpineTextureInfo
// (Final, Native, Private)

void UDebugDisplayComponent::OnTickSpineTextureInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugDisplayComponent", "OnTickSpineTextureInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Trigger_FieldMessage.LaunchFieldMessage
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UFieldMessageAsset*               FieldMessageAssetOverride                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrigger_FieldMessage::LaunchFieldMessage(class UFieldMessageAsset* FieldMessageAssetOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trigger_FieldMessage", "LaunchFieldMessage");

	Params::Trigger_FieldMessage_LaunchFieldMessage Parms{};

	Parms.FieldMessageAssetOverride = FieldMessageAssetOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Trigger_FieldMessage.OnClearStatusChecked
// (Final, Native, Private)
// Parameters:
// EClearStatus                            ClearStatus                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrigger_FieldMessage::OnClearStatusChecked(EClearStatus ClearStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trigger_FieldMessage", "OnClearStatusChecked");

	Params::Trigger_FieldMessage_OnClearStatusChecked Parms{};

	Parms.ClearStatus = ClearStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Trigger_FieldMessage.OnFieldMessageFinished
// (Final, Native, Private)

void ATrigger_FieldMessage::OnFieldMessageFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trigger_FieldMessage", "OnFieldMessageFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Trigger_FieldMessage.GetTargetActor
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ATrigger_FieldMessage::GetTargetActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trigger_FieldMessage", "GetTargetActor");

	Params::Trigger_FieldMessage_GetTargetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DelayFrameAsyncAction.DelayFrame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DelayInFrames                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDelayFrameAsyncAction*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelayFrameAsyncAction* UDelayFrameAsyncAction::DelayFrame(const class UObject* WorldContextObject, int32 DelayInFrames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelayFrameAsyncAction", "DelayFrame");

	Params::DelayFrameAsyncAction_DelayFrame Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DelayInFrames = DelayInFrames;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CommandCharge.OnChargeLevelUp
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   NewChargeLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommandCharge::OnChargeLevelUp(int32 NewChargeLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandCharge", "OnChargeLevelUp");

	Params::CommandCharge_OnChargeLevelUp Parms{};

	Parms.NewChargeLevel = NewChargeLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.CommandCharge.OnRelease
// (Event, Protected, BlueprintEvent)

void UCommandCharge::OnRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandCharge", "OnRelease");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.CommandCharge.GetChargeLevel
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCommandCharge::GetChargeLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandCharge", "GetChargeLevel");

	Params::CommandCharge_GetChargeLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CommandCharge.IsReleased
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommandCharge::IsReleased() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandCharge", "IsReleased");

	Params::CommandCharge_IsReleased Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameplayCondition.CheckGameplayCondition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TSubclassOf<class UGameplayCondition>&GameplayConditionClass                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCondition::CheckGameplayCondition(const TSubclassOf<class UGameplayCondition>& GameplayConditionClass, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCondition", "CheckGameplayCondition");

	Params::GameplayCondition_CheckGameplayCondition Parms{};

	Parms.GameplayConditionClass = GameplayConditionClass;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameplayCondition.OnCheckCondition
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCondition::OnCheckCondition(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCondition", "OnCheckCondition");

	Params::GameplayCondition_OnCheckCondition Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AchievementsSubsystem.InitializeForMainUser
// (Final, Native, Public, BlueprintCallable)

void UAchievementsSubsystem::InitializeForMainUser()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsSubsystem", "InitializeForMainUser");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AchievementsSubsystem.IsAchievementUnlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EZionAchievement                        Achievement                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAchievementsSubsystem::IsAchievementUnlocked(EZionAchievement Achievement) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsSubsystem", "IsAchievementUnlocked");

	Params::AchievementsSubsystem_IsAchievementUnlocked Parms{};

	Parms.Achievement = Achievement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AchievementsSubsystem.IsUsingInternalAchievements
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAchievementsSubsystem::IsUsingInternalAchievements() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsSubsystem", "IsUsingInternalAchievements");

	Params::AchievementsSubsystem_IsUsingInternalAchievements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SleepActivatorComponent.OnWakeTriggerOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USleepActivatorComponent::OnWakeTriggerOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SleepActivatorComponent", "OnWakeTriggerOverlapBegin");

	Params::SleepActivatorComponent_OnWakeTriggerOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SleepActivatorComponent.OnWakeTriggerOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USleepActivatorComponent::OnWakeTriggerOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SleepActivatorComponent", "OnWakeTriggerOverlapEnd");

	Params::SleepActivatorComponent_OnWakeTriggerOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AbilityComponent.LaunchAbility
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FAbilityData&              AbilityData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FAbilityAdditionalData&    AdditionalData                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTransform&                GlobalOffset                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAbility*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAbility* UAbilityComponent::LaunchAbility(const struct FAbilityData& AbilityData, const struct FAbilityAdditionalData& AdditionalData, const struct FTransform& GlobalOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityComponent", "LaunchAbility");

	Params::AbilityComponent_LaunchAbility Parms{};

	Parms.AbilityData = std::move(AbilityData);
	Parms.AdditionalData = std::move(AdditionalData);
	Parms.GlobalOffset = std::move(GlobalOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AbilityComponent.LaunchAbilityInstant
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAbilityData&              AbilityData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            Targets                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FAbilityAdditionalData&    AdditionalData                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AAbilityInstant*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAbilityInstant* UAbilityComponent::LaunchAbilityInstant(const struct FAbilityData& AbilityData, const TArray<class AActor*>& Targets, const struct FAbilityAdditionalData& AdditionalData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityComponent", "LaunchAbilityInstant");

	Params::AbilityComponent_LaunchAbilityInstant Parms{};

	Parms.AbilityData = std::move(AbilityData);
	Parms.Targets = std::move(Targets);
	Parms.AdditionalData = std::move(AdditionalData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionInputDeviceSubsystem.GetActiveControllerID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UZionInputDeviceSubsystem::GetActiveControllerID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionInputDeviceSubsystem", "GetActiveControllerID");

	Params::ZionInputDeviceSubsystem_GetActiveControllerID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionInputDeviceSubsystem.LockActiveController
// (Final, Native, Public, BlueprintCallable)

void UZionInputDeviceSubsystem::LockActiveController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionInputDeviceSubsystem", "LockActiveController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ZionInputDeviceSubsystem.SetInputStyleGamepadOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInputStyle                             NewInputStyleGamepadOverride                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UZionInputDeviceSubsystem::SetInputStyleGamepadOverride(EInputStyle NewInputStyleGamepadOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionInputDeviceSubsystem", "SetInputStyleGamepadOverride");

	Params::ZionInputDeviceSubsystem_SetInputStyleGamepadOverride Parms{};

	Parms.NewInputStyleGamepadOverride = NewInputStyleGamepadOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ZionInputDeviceSubsystem.UnlockActiveController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bResetLockCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UZionInputDeviceSubsystem::UnlockActiveController(bool bResetLockCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionInputDeviceSubsystem", "UnlockActiveController");

	Params::ZionInputDeviceSubsystem_UnlockActiveController Parms{};

	Parms.bResetLockCount = bResetLockCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ZionInputDeviceSubsystem.GetInputStyle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputStyle                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInputStyle UZionInputDeviceSubsystem::GetInputStyle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionInputDeviceSubsystem", "GetInputStyle");

	Params::ZionInputDeviceSubsystem_GetInputStyle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionInputDeviceSubsystem.GetInputStyleGamepadOverride
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputStyle                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInputStyle UZionInputDeviceSubsystem::GetInputStyleGamepadOverride() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionInputDeviceSubsystem", "GetInputStyleGamepadOverride");

	Params::ZionInputDeviceSubsystem_GetInputStyleGamepadOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionInputDeviceSubsystem.IsActiveControllerLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UZionInputDeviceSubsystem::IsActiveControllerLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionInputDeviceSubsystem", "IsActiveControllerLocked");

	Params::ZionInputDeviceSubsystem_IsActiveControllerLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionInputDeviceSubsystem.IsAnyGamepadConnected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UZionInputDeviceSubsystem::IsAnyGamepadConnected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionInputDeviceSubsystem", "IsAnyGamepadConnected");

	Params::ZionInputDeviceSubsystem_IsAnyGamepadConnected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionInputDeviceSubsystem.IsCursorVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UZionInputDeviceSubsystem::IsCursorVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionInputDeviceSubsystem", "IsCursorVisible");

	Params::ZionInputDeviceSubsystem_IsCursorVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionInputDeviceSubsystem.IsUsingGamepad
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UZionInputDeviceSubsystem::IsUsingGamepad() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionInputDeviceSubsystem", "IsUsingGamepad");

	Params::ZionInputDeviceSubsystem_IsUsingGamepad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionCharacterMovementComponent.SetMovementModeCustom
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMovementModeCustom                     NewMovementModeCustom                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UZionCharacterMovementComponent::SetMovementModeCustom(EMovementModeCustom NewMovementModeCustom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionCharacterMovementComponent", "SetMovementModeCustom");

	Params::ZionCharacterMovementComponent_SetMovementModeCustom Parms{};

	Parms.NewMovementModeCustom = NewMovementModeCustom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ZionCharacterMovementComponent.SetMovementSpeedMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMovementSpeedMode                      NewMovementSpeedMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UZionCharacterMovementComponent::SetMovementSpeedMode(EMovementSpeedMode NewMovementSpeedMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionCharacterMovementComponent", "SetMovementSpeedMode");

	Params::ZionCharacterMovementComponent_SetMovementSpeedMode Parms{};

	Parms.NewMovementSpeedMode = NewMovementSpeedMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ZionCharacterMovementComponent.ComputeLaunchVelocityToDestination
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   DestinationLocation                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UZionCharacterMovementComponent::ComputeLaunchVelocityToDestination(const struct FVector& DestinationLocation, float Duration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionCharacterMovementComponent", "ComputeLaunchVelocityToDestination");

	Params::ZionCharacterMovementComponent_ComputeLaunchVelocityToDestination Parms{};

	Parms.DestinationLocation = std::move(DestinationLocation);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionCharacterMovementComponent.GetLastNonFallingLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UZionCharacterMovementComponent::GetLastNonFallingLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionCharacterMovementComponent", "GetLastNonFallingLocation");

	Params::ZionCharacterMovementComponent_GetLastNonFallingLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionCharacterMovementComponent.GetMovementSpeedMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMovementSpeedMode                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMovementSpeedMode UZionCharacterMovementComponent::GetMovementSpeedMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionCharacterMovementComponent", "GetMovementSpeedMode");

	Params::ZionCharacterMovementComponent_GetMovementSpeedMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionCharacterMovementComponent.GetTimeSinceLastGrounded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UZionCharacterMovementComponent::GetTimeSinceLastGrounded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionCharacterMovementComponent", "GetTimeSinceLastGrounded");

	Params::ZionCharacterMovementComponent_GetTimeSinceLastGrounded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionCharacterMovementComponent.GetTimeSinceLastHookAttach
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UZionCharacterMovementComponent::GetTimeSinceLastHookAttach() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionCharacterMovementComponent", "GetTimeSinceLastHookAttach");

	Params::ZionCharacterMovementComponent_GetTimeSinceLastHookAttach Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionCharacterMovementComponent.GetTimeSinceLastWallGrab
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UZionCharacterMovementComponent::GetTimeSinceLastWallGrab() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionCharacterMovementComponent", "GetTimeSinceLastWallGrab");

	Params::ZionCharacterMovementComponent_GetTimeSinceLastWallGrab Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionCharacterMovementComponent.IsAirborne
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UZionCharacterMovementComponent::IsAirborne() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionCharacterMovementComponent", "IsAirborne");

	Params::ZionCharacterMovementComponent_IsAirborne Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionCharacterMovementComponent.IsHookAttached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UZionCharacterMovementComponent::IsHookAttached() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionCharacterMovementComponent", "IsHookAttached");

	Params::ZionCharacterMovementComponent_IsHookAttached Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionCharacterMovementComponent.IsSliding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UZionCharacterMovementComponent::IsSliding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionCharacterMovementComponent", "IsSliding");

	Params::ZionCharacterMovementComponent_IsSliding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionCharacterMovementComponent.IsWallGrabbing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UZionCharacterMovementComponent::IsWallGrabbing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionCharacterMovementComponent", "IsWallGrabbing");

	Params::ZionCharacterMovementComponent_IsWallGrabbing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZionCharacterMovementComponent.IsWallScaling
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UZionCharacterMovementComponent::IsWallScaling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionCharacterMovementComponent", "IsWallScaling");

	Params::ZionCharacterMovementComponent_IsWallScaling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.KnockbackComponent.OnLandingAnimationFinished
// (Final, Native, Private)

void UKnockbackComponent::OnLandingAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnockbackComponent", "OnLandingAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.KnockbackComponent.OnPreStartCommand
// (Final, Native, Private)
// Parameters:
// const class UCommand*                   Command                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKnockbackComponent::OnPreStartCommand(const class UCommand* Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnockbackComponent", "OnPreStartCommand");

	Params::KnockbackComponent_OnPreStartCommand Parms{};

	Parms.Command = Command;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.KnockbackComponent.OnRecoveryAnimationFinished
// (Final, Native, Private)

void UKnockbackComponent::OnRecoveryAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnockbackComponent", "OnRecoveryAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.KnockbackComponent.StartKnockback
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FKnockbackData&            KnockbackData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   KnockbackDirection                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKnockbackComponent::StartKnockback(const struct FKnockbackData& KnockbackData, const struct FVector& KnockbackDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnockbackComponent", "StartKnockback");

	Params::KnockbackComponent_StartKnockback Parms{};

	Parms.KnockbackData = std::move(KnockbackData);
	Parms.KnockbackDirection = std::move(KnockbackDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.KnockbackComponent.IsInKnockback
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKnockbackComponent::IsInKnockback() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnockbackComponent", "IsInKnockback");

	Params::KnockbackComponent_IsInKnockback Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameEngineZion.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameEngineZion*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameEngineZion* UGameEngineZion::Get()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameEngineZion", "Get");

	Params::GameEngineZion_Get Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.MovingBlock_Elevator.CallToDestination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMovingBlock_Elevator::CallToDestination(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingBlock_Elevator", "CallToDestination");

	Params::MovingBlock_Elevator_CallToDestination Parms{};

	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.MovingBlock_Elevator.CallToOrigin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMovingBlock_Elevator::CallToOrigin(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingBlock_Elevator", "CallToOrigin");

	Params::MovingBlock_Elevator_CallToOrigin Parms{};

	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.MovingBlock_Elevator.OnFinishMovement
// (Final, Native, Private)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasMoving                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMovingBlock_Elevator::OnFinishMovement(bool bInstant, bool bWasMoving)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingBlock_Elevator", "OnFinishMovement");

	Params::MovingBlock_Elevator_OnFinishMovement Parms{};

	Parms.bInstant = bInstant;
	Parms.bWasMoving = bWasMoving;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.MovingBlock_Elevator.OnStartMovement
// (Final, Native, Private)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasMoving                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMovingBlock_Elevator::OnStartMovement(bool bInstant, bool bWasMoving)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingBlock_Elevator", "OnStartMovement");

	Params::MovingBlock_Elevator_OnStartMovement Parms{};

	Parms.bInstant = bInstant;
	Parms.bWasMoving = bWasMoving;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AbilityHitboxBounce.OnProjectileBounce
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// const struct FHitResult&                ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FVector&                   ImpactVelocity                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAbilityHitboxBounce::OnProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityHitboxBounce", "OnProjectileBounce");

	Params::AbilityHitboxBounce_OnProjectileBounce Parms{};

	Parms.ImpactResult = std::move(ImpactResult);
	Parms.ImpactVelocity = std::move(ImpactVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Interactable.OnActivateInteractable
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::OnActivateInteractable(class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "OnActivateInteractable");

	Params::Interactable_OnActivateInteractable Parms{};

	Parms.Controller = Controller;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.Interactable.OnCanBeInteractedChanged
// (Event, Protected, BlueprintEvent)

void AInteractable::OnCanBeInteractedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "OnCanBeInteractedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.Interactable.OnDeactivateInteractable
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::OnDeactivateInteractable(class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "OnDeactivateInteractable");

	Params::Interactable_OnDeactivateInteractable Parms{};

	Parms.Controller = Controller;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.Interactable.OnInteract
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::OnInteract(class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "OnInteract");

	Params::Interactable_OnInteract Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Interactable.OnInteract_ConditionCheckFailed
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::OnInteract_ConditionCheckFailed(class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "OnInteract_ConditionCheckFailed");

	Params::Interactable_OnInteract_ConditionCheckFailed Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Interactable.SetCanBeInteracted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanInteract                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::SetCanBeInteracted(bool bCanInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "SetCanBeInteracted");

	Params::Interactable_SetCanBeInteracted Parms{};

	Parms.bCanInteract = bCanInteract;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Interactable.CanBeInteracted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractable::CanBeInteracted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "CanBeInteracted");

	Params::Interactable_CanBeInteracted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Interactable.ConditionsChecked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractable::ConditionsChecked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "ConditionsChecked");

	Params::Interactable_ConditionsChecked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Interactable.GetInteractingController
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* AInteractable::GetInteractingController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "GetInteractingController");

	Params::Interactable_GetInteractingController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Interactable.GetInteractionText
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AInteractable::GetInteractionText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "GetInteractionText");

	Params::Interactable_GetInteractionText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Interactable.PlaySoundEvent
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UFMODEvent*                       SoundEffect                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::PlaySoundEvent(class UFMODEvent* SoundEffect) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "PlaySoundEvent");

	Params::Interactable_PlaySoundEvent Parms{};

	Parms.SoundEffect = SoundEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CommandModule_Summon.GetSpirit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ACharacterZionSpirit*       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ACharacterZionSpirit* UCommandModule_Summon::GetSpirit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandModule_Summon", "GetSpirit");

	Params::CommandModule_Summon_GetSpirit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Inventory.GetAllItemsAvailable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> UInventory::GetAllItemsAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetAllItemsAvailable");

	Params::Inventory_GetAllItemsAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Inventory.MarkItemAsChecked
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ItemRowName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::MarkItemAsChecked(const class FName& ItemRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "MarkItemAsChecked");

	Params::Inventory_MarkItemAsChecked Parms{};

	Parms.ItemRowName = ItemRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Inventory.GetAllItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<class FName, int32>          ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<class FName, int32> UInventory::GetAllItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetAllItems");

	Params::Inventory_GetAllItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Inventory.GetCountOfItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventory::GetCountOfItem(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetCountOfItem");

	Params::Inventory_GetCountOfItem Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Inventory.GetDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UDataTable*                 ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UDataTable* UInventory::GetDataTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetDataTable");

	Params::Inventory_GetDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Inventory.GetItemCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventory::GetItemCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetItemCount");

	Params::Inventory_GetItemCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Inventory.HasItem
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ItemRowName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::HasItem(const class FName& ItemRowName, int32 Count) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "HasItem");

	Params::Inventory_HasItem Parms{};

	Parms.ItemRowName = ItemRowName;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Inventory.HasNonCheckedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::HasNonCheckedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "HasNonCheckedItem");

	Params::Inventory_HasNonCheckedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Inventory.IsItemChecked
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ItemRowName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::IsItemChecked(const class FName& ItemRowName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "IsItemChecked");

	Params::Inventory_IsItemChecked Parms{};

	Parms.ItemRowName = ItemRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventorySkill.GetMaxSkillLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventorySkill::GetMaxSkillLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventorySkill", "GetMaxSkillLevel");

	Params::InventorySkill_GetMaxSkillLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventorySkill.GetMinSkillLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventorySkill::GetMinSkillLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventorySkill", "GetMinSkillLevel");

	Params::InventorySkill_GetMinSkillLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventorySkill.SetSkillLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      SkillID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventorySkill::SetSkillLevel(const class FName& SkillID, int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySkill", "SetSkillLevel");

	Params::InventorySkill_SetSkillLevel Parms{};

	Parms.SkillID = SkillID;
	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventorySkill.GetInitialSkillLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      SkillID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventorySkill::GetInitialSkillLevel(const class FName& SkillID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySkill", "GetInitialSkillLevel");

	Params::InventorySkill_GetInitialSkillLevel Parms{};

	Parms.SkillID = SkillID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventorySkill.GetSkillLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      SkillID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFallbackInitialLevel                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventorySkill::GetSkillLevel(const class FName& SkillID, bool bFallbackInitialLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySkill", "GetSkillLevel");

	Params::InventorySkill_GetSkillLevel Parms{};

	Parms.SkillID = SkillID;
	Parms.bFallbackInitialLevel = bFallbackInitialLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventorySkill.IsMaxSkillLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      SkillID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventorySkill::IsMaxSkillLevel(const class FName& SkillID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySkill", "IsMaxSkillLevel");

	Params::InventorySkill_IsMaxSkillLevel Parms{};

	Parms.SkillID = SkillID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AbilityInstant.SetTargets
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            InTargets                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AAbilityInstant::SetTargets(const TArray<class AActor*>& InTargets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityInstant", "SetTargets");

	Params::AbilityInstant_SetTargets Parms{};

	Parms.InTargets = std::move(InTargets);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ActorBPFLibrary.ClearMovementBase
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorBPFLibrary::ClearMovementBase(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorBPFLibrary", "ClearMovementBase");

	Params::ActorBPFLibrary_ClearMovementBase Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ActorBPFLibrary.FlushAnimations
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetAnimator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorBPFLibrary::FlushAnimations(const class AActor* Actor, bool bResetAnimator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorBPFLibrary", "FlushAnimations");

	Params::ActorBPFLibrary_FlushAnimations Parms{};

	Parms.Actor = Actor;
	Parms.bResetAnimator = bResetAnimator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ActorBPFLibrary.GenerateClearIDForActor
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UActorBPFLibrary::GenerateClearIDForActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorBPFLibrary", "GenerateClearIDForActor");

	Params::ActorBPFLibrary_GenerateClearIDForActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ActorBPFLibrary.GetActorID
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UActorBPFLibrary::GetActorID(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorBPFLibrary", "GetActorID");

	Params::ActorBPFLibrary_GetActorID Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ActorBPFLibrary.GetBottomLocation
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UActorBPFLibrary::GetBottomLocation(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorBPFLibrary", "GetBottomLocation");

	Params::ActorBPFLibrary_GetBottomLocation Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ActorBPFLibrary.GetHalfHeight
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActorBPFLibrary::GetHalfHeight(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorBPFLibrary", "GetHalfHeight");

	Params::ActorBPFLibrary_GetHalfHeight Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ActorBPFLibrary.GetTargetPivotComponent
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class USceneComponent*            ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class USceneComponent* UActorBPFLibrary::GetTargetPivotComponent(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorBPFLibrary", "GetTargetPivotComponent");

	Params::ActorBPFLibrary_GetTargetPivotComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ActorBPFLibrary.GetTargetPivotLocation
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UActorBPFLibrary::GetTargetPivotLocation(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorBPFLibrary", "GetTargetPivotLocation");

	Params::ActorBPFLibrary_GetTargetPivotLocation Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ActorBPFLibrary.GetTopLocation
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UActorBPFLibrary::GetTopLocation(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorBPFLibrary", "GetTopLocation");

	Params::ActorBPFLibrary_GetTopLocation Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ActorBPFLibrary.GetWorldIDForActor
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UActorBPFLibrary::GetWorldIDForActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorBPFLibrary", "GetWorldIDForActor");

	Params::ActorBPFLibrary_GetWorldIDForActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ActorBPFLibrary.IsPlayer
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorBPFLibrary::IsPlayer(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorBPFLibrary", "IsPlayer");

	Params::ActorBPFLibrary_IsPlayer Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ActorBPFLibrary.ResetVelocity
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetY                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetZ                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorBPFLibrary::ResetVelocity(class AActor* Actor, bool bResetX, bool bResetY, bool bResetZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorBPFLibrary", "ResetVelocity");

	Params::ActorBPFLibrary_ResetVelocity Parms{};

	Parms.Actor = Actor;
	Parms.bResetX = bResetX;
	Parms.bResetY = bResetY;
	Parms.bResetZ = bResetZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ActorBPFLibrary.ToggleActor
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorBPFLibrary::ToggleActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorBPFLibrary", "ToggleActor");

	Params::ActorBPFLibrary_ToggleActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HookPoint.GetHookAttachComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AHookPoint::GetHookAttachComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookPoint", "GetHookAttachComponent");

	Params::HookPoint_GetHookAttachComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HookPoint.GetHookLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AHookPoint::GetHookLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookPoint", "GetHookLocation");

	Params::HookPoint_GetHookLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HookPoint.GetHookTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform AHookPoint::GetHookTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookPoint", "GetHookTransform");

	Params::HookPoint_GetHookTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HookPoint.GetHookType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHookType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHookType AHookPoint::GetHookType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookPoint", "GetHookType");

	Params::HookPoint_GetHookType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.WaitGameReadyAsyncAction.WaitGameReady
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlsoWaitWorldLoading                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWaitGameReadyAsyncAction*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWaitGameReadyAsyncAction* UWaitGameReadyAsyncAction::WaitGameReady(const class UObject* WorldContextObject, bool bAlsoWaitWorldLoading)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WaitGameReadyAsyncAction", "WaitGameReady");

	Params::WaitGameReadyAsyncAction_WaitGameReady Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bAlsoWaitWorldLoading = bAlsoWaitWorldLoading;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ActorSpawner.OnPostSpawnActor
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreview                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActorSpawner::OnPostSpawnActor(class AActor* Actor, bool bPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "OnPostSpawnActor");

	Params::ActorSpawner_OnPostSpawnActor Parms{};

	Parms.Actor = Actor;
	Parms.bPreview = bPreview;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ActorSpawner.OnPreSpawnActor
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActorSpawner::OnPreSpawnActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "OnPreSpawnActor");

	Params::ActorSpawner_OnPreSpawnActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ActorSpawner.SetActorToSpawn
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TSoftClassPtr<class UClass>&      InActorClassToSpawn                                    (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActorSpawner::SetActorToSpawn(const TSoftClassPtr<class UClass>& InActorClassToSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "SetActorToSpawn");

	Params::ActorSpawner_SetActorToSpawn Parms{};

	Parms.InActorClassToSpawn = InActorClassToSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AfterImageRenderer.OnSetup
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           Texture                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAfterImageRenderer::OnSetup(const struct FTransform& Transform, class UTextureRenderTarget2D* Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AfterImageRenderer", "OnSetup");

	Params::AfterImageRenderer_OnSetup Parms{};

	Parms.Transform = std::move(Transform);
	Parms.Texture = Texture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.AfterImageRenderer.Release
// (Final, Native, Public, BlueprintCallable)

void AAfterImageRenderer::Release()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AfterImageRenderer", "Release");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AfterImageComponent.SetAfterImageType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAfterImageType                         NewAfterImageType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAfterImageComponent::SetAfterImageType(EAfterImageType NewAfterImageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AfterImageComponent", "SetAfterImageType");

	Params::AfterImageComponent_SetAfterImageType Parms{};

	Parms.NewAfterImageType = NewAfterImageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AfterImageComponent.GetAfterImageType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAfterImageType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAfterImageType UAfterImageComponent::GetAfterImageType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AfterImageComponent", "GetAfterImageType");

	Params::AfterImageComponent_GetAfterImageType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Command_HoldGuard.OnGuarded
// (Final, Native, Private)
// Parameters:
// class AAbility*                         Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommand_HoldGuard::OnGuarded(class AAbility* Ability, class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command_HoldGuard", "OnGuarded");

	Params::Command_HoldGuard_OnGuarded Parms{};

	Parms.Ability = Ability;
	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Command_HoldGuard.OnReceivedDamage
// (Final, Native, Private)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommand_HoldGuard::OnReceivedDamage(class AActor* Source, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command_HoldGuard", "OnReceivedDamage");

	Params::Command_HoldGuard_OnReceivedDamage Parms{};

	Parms.Source = Source;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Command_HoldGuard.OnRelease
// (Event, Protected, BlueprintEvent)

void UCommand_HoldGuard::OnRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command_HoldGuard", "OnRelease");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.Command_HoldGuard.IsReleased
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommand_HoldGuard::IsReleased() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command_HoldGuard", "IsReleased");

	Params::Command_HoldGuard_IsReleased Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AICommandClassProviderInterface.GetFindEnemyCommandClass
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TSubclassOf<class UCommand>*            out_CommandClass                                       (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAICommandClassProviderInterface::GetFindEnemyCommandClass(TSubclassOf<class UCommand>* out_CommandClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AICommandClassProviderInterface", "GetFindEnemyCommandClass");

	Params::AICommandClassProviderInterface_GetFindEnemyCommandClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_CommandClass != nullptr)
		*out_CommandClass = Parms.out_CommandClass;
}


// Function Zion.AICommandClassProviderInterface.GetIdlePeaceCommandClass
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TSubclassOf<class UCommand>*            out_CommandClass                                       (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAICommandClassProviderInterface::GetIdlePeaceCommandClass(TSubclassOf<class UCommand>* out_CommandClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AICommandClassProviderInterface", "GetIdlePeaceCommandClass");

	Params::AICommandClassProviderInterface_GetIdlePeaceCommandClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_CommandClass != nullptr)
		*out_CommandClass = Parms.out_CommandClass;
}


// Function Zion.AIControllerZion.OnChangeTarget
// (Event, Public, BlueprintEvent)
// Parameters:
// const class AActor*                     NewTarget                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAIControllerZion::OnChangeTarget(const class AActor* NewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIControllerZion", "OnChangeTarget");

	Params::AIControllerZion_OnChangeTarget Parms{};

	Parms.NewTarget = NewTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.AIControllerZion.OnPawnDeathProcessEnd
// (Native, Protected)

void AAIControllerZion::OnPawnDeathProcessEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIControllerZion", "OnPawnDeathProcessEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AIControllerZion.OnPawnDeathProcessStart
// (Native, Protected)

void AAIControllerZion::OnPawnDeathProcessStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIControllerZion", "OnPawnDeathProcessStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AIControllerZion.PauseLogic
// (Final, Native, Public, BlueprintCallable)

void AAIControllerZion::PauseLogic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIControllerZion", "PauseLogic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AIControllerZion.RestartLogic
// (Final, Native, Public, BlueprintCallable)

void AAIControllerZion::RestartLogic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIControllerZion", "RestartLogic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AIControllerZion.ResumeLogic
// (Final, Native, Public, BlueprintCallable)

void AAIControllerZion::ResumeLogic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIControllerZion", "ResumeLogic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AIControllerZion.StartLogic
// (Final, Native, Public, BlueprintCallable)

void AAIControllerZion::StartLogic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIControllerZion", "StartLogic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AIControllerZion.StopLogic
// (Final, Native, Public, BlueprintCallable)

void AAIControllerZion::StopLogic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIControllerZion", "StopLogic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EventAction_GrantItemsBase.OnWidgetDestruct
// (Final, Native, Private)

void UEventAction_GrantItemsBase::OnWidgetDestruct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventAction_GrantItemsBase", "OnWidgetDestruct");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AnimationFromVelocityComponent.ResetAnimationCycle
// (Final, Native, Public, BlueprintCallable)

void UAnimationFromVelocityComponent::ResetAnimationCycle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFromVelocityComponent", "ResetAnimationCycle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ArrayBPFLibrary.SortNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>&                    Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UArrayBPFLibrary::SortNames(TArray<class FName>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayBPFLibrary", "SortNames");

	Params::ArrayBPFLibrary_SortNames Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);

	return Parms.ReturnValue;
}


// Function Zion.ArrayBPFLibrary.SortTextIntStructs
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FTextIntStruct>&          Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FTextIntStruct>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTextIntStruct> UArrayBPFLibrary::SortTextIntStructs(TArray<struct FTextIntStruct>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayBPFLibrary", "SortTextIntStructs");

	Params::ArrayBPFLibrary_SortTextIntStructs Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);

	return Parms.ReturnValue;
}


// Function Zion.EventAction_MoveTo.OnMoveCompleted
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventAction_MoveTo::OnMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventAction_MoveTo", "OnMoveCompleted");

	Params::EventAction_MoveTo_OnMoveCompleted Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AssistComponent.EquipAssist
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      AssistID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToCurrentLoadout                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAssistComponent::EquipAssist(const class FName& AssistID, bool bAddToCurrentLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssistComponent", "EquipAssist");

	Params::AssistComponent_EquipAssist Parms{};

	Parms.AssistID = AssistID;
	Parms.bAddToCurrentLoadout = bAddToCurrentLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AssistComponent.EquipAssistLoadout
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LoadoutIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAssistComponent::EquipAssistLoadout(int32 LoadoutIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssistComponent", "EquipAssistLoadout");

	Params::AssistComponent_EquipAssistLoadout Parms{};

	Parms.LoadoutIndex = LoadoutIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AssistComponent.OnPossessedPawnChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAssistComponent::OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssistComponent", "OnPossessedPawnChanged");

	Params::AssistComponent_OnPossessedPawnChanged Parms{};

	Parms.OldPawn = OldPawn;
	Parms.NewPawn = NewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AssistComponent.UnEquipAssist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bRemoveFromCurrentLoadout                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAssistComponent::UnEquipAssist(bool bRemoveFromCurrentLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssistComponent", "UnEquipAssist");

	Params::AssistComponent_UnEquipAssist Parms{};

	Parms.bRemoveFromCurrentLoadout = bRemoveFromCurrentLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AssistComponent.GetAssistDataFromID
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      AssistID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryItemAssistData   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FInventoryItemAssistData UAssistComponent::GetAssistDataFromID(const class FName& AssistID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssistComponent", "GetAssistDataFromID");

	Params::AssistComponent_GetAssistDataFromID Parms{};

	Parms.AssistID = AssistID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AssistComponent.GetAssistID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAssistComponent::GetAssistID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssistComponent", "GetAssistID");

	Params::AssistComponent_GetAssistID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AssistComponent.GetCurrentAssistLoadoutIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAssistComponent::GetCurrentAssistLoadoutIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssistComponent", "GetCurrentAssistLoadoutIndex");

	Params::AssistComponent_GetCurrentAssistLoadoutIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AssistComponent.GetEquippedAssistData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FInventoryItemAssistData   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FInventoryItemAssistData UAssistComponent::GetEquippedAssistData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssistComponent", "GetEquippedAssistData");

	Params::AssistComponent_GetEquippedAssistData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.EnemySpawner.ActivateEnemy
// (Final, Native, Public, BlueprintCallable)

void AEnemySpawner::ActivateEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "ActivateEnemy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EnemySpawner.OnApplyBlackboardOverride
// (Event, Protected, BlueprintEvent)

void AEnemySpawner::OnApplyBlackboardOverride()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "OnApplyBlackboardOverride");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.EnemySpawner.OnClearStatusChecked
// (Final, Native, Private)
// Parameters:
// EClearStatus                            ClearStatus                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemySpawner::OnClearStatusChecked(EClearStatus ClearStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "OnClearStatusChecked");

	Params::EnemySpawner_OnClearStatusChecked Parms{};

	Parms.ClearStatus = ClearStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EnemySpawner.OnEnemyActivation
// (Event, Protected, BlueprintEvent)

void AEnemySpawner::OnEnemyActivation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "OnEnemyActivation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.EnemySpawner.OnEnemyBreakPart
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EBreakType&                       BreakType                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemySpawner::OnEnemyBreakPart(const EBreakType& BreakType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "OnEnemyBreakPart");

	Params::EnemySpawner_OnEnemyBreakPart Parms{};

	Parms.BreakType = BreakType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EnemySpawner.OnEnemyDeathEnd
// (Event, Protected, BlueprintEvent)

void AEnemySpawner::OnEnemyDeathEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "OnEnemyDeathEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.EnemySpawner.OnEnemyDeathProcessEnd
// (Final, Native, Private)

void AEnemySpawner::OnEnemyDeathProcessEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "OnEnemyDeathProcessEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EnemySpawner.OnEnemyDeathProcessStart
// (Final, Native, Private)

void AEnemySpawner::OnEnemyDeathProcessStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "OnEnemyDeathProcessStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EnemySpawner.OnEnemyDeathStart
// (Event, Protected, BlueprintEvent)

void AEnemySpawner::OnEnemyDeathStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "OnEnemyDeathStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.EnemySpawner.OnEnemyPreActivation
// (Event, Protected, BlueprintEvent)

void AEnemySpawner::OnEnemyPreActivation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "OnEnemyPreActivation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.EnemySpawner.OnRegisterEnemy
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACharacterZion*                   Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemySpawner::OnRegisterEnemy(class ACharacterZion* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "OnRegisterEnemy");

	Params::EnemySpawner_OnRegisterEnemy Parms{};

	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.EnemySpawner.OnUnregisterEnemy
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACharacterZion*                   Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemySpawner::OnUnregisterEnemy(class ACharacterZion* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "OnUnregisterEnemy");

	Params::EnemySpawner_OnUnregisterEnemy Parms{};

	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.EnemySpawner.ReplaceEnemy
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       NewEnemyRowHandle                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTransform&                SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemySpawner::ReplaceEnemy(const struct FDataTableRowHandle& NewEnemyRowHandle, const struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "ReplaceEnemy");

	Params::EnemySpawner_ReplaceEnemy Parms{};

	Parms.NewEnemyRowHandle = std::move(NewEnemyRowHandle);
	Parms.SpawnTransform = std::move(SpawnTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EnemySpawner.GetEnemy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacterZion*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacterZion* AEnemySpawner::GetEnemy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "GetEnemy");

	Params::EnemySpawner_GetEnemy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.EnemySpawner.GetEnemyAIController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AAIControllerZion*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAIControllerZion* AEnemySpawner::GetEnemyAIController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "GetEnemyAIController");

	Params::EnemySpawner_GetEnemyAIController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.EnemySpawner.IsEnemyActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEnemySpawner::IsEnemyActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "IsEnemyActivated");

	Params::EnemySpawner_IsEnemyActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.EnemySpawner.ShouldSpawnEvenWhenCleared
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEnemySpawner::ShouldSpawnEvenWhenCleared() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "ShouldSpawnEvenWhenCleared");

	Params::EnemySpawner_ShouldSpawnEvenWhenCleared Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AssistTrigger_HealSuccess.OnHealSucceeded
// (Final, Native, Private)

void UAssistTrigger_HealSuccess::OnHealSucceeded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssistTrigger_HealSuccess", "OnHealSucceeded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AssistTrigger_ParrySuccess.OnParried
// (Final, Native, Private)
// Parameters:
// class AAbility*                         Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAssistTrigger_ParrySuccess::OnParried(class AAbility* Ability, class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssistTrigger_ParrySuccess", "OnParried");

	Params::AssistTrigger_ParrySuccess_OnParried Parms{};

	Parms.Ability = Ability;
	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CustomMarkerComponent.GetCustomMarkerMaxCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomMarkerComponent::GetCustomMarkerMaxCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomMarkerComponent", "GetCustomMarkerMaxCount");

	Params::CustomMarkerComponent_GetCustomMarkerMaxCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.AssistTrigger_ReceiveStatusEffect.OnStatusEffectLaunched
// (Final, Native, Private)
// Parameters:
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAssistTrigger_ReceiveStatusEffect::OnStatusEffectLaunched(class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssistTrigger_ReceiveStatusEffect", "OnStatusEffectLaunched");

	Params::AssistTrigger_ReceiveStatusEffect_OnStatusEffectLaunched Parms{};

	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AssistTrigger_TimeInterval.OnTimeElapsed
// (Final, Native, Private)

void UAssistTrigger_TimeInterval::OnTimeElapsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssistTrigger_TimeInterval", "OnTimeElapsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AssistVisual.OnGameMapChanged
// (Final, Native, Private)

void AAssistVisual::OnGameMapChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssistVisual", "OnGameMapChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetZionShowHide.Hide
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetZionShowHide::Hide(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZionShowHide", "Hide");

	Params::UserWidgetZionShowHide_Hide Parms{};

	Parms.bInstant = bInstant;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetZionShowHide.HideAndRemoveFromParent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetZionShowHide::HideAndRemoveFromParent(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZionShowHide", "HideAndRemoveFromParent");

	Params::UserWidgetZionShowHide_HideAndRemoveFromParent Parms{};

	Parms.bInstant = bInstant;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetZionShowHide.Show
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetZionShowHide::Show(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetZionShowHide", "Show");

	Params::UserWidgetZionShowHide_Show Parms{};

	Parms.bInstant = bInstant;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetMapLegend.OnLegendInitialized
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TSet<EMapIconType>&               VisibleIconTypes                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidgetMapLegend::OnLegendInitialized(const TSet<EMapIconType>& VisibleIconTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapLegend", "OnLegendInitialized");

	Params::UserWidgetMapLegend_OnLegendInitialized Parms{};

	Parms.VisibleIconTypes = std::move(VisibleIconTypes);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.AutoClimbComponent.MarkActorAsIgnored
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAutoClimbComponent::MarkActorAsIgnored(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutoClimbComponent", "MarkActorAsIgnored");

	Params::AutoClimbComponent_MarkActorAsIgnored Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AutoClimbComponent.OnComponentOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAutoClimbComponent::OnComponentOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutoClimbComponent", "OnComponentOverlapBegin");

	Params::AutoClimbComponent_OnComponentOverlapBegin Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AutoClimbComponent.OnComponentOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAutoClimbComponent::OnComponentOverlapEnd(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutoClimbComponent", "OnComponentOverlapEnd");

	Params::AutoClimbComponent_OnComponentOverlapEnd Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AutoClimbComponent.OnMoveBlocked
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FHitResult&                Impact                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAutoClimbComponent::OnMoveBlocked(const struct FHitResult& Impact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutoClimbComponent", "OnMoveBlocked");

	Params::AutoClimbComponent_OnMoveBlocked Parms{};

	Parms.Impact = std::move(Impact);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AutoClimbComponent.UnmarkActorAsIgnored
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAutoClimbComponent::UnmarkActorAsIgnored(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutoClimbComponent", "UnmarkActorAsIgnored");

	Params::AutoClimbComponent_UnmarkActorAsIgnored Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.AutoClimbComponent.GetLastTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAutoClimbComponent::GetLastTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutoClimbComponent", "GetLastTargetLocation");

	Params::AutoClimbComponent_GetLastTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.BattleColorComponent.SetAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewAlpha                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleColorComponent::SetAlpha(float NewAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleColorComponent", "SetAlpha");

	Params::BattleColorComponent_SetAlpha Parms{};

	Parms.NewAlpha = NewAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.BattleColorComponent.SetBattleColorEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleColorComponent::SetBattleColorEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleColorComponent", "SetBattleColorEnabled");

	Params::BattleColorComponent_SetBattleColorEnabled Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.BoxBPFLibrary.GetCenter
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FBox&                      Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBoxBPFLibrary::GetCenter(const struct FBox& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BoxBPFLibrary", "GetCenter");

	Params::BoxBPFLibrary_GetCenter Parms{};

	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.BoxBPFLibrary.IsValid
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FBox&                      Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBoxBPFLibrary::IsValid(const struct FBox& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BoxBPFLibrary", "IsValid");

	Params::BoxBPFLibrary_IsValid Parms{};

	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Breakable.OnBreakableDeathProcessStart
// (Final, Native, Private)

void ABreakable::OnBreakableDeathProcessStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Breakable", "OnBreakableDeathProcessStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Breakable.OnBreakableReceivedDamage
// (Final, Native, Private)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABreakable::OnBreakableReceivedDamage(class AActor* Source, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Breakable", "OnBreakableReceivedDamage");

	Params::Breakable_OnBreakableReceivedDamage Parms{};

	Parms.Source = Source;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Breakable.OnClearStatusChecked
// (Final, Native, Private)
// Parameters:
// EClearStatus                            ClearStatus                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABreakable::OnClearStatusChecked(EClearStatus ClearStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Breakable", "OnClearStatusChecked");

	Params::Breakable_OnClearStatusChecked Parms{};

	Parms.ClearStatus = ClearStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.BreakPartStateManagerComponent.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBreakPartStateManagerComponent*  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBreakPartStateManagerComponent* UBreakPartStateManagerComponent::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BreakPartStateManagerComponent", "Get");

	Params::BreakPartStateManagerComponent_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.BreakPartStateManagerComponent.ClearBreakPartStates
// (Final, Native, Public, BlueprintCallable)

void UBreakPartStateManagerComponent::ClearBreakPartStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakPartStateManagerComponent", "ClearBreakPartStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.BreakPartStateManagerComponent.RegisterBreakPartState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class AEnemySpawner*              EnemySpawner                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBreakType                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBreakType UBreakPartStateManagerComponent::RegisterBreakPartState(const class AEnemySpawner* EnemySpawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakPartStateManagerComponent", "RegisterBreakPartState");

	Params::BreakPartStateManagerComponent_RegisterBreakPartState Parms{};

	Parms.EnemySpawner = EnemySpawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.BreakPartStateManagerComponent.GetBreakPartState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AEnemySpawner*              EnemySpawner                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBreakType                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBreakType UBreakPartStateManagerComponent::GetBreakPartState(const class AEnemySpawner* EnemySpawner) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakPartStateManagerComponent", "GetBreakPartState");

	Params::BreakPartStateManagerComponent_GetBreakPartState Parms{};

	Parms.EnemySpawner = EnemySpawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HealComponent.AddHealCountBonus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   HealCountBonusToAdd                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHealComponent::AddHealCountBonus(int32 HealCountBonusToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealComponent", "AddHealCountBonus");

	Params::HealComponent_AddHealCountBonus Parms{};

	Parms.HealCountBonusToAdd = HealCountBonusToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HealComponent.AddHealPowerPercentageBonus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   HealPercentBonusToAdd                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHealComponent::AddHealPowerPercentageBonus(int32 HealPercentBonusToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealComponent", "AddHealPowerPercentageBonus");

	Params::HealComponent_AddHealPowerPercentageBonus Parms{};

	Parms.HealPercentBonusToAdd = HealPercentBonusToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HealComponent.FullyRestoreHeals
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealComponent::FullyRestoreHeals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealComponent", "FullyRestoreHeals");

	Params::HealComponent_FullyRestoreHeals Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HealComponent.RestoreHeals
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             RestoreCount                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHealComponent::RestoreHeals(const int32 RestoreCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealComponent", "RestoreHeals");

	Params::HealComponent_RestoreHeals Parms{};

	Parms.RestoreCount = RestoreCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HealComponent.SubHealCountBonus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   HealCountBonusToSub                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHealComponent::SubHealCountBonus(int32 HealCountBonusToSub)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealComponent", "SubHealCountBonus");

	Params::HealComponent_SubHealCountBonus Parms{};

	Parms.HealCountBonusToSub = HealCountBonusToSub;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HealComponent.SubHealPowerPercentageBonus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   HealPercentBonusToSub                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHealComponent::SubHealPowerPercentageBonus(int32 HealPercentBonusToSub)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealComponent", "SubHealPowerPercentageBonus");

	Params::HealComponent_SubHealPowerPercentageBonus Parms{};

	Parms.HealPercentBonusToSub = HealPercentBonusToSub;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HealComponent.UseHeal
// (Final, Native, Public, BlueprintCallable)

void UHealComponent::UseHeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealComponent", "UseHeal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HealComponent.GetHealValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHealComponent::GetHealValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealComponent", "GetHealValue");

	Params::HealComponent_GetHealValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HealComponent.GetMaxHealCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHealComponent::GetMaxHealCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealComponent", "GetMaxHealCount");

	Params::HealComponent_GetMaxHealCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HealComponent.GetRemainingHealCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHealComponent::GetRemainingHealCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealComponent", "GetRemainingHealCount");

	Params::HealComponent_GetRemainingHealCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HealComponent.IsHealCountMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealComponent::IsHealCountMax() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealComponent", "IsHealCountMax");

	Params::HealComponent_IsHealCountMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.niagaraBPFLibrary.IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FSpineFXData&              FXData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UniagaraBPFLibrary::IsValid(const struct FSpineFXData& FXData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("niagaraBPFLibrary", "IsValid");

	Params::niagaraBPFLibrary_IsValid Parms{};

	Parms.FXData = std::move(FXData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.niagaraBPFLibrary.TryReleaseToPool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UniagaraBPFLibrary::TryReleaseToPool(class UNiagaraComponent* NiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("niagaraBPFLibrary", "TryReleaseToPool");

	Params::niagaraBPFLibrary_TryReleaseToPool Parms{};

	Parms.NiagaraComponent = NiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.IKBonesComponent.GetIKBone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIKBoneDriver                           IKBoneDriver                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UIKBonesComponent::GetIKBone(EIKBoneDriver IKBoneDriver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IKBonesComponent", "GetIKBone");

	Params::IKBonesComponent_GetIKBone Parms{};

	Parms.IKBoneDriver = IKBoneDriver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.IKBonesComponent.ResetIKBone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIKBoneDriver                           IKBoneDriver                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetIKConstraint                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIKBonesComponent::ResetIKBone(EIKBoneDriver IKBoneDriver, bool bResetIKConstraint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IKBonesComponent", "ResetIKBone");

	Params::IKBonesComponent_ResetIKBone Parms{};

	Parms.IKBoneDriver = IKBoneDriver;
	Parms.bResetIKConstraint = bResetIKConstraint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetPlayTimeClock.UpdatePlayTime
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetPlayTimeClock::UpdatePlayTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayTimeClock", "UpdatePlayTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetWorldSpace.Hide
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetWorldSpace::Hide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpace", "Hide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetWorldSpace.OnHide
// (Event, Protected, BlueprintEvent)

void UUserWidgetWorldSpace::OnHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpace", "OnHide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetWorldSpace.OnShow
// (Event, Protected, BlueprintEvent)

void UUserWidgetWorldSpace::OnShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpace", "OnShow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetWorldSpace.Show
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetWorldSpace::Show()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpace", "Show");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetWorldSpaceText.SetText
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidgetWorldSpaceText::SetText(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpaceText", "SetText");

	Params::UserWidgetWorldSpaceText_SetText Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Command_AI_DashTo.OnMoveBlocked
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCommand_AI_DashTo::OnMoveBlocked(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command_AI_DashTo", "OnMoveBlocked");

	Params::Command_AI_DashTo_OnMoveBlocked Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GuardComponent.OnGuarded
// (Final, Native, Private)
// Parameters:
// class AAbility*                         Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGuardComponent::OnGuarded(class AAbility* Ability, class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GuardComponent", "OnGuarded");

	Params::GuardComponent_OnGuarded Parms{};

	Parms.Ability = Ability;
	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.BTTask_Execute.OnFinishCommand
// (Final, Native, Private)
// Parameters:
// const class UCommand*                   Command                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommandFinishType                      FinishType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTTask_Execute::OnFinishCommand(const class UCommand* Command, ECommandFinishType FinishType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_Execute", "OnFinishCommand");

	Params::BTTask_Execute_OnFinishCommand Parms{};

	Parms.Command = Command;
	Parms.FinishType = FinishType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DeathProcess_Transform.OnDeathAnimationFinished
// (Final, Native, Private)

void UDeathProcess_Transform::OnDeathAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathProcess_Transform", "OnDeathAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DeathProcess_Transform.OnMovementModeChanged
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeathProcess_Transform::OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathProcess_Transform", "OnMovementModeChanged");

	Params::DeathProcess_Transform_OnMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FollowTargetComponent.ClearFollowTarget
// (Final, Native, Public, BlueprintCallable)

void UFollowTargetComponent::ClearFollowTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowTargetComponent", "ClearFollowTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FollowTargetComponent.OnGameMapChanged
// (Final, Native, Private)

void UFollowTargetComponent::OnGameMapChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowTargetComponent", "OnGameMapChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FollowTargetComponent.SetFollowTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  NewFollowTarget                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSnapToTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFollowTargetComponent::SetFollowTarget(class USceneComponent* NewFollowTarget, bool bSnapToTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowTargetComponent", "SetFollowTarget");

	Params::FollowTargetComponent_SetFollowTarget Parms{};

	Parms.NewFollowTarget = NewFollowTarget;
	Parms.bSnapToTarget = bSnapToTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FollowTargetComponent.TeleportToTarget
// (Final, Native, Public, BlueprintCallable)

void UFollowTargetComponent::TeleportToTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowTargetComponent", "TeleportToTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FollowTargetComponent.GetFollowTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UFollowTargetComponent::GetFollowTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowTargetComponent", "GetFollowTarget");

	Params::FollowTargetComponent_GetFollowTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FollowTargetComponent.GetFollowTargetDeltaLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UFollowTargetComponent::GetFollowTargetDeltaLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowTargetComponent", "GetFollowTargetDeltaLocation");

	Params::FollowTargetComponent_GetFollowTargetDeltaLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FollowTargetComponent.GetFollowTargetForward
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UFollowTargetComponent::GetFollowTargetForward() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowTargetComponent", "GetFollowTargetForward");

	Params::FollowTargetComponent_GetFollowTargetForward Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FollowTargetComponent.GetFollowTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UFollowTargetComponent::GetFollowTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowTargetComponent", "GetFollowTargetLocation");

	Params::FollowTargetComponent_GetFollowTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FollowTargetComponent.GetTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class USceneComponent*            PinnedTarget                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UFollowTargetComponent::GetTargetLocation(const class USceneComponent* PinnedTarget) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowTargetComponent", "GetTargetLocation");

	Params::FollowTargetComponent_GetTargetLocation Parms{};

	Parms.PinnedTarget = PinnedTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ContactDamageComponent.OnHitboxBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UContactDamageComponent::OnHitboxBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContactDamageComponent", "OnHitboxBeginOverlap");

	Params::ContactDamageComponent_OnHitboxBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ContactDamageComponent.OnHitboxEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContactDamageComponent::OnHitboxEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContactDamageComponent", "OnHitboxEndOverlap");

	Params::ContactDamageComponent_OnHitboxEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DashChargeComponent.OnCommandStart
// (Final, Native, Private)
// Parameters:
// const class UCommand*                   Command                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDashChargeComponent::OnCommandStart(const class UCommand* Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DashChargeComponent", "OnCommandStart");

	Params::DashChargeComponent_OnCommandStart Parms{};

	Parms.Command = Command;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DashChargeComponent.OnStartAnimation
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      TrackEntry                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDashChargeComponent::OnStartAnimation(class UTrackEntry* TrackEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DashChargeComponent", "OnStartAnimation");

	Params::DashChargeComponent_OnStartAnimation Parms{};

	Parms.TrackEntry = TrackEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DashChargeComponent.IsDashCharged
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDashChargeComponent::IsDashCharged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DashChargeComponent", "IsDashCharged");

	Params::DashChargeComponent_IsDashCharged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.EventAction_MoveTo_TalkDistance.OnMoveCompleted
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventAction_MoveTo_TalkDistance::OnMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventAction_MoveTo_TalkDistance", "OnMoveCompleted");

	Params::EventAction_MoveTo_TalkDistance_OnMoveCompleted Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EventAction_PlayFX.OnSystemCompleted
// (Final, Native, Private)
// Parameters:
// class UNiagaraComponent*                PSystem                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventAction_PlayFX::OnSystemCompleted(class UNiagaraComponent* PSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventAction_PlayFX", "OnSystemCompleted");

	Params::EventAction_PlayFX_OnSystemCompleted Parms{};

	Parms.PSystem = PSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FieldTalkComponent.OnPawnDeath
// (Final, Native, Private)

void UFieldTalkComponent::OnPawnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldTalkComponent", "OnPawnDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FieldTalkComponent.ShowFieldTalkEntry
// (Final, Native, Protected)

void UFieldTalkComponent::ShowFieldTalkEntry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldTalkComponent", "ShowFieldTalkEntry");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FieldTalkComponent.StartFieldTalk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFieldTalkAsset*                  FieldTalkAsset                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipActiveFieldTalkAsset                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldTalkComponent::StartFieldTalk(class UFieldTalkAsset* FieldTalkAsset, bool bSkipActiveFieldTalkAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldTalkComponent", "StartFieldTalk");

	Params::FieldTalkComponent_StartFieldTalk Parms{};

	Parms.FieldTalkAsset = FieldTalkAsset;
	Parms.bSkipActiveFieldTalkAsset = bSkipActiveFieldTalkAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FieldTalkComponent.CanStartFieldTalk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldTalkComponent::CanStartFieldTalk() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldTalkComponent", "CanStartFieldTalk");

	Params::FieldTalkComponent_CanStartFieldTalk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DeathProcess_Player.OnFadeFinished
// (Final, Native, Private)

void UDeathProcess_Player::OnFadeFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathProcess_Player", "OnFadeFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DeathProcess_Player.OnTimerFinished
// (Final, Native, Private)

void UDeathProcess_Player::OnTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathProcess_Player", "OnTimerFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CharacterZion.OnGuarded
// (Event, Public, BlueprintEvent)
// Parameters:
// class AAbility*                         Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterZion::OnGuarded(class AAbility* Ability, class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZion", "OnGuarded");

	Params::CharacterZion_OnGuarded Parms{};

	Parms.Ability = Ability;
	Parms.Source = Source;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.CharacterZion.OnParried
// (Event, Public, BlueprintEvent)
// Parameters:
// class AAbility*                         Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterZion::OnParried(class AAbility* Ability, class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZion", "OnParried");

	Params::CharacterZion_OnParried Parms{};

	Parms.Ability = Ability;
	Parms.Source = Source;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.CharacterZion.OnReceivedDamage
// (Final, Native, Private)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterZion::OnReceivedDamage(class AActor* Source, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZion", "OnReceivedDamage");

	Params::CharacterZion_OnReceivedDamage Parms{};

	Parms.Source = Source;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CharacterZion.ResetJumpCount
// (Final, Native, Public, BlueprintCallable)

void ACharacterZion::ResetJumpCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZion", "ResetJumpCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CharacterZion.GetCollisionComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCollisionComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCollisionComponent* ACharacterZion::GetCollisionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZion", "GetCollisionComponent");

	Params::CharacterZion_GetCollisionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CharacterZion.GetZionCharacterMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UZionCharacterMovementComponent*  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UZionCharacterMovementComponent* ACharacterZion::GetZionCharacterMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZion", "GetZionCharacterMovement");

	Params::CharacterZion_GetZionCharacterMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CharacterZion.IsInEvent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterZion::IsInEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZion", "IsInEvent");

	Params::CharacterZion_IsInEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CharacterZion.ShouldConsiderJumpAsAirborne
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterZion::ShouldConsiderJumpAsAirborne() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZion", "ShouldConsiderJumpAsAirborne");

	Params::CharacterZion_ShouldConsiderJumpAsAirborne Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CharacterZion.ShouldConsiderJumpAsGrounded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterZion::ShouldConsiderJumpAsGrounded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZion", "ShouldConsiderJumpAsGrounded");

	Params::CharacterZion_ShouldConsiderJumpAsGrounded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CharacterZion.ShouldConsiderJumpAsHookAttach
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterZion::ShouldConsiderJumpAsHookAttach() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZion", "ShouldConsiderJumpAsHookAttach");

	Params::CharacterZion_ShouldConsiderJumpAsHookAttach Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CharacterZion.ShouldConsiderJumpAsWallGrab
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterZion::ShouldConsiderJumpAsWallGrab() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZion", "ShouldConsiderJumpAsWallGrab");

	Params::CharacterZion_ShouldConsiderJumpAsWallGrab Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CharacterZionNPC.SetIdleOverrideAnimations
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FSpineAnimationDefinition>&NewIdleOverrideAnimations                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACharacterZionNPC::SetIdleOverrideAnimations(const TArray<struct FSpineAnimationDefinition>& NewIdleOverrideAnimations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionNPC", "SetIdleOverrideAnimations");

	Params::CharacterZionNPC_SetIdleOverrideAnimations Parms{};

	Parms.NewIdleOverrideAnimations = std::move(NewIdleOverrideAnimations);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CharacterZionSpirit.DelayedDismiss
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterZionSpirit::DelayedDismiss(float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionSpirit", "DelayedDismiss");

	Params::CharacterZionSpirit_DelayedDismiss Parms{};

	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CharacterZionSpirit.Dismiss
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterZionSpirit::Dismiss(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionSpirit", "Dismiss");

	Params::CharacterZionSpirit_Dismiss Parms{};

	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CharacterZionSpirit.OnActivate
// (Event, Protected, BlueprintEvent)

void ACharacterZionSpirit::OnActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionSpirit", "OnActivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.CharacterZionSpirit.OnDeactivate
// (Event, Protected, BlueprintEvent)

void ACharacterZionSpirit::OnDeactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionSpirit", "OnDeactivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.CharacterZionSpirit.OnDismiss
// (Event, Protected, BlueprintEvent)

void ACharacterZionSpirit::OnDismiss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionSpirit", "OnDismiss");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.CharacterZionSpirit.OnLocationBlendEnd
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   StartLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   EndLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterZionSpirit::OnLocationBlendEnd(const struct FVector& StartLocation, const struct FVector& EndLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionSpirit", "OnLocationBlendEnd");

	Params::CharacterZionSpirit_OnLocationBlendEnd Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.CharacterZionSpirit.OnLocationBlendStart
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   StartLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   EndLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterZionSpirit::OnLocationBlendStart(const struct FVector& StartLocation, const struct FVector& EndLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionSpirit", "OnLocationBlendStart");

	Params::CharacterZionSpirit_OnLocationBlendStart Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.CharacterZionSpirit.OnPreSummon
// (Event, Protected, BlueprintEvent)

void ACharacterZionSpirit::OnPreSummon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionSpirit", "OnPreSummon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.CharacterZionSpirit.OnSummon
// (Event, Protected, BlueprintEvent)

void ACharacterZionSpirit::OnSummon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionSpirit", "OnSummon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.CharacterZionSpirit.OnTeleport
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   From                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   To                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterZionSpirit::OnTeleport(const struct FVector& From, const struct FVector& To)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionSpirit", "OnTeleport");

	Params::CharacterZionSpirit_OnTeleport Parms{};

	Parms.From = std::move(From);
	Parms.To = std::move(To);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.CharacterZionSpirit.SetActive
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    bNewActive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterZionSpirit::SetActive(bool bNewActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionSpirit", "SetActive");

	Params::CharacterZionSpirit_SetActive Parms{};

	Parms.bNewActive = bNewActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CharacterZionSpirit.GetSummoner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ACharacterZionSpirit::GetSummoner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionSpirit", "GetSummoner");

	Params::CharacterZionSpirit_GetSummoner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CharacterZionSpirit.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterZionSpirit::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionSpirit", "IsActive");

	Params::CharacterZionSpirit_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CharacterZionSpirit.IsSummoned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterZionSpirit::IsSummoned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterZionSpirit", "IsSummoned");

	Params::CharacterZionSpirit_IsSummoned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatsComponent.GetAttack
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatsComponent::GetAttack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsComponent", "GetAttack");

	Params::StatsComponent_GetAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatsComponent.GetDamageCutPercentage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAttackType                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatsComponent::GetDamageCutPercentage(EAttackType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsComponent", "GetDamageCutPercentage");

	Params::StatsComponent_GetDamageCutPercentage Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatsComponent.GetDefense
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatsComponent::GetDefense() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsComponent", "GetDefense");

	Params::StatsComponent_GetDefense Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatsComponent.GetStaminaCutPercentage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAttackType                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatsComponent::GetStaminaCutPercentage(EAttackType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsComponent", "GetStaminaCutPercentage");

	Params::StatsComponent_GetStaminaCutPercentage Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ClearComponent.MarkAsCleared
// (Final, Native, Public, BlueprintCallable)

void UClearComponent::MarkAsCleared()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClearComponent", "MarkAsCleared");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ClearComponent.GetClearStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EClearStatus                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EClearStatus UClearComponent::GetClearStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClearComponent", "GetClearStatus");

	Params::ClearComponent_GetClearStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ClearComponent.GetPreviousRunsClearStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EClearStatus                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EClearStatus UClearComponent::GetPreviousRunsClearStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClearComponent", "GetPreviousRunsClearStatus");

	Params::ClearComponent_GetPreviousRunsClearStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ClearComponent.IsCleared
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClearComponent::IsCleared() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClearComponent", "IsCleared");

	Params::ClearComponent_IsCleared Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ClearComponent.WasClearedOnPreviousRuns
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClearComponent::WasClearedOnPreviousRuns() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClearComponent", "WasClearedOnPreviousRuns");

	Params::ClearComponent_WasClearedOnPreviousRuns Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ClearManagerComponent.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClearManagerComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClearManagerComponent* UClearManagerComponent::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ClearManagerComponent", "Get");

	Params::ClearManagerComponent_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ClearManagerComponent.ResetClearedObjects
// (Final, Native, Public, BlueprintCallable)

void UClearManagerComponent::ResetClearedObjects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClearManagerComponent", "ResetClearedObjects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetRestPointListEntry.InitializeEntry
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidgetMapIcon_RestPoint*     RestPointIcon                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetRestPointListEntry::InitializeEntry(class UUserWidgetMapIcon_RestPoint* RestPointIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointListEntry", "InitializeEntry");

	Params::UserWidgetRestPointListEntry_InitializeEntry Parms{};

	Parms.RestPointIcon = RestPointIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetRestPointListEntry.OnInitializeEntry
// (Event, Public, BlueprintEvent)

void UUserWidgetRestPointListEntry::OnInitializeEntry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointListEntry", "OnInitializeEntry");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetRestPointListEntry.IsRestPointIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUserWidgetMapIcon_RestPoint*     RestPointIcon                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetRestPointListEntry::IsRestPointIcon(class UUserWidgetMapIcon_RestPoint* RestPointIcon) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointListEntry", "IsRestPointIcon");

	Params::UserWidgetRestPointListEntry_IsRestPointIcon Parms{};

	Parms.RestPointIcon = RestPointIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMinimap.ChangeDisplayMode
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetMinimap::ChangeDisplayMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMinimap", "ChangeDisplayMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMinimap.InitializeDefaultDisplayValues
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetMinimap::InitializeDefaultDisplayValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMinimap", "InitializeDefaultDisplayValues");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMinimap.OnGameMapChanged
// (Final, Native, Private)

void UUserWidgetMinimap::OnGameMapChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMinimap", "OnGameMapChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMinimap.OnRefreshMinimap
// (Event, Protected, BlueprintEvent)

void UUserWidgetMinimap::OnRefreshMinimap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMinimap", "OnRefreshMinimap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetMinimap.OnStoryLevelChanged
// (Final, Native, Private)

void UUserWidgetMinimap::OnStoryLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMinimap", "OnStoryLevelChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMinimap.RequestRender
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetMinimap::RequestRender()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMinimap", "RequestRender");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMinimap.HasValidData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetMinimap::HasValidData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMinimap", "HasValidData");

	Params::UserWidgetMinimap_HasValidData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CollisionComponent.RefreshHitboxVisuals
// (Final, Native, Private, BlueprintCallable)

void UCollisionComponent::RefreshHitboxVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollisionComponent", "RefreshHitboxVisuals");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CollisionComponent.RefreshHurtboxVisuals
// (Final, Native, Private, BlueprintCallable)

void UCollisionComponent::RefreshHurtboxVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollisionComponent", "RefreshHurtboxVisuals");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ComboBoxStringZion.AddOptions
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FString>&            OptionsToAdd                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UComboBoxStringZion::AddOptions(const TArray<class FString>& OptionsToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxStringZion", "AddOptions");

	Params::ComboBoxStringZion_AddOptions Parms{};

	Parms.OptionsToAdd = std::move(OptionsToAdd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CommandComponent.AddCommands
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FCommandSettings>&  CommandSettingsArray                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const class UCommandSet*                OverrideCommandSet                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCommandComponent::AddCommands(const TArray<struct FCommandSettings>& CommandSettingsArray, const class UCommandSet* OverrideCommandSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandComponent", "AddCommands");

	Params::CommandComponent_AddCommands Parms{};

	Parms.CommandSettingsArray = std::move(CommandSettingsArray);
	Parms.OverrideCommandSet = OverrideCommandSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CommandComponent.AddCommandsFromClasses
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<TSubclassOf<class UCommand>>&CommandClasses                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// const class UInputAction*               InvokedByInputAction                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommandLayerType                       CommandLayerType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveOnStartFailure                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCommandSet*                OverrideCommandSet                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommandComponent::AddCommandsFromClasses(const TArray<TSubclassOf<class UCommand>>& CommandClasses, const class UInputAction* InvokedByInputAction, ECommandLayerType CommandLayerType, bool bRemoveOnStartFailure, const class UCommandSet* OverrideCommandSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandComponent", "AddCommandsFromClasses");

	Params::CommandComponent_AddCommandsFromClasses Parms{};

	Parms.CommandClasses = std::move(CommandClasses);
	Parms.InvokedByInputAction = InvokedByInputAction;
	Parms.CommandLayerType = CommandLayerType;
	Parms.bRemoveOnStartFailure = bRemoveOnStartFailure;
	Parms.OverrideCommandSet = OverrideCommandSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CommandComponent.AddCommandsToVirtualBufferFromClasses
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<TSubclassOf<class UCommand>>&CommandClasses                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// const class UInputAction*               InvokedByInputAction                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommandLayerType                       CommandLayerType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BufferTTL                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommandComponent::AddCommandsToVirtualBufferFromClasses(const TArray<TSubclassOf<class UCommand>>& CommandClasses, const class UInputAction* InvokedByInputAction, ECommandLayerType CommandLayerType, float BufferTTL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandComponent", "AddCommandsToVirtualBufferFromClasses");

	Params::CommandComponent_AddCommandsToVirtualBufferFromClasses Parms{};

	Parms.CommandClasses = std::move(CommandClasses);
	Parms.InvokedByInputAction = InvokedByInputAction;
	Parms.CommandLayerType = CommandLayerType;
	Parms.BufferTTL = BufferTTL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CommandComponent.ClearCommands
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bStopCurrentCommand                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommandComponent::ClearCommands(bool bStopCurrentCommand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandComponent", "ClearCommands");

	Params::CommandComponent_ClearCommands Parms{};

	Parms.bStopCurrentCommand = bStopCurrentCommand;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CommandComponent.OnMovementModeChanged
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommandComponent::OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandComponent", "OnMovementModeChanged");

	Params::CommandComponent_OnMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CommandComponent.ResetFallingExecutionCounts
// (Final, Native, Public, BlueprintCallable)

void UCommandComponent::ResetFallingExecutionCounts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandComponent", "ResetFallingExecutionCounts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CommandComponent.ResetFallingExecutionCountsOfCategories
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<ECommandCategory>&         CategoriesToReset                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCommandComponent::ResetFallingExecutionCountsOfCategories(const TArray<ECommandCategory>& CategoriesToReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandComponent", "ResetFallingExecutionCountsOfCategories");

	Params::CommandComponent_ResetFallingExecutionCountsOfCategories Parms{};

	Parms.CategoriesToReset = std::move(CategoriesToReset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.CommandComponent.GetCooldownForCommandSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UCommandSet*                CommandSet                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCommandComponent::GetCooldownForCommandSet(const class UCommandSet* CommandSet) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandComponent", "GetCooldownForCommandSet");

	Params::CommandComponent_GetCooldownForCommandSet Parms{};

	Parms.CommandSet = CommandSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CommandComponent.GetCooldownRatioForCommandSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UCommandSet*                CommandSet                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCommandComponent::GetCooldownRatioForCommandSet(const class UCommandSet* CommandSet) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandComponent", "GetCooldownRatioForCommandSet");

	Params::CommandComponent_GetCooldownRatioForCommandSet Parms{};

	Parms.CommandSet = CommandSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CommandComponent.HasCommand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommandComponent::HasCommand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandComponent", "HasCommand");

	Params::CommandComponent_HasCommand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetWorldSpaceText_Talk.CompleteTalk
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetWorldSpaceText_Talk::CompleteTalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpaceText_Talk", "CompleteTalk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetWorldSpaceText_Talk.FinishTalk
// (Event, Public, BlueprintEvent)

void UUserWidgetWorldSpaceText_Talk::FinishTalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpaceText_Talk", "FinishTalk");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetWorldSpaceText_Talk.OnPressConfirm
// (Event, Public, BlueprintEvent)

void UUserWidgetWorldSpaceText_Talk::OnPressConfirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpaceText_Talk", "OnPressConfirm");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetWorldSpaceText_Talk.OnTalk
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FTalkParameters&           TalkParameters                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidgetWorldSpaceText_Talk::OnTalk(const struct FTalkParameters& TalkParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpaceText_Talk", "OnTalk");

	Params::UserWidgetWorldSpaceText_Talk_OnTalk Parms{};

	Parms.TalkParameters = std::move(TalkParameters);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetWorldSpaceText_Talk.SetSpeakerName
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      SpeakerName                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidgetWorldSpaceText_Talk::SetSpeakerName(const class FText& SpeakerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpaceText_Talk", "SetSpeakerName");

	Params::UserWidgetWorldSpaceText_Talk_SetSpeakerName Parms{};

	Parms.SpeakerName = std::move(SpeakerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetStatusEffectIcon.OnStatusEffectFinished
// (Final, Native, Protected)

void UUserWidgetStatusEffectIcon::OnStatusEffectFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetStatusEffectIcon", "OnStatusEffectFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetStatusEffectIcon.UpdateRemainingDuration
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetStatusEffectIcon::UpdateRemainingDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetStatusEffectIcon", "UpdateRemainingDuration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetStatusEffectIcon.GetCachedStatusEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStatusEffect*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffect* UUserWidgetStatusEffectIcon::GetCachedStatusEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetStatusEffectIcon", "GetCachedStatusEffect");

	Params::UserWidgetStatusEffectIcon_GetCachedStatusEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetStatusEffectIcon.GetStatusEffectIconSprite
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UPaperSprite>      ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UPaperSprite> UUserWidgetStatusEffectIcon::GetStatusEffectIconSprite() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetStatusEffectIcon", "GetStatusEffectIconSprite");

	Params::UserWidgetStatusEffectIcon_GetStatusEffectIconSprite Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetStatusEffectIcon.GetStatusEffectIconSpriteFromType
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EStatusEffectType&                StatusEffectType                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UPaperSprite>      ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UPaperSprite> UUserWidgetStatusEffectIcon::GetStatusEffectIconSpriteFromType(const EStatusEffectType& StatusEffectType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetStatusEffectIcon", "GetStatusEffectIconSpriteFromType");

	Params::UserWidgetStatusEffectIcon_GetStatusEffectIconSpriteFromType Parms{};

	Parms.StatusEffectType = StatusEffectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.WallAttachComponent.OnMovementModeChanged
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWallAttachComponent::OnMovementModeChanged(class ACharacter* InCharacter, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WallAttachComponent", "OnMovementModeChanged");

	Params::WallAttachComponent_OnMovementModeChanged Parms{};

	Parms.InCharacter = InCharacter;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetWorldSpaceDebug.ClearTextForTag
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetWorldSpaceDebug::ClearTextForTag(class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpaceDebug", "ClearTextForTag");

	Params::UserWidgetWorldSpaceDebug_ClearTextForTag Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetWorldSpaceDebug.SetTextForTag
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetWorldSpaceDebug::SetTextForTag(class FName Tag, const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpaceDebug", "SetTextForTag");

	Params::UserWidgetWorldSpaceDebug_SetTextForTag Parms{};

	Parms.Tag = Tag;
	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FadeSubsystem.LaunchFadeIn
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FFadeDescriptionData&      FadeDescription                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const TDelegate<void()>&                OnFadeFinishedDelegate                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFadeLayer                              FadeLayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFadeSubsystem::LaunchFadeIn(const struct FFadeDescriptionData& FadeDescription, const TDelegate<void()>& OnFadeFinishedDelegate, EFadeLayer FadeLayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "LaunchFadeIn");

	Params::FadeSubsystem_LaunchFadeIn Parms{};

	Parms.FadeDescription = std::move(FadeDescription);
	Parms.OnFadeFinishedDelegate = OnFadeFinishedDelegate;
	Parms.FadeLayer = FadeLayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FadeSubsystem.LaunchFadeOut
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FFadeDescriptionData&      FadeDescription                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const TDelegate<void()>&                OnFadeFinishedDelegate                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFadeLayer                              FadeLayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFadeSubsystem::LaunchFadeOut(const struct FFadeDescriptionData& FadeDescription, const TDelegate<void()>& OnFadeFinishedDelegate, EFadeLayer FadeLayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "LaunchFadeOut");

	Params::FadeSubsystem_LaunchFadeOut Parms{};

	Parms.FadeDescription = std::move(FadeDescription);
	Parms.OnFadeFinishedDelegate = OnFadeFinishedDelegate;
	Parms.FadeLayer = FadeLayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FadeSubsystem.OnFadeWidgetDestruct
// (Final, Native, Private)

void UFadeSubsystem::OnFadeWidgetDestruct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "OnFadeWidgetDestruct");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FadeSubsystem.SetupFadeIn
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FFadeDescriptionData&      FadeDescription                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EFadeLayer                              FadeLayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFadeSubsystem::SetupFadeIn(const struct FFadeDescriptionData& FadeDescription, EFadeLayer FadeLayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "SetupFadeIn");

	Params::FadeSubsystem_SetupFadeIn Parms{};

	Parms.FadeDescription = std::move(FadeDescription);
	Parms.FadeLayer = FadeLayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FadeSubsystem.GetFadeState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFadeLayer                              FadeLayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFadeState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFadeState UFadeSubsystem::GetFadeState(EFadeLayer FadeLayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "GetFadeState");

	Params::FadeSubsystem_GetFadeState Parms{};

	Parms.FadeLayer = FadeLayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FadeSubsystem.IsAnyFadeVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFadeSubsystem::IsAnyFadeVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "IsAnyFadeVisible");

	Params::FadeSubsystem_IsAnyFadeVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FadeSubsystem.IsFadeVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFadeLayer                              FadeLayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFadeSubsystem::IsFadeVisible(EFadeLayer FadeLayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "IsFadeVisible");

	Params::FadeSubsystem_IsFadeVisible Parms{};

	Parms.FadeLayer = FadeLayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FadeSubsystem.IsFading
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFadeLayer                              FadeLayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFadeSubsystem::IsFading(EFadeLayer FadeLayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "IsFading");

	Params::FadeSubsystem_IsFading Parms{};

	Parms.FadeLayer = FadeLayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DeathComponent.OnHPReachedZero
// (Final, Native, Private)

void UDeathComponent::OnHPReachedZero()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathComponent", "OnHPReachedZero");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DeathComponent.IsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDeathComponent::IsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathComponent", "IsDead");

	Params::DeathComponent_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.WorldLoaderSubsystem.OnFadeInFinished
// (Final, Native, Private)

void UWorldLoaderSubsystem::OnFadeInFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldLoaderSubsystem", "OnFadeInFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.WorldLoaderSubsystem.OnFadeOutFinished
// (Final, Native, Private)

void UWorldLoaderSubsystem::OnFadeOutFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldLoaderSubsystem", "OnFadeOutFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.WorldLoaderSubsystem.OnLevelStreamingDynamicLoaded
// (Final, Native, Private)

void UWorldLoaderSubsystem::OnLevelStreamingDynamicLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldLoaderSubsystem", "OnLevelStreamingDynamicLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.WorldLoaderSubsystem.OnPostLoad
// (Final, Native, Private)

void UWorldLoaderSubsystem::OnPostLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldLoaderSubsystem", "OnPostLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.WorldLoaderSubsystem.OpenGameMap
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       GameMapHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class FName                       PlayerStartTag                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceReload                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFadeDescriptionData&      FadeOutDescription                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FFadeDescriptionData&      FadeInDescription                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UWorldLoaderSubsystem::OpenGameMap(const struct FDataTableRowHandle& GameMapHandle, const class FName PlayerStartTag, bool bForceReload, const struct FFadeDescriptionData& FadeOutDescription, const struct FFadeDescriptionData& FadeInDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldLoaderSubsystem", "OpenGameMap");

	Params::WorldLoaderSubsystem_OpenGameMap Parms{};

	Parms.GameMapHandle = std::move(GameMapHandle);
	Parms.PlayerStartTag = PlayerStartTag;
	Parms.bForceReload = bForceReload;
	Parms.FadeOutDescription = std::move(FadeOutDescription);
	Parms.FadeInDescription = std::move(FadeInDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.WorldLoaderSubsystem.OpenWorld
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UWorld>            WorldToLoad                                            (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PlayerStartTag                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFadeDescriptionData&      FadeOutDescription                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FFadeDescriptionData&      FadeInDescription                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UWorldLoaderSubsystem::OpenWorld(TSoftObjectPtr<class UWorld> WorldToLoad, class FName PlayerStartTag, const struct FFadeDescriptionData& FadeOutDescription, const struct FFadeDescriptionData& FadeInDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldLoaderSubsystem", "OpenWorld");

	Params::WorldLoaderSubsystem_OpenWorld Parms{};

	Parms.WorldToLoad = WorldToLoad;
	Parms.PlayerStartTag = PlayerStartTag;
	Parms.FadeOutDescription = std::move(FadeOutDescription);
	Parms.FadeInDescription = std::move(FadeInDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.WorldLoaderSubsystem.SwitchGameMap_PostFadeIn
// (Final, Native, Private)

void UWorldLoaderSubsystem::SwitchGameMap_PostFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldLoaderSubsystem", "SwitchGameMap_PostFadeIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.WorldLoaderSubsystem.SwitchGameMap_PostFadeOut
// (Final, Native, Private)

void UWorldLoaderSubsystem::SwitchGameMap_PostFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldLoaderSubsystem", "SwitchGameMap_PostFadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.WorldLoaderSubsystem.GetCurrentGameMapData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameMapData               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameMapData UWorldLoaderSubsystem::GetCurrentGameMapData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldLoaderSubsystem", "GetCurrentGameMapData");

	Params::WorldLoaderSubsystem_GetCurrentGameMapData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.WorldLoaderSubsystem.GetCurrentGameMapID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UWorldLoaderSubsystem::GetCurrentGameMapID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldLoaderSubsystem", "GetCurrentGameMapID");

	Params::WorldLoaderSubsystem_GetCurrentGameMapID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.WorldLoaderSubsystem.GetCurrentPlayerStartTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UWorldLoaderSubsystem::GetCurrentPlayerStartTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldLoaderSubsystem", "GetCurrentPlayerStartTag");

	Params::WorldLoaderSubsystem_GetCurrentPlayerStartTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.WorldLoaderSubsystem.IsAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldLoaderSubsystem::IsAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldLoaderSubsystem", "IsAvailable");

	Params::WorldLoaderSubsystem_IsAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.WorldLoaderSubsystem.IsLoading
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bConsiderFadeAsLoading                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldLoaderSubsystem::IsLoading(bool bConsiderFadeAsLoading) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldLoaderSubsystem", "IsLoading");

	Params::WorldLoaderSubsystem_IsLoading Parms{};

	Parms.bConsiderFadeAsLoading = bConsiderFadeAsLoading;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.CommandModule_Timeline_Move.OnMovementModeChanged
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommandModule_Timeline_Move::OnMovementModeChanged(class ACharacter* InCharacter, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandModule_Timeline_Move", "OnMovementModeChanged");

	Params::CommandModule_Timeline_Move_OnMovementModeChanged Parms{};

	Parms.InCharacter = InCharacter;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Command_AI_WarpTo.OnAnimationStart
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      TrackEntry                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommand_AI_WarpTo::OnAnimationStart(class UTrackEntry* TrackEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command_AI_WarpTo", "OnAnimationStart");

	Params::Command_AI_WarpTo_OnAnimationStart Parms{};

	Parms.TrackEntry = TrackEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Command_Hook.OnMoveBlocked
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCommand_Hook::OnMoveBlocked(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command_Hook", "OnMoveBlocked");

	Params::Command_Hook_OnMoveBlocked Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Command_Hook.OnMovementUpdated
// (Final, Native, Private, HasDefaults)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   OldLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   OldVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommand_Hook::OnMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command_Hook", "OnMovementUpdated");

	Params::Command_Hook_OnMovementUpdated Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Command_WallDash_Release.OnMoveBlocked
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCommand_WallDash_Release::OnMoveBlocked(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Command_WallDash_Release", "OnMoveBlocked");

	Params::Command_WallDash_Release_OnMoveBlocked Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ConditionedTextureData.GetConditionedTextures
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FConditionedTexture>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<struct FConditionedTexture> UConditionedTextureData::GetConditionedTextures() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConditionedTextureData", "GetConditionedTextures");

	Params::ConditionedTextureData_GetConditionedTextures Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerControllerZion*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerControllerZion* APlayerControllerZion::Get(const class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerControllerZion", "Get");

	Params::PlayerControllerZion_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.AddRestEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      RestEventID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerZion::AddRestEvent(const class FName& RestEventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "AddRestEvent");

	Params::PlayerControllerZion_AddRestEvent Parms{};

	Parms.RestEventID = RestEventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.DBG_SetRestEventAvailable
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      RestEventID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAvailable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerZion::DBG_SetRestEventAvailable(const class FName& RestEventID, bool bAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "DBG_SetRestEventAvailable");

	Params::PlayerControllerZion_DBG_SetRestEventAvailable Parms{};

	Parms.RestEventID = RestEventID;
	Parms.bAvailable = bAvailable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.DebugMarkEventAsCleared
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      EventId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCleared                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::DebugMarkEventAsCleared(const class FName& EventId, bool bCleared)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "DebugMarkEventAsCleared");

	Params::PlayerControllerZion_DebugMarkEventAsCleared Parms{};

	Parms.EventId = EventId;
	Parms.bCleared = bCleared;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.DisplayAreaName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      AreaName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerZion::DisplayAreaName(const class FName& AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "DisplayAreaName");

	Params::PlayerControllerZion_DisplayAreaName Parms{};

	Parms.AreaName = AreaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.FlushSpiritCache
// (Final, Native, Public, BlueprintCallable)

void APlayerControllerZion::FlushSpiritCache()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "FlushSpiritCache");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.FullyRestore
// (Final, Native, Public, BlueprintCallable)

void APlayerControllerZion::FullyRestore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "FullyRestore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.GetAvailableRestEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDataTableRowHandle*             out_RestPointEventRowHandle                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRestPointEventData*             out_RestPointEventData                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::GetAvailableRestEvent(struct FDataTableRowHandle* out_RestPointEventRowHandle, struct FRestPointEventData* out_RestPointEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "GetAvailableRestEvent");

	Params::PlayerControllerZion_GetAvailableRestEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_RestPointEventRowHandle != nullptr)
		*out_RestPointEventRowHandle = std::move(Parms.out_RestPointEventRowHandle);

	if (out_RestPointEventData != nullptr)
		*out_RestPointEventData = std::move(Parms.out_RestPointEventData);

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.HidePlayerUI
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerZion::HidePlayerUI(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "HidePlayerUI");

	Params::PlayerControllerZion_HidePlayerUI Parms{};

	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.LaunchTutorialHook
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETutorialHook                           TutorialHook                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerZion::LaunchTutorialHook(ETutorialHook TutorialHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "LaunchTutorialHook");

	Params::PlayerControllerZion_LaunchTutorialHook Parms{};

	Parms.TutorialHook = TutorialHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.LockFastTravel
// (Final, Native, Public, BlueprintCallable)

void APlayerControllerZion::LockFastTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "LockFastTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.MarkEnemyAsKilled
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       EnemyDataHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void APlayerControllerZion::MarkEnemyAsKilled(const struct FDataTableRowHandle& EnemyDataHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "MarkEnemyAsKilled");

	Params::PlayerControllerZion_MarkEnemyAsKilled Parms{};

	Parms.EnemyDataHandle = std::move(EnemyDataHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.MarkEventAsCleared
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UEventAsset*                EventAsset                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerZion::MarkEventAsCleared(const class UEventAsset* EventAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "MarkEventAsCleared");

	Params::PlayerControllerZion_MarkEventAsCleared Parms{};

	Parms.EventAsset = EventAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.MarkExtraEnemyInfoAsAvailable
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       ExtraEnemyInfoItem                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void APlayerControllerZion::MarkExtraEnemyInfoAsAvailable(const struct FDataTableRowHandle& ExtraEnemyInfoItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "MarkExtraEnemyInfoAsAvailable");

	Params::PlayerControllerZion_MarkExtraEnemyInfoAsAvailable Parms{};

	Parms.ExtraEnemyInfoItem = std::move(ExtraEnemyInfoItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.MarkRecollectionItemAsChecked
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       RecollectionItem                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void APlayerControllerZion::MarkRecollectionItemAsChecked(const struct FDataTableRowHandle& RecollectionItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "MarkRecollectionItemAsChecked");

	Params::PlayerControllerZion_MarkRecollectionItemAsChecked Parms{};

	Parms.RecollectionItem = std::move(RecollectionItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.MarkRestEventAsSeen
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      RestEventID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerZion::MarkRestEventAsSeen(const class FName& RestEventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "MarkRestEventAsSeen");

	Params::PlayerControllerZion_MarkRestEventAsSeen Parms{};

	Parms.RestEventID = RestEventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.OnAchievementUnlocked
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      AchievementID                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerZion::OnAchievementUnlocked(const class FName& AchievementID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "OnAchievementUnlocked");

	Params::PlayerControllerZion_OnAchievementUnlocked Parms{};

	Parms.AchievementID = AchievementID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.PlayerControllerZion.OnDisplayAreaName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      AreaName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerZion::OnDisplayAreaName(const class FName& AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "OnDisplayAreaName");

	Params::PlayerControllerZion_OnDisplayAreaName Parms{};

	Parms.AreaName = AreaName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.PlayerControllerZion.OnGameMapChangeFinished
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      GameMapID                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerZion::OnGameMapChangeFinished(const class FName& GameMapID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "OnGameMapChangeFinished");

	Params::PlayerControllerZion_OnGameMapChangeFinished Parms{};

	Parms.GameMapID = GameMapID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.PlayerControllerZion.OnGameMapChangeStart
// (Event, Protected, BlueprintEvent)

void APlayerControllerZion::OnGameMapChangeStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "OnGameMapChangeStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.PlayerControllerZion.OnGameReady
// (Final, Native, Private)

void APlayerControllerZion::OnGameReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "OnGameReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.OnPawnDeathProcessEnd
// (Final, Native, Private)

void APlayerControllerZion::OnPawnDeathProcessEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "OnPawnDeathProcessEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.OnRequestTutorials
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<class FName>&              TutorialIDs                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerControllerZion::OnRequestTutorials(const TArray<class FName>& TutorialIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "OnRequestTutorials");

	Params::PlayerControllerZion_OnRequestTutorials Parms{};

	Parms.TutorialIDs = std::move(TutorialIDs);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.PlayerControllerZion.OnRespawnCompleted
// (Event, Protected, BlueprintEvent)
// Parameters:
// ERespawnReason                          RespawnReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerZion::OnRespawnCompleted(ERespawnReason RespawnReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "OnRespawnCompleted");

	Params::PlayerControllerZion_OnRespawnCompleted Parms{};

	Parms.RespawnReason = RespawnReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.PlayerControllerZion.OnStoryLevelChanged
// (Event, Protected, BlueprintEvent)

void APlayerControllerZion::OnStoryLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "OnStoryLevelChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.PlayerControllerZion.SetMinimapDisplayMode
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const EWidgetMinimapDisplayMode&        NewMinimapDisplayMode                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWidgetMinimapDisplayMode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWidgetMinimapDisplayMode APlayerControllerZion::SetMinimapDisplayMode(const EWidgetMinimapDisplayMode& NewMinimapDisplayMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "SetMinimapDisplayMode");

	Params::PlayerControllerZion_SetMinimapDisplayMode Parms{};

	Parms.NewMinimapDisplayMode = NewMinimapDisplayMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.SetRespawnRestPoint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InRespawnRestPointID                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerZion::SetRespawnRestPoint(const class FName& InRespawnRestPointID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "SetRespawnRestPoint");

	Params::PlayerControllerZion_SetRespawnRestPoint Parms{};

	Parms.InRespawnRestPointID = InRespawnRestPointID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.SetRuntimeCheckpointData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRuntimeCheckpointData&    NewRuntimeCheckpointData                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRuntimeCheckpointData           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRuntimeCheckpointData APlayerControllerZion::SetRuntimeCheckpointData(const struct FRuntimeCheckpointData& NewRuntimeCheckpointData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "SetRuntimeCheckpointData");

	Params::PlayerControllerZion_SetRuntimeCheckpointData Parms{};

	Parms.NewRuntimeCheckpointData = std::move(NewRuntimeCheckpointData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.ShowPlayerUI
// (Final, Native, Private, BlueprintCallable)

void APlayerControllerZion::ShowPlayerUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "ShowPlayerUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.UnlockFastTravel
// (Final, Native, Public, BlueprintCallable)

void APlayerControllerZion::UnlockFastTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "UnlockFastTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerControllerZion.GetMinimapDisplayMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWidgetMinimapDisplayMode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWidgetMinimapDisplayMode APlayerControllerZion::GetMinimapDisplayMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "GetMinimapDisplayMode");

	Params::PlayerControllerZion_GetMinimapDisplayMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.GetPlayerUI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUserWidgetPlayerUI*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidgetPlayerUI* APlayerControllerZion::GetPlayerUI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "GetPlayerUI");

	Params::PlayerControllerZion_GetPlayerUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.GetRespawnRestPointID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName APlayerControllerZion::GetRespawnRestPointID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "GetRespawnRestPointID");

	Params::PlayerControllerZion_GetRespawnRestPointID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.GetRuntimeCheckpointData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRuntimeCheckpointData           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRuntimeCheckpointData APlayerControllerZion::GetRuntimeCheckpointData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "GetRuntimeCheckpointData");

	Params::PlayerControllerZion_GetRuntimeCheckpointData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.GetWidgetMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUserWidgetMap*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidgetMap* APlayerControllerZion::GetWidgetMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "GetWidgetMap");

	Params::PlayerControllerZion_GetWidgetMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.HasAvailableRestEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::HasAvailableRestEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "HasAvailableRestEvent");

	Params::PlayerControllerZion_HasAvailableRestEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.IsAreaNameDisplayed
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      AreaName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::IsAreaNameDisplayed(const class FName& AreaName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "IsAreaNameDisplayed");

	Params::PlayerControllerZion_IsAreaNameDisplayed Parms{};

	Parms.AreaName = AreaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.IsAreaVisited
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      AreaName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::IsAreaVisited(const class FName& AreaName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "IsAreaVisited");

	Params::PlayerControllerZion_IsAreaVisited Parms{};

	Parms.AreaName = AreaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.IsBackToRestPointLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::IsBackToRestPointLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "IsBackToRestPointLocked");

	Params::PlayerControllerZion_IsBackToRestPointLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.IsEnemyKilled
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDataTableRowHandle&       EnemyDataHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::IsEnemyKilled(const struct FDataTableRowHandle& EnemyDataHandle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "IsEnemyKilled");

	Params::PlayerControllerZion_IsEnemyKilled Parms{};

	Parms.EnemyDataHandle = std::move(EnemyDataHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.IsEventCleared
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       EventId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EEventClearedCheckMode            CheckMode                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::IsEventCleared(const class FName EventId, const EEventClearedCheckMode CheckMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "IsEventCleared");

	Params::PlayerControllerZion_IsEventCleared Parms{};

	Parms.EventId = EventId;
	Parms.CheckMode = CheckMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.IsExtraEnemyInfoAvailable
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDataTableRowHandle&       ExtraEnemyInfoItem                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::IsExtraEnemyInfoAvailable(const struct FDataTableRowHandle& ExtraEnemyInfoItem) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "IsExtraEnemyInfoAvailable");

	Params::PlayerControllerZion_IsExtraEnemyInfoAvailable Parms{};

	Parms.ExtraEnemyInfoItem = std::move(ExtraEnemyInfoItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.IsFastTravelLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::IsFastTravelLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "IsFastTravelLocked");

	Params::PlayerControllerZion_IsFastTravelLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.IsInEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::IsInEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "IsInEvent");

	Params::PlayerControllerZion_IsInEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.IsMapTransitionSpawnPointUsed
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMapTransitionSpawnPointData&MapTransitionSpawnPointData                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::IsMapTransitionSpawnPointUsed(const struct FMapTransitionSpawnPointData& MapTransitionSpawnPointData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "IsMapTransitionSpawnPointUsed");

	Params::PlayerControllerZion_IsMapTransitionSpawnPointUsed Parms{};

	Parms.MapTransitionSpawnPointData = std::move(MapTransitionSpawnPointData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.IsRecollectionItemChecked
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDataTableRowHandle&       RecollectionItem                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::IsRecollectionItemChecked(const struct FDataTableRowHandle& RecollectionItem) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "IsRecollectionItemChecked");

	Params::PlayerControllerZion_IsRecollectionItemChecked Parms{};

	Parms.RecollectionItem = std::move(RecollectionItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.IsRestEventAvailable
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      RestEventID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::IsRestEventAvailable(const class FName& RestEventID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "IsRestEventAvailable");

	Params::PlayerControllerZion_IsRestEventAvailable Parms{};

	Parms.RestEventID = RestEventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.IsSoftEventCleared
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSoftObjectPtr<class UEventAsset>&EventAsset                                             (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::IsSoftEventCleared(const TSoftObjectPtr<class UEventAsset>& EventAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "IsSoftEventCleared");

	Params::PlayerControllerZion_IsSoftEventCleared Parms{};

	Parms.EventAsset = EventAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerControllerZion.IsZoneVisited
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FClearActorData&           ZoneActorData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerZion::IsZoneVisited(const struct FClearActorData& ZoneActorData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerZion", "IsZoneVisited");

	Params::PlayerControllerZion_IsZoneVisited Parms{};

	Parms.ZoneActorData = std::move(ZoneActorData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetInventoryItemData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInventoryItemData*              out_ItemData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetInventoryItemData(const struct FDataTableRowHandle& Handle, struct FInventoryItemData* out_ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetInventoryItemData");

	Params::DataTableBPFLibrary_GetInventoryItemData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ItemData != nullptr)
		*out_ItemData = std::move(Parms.out_ItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetItemAptitudeDataFromType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAptitudeType                           AptitudeType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInventoryItemAptitudeData*      out_AptitudeData                                       (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetItemAptitudeDataFromType(class UDataTable* DataTable, EAptitudeType AptitudeType, struct FInventoryItemAptitudeData* out_AptitudeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetItemAptitudeDataFromType");

	Params::DataTableBPFLibrary_GetItemAptitudeDataFromType Parms{};

	Parms.DataTable = DataTable;
	Parms.AptitudeType = AptitudeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_AptitudeData != nullptr)
		*out_AptitudeData = std::move(Parms.out_AptitudeData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetItemAssistData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInventoryItemAssistData*        out_ItemData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetItemAssistData(const struct FDataTableRowHandle& Handle, struct FInventoryItemAssistData* out_ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetItemAssistData");

	Params::DataTableBPFLibrary_GetItemAssistData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ItemData != nullptr)
		*out_ItemData = std::move(Parms.out_ItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetItemBaseEquipmentData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInventoryItemBaseEquipmentData* out_ItemData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetItemBaseEquipmentData(const struct FDataTableRowHandle& Handle, struct FInventoryItemBaseEquipmentData* out_ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetItemBaseEquipmentData");

	Params::DataTableBPFLibrary_GetItemBaseEquipmentData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ItemData != nullptr)
		*out_ItemData = std::move(Parms.out_ItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetItemCostumeData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInventoryItemCostumeData*       out_ItemData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetItemCostumeData(const struct FDataTableRowHandle& Handle, struct FInventoryItemCostumeData* out_ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetItemCostumeData");

	Params::DataTableBPFLibrary_GetItemCostumeData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ItemData != nullptr)
		*out_ItemData = std::move(Parms.out_ItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetItemEnemyInfoData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInventoryItemEnemyInfoData*     out_ItemData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetItemEnemyInfoData(const struct FDataTableRowHandle& Handle, struct FInventoryItemEnemyInfoData* out_ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetItemEnemyInfoData");

	Params::DataTableBPFLibrary_GetItemEnemyInfoData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ItemData != nullptr)
		*out_ItemData = std::move(Parms.out_ItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetItemEquipmentData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInventoryItemEquipmentData*     out_ItemData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetItemEquipmentData(const struct FDataTableRowHandle& Handle, struct FInventoryItemEquipmentData* out_ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetItemEquipmentData");

	Params::DataTableBPFLibrary_GetItemEquipmentData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ItemData != nullptr)
		*out_ItemData = std::move(Parms.out_ItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetItemGalleryData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInventoryItemGalleryData*       out_ItemData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetItemGalleryData(const struct FDataTableRowHandle& Handle, struct FInventoryItemGalleryData* out_ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetItemGalleryData");

	Params::DataTableBPFLibrary_GetItemGalleryData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ItemData != nullptr)
		*out_ItemData = std::move(Parms.out_ItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetItemGenericInfoData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInventoryItemGenericInfoData*   out_ItemData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetItemGenericInfoData(const struct FDataTableRowHandle& Handle, struct FInventoryItemGenericInfoData* out_ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetItemGenericInfoData");

	Params::DataTableBPFLibrary_GetItemGenericInfoData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ItemData != nullptr)
		*out_ItemData = std::move(Parms.out_ItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetItemNPCInfoData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInventoryItemNPCInfoData*       out_ItemData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetItemNPCInfoData(const struct FDataTableRowHandle& Handle, struct FInventoryItemNPCInfoData* out_ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetItemNPCInfoData");

	Params::DataTableBPFLibrary_GetItemNPCInfoData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ItemData != nullptr)
		*out_ItemData = std::move(Parms.out_ItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetItemPassiveData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInventoryItemPassiveData*       out_ItemData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetItemPassiveData(const struct FDataTableRowHandle& Handle, struct FInventoryItemPassiveData* out_ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetItemPassiveData");

	Params::DataTableBPFLibrary_GetItemPassiveData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ItemData != nullptr)
		*out_ItemData = std::move(Parms.out_ItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetItemSkillData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInventoryItemSkillData*         out_ItemData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetItemSkillData(const struct FDataTableRowHandle& Handle, struct FInventoryItemSkillData* out_ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetItemSkillData");

	Params::DataTableBPFLibrary_GetItemSkillData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ItemData != nullptr)
		*out_ItemData = std::move(Parms.out_ItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetItemSpiritData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInventoryItemSpiritData*        out_ItemData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetItemSpiritData(const struct FDataTableRowHandle& Handle, struct FInventoryItemSpiritData* out_ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetItemSpiritData");

	Params::DataTableBPFLibrary_GetItemSpiritData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ItemData != nullptr)
		*out_ItemData = std::move(Parms.out_ItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetItemTipData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInventoryItemTipData*           out_ItemData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetItemTipData(const struct FDataTableRowHandle& Handle, struct FInventoryItemTipData* out_ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetItemTipData");

	Params::DataTableBPFLibrary_GetItemTipData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ItemData != nullptr)
		*out_ItemData = std::move(Parms.out_ItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetItemTutorialData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInventoryItemTutorialData*      out_ItemData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetItemTutorialData(const struct FDataTableRowHandle& Handle, struct FInventoryItemTutorialData* out_ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetItemTutorialData");

	Params::DataTableBPFLibrary_GetItemTutorialData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ItemData != nullptr)
		*out_ItemData = std::move(Parms.out_ItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetMapTransitionRowHandleFromTransitionSpawnPointData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UDataTable*                 MapTransitionDataTable                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMapTransitionSpawnPointData&MapTransitionSpawnPointData                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDataTableRowHandle*             out_MapTransitionRowHandle                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetMapTransitionRowHandleFromTransitionSpawnPointData(const class UDataTable* MapTransitionDataTable, const struct FMapTransitionSpawnPointData& MapTransitionSpawnPointData, struct FDataTableRowHandle* out_MapTransitionRowHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetMapTransitionRowHandleFromTransitionSpawnPointData");

	Params::DataTableBPFLibrary_GetMapTransitionRowHandleFromTransitionSpawnPointData Parms{};

	Parms.MapTransitionDataTable = MapTransitionDataTable;
	Parms.MapTransitionSpawnPointData = std::move(MapTransitionSpawnPointData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_MapTransitionRowHandle != nullptr)
		*out_MapTransitionRowHandle = std::move(Parms.out_MapTransitionRowHandle);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetRecollectionItemData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ERecollectionItemType                   RecollectionItemType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRecollectionItemData*           out_RecollectionItemData                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetRecollectionItemData(const struct FDataTableRowHandle& Handle, ERecollectionItemType RecollectionItemType, struct FRecollectionItemData* out_RecollectionItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetRecollectionItemData");

	Params::DataTableBPFLibrary_GetRecollectionItemData Parms{};

	Parms.Handle = std::move(Handle);
	Parms.RecollectionItemType = RecollectionItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_RecollectionItemData != nullptr)
		*out_RecollectionItemData = std::move(Parms.out_RecollectionItemData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetRestPointData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRestPointData*                  out_RestPointData                                      (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetRestPointData(const struct FDataTableRowHandle& Handle, struct FRestPointData* out_RestPointData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetRestPointData");

	Params::DataTableBPFLibrary_GetRestPointData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_RestPointData != nullptr)
		*out_RestPointData = std::move(Parms.out_RestPointData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetRestPointEventData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRestPointEventData*             out_RestPointEventData                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetRestPointEventData(const struct FDataTableRowHandle& Handle, struct FRestPointEventData* out_RestPointEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetRestPointEventData");

	Params::DataTableBPFLibrary_GetRestPointEventData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_RestPointEventData != nullptr)
		*out_RestPointEventData = std::move(Parms.out_RestPointEventData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.GetSkillLevelDataFromItemSkillData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FInventoryItemSkillData&   ItemSkillData                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSkillLevelData*                 out_SkillData                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::GetSkillLevelDataFromItemSkillData(const struct FInventoryItemSkillData& ItemSkillData, int32 Level, struct FSkillLevelData* out_SkillData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "GetSkillLevelDataFromItemSkillData");

	Params::DataTableBPFLibrary_GetSkillLevelDataFromItemSkillData Parms{};

	Parms.ItemSkillData = std::move(ItemSkillData);
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_SkillData != nullptr)
		*out_SkillData = std::move(Parms.out_SkillData);

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.IsAllRecollectionItemsChecked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerControllerZion*            PlayerControllerZion                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDataTable*                 DataTable                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERecollectionItemType                   RecollectionItemType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::IsAllRecollectionItemsChecked(class APlayerControllerZion* PlayerControllerZion, const class UDataTable* DataTable, ERecollectionItemType RecollectionItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "IsAllRecollectionItemsChecked");

	Params::DataTableBPFLibrary_IsAllRecollectionItemsChecked Parms{};

	Parms.PlayerControllerZion = PlayerControllerZion;
	Parms.DataTable = DataTable;
	Parms.RecollectionItemType = RecollectionItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.IsAnyRecollectionItemVisible
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerControllerZion*            PlayerControllerZion                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDataTable*                 DataTable                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERecollectionItemType                   RecollectionItemType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::IsAnyRecollectionItemVisible(class APlayerControllerZion* PlayerControllerZion, const class UDataTable* DataTable, ERecollectionItemType RecollectionItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "IsAnyRecollectionItemVisible");

	Params::DataTableBPFLibrary_IsAnyRecollectionItemVisible Parms{};

	Parms.PlayerControllerZion = PlayerControllerZion;
	Parms.DataTable = DataTable;
	Parms.RecollectionItemType = RecollectionItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.IsEqual
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDataTableRowHandle&       A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::IsEqual(const struct FDataTableRowHandle& A, const struct FDataTableRowHandle& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "IsEqual");

	Params::DataTableBPFLibrary_IsEqual Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.IsItemEnemyInfoVisible
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerControllerZion*      PlayerControllerZion                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::IsItemEnemyInfoVisible(const class APlayerControllerZion* PlayerControllerZion, const struct FDataTableRowHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "IsItemEnemyInfoVisible");

	Params::DataTableBPFLibrary_IsItemEnemyInfoVisible Parms{};

	Parms.PlayerControllerZion = PlayerControllerZion;
	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.IsItemGalleryVisible
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerControllerZion*            PlayerControllerZion                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::IsItemGalleryVisible(class APlayerControllerZion* PlayerControllerZion, const struct FDataTableRowHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "IsItemGalleryVisible");

	Params::DataTableBPFLibrary_IsItemGalleryVisible Parms{};

	Parms.PlayerControllerZion = PlayerControllerZion;
	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.IsItemGenericAnimationVisible
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerControllerZion*            PlayerControllerZion                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FItemGenericAnimationConditionData&AnimationConditions                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::IsItemGenericAnimationVisible(class APlayerControllerZion* PlayerControllerZion, const struct FItemGenericAnimationConditionData& AnimationConditions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "IsItemGenericAnimationVisible");

	Params::DataTableBPFLibrary_IsItemGenericAnimationVisible Parms{};

	Parms.PlayerControllerZion = PlayerControllerZion;
	Parms.AnimationConditions = std::move(AnimationConditions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.IsItemNPCInfoVisible
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerControllerZion*            PlayerControllerZion                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::IsItemNPCInfoVisible(class APlayerControllerZion* PlayerControllerZion, const struct FDataTableRowHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "IsItemNPCInfoVisible");

	Params::DataTableBPFLibrary_IsItemNPCInfoVisible Parms{};

	Parms.PlayerControllerZion = PlayerControllerZion;
	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.IsProgressionItem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDataTableRowHandle&       ItemHandle                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::IsProgressionItem(const struct FDataTableRowHandle& ItemHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "IsProgressionItem");

	Params::DataTableBPFLibrary_IsProgressionItem Parms{};

	Parms.ItemHandle = std::move(ItemHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.IsRecollectionItemVisible
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerControllerZion*            PlayerControllerZion                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ERecollectionItemType                   RecollectionItemType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::IsRecollectionItemVisible(class APlayerControllerZion* PlayerControllerZion, const struct FDataTableRowHandle& Handle, ERecollectionItemType RecollectionItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "IsRecollectionItemVisible");

	Params::DataTableBPFLibrary_IsRecollectionItemVisible Parms{};

	Parms.PlayerControllerZion = PlayerControllerZion;
	Parms.Handle = std::move(Handle);
	Parms.RecollectionItemType = RecollectionItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DataTableBPFLibrary.IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDataTableRowHandle&       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableBPFLibrary::IsValid(const struct FDataTableRowHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableBPFLibrary", "IsValid");

	Params::DataTableBPFLibrary_IsValid Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DeathProcess_SpineAnimation.OnAnimationFinished
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      TrackEntry                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeathProcess_SpineAnimation::OnAnimationFinished(class UTrackEntry* TrackEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathProcess_SpineAnimation", "OnAnimationFinished");

	Params::DeathProcess_SpineAnimation_OnAnimationFinished Parms{};

	Parms.TrackEntry = TrackEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DelayRealTimeAsyncAction.DelayRealTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayInSeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDelayRealTimeAsyncAction*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelayRealTimeAsyncAction* UDelayRealTimeAsyncAction::DelayRealTime(const class UObject* WorldContextObject, float DelayInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelayRealTimeAsyncAction", "DelayRealTime");

	Params::DelayRealTimeAsyncAction_DelayRealTime Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DelayInSeconds = DelayInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DelayUndilatedAsyncAction.DelayUndilated
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayInSeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDelayUndilatedAsyncAction*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelayUndilatedAsyncAction* UDelayUndilatedAsyncAction::DelayUndilated(const class UObject* WorldContextObject, float DelayInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelayUndilatedAsyncAction", "DelayUndilated");

	Params::DelayUndilatedAsyncAction_DelayUndilated Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DelayInSeconds = DelayInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DifficultySystemComponent.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDifficultySystemComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDifficultySystemComponent* UDifficultySystemComponent::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DifficultySystemComponent", "Get");

	Params::DifficultySystemComponent_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DifficultySystemComponent.GetDifficultyPresetFromSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDifficultySettings&       InDifficultySettings                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EDifficultyPreset                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDifficultyPreset UDifficultySystemComponent::GetDifficultyPresetFromSettings(const struct FDifficultySettings& InDifficultySettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySystemComponent", "GetDifficultyPresetFromSettings");

	Params::DifficultySystemComponent_GetDifficultyPresetFromSettings Parms{};

	Parms.InDifficultySettings = std::move(InDifficultySettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DifficultySystemComponent.SetDifficultyMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDifficultyMode                         NewDifficultyMode                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDifficultySystemComponent::SetDifficultyMode(EDifficultyMode NewDifficultyMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySystemComponent", "SetDifficultyMode");

	Params::DifficultySystemComponent_SetDifficultyMode Parms{};

	Parms.NewDifficultyMode = NewDifficultyMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DifficultySystemComponent.SetDifficultyPresetAndSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EDifficultyPreset                       NewDifficultyPreset                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDifficultySettings&       NewDifficultySettings                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDifficultySystemComponent::SetDifficultyPresetAndSettings(EDifficultyPreset NewDifficultyPreset, const struct FDifficultySettings& NewDifficultySettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySystemComponent", "SetDifficultyPresetAndSettings");

	Params::DifficultySystemComponent_SetDifficultyPresetAndSettings Parms{};

	Parms.NewDifficultyPreset = NewDifficultyPreset;
	Parms.NewDifficultySettings = std::move(NewDifficultySettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DifficultySystemComponent.GetCurrencyFactor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDifficultySystemComponent::GetCurrencyFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySystemComponent", "GetCurrencyFactor");

	Params::DifficultySystemComponent_GetCurrencyFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DifficultySystemComponent.GetCurrencyFactorRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDifficultySystemComponent::GetCurrencyFactorRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySystemComponent", "GetCurrencyFactorRatio");

	Params::DifficultySystemComponent_GetCurrencyFactorRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DifficultySystemComponent.GetDifficultyMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDifficultyMode                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDifficultyMode UDifficultySystemComponent::GetDifficultyMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySystemComponent", "GetDifficultyMode");

	Params::DifficultySystemComponent_GetDifficultyMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DifficultySystemComponent.GetDifficultyPreset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDifficultyPreset                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDifficultyPreset UDifficultySystemComponent::GetDifficultyPreset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySystemComponent", "GetDifficultyPreset");

	Params::DifficultySystemComponent_GetDifficultyPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DifficultySystemComponent.GetDifficultyPresetForMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDifficultyMode                         InDifficultyMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDifficultyPreset                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDifficultyPreset UDifficultySystemComponent::GetDifficultyPresetForMode(EDifficultyMode InDifficultyMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySystemComponent", "GetDifficultyPresetForMode");

	Params::DifficultySystemComponent_GetDifficultyPresetForMode Parms{};

	Parms.InDifficultyMode = InDifficultyMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DifficultySystemComponent.GetDifficultySettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDifficultySettings        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FDifficultySettings UDifficultySystemComponent::GetDifficultySettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySystemComponent", "GetDifficultySettings");

	Params::DifficultySystemComponent_GetDifficultySettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DifficultySystemComponent.GetDifficultySettingsForMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDifficultyMode                         InDifficultyMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDifficultySettings        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FDifficultySettings UDifficultySystemComponent::GetDifficultySettingsForMode(EDifficultyMode InDifficultyMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySystemComponent", "GetDifficultySettingsForMode");

	Params::DifficultySystemComponent_GetDifficultySettingsForMode Parms{};

	Parms.InDifficultyMode = InDifficultyMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DifficultySystemComponent.GetDifficultySettingsForPreset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDifficultyPreset                       InDifficultyPreset                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDifficultySettings        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FDifficultySettings UDifficultySystemComponent::GetDifficultySettingsForPreset(EDifficultyPreset InDifficultyPreset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySystemComponent", "GetDifficultySettingsForPreset");

	Params::DifficultySystemComponent_GetDifficultySettingsForPreset Parms{};

	Parms.InDifficultyPreset = InDifficultyPreset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DifficultySystemComponent.HasAnyChallengeEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDifficultySystemComponent::HasAnyChallengeEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySystemComponent", "HasAnyChallengeEnabled");

	Params::DifficultySystemComponent_HasAnyChallengeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DropComponent.LaunchDropProcess
// (Final, Native, Public, BlueprintCallable)

void UDropComponent::LaunchDropProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropComponent", "LaunchDropProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DropComponent.OnDeath
// (Final, Native, Private)

void UDropComponent::OnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropComponent", "OnDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.DropSystemComponent.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDropSystemComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDropSystemComponent* UDropSystemComponent::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DropSystemComponent", "Get");

	Params::DropSystemComponent_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.DropSystemComponent.LaunchExperienceDrop
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Experience                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Origin                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDropSystemComponent::LaunchExperienceDrop(int32 Experience, const struct FTransform& Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropSystemComponent", "LaunchExperienceDrop");

	Params::DropSystemComponent_LaunchExperienceDrop Parms{};

	Parms.Experience = Experience;
	Parms.Origin = std::move(Origin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ElevatorMovementComponent.GoToDestination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UElevatorMovementComponent::GoToDestination(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorMovementComponent", "GoToDestination");

	Params::ElevatorMovementComponent_GoToDestination Parms{};

	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ElevatorMovementComponent.GoToOrigin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UElevatorMovementComponent::GoToOrigin(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorMovementComponent", "GoToOrigin");

	Params::ElevatorMovementComponent_GoToOrigin Parms{};

	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ElevatorMovementComponent.SetAllowOutOfScreenSpeedFactor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllowed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UElevatorMovementComponent::SetAllowOutOfScreenSpeedFactor(bool bAllowed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorMovementComponent", "SetAllowOutOfScreenSpeedFactor");

	Params::ElevatorMovementComponent_SetAllowOutOfScreenSpeedFactor Parms{};

	Parms.bAllowed = bAllowed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ElevatorMovementComponent.TeleportToDestination
// (Final, Native, Public, BlueprintCallable)

void UElevatorMovementComponent::TeleportToDestination()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorMovementComponent", "TeleportToDestination");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ElevatorMovementComponent.TeleportToOrigin
// (Final, Native, Public, BlueprintCallable)

void UElevatorMovementComponent::TeleportToOrigin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorMovementComponent", "TeleportToOrigin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ElevatorMovementComponent.GetCurrentLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UElevatorMovementComponent::GetCurrentLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorMovementComponent", "GetCurrentLocation");

	Params::ElevatorMovementComponent_GetCurrentLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ElevatorMovementComponent.IsDirectionSetToDestination
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UElevatorMovementComponent::IsDirectionSetToDestination() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorMovementComponent", "IsDirectionSetToDestination");

	Params::ElevatorMovementComponent_IsDirectionSetToDestination Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ElevatorMovementComponent.IsMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UElevatorMovementComponent::IsMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorMovementComponent", "IsMoving");

	Params::ElevatorMovementComponent_IsMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ElevatorStateManagerComponent.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UElevatorStateManagerComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UElevatorStateManagerComponent* UElevatorStateManagerComponent::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ElevatorStateManagerComponent", "Get");

	Params::ElevatorStateManagerComponent_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ElevatorStateManagerComponent.ClearElevatorStates
// (Final, Native, Public, BlueprintCallable)

void UElevatorStateManagerComponent::ClearElevatorStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorStateManagerComponent", "ClearElevatorStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ElevatorStateManagerComponent.OnGameMapChangeFinished
// (Final, Native, Private)

void UElevatorStateManagerComponent::OnGameMapChangeFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorStateManagerComponent", "OnGameMapChangeFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ElevatorStateManagerComponent.RegisterElevatorState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class AMovingPlatform_Elevator*   ElevatorActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EElevatorState                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EElevatorState UElevatorStateManagerComponent::RegisterElevatorState(const class AMovingPlatform_Elevator* ElevatorActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorStateManagerComponent", "RegisterElevatorState");

	Params::ElevatorStateManagerComponent_RegisterElevatorState Parms{};

	Parms.ElevatorActor = ElevatorActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ElevatorStateManagerComponent.GetElevatorState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AMovingPlatform_Elevator*   ElevatorActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EElevatorState                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EElevatorState UElevatorStateManagerComponent::GetElevatorState(const class AMovingPlatform_Elevator* ElevatorActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorStateManagerComponent", "GetElevatorState");

	Params::ElevatorStateManagerComponent_GetElevatorState Parms{};

	Parms.ElevatorActor = ElevatorActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.EquipmentComponent.Equip
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EEquipmentSlot                          EquipmentSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      EquipmentID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToCurrentLoadout                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::Equip(EEquipmentSlot EquipmentSlot, const class FName& EquipmentID, bool bAddToCurrentLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "Equip");

	Params::EquipmentComponent_Equip Parms{};

	Parms.EquipmentSlot = EquipmentSlot;
	Parms.EquipmentID = EquipmentID;
	Parms.bAddToCurrentLoadout = bAddToCurrentLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EquipmentComponent.EquipEquipmentLoadout
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LoadoutIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::EquipEquipmentLoadout(int32 LoadoutIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "EquipEquipmentLoadout");

	Params::EquipmentComponent_EquipEquipmentLoadout Parms{};

	Parms.LoadoutIndex = LoadoutIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EquipmentComponent.OnPossessedPawnChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnPossessedPawnChanged");

	Params::EquipmentComponent_OnPossessedPawnChanged Parms{};

	Parms.OldPawn = OldPawn;
	Parms.NewPawn = NewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EquipmentComponent.UnEquip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEquipmentSlot                          EquipmentSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveFromCurrentLoadout                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::UnEquip(EEquipmentSlot EquipmentSlot, bool bRemoveFromCurrentLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "UnEquip");

	Params::EquipmentComponent_UnEquip Parms{};

	Parms.EquipmentSlot = EquipmentSlot;
	Parms.bRemoveFromCurrentLoadout = bRemoveFromCurrentLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EquipmentComponent.UnEquipAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bRemoveFromCurrentLoadout                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::UnEquipAll(bool bRemoveFromCurrentLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "UnEquipAll");

	Params::EquipmentComponent_UnEquipAll Parms{};

	Parms.bRemoveFromCurrentLoadout = bRemoveFromCurrentLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EquipmentComponent.GetCurrentEquipmentLoadoutIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEquipmentComponent::GetCurrentEquipmentLoadoutIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "GetCurrentEquipmentLoadoutIndex");

	Params::EquipmentComponent_GetCurrentEquipmentLoadoutIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.EquipmentComponent.GetEquipmentDataFromID
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      EquipmentID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryItemEquipmentDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FInventoryItemEquipmentData UEquipmentComponent::GetEquipmentDataFromID(const class FName& EquipmentID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "GetEquipmentDataFromID");

	Params::EquipmentComponent_GetEquipmentDataFromID Parms{};

	Parms.EquipmentID = EquipmentID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.EquipmentComponent.GetEquipmentDataFromSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentSlot                          EquipmentSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryItemEquipmentDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FInventoryItemEquipmentData UEquipmentComponent::GetEquipmentDataFromSlot(EEquipmentSlot EquipmentSlot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "GetEquipmentDataFromSlot");

	Params::EquipmentComponent_GetEquipmentDataFromSlot Parms{};

	Parms.EquipmentSlot = EquipmentSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.EquipmentComponent.GetEquipmentIDFromSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentSlot                          EquipmentSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEquipmentComponent::GetEquipmentIDFromSlot(EEquipmentSlot EquipmentSlot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "GetEquipmentIDFromSlot");

	Params::EquipmentComponent_GetEquipmentIDFromSlot Parms{};

	Parms.EquipmentSlot = EquipmentSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.EquipmentComponent.IsEquipped
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      EquipmentID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentComponent::IsEquipped(const class FName& EquipmentID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "IsEquipped");

	Params::EquipmentComponent_IsEquipped Parms{};

	Parms.EquipmentID = EquipmentID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.EquipmentComponent.IsEquippedOnSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentSlot                          EquipmentSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      EquipmentID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentComponent::IsEquippedOnSlot(EEquipmentSlot EquipmentSlot, const class FName& EquipmentID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "IsEquippedOnSlot");

	Params::EquipmentComponent_IsEquippedOnSlot Parms{};

	Parms.EquipmentSlot = EquipmentSlot;
	Parms.EquipmentID = EquipmentID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.EventAction_Fade.OnFadeCompleted
// (Final, Native, Private)

void UEventAction_Fade::OnFadeCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventAction_Fade", "OnFadeCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EventAction_PlayLevelSequence.OnLevelSequenceFinished
// (Final, Native, Private)

void UEventAction_PlayLevelSequence::OnLevelSequenceFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventAction_PlayLevelSequence", "OnLevelSequenceFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EventAction_PlayRandomAnimations.OnAnimationFinished
// (Final, Native, Private)

void UEventAction_PlayRandomAnimations::OnAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventAction_PlayRandomAnimations", "OnAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EventAction_SaveGame.OnSaveFinished
// (Final, Native, Private)
// Parameters:
// bool                                    bResult                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventAction_SaveGame::OnSaveFinished(bool bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventAction_SaveGame", "OnSaveFinished");

	Params::EventAction_SaveGame_OnSaveFinished Parms{};

	Parms.bResult = bResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PassiveComponent.EquipPassive
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      PassiveID                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToCurrentLoadout                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InsertIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPassiveEquipResult                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPassiveEquipResult UPassiveComponent::EquipPassive(const class FName& PassiveID, bool bAddToCurrentLoadout, int32 InsertIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassiveComponent", "EquipPassive");

	Params::PassiveComponent_EquipPassive Parms{};

	Parms.PassiveID = PassiveID;
	Parms.bAddToCurrentLoadout = bAddToCurrentLoadout;
	Parms.InsertIndex = InsertIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PassiveComponent.EquipPassiveLoadout
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LoadoutIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPassiveComponent::EquipPassiveLoadout(int32 LoadoutIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassiveComponent", "EquipPassiveLoadout");

	Params::PassiveComponent_EquipPassiveLoadout Parms{};

	Parms.LoadoutIndex = LoadoutIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PassiveComponent.OnPossessedPawnChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPassiveComponent::OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassiveComponent", "OnPossessedPawnChanged");

	Params::PassiveComponent_OnPossessedPawnChanged Parms{};

	Parms.OldPawn = OldPawn;
	Parms.NewPawn = NewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PassiveComponent.ReplacePassiveInAllLoadouts
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      PassiveToRemove                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      PassiveToAdd                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPassiveComponent::ReplacePassiveInAllLoadouts(const class FName& PassiveToRemove, const class FName& PassiveToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassiveComponent", "ReplacePassiveInAllLoadouts");

	Params::PassiveComponent_ReplacePassiveInAllLoadouts Parms{};

	Parms.PassiveToRemove = PassiveToRemove;
	Parms.PassiveToAdd = PassiveToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PassiveComponent.UnequipPassive
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      PassiveID                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutPassiveIndex                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveFromCurrentLoadout                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPassiveComponent::UnequipPassive(const class FName& PassiveID, int32* OutPassiveIndex, bool bRemoveFromCurrentLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassiveComponent", "UnequipPassive");

	Params::PassiveComponent_UnequipPassive Parms{};

	Parms.PassiveID = PassiveID;
	Parms.bRemoveFromCurrentLoadout = bRemoveFromCurrentLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPassiveIndex != nullptr)
		*OutPassiveIndex = Parms.OutPassiveIndex;

	return Parms.ReturnValue;
}


// Function Zion.PassiveComponent.CanEquipPassive
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FInventoryItemPassiveData& ItemPassiveData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EPassiveEquipResult                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPassiveEquipResult UPassiveComponent::CanEquipPassive(const struct FInventoryItemPassiveData& ItemPassiveData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassiveComponent", "CanEquipPassive");

	Params::PassiveComponent_CanEquipPassive Parms{};

	Parms.ItemPassiveData = std::move(ItemPassiveData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PassiveComponent.GetAvailableSlotCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPassiveComponent::GetAvailableSlotCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassiveComponent", "GetAvailableSlotCount");

	Params::PassiveComponent_GetAvailableSlotCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PassiveComponent.GetCurrentPassiveLoadoutIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPassiveComponent::GetCurrentPassiveLoadoutIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassiveComponent", "GetCurrentPassiveLoadoutIndex");

	Params::PassiveComponent_GetCurrentPassiveLoadoutIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PassiveComponent.GetEquippedPassives
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FPassiveRuntimeData>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FPassiveRuntimeData> UPassiveComponent::GetEquippedPassives() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassiveComponent", "GetEquippedPassives");

	Params::PassiveComponent_GetEquippedPassives Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PassiveComponent.GetSlotCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPassiveComponent::GetSlotCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassiveComponent", "GetSlotCount");

	Params::PassiveComponent_GetSlotCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PassiveComponent.GetUsedSlotCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPassiveComponent::GetUsedSlotCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassiveComponent", "GetUsedSlotCount");

	Params::PassiveComponent_GetUsedSlotCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PassiveComponent.IsPassiveEquipped
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      PassiveID                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPassiveComponent::IsPassiveEquipped(const class FName& PassiveID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassiveComponent", "IsPassiveEquipped");

	Params::PassiveComponent_IsPassiveEquipped Parms{};

	Parms.PassiveID = PassiveID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.EventAction_WaitMove.OnMoveCompleted
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventAction_WaitMove::OnMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventAction_WaitMove", "OnMoveCompleted");

	Params::EventAction_WaitMove_OnMoveCompleted Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.EventBPFLibrary.AppendActorBindings
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<class FName, class AActor*>&       ActorBindings                                          (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TMap<class FName, class AActor*>& AdditionalBindings                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEventBPFLibrary::AppendActorBindings(TMap<class FName, class AActor*>& ActorBindings, const TMap<class FName, class AActor*>& AdditionalBindings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBPFLibrary", "AppendActorBindings");

	Params::EventBPFLibrary_AppendActorBindings Parms{};

	Parms.ActorBindings = std::move(ActorBindings);
	Parms.AdditionalBindings = std::move(AdditionalBindings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ActorBindings = std::move(Parms.ActorBindings);
}


// Function Zion.EventBPFLibrary.GenerateActorBindings
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TMap<class FName, class AActor*>& ActorBindings                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TMap<class FName, class ASpawner*>&SpawnerBindings                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TMap<class FName, class AActor*>        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, class AActor*> UEventBPFLibrary::GenerateActorBindings(const TMap<class FName, class AActor*>& ActorBindings, const TMap<class FName, class ASpawner*>& SpawnerBindings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBPFLibrary", "GenerateActorBindings");

	Params::EventBPFLibrary_GenerateActorBindings Parms{};

	Parms.ActorBindings = std::move(ActorBindings);
	Parms.SpawnerBindings = std::move(SpawnerBindings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.EventBPFLibrary.GenerateActorBindingsFromSpawners
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TMap<class FName, class ASpawner*>&SpawnerBindings                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TMap<class FName, class AActor*>        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, class AActor*> UEventBPFLibrary::GenerateActorBindingsFromSpawners(const TMap<class FName, class ASpawner*>& SpawnerBindings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBPFLibrary", "GenerateActorBindingsFromSpawners");

	Params::EventBPFLibrary_GenerateActorBindingsFromSpawners Parms{};

	Parms.SpawnerBindings = std::move(SpawnerBindings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FakeWall.Clear
// (Final, Native, Public, BlueprintCallable)

void AFakeWall::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FakeWall", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FakeWall.Hide
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFakeWall::Hide(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FakeWall", "Hide");

	Params::FakeWall_Hide Parms{};

	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FakeWall.OnClearStatusChecked
// (Final, Native, Private)
// Parameters:
// EClearStatus                            ClearStatus                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFakeWall::OnClearStatusChecked(EClearStatus ClearStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FakeWall", "OnClearStatusChecked");

	Params::FakeWall_OnClearStatusChecked Parms{};

	Parms.ClearStatus = ClearStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FakeWall.IsCleared
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFakeWall::IsCleared() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FakeWall", "IsCleared");

	Params::FakeWall_IsCleared Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FallDamageComponent.OnLandedCallback
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFallDamageComponent::OnLandedCallback(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FallDamageComponent", "OnLandedCallback");

	Params::FallDamageComponent_OnLandedCallback Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FallThroughComponent.ClearAllIgnoredPlatforms
// (Final, Native, Public, BlueprintCallable)

void UFallThroughComponent::ClearAllIgnoredPlatforms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FallThroughComponent", "ClearAllIgnoredPlatforms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FallThroughComponent.FallThroughOneWayPlatform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOneWayPlatform*                  OneWayPlatform                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFallThroughComponent::FallThroughOneWayPlatform(class AOneWayPlatform* OneWayPlatform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FallThroughComponent", "FallThroughOneWayPlatform");

	Params::FallThroughComponent_FallThroughOneWayPlatform Parms{};

	Parms.OneWayPlatform = OneWayPlatform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FieldMessageComponent.Abort
// (Final, Native, Public, BlueprintCallable)

void UFieldMessageComponent::Abort()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMessageComponent", "Abort");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FieldMessageComponent.LaunchFieldMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMessageComponent::LaunchFieldMessage(class AActor* InTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMessageComponent", "LaunchFieldMessage");

	Params::FieldMessageComponent_LaunchFieldMessage Parms{};

	Parms.InTargetActor = InTargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FieldMessageComponent.OnMessageCompleted
// (Final, Native, Private)

void UFieldMessageComponent::OnMessageCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMessageComponent", "OnMessageCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FieldMessageComponent.SetMessageData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFieldMessageAsset*               MessageDataAsset                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMessageComponent::SetMessageData(class UFieldMessageAsset* MessageDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMessageComponent", "SetMessageData");

	Params::FieldMessageComponent_SetMessageData Parms{};

	Parms.MessageDataAsset = MessageDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FieldMessageComponent.GetFieldMessageAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFieldMessageAsset*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFieldMessageAsset* UFieldMessageComponent::GetFieldMessageAsset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMessageComponent", "GetFieldMessageAsset");

	Params::FieldMessageComponent_GetFieldMessageAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FieldMessageComponent.IsProcessingFieldMessage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMessageComponent::IsProcessingFieldMessage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMessageComponent", "IsProcessingFieldMessage");

	Params::FieldMessageComponent_IsProcessingFieldMessage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FluidBody.GenerateSplash
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SizePercent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEntering                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLaunchFX                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFluidBody::GenerateSplash(const struct FVector& WorldLocation, float Strength, float SizePercent, bool bEntering, bool bLaunchFX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FluidBody", "GenerateSplash");

	Params::FluidBody_GenerateSplash Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.Strength = Strength;
	Parms.SizePercent = SizePercent;
	Parms.bEntering = bEntering;
	Parms.bLaunchFX = bLaunchFX;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FluidBody.OnBeginOverlapSurface
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBFromSweep                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AFluidBody::OnBeginOverlapSurface(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bBFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FluidBody", "OnBeginOverlapSurface");

	Params::FluidBody_OnBeginOverlapSurface Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bBFromSweep = bBFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FluidBody.OnEndOverlapSurface
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFluidBody::OnEndOverlapSurface(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FluidBody", "OnEndOverlapSurface");

	Params::FluidBody_OnEndOverlapSurface Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FluidBody.RegenerateFluidMesh
// (Final, Native, Private, Const)

void AFluidBody::RegenerateFluidMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FluidBody", "RegenerateFluidMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FluidMeshComponent.RegenerateMesh
// (Final, Native, Public, BlueprintCallable)

void UFluidMeshComponent::RegenerateMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FluidMeshComponent", "RegenerateMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FluidSimulationComponent.GenerateSplash
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SizePercent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFluidSimulationComponent::GenerateSplash(const struct FVector& WorldLocation, float Strength, float SizePercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FluidSimulationComponent", "GenerateSplash");

	Params::FluidSimulationComponent_GenerateSplash Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.Strength = Strength;
	Parms.SizePercent = SizePercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FogOfWarComponent.ClearAllMapsFogOfWar
// (Final, Native, Public, BlueprintCallable)

void UFogOfWarComponent::ClearAllMapsFogOfWar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FogOfWarComponent", "ClearAllMapsFogOfWar");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FogOfWarComponent.ClearMapFogOfWar
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      MapName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFogOfWarComponent::ClearMapFogOfWar(const class FName& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FogOfWarComponent", "ClearMapFogOfWar");

	Params::FogOfWarComponent_ClearMapFogOfWar Parms{};

	Parms.MapName = MapName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FogOfWarComponent.ResetAllMapsFogOfWar
// (Final, Native, Public, BlueprintCallable)

void UFogOfWarComponent::ResetAllMapsFogOfWar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FogOfWarComponent", "ResetAllMapsFogOfWar");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FogOfWarComponent.ResetMapFogOfWar
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      MapName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFogOfWarComponent::ResetMapFogOfWar(const class FName& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FogOfWarComponent", "ResetMapFogOfWar");

	Params::FogOfWarComponent_ResetMapFogOfWar Parms{};

	Parms.MapName = MapName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FollowGeometryMovementComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void UFollowGeometryMovementComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowGeometryMovementComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FollowGeometryMovementComponent.SetSpeedFactor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewSpeedFactor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFollowGeometryMovementComponent::SetSpeedFactor(float NewSpeedFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowGeometryMovementComponent", "SetSpeedFactor");

	Params::FollowGeometryMovementComponent_SetSpeedFactor Parms{};

	Parms.NewSpeedFactor = NewSpeedFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FollowGeometryMovementComponent.StartMovement
// (Final, Native, Public, BlueprintCallable)

void UFollowGeometryMovementComponent::StartMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowGeometryMovementComponent", "StartMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FollowGeometryMovementComponent.StopMovement
// (Final, Native, Public, BlueprintCallable)

void UFollowGeometryMovementComponent::StopMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowGeometryMovementComponent", "StopMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FollowGeometryMovementComponent.GetSpeedFactor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFollowGeometryMovementComponent::GetSpeedFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowGeometryMovementComponent", "GetSpeedFactor");

	Params::FollowGeometryMovementComponent_GetSpeedFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FollowGeometryMovementComponent.IsMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFollowGeometryMovementComponent::IsMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowGeometryMovementComponent", "IsMoving");

	Params::FollowGeometryMovementComponent_IsMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FollowSplineComponent.IsClosedLoop
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFollowSplineComponent::IsClosedLoop() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FollowSplineComponent", "IsClosedLoop");

	Params::FollowSplineComponent_IsClosedLoop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.FootIKComponent.OnAnimationStart
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      TrackEntry                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFootIKComponent::OnAnimationStart(class UTrackEntry* TrackEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootIKComponent", "OnAnimationStart");

	Params::FootIKComponent_OnAnimationStart Parms{};

	Parms.TrackEntry = TrackEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FootIKComponent.OnBeforeUpdateWorldTransform
// (Final, Native, Private)
// Parameters:
// class USpineSkeletonComponent*          Skeleton                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFootIKComponent::OnBeforeUpdateWorldTransform(class USpineSkeletonComponent* Skeleton)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootIKComponent", "OnBeforeUpdateWorldTransform");

	Params::FootIKComponent_OnBeforeUpdateWorldTransform Parms{};

	Parms.Skeleton = Skeleton;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FXComponent.ActivateAuraFXs
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      AuraFXTag                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXComponent::ActivateAuraFXs(const class FName& AuraFXTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FXComponent", "ActivateAuraFXs");

	Params::FXComponent_ActivateAuraFXs Parms{};

	Parms.AuraFXTag = AuraFXTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FXComponent.DeactivateAuraFXs
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      AuraFXTag                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXComponent::DeactivateAuraFXs(const class FName& AuraFXTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FXComponent", "DeactivateAuraFXs");

	Params::FXComponent_DeactivateAuraFXs Parms{};

	Parms.AuraFXTag = AuraFXTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FXComponent.OnDeathProcessStart
// (Final, Native, Private)

void UFXComponent::OnDeathProcessStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FXComponent", "OnDeathProcessStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FXComponent.OnFinishCommand
// (Final, Native, Private)
// Parameters:
// const class UCommand*                   Command                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommandFinishType                      FinishType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXComponent::OnFinishCommand(const class UCommand* Command, ECommandFinishType FinishType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FXComponent", "OnFinishCommand");

	Params::FXComponent_OnFinishCommand Parms{};

	Parms.Command = Command;
	Parms.FinishType = FinishType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FXComponent.OnGuarded
// (Final, Native, Private)
// Parameters:
// class AAbility*                         Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXComponent::OnGuarded(class AAbility* Ability, class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FXComponent", "OnGuarded");

	Params::FXComponent_OnGuarded Parms{};

	Parms.Ability = Ability;
	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FXComponent.OnLanded
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFXComponent::OnLanded(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FXComponent", "OnLanded");

	Params::FXComponent_OnLanded Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FXComponent.OnParried
// (Final, Native, Private)
// Parameters:
// class AAbility*                         Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXComponent::OnParried(class AAbility* Ability, class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FXComponent", "OnParried");

	Params::FXComponent_OnParried Parms{};

	Parms.Ability = Ability;
	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FXComponent.OnSPValueChanged
// (Final, Native, Private)

void UFXComponent::OnSPValueChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FXComponent", "OnSPValueChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FXComponent.OnStatusEffectLaunched
// (Final, Native, Private)
// Parameters:
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXComponent::OnStatusEffectLaunched(class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FXComponent", "OnStatusEffectLaunched");

	Params::FXComponent_OnStatusEffectLaunched Parms{};

	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.FXComponent.OnStatusEffectStopped
// (Final, Native, Private)
// Parameters:
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXComponent::OnStatusEffectStopped(class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FXComponent", "OnStatusEffectStopped");

	Params::FXComponent_OnStatusEffectStopped Parms{};

	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameInstanceZion.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameInstanceZion*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameInstanceZion* UGameInstanceZion::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameInstanceZion", "Get");

	Params::GameInstanceZion_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameInstanceZion.ClearLaunchGameIntent
// (Final, Native, Public, BlueprintCallable)

void UGameInstanceZion::ClearLaunchGameIntent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceZion", "ClearLaunchGameIntent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameInstanceZion.HandleSettingsDelegate
// (Final, Native, Private)
// Parameters:
// class USentrySettings*                  Settings                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInstanceZion::HandleSettingsDelegate(class USentrySettings* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceZion", "HandleSettingsDelegate");

	Params::GameInstanceZion_HandleSettingsDelegate Parms{};

	Parms.Settings = Settings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameInstanceZion.OnAutoUploadCrashReportChanged
// (Final, Native, Private)

void UGameInstanceZion::OnAutoUploadCrashReportChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceZion", "OnAutoUploadCrashReportChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameInstanceZion.SetLaunchGameIntent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELaunchGameIntent                       NewLaunchGameIntent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInstanceZion::SetLaunchGameIntent(ELaunchGameIntent NewLaunchGameIntent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceZion", "SetLaunchGameIntent");

	Params::GameInstanceZion_SetLaunchGameIntent Parms{};

	Parms.NewLaunchGameIntent = NewLaunchGameIntent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameInstanceZion.GetLaunchGameIntent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELaunchGameIntent                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELaunchGameIntent UGameInstanceZion::GetLaunchGameIntent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceZion", "GetLaunchGameIntent");

	Params::GameInstanceZion_GetLaunchGameIntent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.CanUnlockAnySkillLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UInventoryComponent*        InventoryComponent                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameLogicBPFLibrary::CanUnlockAnySkillLevel(const class UInventoryComponent* InventoryComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "CanUnlockAnySkillLevel");

	Params::GameLogicBPFLibrary_CanUnlockAnySkillLevel Parms{};

	Parms.InventoryComponent = InventoryComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.CanUnlockSkillLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UInventoryComponent*        InventoryComponent                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       SkillHandle                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillUnlockResultType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESkillUnlockResultType UGameLogicBPFLibrary::CanUnlockSkillLevel(const class UInventoryComponent* InventoryComponent, const struct FDataTableRowHandle& SkillHandle, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "CanUnlockSkillLevel");

	Params::GameLogicBPFLibrary_CanUnlockSkillLevel Parms{};

	Parms.InventoryComponent = InventoryComponent;
	Parms.SkillHandle = std::move(SkillHandle);
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.CheckGameplayConditions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayConditionChecker& GameplayConditions                                     (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameLogicBPFLibrary::CheckGameplayConditions(class APlayerController* PlayerController, const struct FGameplayConditionChecker& GameplayConditions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "CheckGameplayConditions");

	Params::GameLogicBPFLibrary_CheckGameplayConditions Parms{};

	Parms.PlayerController = PlayerController;
	Parms.GameplayConditions = std::move(GameplayConditions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.CheckItemConditions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerControllerZion*            PlayerControllerZion                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FItemConditionData&        ItemConditionData                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameLogicBPFLibrary::CheckItemConditions(class APlayerControllerZion* PlayerControllerZion, const struct FItemConditionData& ItemConditionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "CheckItemConditions");

	Params::GameLogicBPFLibrary_CheckItemConditions Parms{};

	Parms.PlayerControllerZion = PlayerControllerZion;
	Parms.ItemConditionData = std::move(ItemConditionData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.GetEquipLoadoutCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameLogicBPFLibrary::GetEquipLoadoutCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "GetEquipLoadoutCount");

	Params::GameLogicBPFLibrary_GetEquipLoadoutCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.GetNextLevelForSkill
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UInventoryComponent*        InventoryComponent                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       SkillHandle                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameLogicBPFLibrary::GetNextLevelForSkill(const class UInventoryComponent* InventoryComponent, const struct FDataTableRowHandle& SkillHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "GetNextLevelForSkill");

	Params::GameLogicBPFLibrary_GetNextLevelForSkill Parms{};

	Parms.InventoryComponent = InventoryComponent;
	Parms.SkillHandle = std::move(SkillHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.GetPlayerMaxAttackLimit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerControllerZion*      PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameLogicBPFLibrary::GetPlayerMaxAttackLimit(const class APlayerControllerZion* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "GetPlayerMaxAttackLimit");

	Params::GameLogicBPFLibrary_GetPlayerMaxAttackLimit Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.GetPlayerMaxDefenseLimit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerControllerZion*      PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameLogicBPFLibrary::GetPlayerMaxDefenseLimit(const class APlayerControllerZion* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "GetPlayerMaxDefenseLimit");

	Params::GameLogicBPFLibrary_GetPlayerMaxDefenseLimit Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.GetPlayerMaxHealCountLimit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerControllerZion*      PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameLogicBPFLibrary::GetPlayerMaxHealCountLimit(const class APlayerControllerZion* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "GetPlayerMaxHealCountLimit");

	Params::GameLogicBPFLibrary_GetPlayerMaxHealCountLimit Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.GetPlayerMaxHealPowerLimit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerControllerZion*      PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameLogicBPFLibrary::GetPlayerMaxHealPowerLimit(const class APlayerControllerZion* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "GetPlayerMaxHealPowerLimit");

	Params::GameLogicBPFLibrary_GetPlayerMaxHealPowerLimit Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.GetPlayerMaxHPLimit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerControllerZion*      PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameLogicBPFLibrary::GetPlayerMaxHPLimit(const class APlayerControllerZion* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "GetPlayerMaxHPLimit");

	Params::GameLogicBPFLibrary_GetPlayerMaxHPLimit Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.GetPlayerMaxPossibleStats
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerControllerZion*      PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FExtendedStatsData         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FExtendedStatsData UGameLogicBPFLibrary::GetPlayerMaxPossibleStats(const class APlayerControllerZion* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "GetPlayerMaxPossibleStats");

	Params::GameLogicBPFLibrary_GetPlayerMaxPossibleStats Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.GetPlayerMaxSPLimit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerControllerZion*      PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameLogicBPFLibrary::GetPlayerMaxSPLimit(const class APlayerControllerZion* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "GetPlayerMaxSPLimit");

	Params::GameLogicBPFLibrary_GetPlayerMaxSPLimit Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.GetSkillLevelFromHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       SkillHandle                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameLogicBPFLibrary::GetSkillLevelFromHandle(const class UObject* WorldContextObject, const struct FDataTableRowHandle& SkillHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "GetSkillLevelFromHandle");

	Params::GameLogicBPFLibrary_GetSkillLevelFromHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SkillHandle = std::move(SkillHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.GetSkillLevelFromID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      SkillID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameLogicBPFLibrary::GetSkillLevelFromID(const class UObject* WorldContextObject, const class FName& SkillID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "GetSkillLevelFromID");

	Params::GameLogicBPFLibrary_GetSkillLevelFromID Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SkillID = SkillID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.GetSPGaugeValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameLogicBPFLibrary::GetSPGaugeValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "GetSPGaugeValue");

	Params::GameLogicBPFLibrary_GetSPGaugeValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.LaunchForceFeedback
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreTimeDilation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayWhilePaused                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameLogicBPFLibrary::LaunchForceFeedback(class APlayerController* PlayerController, class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag, bool bLooping, bool bIgnoreTimeDilation, bool bPlayWhilePaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "LaunchForceFeedback");

	Params::GameLogicBPFLibrary_LaunchForceFeedback Parms{};

	Parms.PlayerController = PlayerController;
	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.Tag = Tag;
	Parms.bLooping = bLooping;
	Parms.bIgnoreTimeDilation = bIgnoreTimeDilation;
	Parms.bPlayWhilePaused = bPlayWhilePaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameLogicBPFLibrary.StopForceFeedbackByTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameLogicBPFLibrary::StopForceFeedbackByTag(class APlayerController* PlayerController, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "StopForceFeedbackByTag");

	Params::GameLogicBPFLibrary_StopForceFeedbackByTag Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameLogicBPFLibrary.TryLaunchTutorialWidget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSubclassOf<class UUserWidgetTutorial>TutorialWidgetClass                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       TutorialHandle                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const EUMGLayer                         UMGLayer                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidgetTutorial*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidgetTutorial* UGameLogicBPFLibrary::TryLaunchTutorialWidget(const class UObject* WorldContextObject, const TSubclassOf<class UUserWidgetTutorial> TutorialWidgetClass, const struct FDataTableRowHandle& TutorialHandle, const EUMGLayer UMGLayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "TryLaunchTutorialWidget");

	Params::GameLogicBPFLibrary_TryLaunchTutorialWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TutorialWidgetClass = TutorialWidgetClass;
	Parms.TutorialHandle = std::move(TutorialHandle);
	Parms.UMGLayer = UMGLayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameLogicBPFLibrary.UnlockSkillLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UInventoryComponent*              InventoryComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       SkillHandle                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameLogicBPFLibrary::UnlockSkillLevel(class UInventoryComponent* InventoryComponent, const struct FDataTableRowHandle& SkillHandle, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicBPFLibrary", "UnlockSkillLevel");

	Params::GameLogicBPFLibrary_UnlockSkillLevel Parms{};

	Parms.InventoryComponent = InventoryComponent;
	Parms.SkillHandle = std::move(SkillHandle);
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameMapBPFLibrary.GetPixelPerMeter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameMapBPFLibrary::GetPixelPerMeter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameMapBPFLibrary", "GetPixelPerMeter");

	Params::GameMapBPFLibrary_GetPixelPerMeter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameMapBPFLibrary.WorldToPixelLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGameMapBPFLibrary::WorldToPixelLocation(const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameMapBPFLibrary", "WorldToPixelLocation");

	Params::GameMapBPFLibrary_WorldToPixelLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameMapChangeDataProviderInterface.GetGameMapChangeProviderData
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameMapChangeProviderData*      OutGameMapChangeProviderData                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void IGameMapChangeDataProviderInterface::GetGameMapChangeProviderData(struct FGameMapChangeProviderData* OutGameMapChangeProviderData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GameMapChangeDataProviderInterface", "GetGameMapChangeProviderData");

	Params::GameMapChangeDataProviderInterface_GetGameMapChangeProviderData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGameMapChangeProviderData != nullptr)
		*OutGameMapChangeProviderData = std::move(Parms.OutGameMapChangeProviderData);
}


// Function Zion.GameModeZion.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameModeZion*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameModeZion* AGameModeZion::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameModeZion", "Get");

	Params::GameModeZion_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetMaxEnvironmentLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   NewGamePlusGeneration_0                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeZion::GetMaxEnvironmentLevel(int32 NewGamePlusGeneration_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameModeZion", "GetMaxEnvironmentLevel");

	Params::GameModeZion_GetMaxEnvironmentLevel Parms{};

	Parms.NewGamePlusGeneration_0 = NewGamePlusGeneration_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.DBG_SetNewGamePlusGeneration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewNewGamePlusGeneration                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeZion::DBG_SetNewGamePlusGeneration(int32 NewNewGamePlusGeneration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "DBG_SetNewGamePlusGeneration");

	Params::GameModeZion_DBG_SetNewGamePlusGeneration Parms{};

	Parms.NewNewGamePlusGeneration = NewNewGamePlusGeneration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameModeZion.FastTravel
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      RestPointID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeZion::FastTravel(const class FName& RestPointID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "FastTravel");

	Params::GameModeZion_FastTravel Parms{};

	Parms.RestPointID = RestPointID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameModeZion.NotifyGameEndingReached
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameEndingType                         GameEndingType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeZion::NotifyGameEndingReached(EGameEndingType GameEndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "NotifyGameEndingReached");

	Params::GameModeZion_NotifyGameEndingReached Parms{};

	Parms.GameEndingType = GameEndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameModeZion.RegisterBossRushComponent
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class URecollectionBossRushComponent*   NewBossRushComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeZion::RegisterBossRushComponent(class URecollectionBossRushComponent* NewBossRushComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "RegisterBossRushComponent");

	Params::GameModeZion_RegisterBossRushComponent Parms{};

	Parms.NewBossRushComponent = NewBossRushComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameModeZion.RegisterRecollectionBossComponent
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class URecollectionBossComponent*       NewRecollectionBossComponent                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeZion::RegisterRecollectionBossComponent(class URecollectionBossComponent* NewRecollectionBossComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "RegisterRecollectionBossComponent");

	Params::GameModeZion_RegisterRecollectionBossComponent Parms{};

	Parms.NewRecollectionBossComponent = NewRecollectionBossComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameModeZion.ResetEnvironmentLevelOverride
// (Final, Native, Public, BlueprintCallable)

void AGameModeZion::ResetEnvironmentLevelOverride()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "ResetEnvironmentLevelOverride");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameModeZion.ResetNewGamePlusGenerationOverride
// (Final, Native, Public, BlueprintCallable)

void AGameModeZion::ResetNewGamePlusGenerationOverride()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "ResetNewGamePlusGenerationOverride");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameModeZion.RespawnPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERespawnReason                          Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeZion::RespawnPlayer(ERespawnReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "RespawnPlayer");

	Params::GameModeZion_RespawnPlayer Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameModeZion.SetEnvironmentLevelOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LevelOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeZion::SetEnvironmentLevelOverride(int32 LevelOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "SetEnvironmentLevelOverride");

	Params::GameModeZion_SetEnvironmentLevelOverride Parms{};

	Parms.LevelOverride = LevelOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameModeZion.SetNewGamePlusGenerationOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   GenerationOverride                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeZion::SetNewGamePlusGenerationOverride(int32 GenerationOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "SetNewGamePlusGenerationOverride");

	Params::GameModeZion_SetNewGamePlusGenerationOverride Parms{};

	Parms.GenerationOverride = GenerationOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameModeZion.StartRecollectionBoss
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       RecollectionBossDataHandle                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AGameModeZion::StartRecollectionBoss(const struct FDataTableRowHandle& RecollectionBossDataHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "StartRecollectionBoss");

	Params::GameModeZion_StartRecollectionBoss Parms{};

	Parms.RecollectionBossDataHandle = std::move(RecollectionBossDataHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameModeZion.StartRecollectionBossRush
// (Final, Native, Public, BlueprintCallable)

void AGameModeZion::StartRecollectionBossRush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "StartRecollectionBossRush");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameModeZion.CanLeaveRecollectionBoss
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeZion::CanLeaveRecollectionBoss() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "CanLeaveRecollectionBoss");

	Params::GameModeZion_CanLeaveRecollectionBoss Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.DidReachGameEnding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameEndingType                         GameEndingType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckPreviousGameGeneration                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeZion::DidReachGameEnding(EGameEndingType GameEndingType, bool bCheckPreviousGameGeneration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "DidReachGameEnding");

	Params::GameModeZion_DidReachGameEnding Parms{};

	Parms.GameEndingType = GameEndingType;
	Parms.bCheckPreviousGameGeneration = bCheckPreviousGameGeneration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetAbilityFXMatrixData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialFXMatrixData*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialFXMatrixData* AGameModeZion::GetAbilityFXMatrixData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetAbilityFXMatrixData");

	Params::GameModeZion_GetAbilityFXMatrixData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetAbilitySEMatrixData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialSEMatrixData*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialSEMatrixData* AGameModeZion::GetAbilitySEMatrixData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetAbilitySEMatrixData");

	Params::GameModeZion_GetAbilitySEMatrixData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetCurrentRespawnReason
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERespawnReason                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERespawnReason AGameModeZion::GetCurrentRespawnReason() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetCurrentRespawnReason");

	Params::GameModeZion_GetCurrentRespawnReason Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableAchievements
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableAchievements() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableAchievements");

	Params::GameModeZion_GetDataTableAchievements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableEnemies
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableEnemies() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableEnemies");

	Params::GameModeZion_GetDataTableEnemies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableGameMaps
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableGameMaps() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableGameMaps");

	Params::GameModeZion_GetDataTableGameMaps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableGameMapTransitions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableGameMapTransitions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableGameMapTransitions");

	Params::GameModeZion_GetDataTableGameMapTransitions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemAptitudes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemAptitudes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemAptitudes");

	Params::GameModeZion_GetDataTableItemAptitudes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemAssists
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemAssists() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemAssists");

	Params::GameModeZion_GetDataTableItemAssists Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemCostumes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemCostumes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemCostumes");

	Params::GameModeZion_GetDataTableItemCostumes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemCurrencies
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemCurrencies() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemCurrencies");

	Params::GameModeZion_GetDataTableItemCurrencies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemEnemyInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemEnemyInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemEnemyInfo");

	Params::GameModeZion_GetDataTableItemEnemyInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemEquipments
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemEquipments() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemEquipments");

	Params::GameModeZion_GetDataTableItemEquipments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemGallery
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemGallery() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemGallery");

	Params::GameModeZion_GetDataTableItemGallery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemKeys
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemKeys() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemKeys");

	Params::GameModeZion_GetDataTableItemKeys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemMaterials
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemMaterials() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemMaterials");

	Params::GameModeZion_GetDataTableItemMaterials Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemNPCInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemNPCInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemNPCInfo");

	Params::GameModeZion_GetDataTableItemNPCInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemPassives
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemPassives() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemPassives");

	Params::GameModeZion_GetDataTableItemPassives Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemQuests
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemQuests() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemQuests");

	Params::GameModeZion_GetDataTableItemQuests Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemSkills
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemSkills() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemSkills");

	Params::GameModeZion_GetDataTableItemSkills Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemSpirits
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemSpirits() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemSpirits");

	Params::GameModeZion_GetDataTableItemSpirits Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemStats
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemStats() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemStats");

	Params::GameModeZion_GetDataTableItemStats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemTips
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemTips() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemTips");

	Params::GameModeZion_GetDataTableItemTips Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableItemTutorials
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableItemTutorials() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableItemTutorials");

	Params::GameModeZion_GetDataTableItemTutorials Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableRecollectionBosses
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableRecollectionBosses() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableRecollectionBosses");

	Params::GameModeZion_GetDataTableRecollectionBosses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableRestPointEvents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableRestPointEvents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableRestPointEvents");

	Params::GameModeZion_GetDataTableRestPointEvents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableRestPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableRestPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableRestPoints");

	Params::GameModeZion_GetDataTableRestPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetDataTableStoryLevels
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AGameModeZion::GetDataTableStoryLevels() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetDataTableStoryLevels");

	Params::GameModeZion_GetDataTableStoryLevels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetEnvironmentLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeZion::GetEnvironmentLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetEnvironmentLevel");

	Params::GameModeZion_GetEnvironmentLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetEnvironmentLevelNewGamePlus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeZion::GetEnvironmentLevelNewGamePlus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetEnvironmentLevelNewGamePlus");

	Params::GameModeZion_GetEnvironmentLevelNewGamePlus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetEnvironmentLevelOverride
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeZion::GetEnvironmentLevelOverride() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetEnvironmentLevelOverride");

	Params::GameModeZion_GetEnvironmentLevelOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetGameClearCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeZion::GetGameClearCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetGameClearCount");

	Params::GameModeZion_GetGameClearCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetGameEndingCountReached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeZion::GetGameEndingCountReached() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetGameEndingCountReached");

	Params::GameModeZion_GetGameEndingCountReached Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetGameModeType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameModeType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameModeType AGameModeZion::GetGameModeType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetGameModeType");

	Params::GameModeZion_GetGameModeType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetLastBossRecollectionHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDataTableRowHandle              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDataTableRowHandle AGameModeZion::GetLastBossRecollectionHandle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetLastBossRecollectionHandle");

	Params::GameModeZion_GetLastBossRecollectionHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetNewGamePlusGeneration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeZion::GetNewGamePlusGeneration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetNewGamePlusGeneration");

	Params::GameModeZion_GetNewGamePlusGeneration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetNewGamePlusGenerationOverride
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeZion::GetNewGamePlusGenerationOverride() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetNewGamePlusGenerationOverride");

	Params::GameModeZion_GetNewGamePlusGenerationOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetPlayTimeAsString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AGameModeZion::GetPlayTimeAsString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetPlayTimeAsString");

	Params::GameModeZion_GetPlayTimeAsString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetRawEnvironmentLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeZion::GetRawEnvironmentLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetRawEnvironmentLevel");

	Params::GameModeZion_GetRawEnvironmentLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.GetStepMatrixData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStepMatrixData*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStepMatrixData* AGameModeZion::GetStepMatrixData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "GetStepMatrixData");

	Params::GameModeZion_GetStepMatrixData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.IsDeathProcessingAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeZion::IsDeathProcessingAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "IsDeathProcessingAllowed");

	Params::GameModeZion_IsDeathProcessingAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.IsGameCleared
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeZion::IsGameCleared() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "IsGameCleared");

	Params::GameModeZion_IsGameCleared Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.IsGameReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeZion::IsGameReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "IsGameReady");

	Params::GameModeZion_IsGameReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameModeZion.IsInNewGamePlus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeZion::IsInNewGamePlus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeZion", "IsInNewGamePlus");

	Params::GameModeZion_IsInNewGamePlus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameplayCamera.ClearSettings
// (Final, Native, Protected, BlueprintCallable)

void AGameplayCamera::ClearSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCamera", "ClearSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameplayCamera.FlushCamera
// (Final, Native, Public, BlueprintCallable)

void AGameplayCamera::FlushCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCamera", "FlushCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameplayCamera.RegisterEnemyPawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            EnemyPawnToAdd                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameplayCamera::RegisterEnemyPawn(class APawn* EnemyPawnToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCamera", "RegisterEnemyPawn");

	Params::GameplayCamera_RegisterEnemyPawn Parms{};

	Parms.EnemyPawnToAdd = EnemyPawnToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameplayCamera.RegisterEnemyPawns
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class APawn*>&             EnemyPawnsToAdd                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AGameplayCamera::RegisterEnemyPawns(const TArray<class APawn*>& EnemyPawnsToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCamera", "RegisterEnemyPawns");

	Params::GameplayCamera_RegisterEnemyPawns Parms{};

	Parms.EnemyPawnsToAdd = std::move(EnemyPawnsToAdd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameplayCamera.ResetCameraToDefault
// (Final, Native, Protected, BlueprintCallable)

void AGameplayCamera::ResetCameraToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCamera", "ResetCameraToDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameplayCamera.SetSettings
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayCameraSettings&   NewSettings                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AGameplayCamera::SetSettings(const struct FGameplayCameraSettings& NewSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCamera", "SetSettings");

	Params::GameplayCamera_SetSettings Parms{};

	Parms.NewSettings = std::move(NewSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameplayCamera.UnregisterEnemyPawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            EnemyPawnToRemove                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameplayCamera::UnregisterEnemyPawn(class APawn* EnemyPawnToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCamera", "UnregisterEnemyPawn");

	Params::GameplayCamera_UnregisterEnemyPawn Parms{};

	Parms.EnemyPawnToRemove = EnemyPawnToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameplayCamera.UnregisterEnemyPawns
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class APawn*>&             EnemyPawnsToRemove                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AGameplayCamera::UnregisterEnemyPawns(const TArray<class APawn*>& EnemyPawnsToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCamera", "UnregisterEnemyPawns");

	Params::GameplayCamera_UnregisterEnemyPawns Parms{};

	Parms.EnemyPawnsToRemove = std::move(EnemyPawnsToRemove);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameplayConditionCheckerAsset.CheckGameplayConditionAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TSubclassOf<class UGameplayConditionCheckerAsset>&GameplayConditionAssetClass                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayConditionCheckerAsset::CheckGameplayConditionAsset(const TSubclassOf<class UGameplayConditionCheckerAsset>& GameplayConditionAssetClass, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayConditionCheckerAsset", "CheckGameplayConditionAsset");

	Params::GameplayConditionCheckerAsset_CheckGameplayConditionAsset Parms{};

	Parms.GameplayConditionAssetClass = GameplayConditionAssetClass;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameplayConditionCheckerAsset.CheckCondition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayConditionCheckerAsset::CheckCondition(class APlayerController* PlayerController) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayConditionCheckerAsset", "CheckCondition");

	Params::GameplayConditionCheckerAsset_CheckCondition Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetMaxResolutionScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::GetMaxResolutionScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSettingsSubsystem", "GetMaxResolutionScale");

	Params::GameSettingsSubsystem_GetMaxResolutionScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetMinResolutionScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::GetMinResolutionScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSettingsSubsystem", "GetMinResolutionScale");

	Params::GameSettingsSubsystem_GetMinResolutionScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetAntiAliasingMethod
// (Final, Native, Public, BlueprintCallable)

void UGameSettingsSubsystem::ResetAntiAliasingMethod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetAntiAliasingMethod");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameSettingsSubsystem.ResetAspectRatio
// (Final, Native, Public, BlueprintCallable)

void UGameSettingsSubsystem::ResetAspectRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetAspectRatio");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameSettingsSubsystem.ResetAutoClimbDirectionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAutoClimbDirectionMode                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAutoClimbDirectionMode UGameSettingsSubsystem::ResetAutoClimbDirectionMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetAutoClimbDirectionMode");

	Params::GameSettingsSubsystem_ResetAutoClimbDirectionMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetAutoSkipAlreadySeenEvents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::ResetAutoSkipAlreadySeenEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetAutoSkipAlreadySeenEvents");

	Params::GameSettingsSubsystem_ResetAutoSkipAlreadySeenEvents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetCameraOscillation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::ResetCameraOscillation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetCameraOscillation");

	Params::GameSettingsSubsystem_ResetCameraOscillation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetCameraShake
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::ResetCameraShake()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetCameraShake");

	Params::GameSettingsSubsystem_ResetCameraShake Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetControllerVibration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::ResetControllerVibration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetControllerVibration");

	Params::GameSettingsSubsystem_ResetControllerVibration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetDisplayAchievementNotifications
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::ResetDisplayAchievementNotifications()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetDisplayAchievementNotifications");

	Params::GameSettingsSubsystem_ResetDisplayAchievementNotifications Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetDisplayDamageValues
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::ResetDisplayDamageValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetDisplayDamageValues");

	Params::GameSettingsSubsystem_ResetDisplayDamageValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetDisplayEnemyGauges
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::ResetDisplayEnemyGauges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetDisplayEnemyGauges");

	Params::GameSettingsSubsystem_ResetDisplayEnemyGauges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetDisplayHealValues
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::ResetDisplayHealValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetDisplayHealValues");

	Params::GameSettingsSubsystem_ResetDisplayHealValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetDisplayHPAboveGauge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::ResetDisplayHPAboveGauge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetDisplayHPAboveGauge");

	Params::GameSettingsSubsystem_ResetDisplayHPAboveGauge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetDisplayPlayerUI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::ResetDisplayPlayerUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetDisplayPlayerUI");

	Params::GameSettingsSubsystem_ResetDisplayPlayerUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetDisplayTutorials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::ResetDisplayTutorials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetDisplayTutorials");

	Params::GameSettingsSubsystem_ResetDisplayTutorials Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetHoldDownToDodgeStill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::ResetHoldDownToDodgeStill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetHoldDownToDodgeStill");

	Params::GameSettingsSubsystem_ResetHoldDownToDodgeStill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetLowHPFeedbackOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::ResetLowHPFeedbackOpacity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetLowHPFeedbackOpacity");

	Params::GameSettingsSubsystem_ResetLowHPFeedbackOpacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetResolutionScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::ResetResolutionScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetResolutionScale");

	Params::GameSettingsSubsystem_ResetResolutionScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.ResetSticksDeadZone
// (Final, Native, Public, BlueprintCallable)

void UGameSettingsSubsystem::ResetSticksDeadZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetSticksDeadZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameSettingsSubsystem.ResetToDefault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameSettingsType                       GameSettingsToReset                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSettingsSubsystem::ResetToDefault(EGameSettingsType GameSettingsToReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "ResetToDefault");

	Params::GameSettingsSubsystem_ResetToDefault Parms{};

	Parms.GameSettingsToReset = GameSettingsToReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameSettingsSubsystem.SetAntiAliasingMethod
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const EAntiAliasingMethod&              NewAntiAliasingMethod                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAntiAliasingMethod                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAntiAliasingMethod UGameSettingsSubsystem::SetAntiAliasingMethod(const EAntiAliasingMethod& NewAntiAliasingMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetAntiAliasingMethod");

	Params::GameSettingsSubsystem_SetAntiAliasingMethod Parms{};

	Parms.NewAntiAliasingMethod = NewAntiAliasingMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetAutoClimbDirectionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAutoClimbDirectionMode                 NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAutoClimbDirectionMode                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAutoClimbDirectionMode UGameSettingsSubsystem::SetAutoClimbDirectionMode(EAutoClimbDirectionMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetAutoClimbDirectionMode");

	Params::GameSettingsSubsystem_SetAutoClimbDirectionMode Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetAutoSkipAlreadySeenEvents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAutoSkip                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::SetAutoSkipAlreadySeenEvents(bool bAutoSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetAutoSkipAlreadySeenEvents");

	Params::GameSettingsSubsystem_SetAutoSkipAlreadySeenEvents Parms{};

	Parms.bAutoSkip = bAutoSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetAutoUploadCrashReport
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewAutoUploadCrashReport                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSettingsSubsystem::SetAutoUploadCrashReport(bool bNewAutoUploadCrashReport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetAutoUploadCrashReport");

	Params::GameSettingsSubsystem_SetAutoUploadCrashReport Parms{};

	Parms.bNewAutoUploadCrashReport = bNewAutoUploadCrashReport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameSettingsSubsystem.SetCameraOscillation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::SetCameraOscillation(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetCameraOscillation");

	Params::GameSettingsSubsystem_SetCameraOscillation Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetCameraShake
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewCameraShake                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::SetCameraShake(float NewCameraShake)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetCameraShake");

	Params::GameSettingsSubsystem_SetCameraShake Parms{};

	Parms.NewCameraShake = NewCameraShake;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetConstraintCameraAspectRatio
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const EConstraintCameraAspectRatio&     NewConstraintCameraAspectRatio                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EConstraintCameraAspectRatio            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConstraintCameraAspectRatio UGameSettingsSubsystem::SetConstraintCameraAspectRatio(const EConstraintCameraAspectRatio& NewConstraintCameraAspectRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetConstraintCameraAspectRatio");

	Params::GameSettingsSubsystem_SetConstraintCameraAspectRatio Parms{};

	Parms.NewConstraintCameraAspectRatio = NewConstraintCameraAspectRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetConstraintHUDAspectRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewConstraintHUDAspectRatio                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::SetConstraintHUDAspectRatio(bool bNewConstraintHUDAspectRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetConstraintHUDAspectRatio");

	Params::GameSettingsSubsystem_SetConstraintHUDAspectRatio Parms{};

	Parms.bNewConstraintHUDAspectRatio = bNewConstraintHUDAspectRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetControllerVibration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewControllerVibration                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::SetControllerVibration(float NewControllerVibration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetControllerVibration");

	Params::GameSettingsSubsystem_SetControllerVibration Parms{};

	Parms.NewControllerVibration = NewControllerVibration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetDisplayAchievementNotifications
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisplay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::SetDisplayAchievementNotifications(bool bDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetDisplayAchievementNotifications");

	Params::GameSettingsSubsystem_SetDisplayAchievementNotifications Parms{};

	Parms.bDisplay = bDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetDisplayDamageValues
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisplayDamageValues                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::SetDisplayDamageValues(bool bDisplayDamageValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetDisplayDamageValues");

	Params::GameSettingsSubsystem_SetDisplayDamageValues Parms{};

	Parms.bDisplayDamageValues = bDisplayDamageValues;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetDisplayEnemyGauges
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisplay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::SetDisplayEnemyGauges(bool bDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetDisplayEnemyGauges");

	Params::GameSettingsSubsystem_SetDisplayEnemyGauges Parms{};

	Parms.bDisplay = bDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetDisplayHealValues
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisplayHealValues                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::SetDisplayHealValues(bool bDisplayHealValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetDisplayHealValues");

	Params::GameSettingsSubsystem_SetDisplayHealValues Parms{};

	Parms.bDisplayHealValues = bDisplayHealValues;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetDisplayHPAboveGauge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisplayHPAboveGauge                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::SetDisplayHPAboveGauge(bool bDisplayHPAboveGauge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetDisplayHPAboveGauge");

	Params::GameSettingsSubsystem_SetDisplayHPAboveGauge Parms{};

	Parms.bDisplayHPAboveGauge = bDisplayHPAboveGauge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetDisplayPlayerUI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisplay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::SetDisplayPlayerUI(bool bDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetDisplayPlayerUI");

	Params::GameSettingsSubsystem_SetDisplayPlayerUI Parms{};

	Parms.bDisplay = bDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetDisplayTutorials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisplay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::SetDisplayTutorials(bool bDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetDisplayTutorials");

	Params::GameSettingsSubsystem_SetDisplayTutorials Parms{};

	Parms.bDisplay = bDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetGamma
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewGamma                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::SetGamma(float NewGamma)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetGamma");

	Params::GameSettingsSubsystem_SetGamma Parms{};

	Parms.NewGamma = NewGamma;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetGammaPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewGammaPercentage                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::SetGammaPercentage(float NewGammaPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetGammaPercentage");

	Params::GameSettingsSubsystem_SetGammaPercentage Parms{};

	Parms.NewGammaPercentage = NewGammaPercentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetHoldDownToDodgeStill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::SetHoldDownToDodgeStill(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetHoldDownToDodgeStill");

	Params::GameSettingsSubsystem_SetHoldDownToDodgeStill Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetInitialSettingsDone
// (Final, Native, Public, BlueprintCallable)

void UGameSettingsSubsystem::SetInitialSettingsDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetInitialSettingsDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameSettingsSubsystem.SetLanguage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Language                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSettingsSubsystem::SetLanguage(const class FString& Language)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetLanguage");

	Params::GameSettingsSubsystem_SetLanguage Parms{};

	Parms.Language = std::move(Language);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameSettingsSubsystem.SetLowHPFeedbackOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewLowHPFeedbackOpacity                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::SetLowHPFeedbackOpacity(float NewLowHPFeedbackOpacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetLowHPFeedbackOpacity");

	Params::GameSettingsSubsystem_SetLowHPFeedbackOpacity Parms{};

	Parms.NewLowHPFeedbackOpacity = NewLowHPFeedbackOpacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetResolutionScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewResolutionScale                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::SetResolutionScale(float NewResolutionScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetResolutionScale");

	Params::GameSettingsSubsystem_SetResolutionScale Parms{};

	Parms.NewResolutionScale = NewResolutionScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetStickDeadZone
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const EInputStick&                      InputStick                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewDeadZone                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::SetStickDeadZone(const EInputStick& InputStick, float NewDeadZone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetStickDeadZone");

	Params::GameSettingsSubsystem_SetStickDeadZone Parms{};

	Parms.InputStick = InputStick;
	Parms.NewDeadZone = NewDeadZone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.SetTitleType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameEndingType                         TitleType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSettingsSubsystem::SetTitleType(EGameEndingType TitleType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetTitleType");

	Params::GameSettingsSubsystem_SetTitleType Parms{};

	Parms.TitleType = TitleType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameSettingsSubsystem.SetUIAspectRatio
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const EConstraintCameraAspectRatio&     NewUIAspectRatio                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EConstraintCameraAspectRatio            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConstraintCameraAspectRatio UGameSettingsSubsystem::SetUIAspectRatio(const EConstraintCameraAspectRatio& NewUIAspectRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "SetUIAspectRatio");

	Params::GameSettingsSubsystem_SetUIAspectRatio Parms{};

	Parms.NewUIAspectRatio = NewUIAspectRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.DidReachAnyGameEnding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::DidReachAnyGameEnding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "DidReachAnyGameEnding");

	Params::GameSettingsSubsystem_DidReachAnyGameEnding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.DidReachGameEnding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameEndingType                         GameEndingType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::DidReachGameEnding(EGameEndingType GameEndingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "DidReachGameEnding");

	Params::GameSettingsSubsystem_DidReachGameEnding Parms{};

	Parms.GameEndingType = GameEndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetAntiAliasingMethod
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAntiAliasingMethod                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAntiAliasingMethod UGameSettingsSubsystem::GetAntiAliasingMethod() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetAntiAliasingMethod");

	Params::GameSettingsSubsystem_GetAntiAliasingMethod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetAutoClimbDirectionMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAutoClimbDirectionMode                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAutoClimbDirectionMode UGameSettingsSubsystem::GetAutoClimbDirectionMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetAutoClimbDirectionMode");

	Params::GameSettingsSubsystem_GetAutoClimbDirectionMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetAutoSkipAlreadySeenEvents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::GetAutoSkipAlreadySeenEvents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetAutoSkipAlreadySeenEvents");

	Params::GameSettingsSubsystem_GetAutoSkipAlreadySeenEvents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetAutoUploadCrashReport
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::GetAutoUploadCrashReport() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetAutoUploadCrashReport");

	Params::GameSettingsSubsystem_GetAutoUploadCrashReport Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetCameraOscillation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::GetCameraOscillation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetCameraOscillation");

	Params::GameSettingsSubsystem_GetCameraOscillation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetCameraShake
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::GetCameraShake() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetCameraShake");

	Params::GameSettingsSubsystem_GetCameraShake Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetConstraintCameraAspectRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EConstraintCameraAspectRatio            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConstraintCameraAspectRatio UGameSettingsSubsystem::GetConstraintCameraAspectRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetConstraintCameraAspectRatio");

	Params::GameSettingsSubsystem_GetConstraintCameraAspectRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetConstraintHUDAspectRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::GetConstraintHUDAspectRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetConstraintHUDAspectRatio");

	Params::GameSettingsSubsystem_GetConstraintHUDAspectRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetControllerVibration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::GetControllerVibration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetControllerVibration");

	Params::GameSettingsSubsystem_GetControllerVibration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetDisplayAchievementNotifications
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::GetDisplayAchievementNotifications() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetDisplayAchievementNotifications");

	Params::GameSettingsSubsystem_GetDisplayAchievementNotifications Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetDisplayDamageValues
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::GetDisplayDamageValues() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetDisplayDamageValues");

	Params::GameSettingsSubsystem_GetDisplayDamageValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetDisplayEnemyGauges
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::GetDisplayEnemyGauges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetDisplayEnemyGauges");

	Params::GameSettingsSubsystem_GetDisplayEnemyGauges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetDisplayHealValues
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::GetDisplayHealValues() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetDisplayHealValues");

	Params::GameSettingsSubsystem_GetDisplayHealValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetDisplayHPAboveGauge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::GetDisplayHPAboveGauge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetDisplayHPAboveGauge");

	Params::GameSettingsSubsystem_GetDisplayHPAboveGauge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetDisplayPlayerUI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::GetDisplayPlayerUI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetDisplayPlayerUI");

	Params::GameSettingsSubsystem_GetDisplayPlayerUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetDisplayTutorials
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::GetDisplayTutorials() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetDisplayTutorials");

	Params::GameSettingsSubsystem_GetDisplayTutorials Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetGamma
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::GetGamma() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetGamma");

	Params::GameSettingsSubsystem_GetGamma Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetGammaDefault
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::GetGammaDefault() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetGammaDefault");

	Params::GameSettingsSubsystem_GetGammaDefault Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetGammaMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::GetGammaMax() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetGammaMax");

	Params::GameSettingsSubsystem_GetGammaMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetGammaMin
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::GetGammaMin() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetGammaMin");

	Params::GameSettingsSubsystem_GetGammaMin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetGammaPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::GetGammaPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetGammaPercentage");

	Params::GameSettingsSubsystem_GetGammaPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetHoldDownToDodgeStill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::GetHoldDownToDodgeStill() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetHoldDownToDodgeStill");

	Params::GameSettingsSubsystem_GetHoldDownToDodgeStill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetLanguage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGameSettingsSubsystem::GetLanguage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetLanguage");

	Params::GameSettingsSubsystem_GetLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetLowHPFeedbackOpacity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::GetLowHPFeedbackOpacity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetLowHPFeedbackOpacity");

	Params::GameSettingsSubsystem_GetLowHPFeedbackOpacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetResolutionScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::GetResolutionScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetResolutionScale");

	Params::GameSettingsSubsystem_GetResolutionScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetStickDeadZone
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EInputStick&                      InputStick                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSettingsSubsystem::GetStickDeadZone(const EInputStick& InputStick) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetStickDeadZone");

	Params::GameSettingsSubsystem_GetStickDeadZone Parms{};

	Parms.InputStick = InputStick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetTitleType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameEndingType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameEndingType UGameSettingsSubsystem::GetTitleType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetTitleType");

	Params::GameSettingsSubsystem_GetTitleType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.GetUIAspectRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EConstraintCameraAspectRatio            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConstraintCameraAspectRatio UGameSettingsSubsystem::GetUIAspectRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "GetUIAspectRatio");

	Params::GameSettingsSubsystem_GetUIAspectRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameSettingsSubsystem.IsInitialSettingsDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSettingsSubsystem::IsInitialSettingsDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSettingsSubsystem", "IsInitialSettingsDone");

	Params::GameSettingsSubsystem_IsInitialSettingsDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameViewportZion.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameViewportZion*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameViewportZion* UGameViewportZion::Get()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameViewportZion", "Get");

	Params::GameViewportZion_Get Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameViewportZion.SetViewportOverlayRenderOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Opacity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameViewportZion::SetViewportOverlayRenderOpacity(float Opacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameViewportZion", "SetViewportOverlayRenderOpacity");

	Params::GameViewportZion_SetViewportOverlayRenderOpacity Parms{};

	Parms.Opacity = Opacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameViewportZion.SetViewportOverlayWidgetVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameViewportZion::SetViewportOverlayWidgetVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameViewportZion", "SetViewportOverlayWidgetVisible");

	Params::GameViewportZion_SetViewportOverlayWidgetVisible Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameViewportZion.SetWorldRenderingEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableWorldRendering                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameViewportZion::SetWorldRenderingEnable(bool bEnableWorldRendering)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameViewportZion", "SetWorldRenderingEnable");

	Params::GameViewportZion_SetWorldRenderingEnable Parms{};

	Parms.bEnableWorldRendering = bEnableWorldRendering;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GameViewportZion.GetUserWidgetInStack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UUserWidget>          ClassToFind                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UGameViewportZion::GetUserWidgetInStack(TSubclassOf<class UUserWidget> ClassToFind) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameViewportZion", "GetUserWidgetInStack");

	Params::GameViewportZion_GetUserWidgetInStack Parms{};

	Parms.ClassToFind = ClassToFind;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GameViewportZion.IsShowingCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameViewportZion::IsShowingCollision() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameViewportZion", "IsShowingCollision");

	Params::GameViewportZion_IsShowingCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.GunmanIKBoneTargetComponent.OnSpiritActivationChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bNewActive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGunmanIKBoneTargetComponent::OnSpiritActivationChanged(bool bNewActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GunmanIKBoneTargetComponent", "OnSpiritActivationChanged");

	Params::GunmanIKBoneTargetComponent_OnSpiritActivationChanged Parms{};

	Parms.bNewActive = bNewActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.GunmanIKBoneTargetComponent.GetAbilityGlobalOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FTransform                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FTransform UGunmanIKBoneTargetComponent::GetAbilityGlobalOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GunmanIKBoneTargetComponent", "GetAbilityGlobalOffset");

	Params::GunmanIKBoneTargetComponent_GetAbilityGlobalOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HitStopComponent.LaunchHitStop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   HitStopDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHitStopComponent::LaunchHitStop(float HitStopDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitStopComponent", "LaunchHitStop");

	Params::HitStopComponent_LaunchHitStop Parms{};

	Parms.HitStopDuration = HitStopDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HitStopComponent.IsInHitStop
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHitStopComponent::IsInHitStop() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitStopComponent", "IsInHitStop");

	Params::HitStopComponent_IsInHitStop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HomingComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void UHomingComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HomingComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HomingComponent.SetTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHomingComponent::SetTarget(const class AActor* TargetActor, bool bReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HomingComponent", "SetTarget");

	Params::HomingComponent_SetTarget Parms{};

	Parms.TargetActor = TargetActor;
	Parms.bReset = bReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HomingComponent.DidReachTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class USceneComponent*            PinnedTarget                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHomingComponent::DidReachTarget(const class USceneComponent* PinnedTarget) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HomingComponent", "DidReachTarget");

	Params::HomingComponent_DidReachTarget Parms{};

	Parms.PinnedTarget = PinnedTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HomingComponent.GetTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class USceneComponent*            ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class USceneComponent* UHomingComponent::GetTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HomingComponent", "GetTarget");

	Params::HomingComponent_GetTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HookComponent.LockCurrentHook
// (Final, Native, Public, BlueprintCallable)

void UHookComponent::LockCurrentHook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookComponent", "LockCurrentHook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HookComponent.OnAptitudesChanged
// (Final, Native, Private)

void UHookComponent::OnAptitudesChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookComponent", "OnAptitudesChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HookComponent.OnComponentOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UHookComponent::OnComponentOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookComponent", "OnComponentOverlapBegin");

	Params::HookComponent_OnComponentOverlapBegin Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HookComponent.OnComponentOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookComponent::OnComponentOverlapEnd(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookComponent", "OnComponentOverlapEnd");

	Params::HookComponent_OnComponentOverlapEnd Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HookComponent.OnLockHook
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AHookPoint*                       HookPoint                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookComponent::OnLockHook(class AHookPoint* HookPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookComponent", "OnLockHook");

	Params::HookComponent_OnLockHook Parms{};

	Parms.HookPoint = HookPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.HookComponent.OnUnlockHook
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AHookPoint*                       HookPoint                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookComponent::OnUnlockHook(class AHookPoint* HookPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookComponent", "OnUnlockHook");

	Params::HookComponent_OnUnlockHook Parms{};

	Parms.HookPoint = HookPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.HookComponent.ResetOverrideHookPoint
// (Final, Native, Public, BlueprintCallable)

void UHookComponent::ResetOverrideHookPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookComponent", "ResetOverrideHookPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HookComponent.ResetOverrideHookWorldLocation
// (Final, Native, Public, BlueprintCallable)

void UHookComponent::ResetOverrideHookWorldLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookComponent", "ResetOverrideHookWorldLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HookComponent.SetOverrideHookPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHookPoint*                       NewHookPoint                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookComponent::SetOverrideHookPoint(class AHookPoint* NewHookPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookComponent", "SetOverrideHookPoint");

	Params::HookComponent_SetOverrideHookPoint Parms{};

	Parms.NewHookPoint = NewHookPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HookComponent.SetOverrideHookWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewHookWorldLocation                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookComponent::SetOverrideHookWorldLocation(const struct FVector& NewHookWorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookComponent", "SetOverrideHookWorldLocation");

	Params::HookComponent_SetOverrideHookWorldLocation Parms{};

	Parms.NewHookWorldLocation = std::move(NewHookWorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HookComponent.UnlockHook
// (Final, Native, Public, BlueprintCallable)

void UHookComponent::UnlockHook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookComponent", "UnlockHook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HookComponent.CanTargetHook
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHookType                               HookType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHookComponent::CanTargetHook(EHookType HookType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookComponent", "CanTargetHook");

	Params::HookComponent_CanTargetHook Parms{};

	Parms.HookType = HookType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HookComponent.GetHookWorldLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UHookComponent::GetHookWorldLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookComponent", "GetHookWorldLocation");

	Params::HookComponent_GetHookWorldLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.HookPoint_Moving.OnComponentOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AHookPoint_Moving::OnComponentOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookPoint_Moving", "OnComponentOverlapBegin");

	Params::HookPoint_Moving_OnComponentOverlapBegin Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.HookPoint_Moving.OnMovementModeChanged
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHookPoint_Moving::OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookPoint_Moving", "OnMovementModeChanged");

	Params::HookPoint_Moving_OnMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.InputBPFLibrary.IsEqual
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FInputSnapshot&            A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FInputSnapshot&            B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputBPFLibrary::IsEqual(const struct FInputSnapshot& A, const struct FInputSnapshot& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InputBPFLibrary", "IsEqual");

	Params::InputBPFLibrary_IsEqual Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InputBPFLibrary.IsInputActionJustTriggered
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FInputSnapshot&            InputSnapshot                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UInputAction*               InputAction                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputBPFLibrary::IsInputActionJustTriggered(const struct FInputSnapshot& InputSnapshot, const class UInputAction* InputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InputBPFLibrary", "IsInputActionJustTriggered");

	Params::InputBPFLibrary_IsInputActionJustTriggered Parms{};

	Parms.InputSnapshot = std::move(InputSnapshot);
	Parms.InputAction = InputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InputBPFLibrary.IsInputActionTriggering
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FInputSnapshot&            InputSnapshot                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UInputAction*               InputAction                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputBPFLibrary::IsInputActionTriggering(const struct FInputSnapshot& InputSnapshot, const class UInputAction* InputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InputBPFLibrary", "IsInputActionTriggering");

	Params::InputBPFLibrary_IsInputActionTriggering Parms{};

	Parms.InputSnapshot = std::move(InputSnapshot);
	Parms.InputAction = InputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InputBPFLibrary.IsSameHorizontalDirection
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EInputDirection                         DirectionA                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDirection                         DirectionB                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsiderNeutralAsSame                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputBPFLibrary::IsSameHorizontalDirection(EInputDirection DirectionA, EInputDirection DirectionB, bool bConsiderNeutralAsSame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InputBPFLibrary", "IsSameHorizontalDirection");

	Params::InputBPFLibrary_IsSameHorizontalDirection Parms{};

	Parms.DirectionA = DirectionA;
	Parms.DirectionB = DirectionB;
	Parms.bConsiderNeutralAsSame = bConsiderNeutralAsSame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InputBPFLibrary.IsSameVerticalDirection
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EInputDirection                         DirectionA                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDirection                         DirectionB                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsiderNeutralAsSame                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputBPFLibrary::IsSameVerticalDirection(EInputDirection DirectionA, EInputDirection DirectionB, bool bConsiderNeutralAsSame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InputBPFLibrary", "IsSameVerticalDirection");

	Params::InputBPFLibrary_IsSameVerticalDirection Parms{};

	Parms.DirectionA = DirectionA;
	Parms.DirectionB = DirectionB;
	Parms.bConsiderNeutralAsSame = bConsiderNeutralAsSame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InputBufferComponent.GetInputSnapshotAtIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTimedInputSnapshot        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FTimedInputSnapshot UInputBufferComponent::GetInputSnapshotAtIndex(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputBufferComponent", "GetInputSnapshotAtIndex");

	Params::InputBufferComponent_GetInputSnapshotAtIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InputBufferComponent.GetInputSnapshotCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInputBufferComponent::GetInputSnapshotCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputBufferComponent", "GetInputSnapshotCount");

	Params::InputBufferComponent_GetInputSnapshotCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InputDeviceCheckerComponent.OnActiveControllerDisconnected
// (Final, Native, Private)

void UInputDeviceCheckerComponent::OnActiveControllerDisconnected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputDeviceCheckerComponent", "OnActiveControllerDisconnected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.InputDeviceCheckerComponent.OnWidgetClosed
// (Final, Native, Private)

void UInputDeviceCheckerComponent::OnWidgetClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputDeviceCheckerComponent", "OnWidgetClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.InputSettingsSubsystem.RemapKey
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const EActionInputType&                 ActionInputType                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      NewKey                                                 (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSet<EActionInputType>&           InvalidInputTypes                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsGamepadKey                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputSettingsSubsystem::RemapKey(const EActionInputType& ActionInputType, const struct FKey& NewKey, const TSet<EActionInputType>& InvalidInputTypes, bool bIsGamepadKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsSubsystem", "RemapKey");

	Params::InputSettingsSubsystem_RemapKey Parms{};

	Parms.ActionInputType = ActionInputType;
	Parms.NewKey = std::move(NewKey);
	Parms.InvalidInputTypes = std::move(InvalidInputTypes);
	Parms.bIsGamepadKey = bIsGamepadKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InputSettingsSubsystem.ResetAllInputMappingContextsToDefault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsGamepad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputSettingsSubsystem::ResetAllInputMappingContextsToDefault(bool bIsGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsSubsystem", "ResetAllInputMappingContextsToDefault");

	Params::InputSettingsSubsystem_ResetAllInputMappingContextsToDefault Parms{};

	Parms.bIsGamepad = bIsGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.InputSettingsSubsystem.ResetInputMappingContextToDefault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInputMappingContext*             InputMappingContext                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsGamepad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputSettingsSubsystem::ResetInputMappingContextToDefault(class UInputMappingContext* InputMappingContext, bool bIsGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsSubsystem", "ResetInputMappingContextToDefault");

	Params::InputSettingsSubsystem_ResetInputMappingContextToDefault Parms{};

	Parms.InputMappingContext = InputMappingContext;
	Parms.bIsGamepad = bIsGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.InputSettingsSubsystem.GetMappedKey
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      MappingName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey UInputSettingsSubsystem::GetMappedKey(const class FName& MappingName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsSubsystem", "GetMappedKey");

	Params::InputSettingsSubsystem_GetMappedKey Parms{};

	Parms.MappingName = MappingName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InputSettingsSubsystem.GetMappingNameFromInputAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UInputAction*               InputAction                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsGamepad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UInputSettingsSubsystem::GetMappingNameFromInputAction(const class UInputAction* InputAction, bool bIsGamepad) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsSubsystem", "GetMappingNameFromInputAction");

	Params::InputSettingsSubsystem_GetMappingNameFromInputAction Parms{};

	Parms.InputAction = InputAction;
	Parms.bIsGamepad = bIsGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Interactable_Event.OnClearStatusChecked
// (Final, Native, Private)
// Parameters:
// EClearStatus                            ClearStatus                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable_Event::OnClearStatusChecked(EClearStatus ClearStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable_Event", "OnClearStatusChecked");

	Params::Interactable_Event_OnClearStatusChecked Parms{};

	Parms.ClearStatus = ClearStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Interactable_Event.OnEventFinished
// (Final, Native, Private)
// Parameters:
// class UEventPlayer*                     InEventPlayer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCompletedEvent                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEventPlayerResult                      EventResult                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable_Event::OnEventFinished(class UEventPlayer* InEventPlayer, bool bCompletedEvent, EEventPlayerResult EventResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable_Event", "OnEventFinished");

	Params::Interactable_Event_OnEventFinished Parms{};

	Parms.InEventPlayer = InEventPlayer;
	Parms.bCompletedEvent = bCompletedEvent;
	Parms.EventResult = EventResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Interactable_Event.OnPostEventProcess
// (Event, Protected, BlueprintEvent)

void AInteractable_Event::OnPostEventProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable_Event", "OnPostEventProcess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.Interactable_Event.SetupAdditionalBindings
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TMap<class FName, class AActor*>*       AdditionalBindings                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void AInteractable_Event::SetupAdditionalBindings(TMap<class FName, class AActor*>* AdditionalBindings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable_Event", "SetupAdditionalBindings");

	Params::Interactable_Event_SetupAdditionalBindings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AdditionalBindings != nullptr)
		*AdditionalBindings = std::move(Parms.AdditionalBindings);
}


// Function Zion.Interactable_Event.SetupAdditionalBlackboardValues
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FEventBlackboardInit&            EventBlackboardInit                                    (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AInteractable_Event::SetupAdditionalBlackboardValues(struct FEventBlackboardInit& EventBlackboardInit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable_Event", "SetupAdditionalBlackboardValues");

	Params::Interactable_Event_SetupAdditionalBlackboardValues Parms{};

	Parms.EventBlackboardInit = std::move(EventBlackboardInit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	EventBlackboardInit = std::move(Parms.EventBlackboardInit);
}


// Function Zion.Interactable_EventNPC.GetNPC
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacterZionNPC*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacterZionNPC* AInteractable_EventNPC::GetNPC() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable_EventNPC", "GetNPC");

	Params::Interactable_EventNPC_GetNPC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Interactable_RestPoint.ClearNextEventDataHandle
// (Final, Native, Public, BlueprintCallable)

void AInteractable_RestPoint::ClearNextEventDataHandle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable_RestPoint", "ClearNextEventDataHandle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Interactable_RestPoint.SetNextEventDataHandle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       InNextEventDataHandle                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AInteractable_RestPoint::SetNextEventDataHandle(const struct FDataTableRowHandle& InNextEventDataHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable_RestPoint", "SetNextEventDataHandle");

	Params::Interactable_RestPoint_SetNextEventDataHandle Parms{};

	Parms.InNextEventDataHandle = std::move(InNextEventDataHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Interactable_RestPoint.GetNextEventDataHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDataTableRowHandle        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FDataTableRowHandle AInteractable_RestPoint::GetNextEventDataHandle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable_RestPoint", "GetNextEventDataHandle");

	Params::Interactable_RestPoint_GetNextEventDataHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.Interactable_RestPoint.GetRestPointDataHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDataTableRowHandle        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FDataTableRowHandle AInteractable_RestPoint::GetRestPointDataHandle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable_RestPoint", "GetRestPointDataHandle");

	Params::Interactable_RestPoint_GetRestPointDataHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InteractComponent.OnOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInteractComponent::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractComponent", "OnOverlapBegin");

	Params::InteractComponent_OnOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.InteractComponent.OnOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractComponent::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractComponent", "OnOverlapEnd");

	Params::InteractComponent_OnOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.InventoryComponent.AddCurrency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECurrencyType                           CurrencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrencyToAdd                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryComponent::AddCurrency(ECurrencyType CurrencyType, int32 CurrencyToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "AddCurrency");

	Params::InventoryComponent_AddCurrency Parms{};

	Parms.CurrencyType = CurrencyType;
	Parms.CurrencyToAdd = CurrencyToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.AddDrop
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDrop&                     Drop                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DropFactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::AddDrop(const struct FDrop& Drop, float DropFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "AddDrop");

	Params::InventoryComponent_AddDrop Parms{};

	Parms.Drop = std::move(Drop);
	Parms.DropFactor = DropFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.AddItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       ItemHandle                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::AddItem(const struct FDataTableRowHandle& ItemHandle, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "AddItem");

	Params::InventoryComponent_AddItem Parms{};

	Parms.ItemHandle = std::move(ItemHandle);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.HasItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       ItemHandle                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::HasItem(const struct FDataTableRowHandle& ItemHandle, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "HasItem");

	Params::InventoryComponent_HasItem Parms{};

	Parms.ItemHandle = std::move(ItemHandle);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.MarkItemAsChecked
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       ItemHandle                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UInventoryComponent::MarkItemAsChecked(const struct FDataTableRowHandle& ItemHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "MarkItemAsChecked");

	Params::InventoryComponent_MarkItemAsChecked Parms{};

	Parms.ItemHandle = std::move(ItemHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.InventoryComponent.RemoveItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       ItemHandle                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::RemoveItem(const struct FDataTableRowHandle& ItemHandle, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "RemoveItem");

	Params::InventoryComponent_RemoveItem Parms{};

	Parms.ItemHandle = std::move(ItemHandle);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.SpendCurrency
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCurrencyValue&            CurrencyValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryComponent::SpendCurrency(const struct FCurrencyValue& CurrencyValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "SpendCurrency");

	Params::InventoryComponent_SpendCurrency Parms{};

	Parms.CurrencyValue = std::move(CurrencyValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.CanSpendCurrency
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FCurrencyValue&            CurrencyValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::CanSpendCurrency(const struct FCurrencyValue& CurrencyValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "CanSpendCurrency");

	Params::InventoryComponent_CanSpendCurrency Parms{};

	Parms.CurrencyValue = std::move(CurrencyValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetAptitudeInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventoryAptitude*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventoryAptitude* UInventoryComponent::GetAptitudeInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetAptitudeInventory");

	Params::InventoryComponent_GetAptitudeInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetAssistInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UInventoryComponent::GetAssistInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetAssistInventory");

	Params::InventoryComponent_GetAssistInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetCostumeInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UInventoryComponent::GetCostumeInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetCostumeInventory");

	Params::InventoryComponent_GetCostumeInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetCountOfItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDataTableRowHandle&       ItemHandle                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryComponent::GetCountOfItem(const struct FDataTableRowHandle& ItemHandle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetCountOfItem");

	Params::InventoryComponent_GetCountOfItem Parms{};

	Parms.ItemHandle = std::move(ItemHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetCurrency
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECurrencyType                           CurrencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryComponent::GetCurrency(ECurrencyType CurrencyType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetCurrency");

	Params::InventoryComponent_GetCurrency Parms{};

	Parms.CurrencyType = CurrencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetCurrencyInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UInventoryComponent::GetCurrencyInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetCurrencyInventory");

	Params::InventoryComponent_GetCurrencyInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetEnemyInfoInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UInventoryComponent::GetEnemyInfoInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetEnemyInfoInventory");

	Params::InventoryComponent_GetEnemyInfoInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetEquipmentInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UInventoryComponent::GetEquipmentInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetEquipmentInventory");

	Params::InventoryComponent_GetEquipmentInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetGalleryInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UInventoryComponent::GetGalleryInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetGalleryInventory");

	Params::InventoryComponent_GetGalleryInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetInventoryFromItemType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInventoryItemType                      ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UInventoryComponent::GetInventoryFromItemType(EInventoryItemType ItemType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetInventoryFromItemType");

	Params::InventoryComponent_GetInventoryFromItemType Parms{};

	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetNPCInfoInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UInventoryComponent::GetNPCInfoInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetNPCInfoInventory");

	Params::InventoryComponent_GetNPCInfoInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetPassiveInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UInventoryComponent::GetPassiveInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetPassiveInventory");

	Params::InventoryComponent_GetPassiveInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetSkillInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventorySkill*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventorySkill* UInventoryComponent::GetSkillInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetSkillInventory");

	Params::InventoryComponent_GetSkillInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetSpiritInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UInventoryComponent::GetSpiritInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetSpiritInventory");

	Params::InventoryComponent_GetSpiritInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetStatsInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UInventoryComponent::GetStatsInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetStatsInventory");

	Params::InventoryComponent_GetStatsInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetTipInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UInventoryComponent::GetTipInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetTipInventory");

	Params::InventoryComponent_GetTipInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.GetTutorialInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UInventoryComponent::GetTutorialInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetTutorialInventory");

	Params::InventoryComponent_GetTutorialInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.HasAptitude
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EAptitudeType&                    AptitudeType                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::HasAptitude(const EAptitudeType& AptitudeType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "HasAptitude");

	Params::InventoryComponent_HasAptitude Parms{};

	Parms.AptitudeType = AptitudeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.HasNonCheckedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInventoryItemType                      ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::HasNonCheckedItem(EInventoryItemType ItemType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "HasNonCheckedItem");

	Params::InventoryComponent_HasNonCheckedItem Parms{};

	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.InventoryComponent.IsItemChecked
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDataTableRowHandle&       ItemHandle                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::IsItemChecked(const struct FDataTableRowHandle& ItemHandle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "IsItemChecked");

	Params::InventoryComponent_IsItemChecked Parms{};

	Parms.ItemHandle = std::move(ItemHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.LocalizationBPFLibrary.GetAvailableLanguages
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> ULocalizationBPFLibrary::GetAvailableLanguages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LocalizationBPFLibrary", "GetAvailableLanguages");

	Params::LocalizationBPFLibrary_GetAvailableLanguages Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.LocalizationBPFLibrary.GetLanguage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULocalizationBPFLibrary::GetLanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LocalizationBPFLibrary", "GetLanguage");

	Params::LocalizationBPFLibrary_GetLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.LocalizationBPFLibrary.SetLanguage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Language                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalizationBPFLibrary::SetLanguage(const class FString& Language)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LocalizationBPFLibrary", "SetLanguage");

	Params::LocalizationBPFLibrary_SetLanguage Parms{};

	Parms.Language = std::move(Language);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.LocalizationBPFLibrary.SetLanguageToSystemLanguage
// (Final, Native, Static, Public, BlueprintCallable)

void ULocalizationBPFLibrary::SetLanguageToSystemLanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LocalizationBPFLibrary", "SetLanguageToSystemLanguage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.LocomotionComponent.SetFacing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFacingType                             FacingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocomotionComponent::SetFacing(EFacingType FacingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocomotionComponent", "SetFacing");

	Params::LocomotionComponent_SetFacing Parms{};

	Parms.FacingType = FacingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.LocomotionComponent.SetFacingFromVector
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocomotionComponent::SetFacingFromVector(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocomotionComponent", "SetFacingFromVector");

	Params::LocomotionComponent_SetFacingFromVector Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.LocomotionComponent.SetUpdateFacing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewUpdateFacing                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocomotionComponent::SetUpdateFacing(bool bNewUpdateFacing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocomotionComponent", "SetUpdateFacing");

	Params::LocomotionComponent_SetUpdateFacing Parms{};

	Parms.bNewUpdateFacing = bNewUpdateFacing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.LocomotionComponent.SetUpVector
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewUpVector                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocomotionComponent::SetUpVector(const struct FVector& NewUpVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocomotionComponent", "SetUpVector");

	Params::LocomotionComponent_SetUpVector Parms{};

	Parms.NewUpVector = std::move(NewUpVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.LocomotionComponent.ToggleFacing
// (Final, Native, Public, BlueprintCallable)

void ULocomotionComponent::ToggleFacing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocomotionComponent", "ToggleFacing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.LocomotionComponent.GetFacing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFacingType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFacingType ULocomotionComponent::GetFacing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocomotionComponent", "GetFacing");

	Params::LocomotionComponent_GetFacing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.LocomotionComponent.GetUpdateFacing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULocomotionComponent::GetUpdateFacing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocomotionComponent", "GetUpdateFacing");

	Params::LocomotionComponent_GetUpdateFacing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.LocomotionComponent.GetUpVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector ULocomotionComponent::GetUpVector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocomotionComponent", "GetUpVector");

	Params::LocomotionComponent_GetUpVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.LocomotionComponent.GetWorldUpToUpRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FQuat ULocomotionComponent::GetWorldUpToUpRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocomotionComponent", "GetWorldUpToUpRotation");

	Params::LocomotionComponent_GetWorldUpToUpRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.MapIconProviderInterface.GetMapIconActorWithDependencies
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMapIconProviderData*            OutMapIconProviderData                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void IMapIconProviderInterface::GetMapIconActorWithDependencies(struct FMapIconProviderData* OutMapIconProviderData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MapIconProviderInterface", "GetMapIconActorWithDependencies");

	Params::MapIconProviderInterface_GetMapIconActorWithDependencies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapIconProviderData != nullptr)
		*OutMapIconProviderData = std::move(Parms.OutMapIconProviderData);
}


// Function Zion.MapIconProviderInterface.GetMapIconGameplayConditions
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayConditionChecker*       OutConditionChecker                                    (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IMapIconProviderInterface::GetMapIconGameplayConditions(struct FGameplayConditionChecker* OutConditionChecker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MapIconProviderInterface", "GetMapIconGameplayConditions");

	Params::MapIconProviderInterface_GetMapIconGameplayConditions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutConditionChecker != nullptr)
		*OutConditionChecker = std::move(Parms.OutConditionChecker);

	return Parms.ReturnValue;
}


// Function Zion.MathBPFLibrary.AngleBetweenAsDegree
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   VectorA                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   VectorB                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMathBPFLibrary::AngleBetweenAsDegree(const struct FVector& VectorA, const struct FVector& VectorB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MathBPFLibrary", "AngleBetweenAsDegree");

	Params::MathBPFLibrary_AngleBetweenAsDegree Parms{};

	Parms.VectorA = std::move(VectorA);
	Parms.VectorB = std::move(VectorB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.MathBPFLibrary.AngleBetweenAsRad
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   VectorA                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   VectorB                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMathBPFLibrary::AngleBetweenAsRad(const struct FVector& VectorA, const struct FVector& VectorB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MathBPFLibrary", "AngleBetweenAsRad");

	Params::MathBPFLibrary_AngleBetweenAsRad Parms{};

	Parms.VectorA = std::move(VectorA);
	Parms.VectorB = std::move(VectorB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.MathBPFLibrary.Evaluate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRuntimeFloatCurve&        Curve                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMathBPFLibrary::Evaluate(const struct FRuntimeFloatCurve& Curve, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MathBPFLibrary", "Evaluate");

	Params::MathBPFLibrary_Evaluate Parms{};

	Parms.Curve = std::move(Curve);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.MathBPFLibrary.GetMaxTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRuntimeFloatCurve&        Curve                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMathBPFLibrary::GetMaxTime(const struct FRuntimeFloatCurve& Curve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MathBPFLibrary", "GetMaxTime");

	Params::MathBPFLibrary_GetMaxTime Parms{};

	Parms.Curve = std::move(Curve);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.MathBPFLibrary.GetMinTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRuntimeFloatCurve&        Curve                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMathBPFLibrary::GetMinTime(const struct FRuntimeFloatCurve& Curve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MathBPFLibrary", "GetMinTime");

	Params::MathBPFLibrary_GetMinTime Parms{};

	Parms.Curve = std::move(Curve);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.MathBPFLibrary.LoopAround
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMathBPFLibrary::LoopAround(int32 Value, int32 Min, int32 Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MathBPFLibrary", "LoopAround");

	Params::MathBPFLibrary_LoopAround Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.MoveComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void UMoveComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.MoveComponent.SetVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoveComponent::SetVelocity(const struct FVector& NewVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveComponent", "SetVelocity");

	Params::MoveComponent_SetVelocity Parms{};

	Parms.NewVelocity = std::move(NewVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.OneWayPlatform.OnComponentOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOneWayPlatform::OnComponentOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OneWayPlatform", "OnComponentOverlapBegin");

	Params::OneWayPlatform_OnComponentOverlapBegin Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.OneWayPlatform.OnComponentOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOneWayPlatform::OnComponentOverlapEnd(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OneWayPlatform", "OnComponentOverlapEnd");

	Params::OneWayPlatform_OnComponentOverlapEnd Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.OneWayPlatform.IsFallThrough
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOneWayPlatform::IsFallThrough() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OneWayPlatform", "IsFallThrough");

	Params::OneWayPlatform_IsFallThrough Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.MovingPlatform_Elevator.CallToDestination
// (Final, Native, Public, BlueprintCallable)

void AMovingPlatform_Elevator::CallToDestination()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingPlatform_Elevator", "CallToDestination");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.MovingPlatform_Elevator.CallToOrigin
// (Final, Native, Public, BlueprintCallable)

void AMovingPlatform_Elevator::CallToOrigin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingPlatform_Elevator", "CallToOrigin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.MovingPlatform_Elevator.OnFinishMovement
// (Final, Native, Private)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasMoving                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMovingPlatform_Elevator::OnFinishMovement(bool bInstant, bool bWasMoving)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingPlatform_Elevator", "OnFinishMovement");

	Params::MovingPlatform_Elevator_OnFinishMovement Parms{};

	Parms.bInstant = bInstant;
	Parms.bWasMoving = bWasMoving;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.MovingPlatform_Elevator.OnPlayerDetectorOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMovingPlatform_Elevator::OnPlayerDetectorOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingPlatform_Elevator", "OnPlayerDetectorOverlapBegin");

	Params::MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.MovingPlatform_Elevator.OnPlayerDetectorOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMovingPlatform_Elevator::OnPlayerDetectorOverlapEnd(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingPlatform_Elevator", "OnPlayerDetectorOverlapEnd");

	Params::MovingPlatform_Elevator_OnPlayerDetectorOverlapEnd Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.MovingPlatform_Elevator.OnStartMovement
// (Final, Native, Private)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasMoving                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMovingPlatform_Elevator::OnStartMovement(bool bInstant, bool bWasMoving)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingPlatform_Elevator", "OnStartMovement");

	Params::MovingPlatform_Elevator_OnStartMovement Parms{};

	Parms.bInstant = bInstant;
	Parms.bWasMoving = bWasMoving;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.MovingPlatform_Elevator.TriggerElevator
// (Final, Native, Public, BlueprintCallable)

void AMovingPlatform_Elevator::TriggerElevator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingPlatform_Elevator", "TriggerElevator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.MovingPlatform_Elevator.GetPlayerDetectionRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMovingPlatform_Elevator::GetPlayerDetectionRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingPlatform_Elevator", "GetPlayerDetectionRange");

	Params::MovingPlatform_Elevator_GetPlayerDetectionRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.MovingPlatform_Elevator.IsMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMovingPlatform_Elevator::IsMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingPlatform_Elevator", "IsMoving");

	Params::MovingPlatform_Elevator_IsMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.NotificationComponent.OnItemAdded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const class UInventory*                 Inventory                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddedCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNotificationComponent::OnItemAdded(const class UInventory* Inventory, const class FName& ItemId, int32 AddedCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationComponent", "OnItemAdded");

	Params::NotificationComponent_OnItemAdded Parms{};

	Parms.Inventory = Inventory;
	Parms.ItemId = ItemId;
	Parms.AddedCount = AddedCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.NotificationComponent.OnNotificationDelayFinished
// (Final, Native, Protected)

void UNotificationComponent::OnNotificationDelayFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationComponent", "OnNotificationDelayFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.NotificationComponent.OnNotificationDurationFinished
// (Final, Native, Protected)

void UNotificationComponent::OnNotificationDurationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationComponent", "OnNotificationDurationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.NotificationComponent.OnPawnDeath
// (Final, Native, Private)

void UNotificationComponent::OnPawnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationComponent", "OnPawnDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.NotificationComponent.CanStartNotification
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNotificationComponent::CanStartNotification() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationComponent", "CanStartNotification");

	Params::NotificationComponent_CanStartNotification Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PhysicsReactionComponent.OnGotAbilityApplied
// (Final, Native, Private, HasOutParams)
// Parameters:
// class AAbility*                         Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitData&                  HitData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPhysicsReactionComponent::OnGotAbilityApplied(class AAbility* Ability, class AActor* Source, const struct FHitData& HitData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhysicsReactionComponent", "OnGotAbilityApplied");

	Params::PhysicsReactionComponent_OnGotAbilityApplied Parms{};

	Parms.Ability = Ability;
	Parms.Source = Source;
	Parms.HitData = std::move(HitData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PhysicsReactionComponent.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsReactionComponent::SetEnabled(bool bNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhysicsReactionComponent", "SetEnabled");

	Params::PhysicsReactionComponent_SetEnabled Parms{};

	Parms.bNewEnabled = bNewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PhysicsReactionComponent.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhysicsReactionComponent::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhysicsReactionComponent", "IsEnabled");

	Params::PhysicsReactionComponent_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerCameraManagerZion.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerControllerIndex                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerCameraManagerZion*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerCameraManagerZion* APlayerCameraManagerZion::Get(const class UObject* WorldContextObject, int32 PlayerControllerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerCameraManagerZion", "Get");

	Params::PlayerCameraManagerZion_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerControllerIndex = PlayerControllerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerCameraManagerZion.ResetCameraLocation
// (Final, Native, Public, BlueprintCallable)

void APlayerCameraManagerZion::ResetCameraLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCameraManagerZion", "ResetCameraLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerCameraManagerZion.SetViewTargetToGameplayCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FViewTargetTransitionParams&ViewTargetTransitionParams                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bInterruptOnGoingBlend                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManagerZion::SetViewTargetToGameplayCamera(const struct FViewTargetTransitionParams& ViewTargetTransitionParams, bool bInterruptOnGoingBlend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCameraManagerZion", "SetViewTargetToGameplayCamera");

	Params::PlayerCameraManagerZion_SetViewTargetToGameplayCamera Parms{};

	Parms.ViewTargetTransitionParams = std::move(ViewTargetTransitionParams);
	Parms.bInterruptOnGoingBlend = bInterruptOnGoingBlend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerCameraManagerZion.GetActiveCameraClampBox
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox APlayerCameraManagerZion::GetActiveCameraClampBox() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCameraManagerZion", "GetActiveCameraClampBox");

	Params::PlayerCameraManagerZion_GetActiveCameraClampBox Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerCameraManagerZion.GetGameplayCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AGameplayCamera*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameplayCamera* APlayerCameraManagerZion::GetGameplayCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCameraManagerZion", "GetGameplayCamera");

	Params::PlayerCameraManagerZion_GetGameplayCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerCostumeComponent.ApplyPendingCostume
// (Final, Native, Public, BlueprintCallable)

void UPlayerCostumeComponent::ApplyPendingCostume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCostumeComponent", "ApplyPendingCostume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerCostumeComponent.EquipCostume
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InCostumeID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerCostumeComponent::EquipCostume(const class FName& InCostumeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCostumeComponent", "EquipCostume");

	Params::PlayerCostumeComponent_EquipCostume Parms{};

	Parms.InCostumeID = InCostumeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerCostumeComponent.SetPendingCostumeID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InCostumeID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerCostumeComponent::SetPendingCostumeID(const class FName& InCostumeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCostumeComponent", "SetPendingCostumeID");

	Params::PlayerCostumeComponent_SetPendingCostumeID Parms{};

	Parms.InCostumeID = InCostumeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.PlayerCostumeComponent.GetEquippedCostumeID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UPlayerCostumeComponent::GetEquippedCostumeID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCostumeComponent", "GetEquippedCostumeID");

	Params::PlayerCostumeComponent_GetEquippedCostumeID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayerCostumeComponent.GetPendingOrEquippedCostumeID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UPlayerCostumeComponent::GetPendingOrEquippedCostumeID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCostumeComponent", "GetPendingOrEquippedCostumeID");

	Params::PlayerCostumeComponent_GetPendingOrEquippedCostumeID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PlayUMGAnimationAsyncAction.PlayUMGAnimation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetAnimation*                 InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockNavigation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayUMGAnimationAsyncAction*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayUMGAnimationAsyncAction* UPlayUMGAnimationAsyncAction::PlayUMGAnimation(class UUserWidget* Widget, class UWidgetAnimation* InAnimation, bool bLockNavigation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayUMGAnimationAsyncAction", "PlayUMGAnimation");

	Params::PlayUMGAnimationAsyncAction_PlayUMGAnimation Parms{};

	Parms.Widget = Widget;
	Parms.InAnimation = InAnimation;
	Parms.bLockNavigation = bLockNavigation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.PoolSystemComponent.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPoolSystemComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPoolSystemComponent* UPoolSystemComponent::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PoolSystemComponent", "Get");

	Params::PoolSystemComponent_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ProfileSubsystem.GetCurrentProfileName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UProfileSubsystem::GetCurrentProfileName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProfileSubsystem", "GetCurrentProfileName");

	Params::ProfileSubsystem_GetCurrentProfileName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ProfileSubsystem.IsUsingProfileSystem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UProfileSubsystem::IsUsingProfileSystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProfileSubsystem", "IsUsingProfileSystem");

	Params::ProfileSubsystem_IsUsingProfileSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RefreshableRichTextBlock.Refresh
// (Final, Native, Public, BlueprintCallable)

void URefreshableRichTextBlock::Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RefreshableRichTextBlock", "Refresh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RefreshableRichTextBlock.SetDecoratorMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERichTextDecoratorMode                  NewDecoratorMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URefreshableRichTextBlock::SetDecoratorMode(ERichTextDecoratorMode NewDecoratorMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RefreshableRichTextBlock", "SetDecoratorMode");

	Params::RefreshableRichTextBlock_SetDecoratorMode Parms{};

	Parms.NewDecoratorMode = NewDecoratorMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RefreshableRichTextBlock.SetFormat
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FText&                      NewFormat                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URefreshableRichTextBlock::SetFormat(const class FText& NewFormat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RefreshableRichTextBlock", "SetFormat");

	Params::RefreshableRichTextBlock_SetFormat Parms{};

	Parms.NewFormat = std::move(NewFormat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RefreshableRichTextBlock.SetFormatElements
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FRichTextInputElement>&NewFormatElements                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class FString>&            NewStringElements                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URefreshableRichTextBlock::SetFormatElements(const TArray<struct FRichTextInputElement>& NewFormatElements, const TArray<class FString>& NewStringElements)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RefreshableRichTextBlock", "SetFormatElements");

	Params::RefreshableRichTextBlock_SetFormatElements Parms{};

	Parms.NewFormatElements = std::move(NewFormatElements);
	Parms.NewStringElements = std::move(NewStringElements);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RefreshableRichTextBlock.SetupAndRefresh
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FText&                      NewFormat                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FRichTextInputElement>&NewFormatElements                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class FString>&            NewStringElements                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URefreshableRichTextBlock::SetupAndRefresh(const class FText& NewFormat, const TArray<struct FRichTextInputElement>& NewFormatElements, const TArray<class FString>& NewStringElements)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RefreshableRichTextBlock", "SetupAndRefresh");

	Params::RefreshableRichTextBlock_SetupAndRefresh Parms{};

	Parms.NewFormat = std::move(NewFormat);
	Parms.NewFormatElements = std::move(NewFormatElements);
	Parms.NewStringElements = std::move(NewStringElements);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RefreshableRichTextBlock.GetDecoratorMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERichTextDecoratorMode                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERichTextDecoratorMode URefreshableRichTextBlock::GetDecoratorMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RefreshableRichTextBlock", "GetDecoratorMode");

	Params::RefreshableRichTextBlock_GetDecoratorMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RefreshableRichTextBlock.GetFormatElements
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FRichTextInputElement>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FRichTextInputElement> URefreshableRichTextBlock::GetFormatElements() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RefreshableRichTextBlock", "GetFormatElements");

	Params::RefreshableRichTextBlock_GetFormatElements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RenderStateManagerComponent.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URenderStateManagerComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URenderStateManagerComponent* URenderStateManagerComponent::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RenderStateManagerComponent", "Get");

	Params::RenderStateManagerComponent_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.RenderStateManagerComponent.OnGameMapChangeFinished
// (Final, Native, Private)

void URenderStateManagerComponent::OnGameMapChangeFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RenderStateManagerComponent", "OnGameMapChangeFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RenderStateManagerComponent.OnGameMapChangeStarted
// (Final, Native, Private)

void URenderStateManagerComponent::OnGameMapChangeStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RenderStateManagerComponent", "OnGameMapChangeStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RepulsionEnemyComponent.OnComponentOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URepulsionEnemyComponent::OnComponentOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RepulsionEnemyComponent", "OnComponentOverlapBegin");

	Params::RepulsionEnemyComponent_OnComponentOverlapBegin Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RepulsionEnemyComponent.OnComponentOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URepulsionEnemyComponent::OnComponentOverlapEnd(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RepulsionEnemyComponent", "OnComponentOverlapEnd");

	Params::RepulsionEnemyComponent_OnComponentOverlapEnd Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RepulsionPlayerComponent.AddRepulsionEnemyComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URepulsionEnemyComponent*         RepulsionEnemyComponent                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              Collider                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URepulsionPlayerComponent::AddRepulsionEnemyComponent(class URepulsionEnemyComponent* RepulsionEnemyComponent, class UPrimitiveComponent* Collider)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RepulsionPlayerComponent", "AddRepulsionEnemyComponent");

	Params::RepulsionPlayerComponent_AddRepulsionEnemyComponent Parms{};

	Parms.RepulsionEnemyComponent = RepulsionEnemyComponent;
	Parms.Collider = Collider;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RepulsionPlayerComponent.RemoveRepulsionEnemyComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URepulsionEnemyComponent*         RepulsionEnemyComponent                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              Collider                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URepulsionPlayerComponent::RemoveRepulsionEnemyComponent(class URepulsionEnemyComponent* RepulsionEnemyComponent, class UPrimitiveComponent* Collider)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RepulsionPlayerComponent", "RemoveRepulsionEnemyComponent");

	Params::RepulsionPlayerComponent_RemoveRepulsionEnemyComponent Parms{};

	Parms.RepulsionEnemyComponent = RepulsionEnemyComponent;
	Parms.Collider = Collider;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.RichPresenceSubsystem.RefreshPresence
// (Final, Native, Public, BlueprintCallable)

void URichPresenceSubsystem::RefreshPresence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RichPresenceSubsystem", "RefreshPresence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SaveSubsystem.CheckCurrentSlotExistence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESaveExistsType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESaveExistsType USaveSubsystem::CheckCurrentSlotExistence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "CheckCurrentSlotExistence");

	Params::SaveSubsystem_CheckCurrentSlotExistence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SaveSubsystem.CheckSlotExistence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESaveExistsType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESaveExistsType USaveSubsystem::CheckSlotExistence(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "CheckSlotExistence");

	Params::SaveSubsystem_CheckSlotExistence Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SaveSubsystem.CopyGameDataToEmptySlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SlotToCopy                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  out_TargetSlot                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESaveCopyResult                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESaveCopyResult USaveSubsystem::CopyGameDataToEmptySlot(int32 SlotToCopy, int32* out_TargetSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "CopyGameDataToEmptySlot");

	Params::SaveSubsystem_CopyGameDataToEmptySlot Parms{};

	Parms.SlotToCopy = SlotToCopy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_TargetSlot != nullptr)
		*out_TargetSlot = Parms.out_TargetSlot;

	return Parms.ReturnValue;
}


// Function Zion.SaveSubsystem.DeleteSaveDataAtSlotIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveSubsystem::DeleteSaveDataAtSlotIndex(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "DeleteSaveDataAtSlotIndex");

	Params::SaveSubsystem_DeleteSaveDataAtSlotIndex Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SaveSubsystem.DeleteSettings
// (Final, Native, Public, BlueprintCallable)

void USaveSubsystem::DeleteSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "DeleteSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SaveSubsystem.LoadGameFromCurrentSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USaveGameZion**                   out_GameData                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESaveExistsType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESaveExistsType USaveSubsystem::LoadGameFromCurrentSlot(class USaveGameZion** out_GameData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "LoadGameFromCurrentSlot");

	Params::SaveSubsystem_LoadGameFromCurrentSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_GameData != nullptr)
		*out_GameData = Parms.out_GameData;

	return Parms.ReturnValue;
}


// Function Zion.SaveSubsystem.LoadGameFromCurrentSlotAsync
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(ESaveExistsType Result, class USaveGameZion* LoadedData)>OnLoadFinished                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveSubsystem::LoadGameFromCurrentSlotAsync(TDelegate<void(ESaveExistsType Result, class USaveGameZion* LoadedData)> OnLoadFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "LoadGameFromCurrentSlotAsync");

	Params::SaveSubsystem_LoadGameFromCurrentSlotAsync Parms{};

	Parms.OnLoadFinished = OnLoadFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SaveSubsystem.LoadGameFromSlotAsync
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(ESaveExistsType Result, class USaveGameZion* LoadedData)>OnLoadFinished                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveSubsystem::LoadGameFromSlotAsync(int32 SlotIndex, TDelegate<void(ESaveExistsType Result, class USaveGameZion* LoadedData)> OnLoadFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "LoadGameFromSlotAsync");

	Params::SaveSubsystem_LoadGameFromSlotAsync Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.OnLoadFinished = OnLoadFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SaveSubsystem.LoadSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForceReload                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESaveExistsType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESaveExistsType USaveSubsystem::LoadSettings(bool bForceReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "LoadSettings");

	Params::SaveSubsystem_LoadSettings Parms{};

	Parms.bForceReload = bForceReload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SaveSubsystem.ResetTimeSinceLastGameSave
// (Final, Native, Public, BlueprintCallable)

void USaveSubsystem::ResetTimeSinceLastGameSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "ResetTimeSinceLastGameSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SaveSubsystem.SaveGameInCurrentSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveSubsystem::SaveGameInCurrentSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "SaveGameInCurrentSlot");

	Params::SaveSubsystem_SaveGameInCurrentSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SaveSubsystem.SaveGameInCurrentSlotAsync
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool Result)>            OnSaveFinished                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveSubsystem::SaveGameInCurrentSlotAsync(TDelegate<void(bool Result)> OnSaveFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "SaveGameInCurrentSlotAsync");

	Params::SaveSubsystem_SaveGameInCurrentSlotAsync Parms{};

	Parms.OnSaveFinished = OnSaveFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SaveSubsystem.SaveSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveSubsystem::SaveSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "SaveSettings");

	Params::SaveSubsystem_SaveSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SaveSubsystem.SetCurrentSlotIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewSlotIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveSubsystem::SetCurrentSlotIndex(int32 NewSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "SetCurrentSlotIndex");

	Params::SaveSubsystem_SetCurrentSlotIndex Parms{};

	Parms.NewSlotIndex = NewSlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SaveSubsystem.GetTimeSinceLastGameSave
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USaveSubsystem::GetTimeSinceLastGameSave() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "GetTimeSinceLastGameSave");

	Params::SaveSubsystem_GetTimeSinceLastGameSave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SaveSubsystem.IsLoadingGameData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveSubsystem::IsLoadingGameData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSubsystem", "IsLoadingGameData");

	Params::SaveSubsystem_IsLoadingGameData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ScrollBoxZion.CopyWidgetNavigation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetNavigation*                WidgetNavigation                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBoxZion::CopyWidgetNavigation(class UWidgetNavigation* WidgetNavigation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScrollBoxZion", "CopyWidgetNavigation");

	Params::ScrollBoxZion_CopyWidgetNavigation Parms{};

	Parms.WidgetNavigation = WidgetNavigation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ScrollBoxZion.ScrollWidgetHostIntoView
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNativeWidgetHost*                NativeWidgetHost                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAnimateScroll                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDescendantScrollDestination            InDestination                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InScrollPadding                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBoxZion::ScrollWidgetHostIntoView(class UNativeWidgetHost* NativeWidgetHost, bool InAnimateScroll, EDescendantScrollDestination InDestination, float InScrollPadding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScrollBoxZion", "ScrollWidgetHostIntoView");

	Params::ScrollBoxZion_ScrollWidgetHostIntoView Parms{};

	Parms.NativeWidgetHost = NativeWidgetHost;
	Parms.InAnimateScroll = InAnimateScroll;
	Parms.InDestination = InDestination;
	Parms.InScrollPadding = InScrollPadding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ScrollBoxZion.SetElementCountPerLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewElementCountsPerLine                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBoxZion::SetElementCountPerLine(int32 NewElementCountsPerLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScrollBoxZion", "SetElementCountPerLine");

	Params::ScrollBoxZion_SetElementCountPerLine Parms{};

	Parms.NewElementCountsPerLine = NewElementCountsPerLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ScrollBoxZion.SetNavigationOrientation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrientation                            NewNavigationOrientation                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBoxZion::SetNavigationOrientation(EOrientation NewNavigationOrientation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScrollBoxZion", "SetNavigationOrientation");

	Params::ScrollBoxZion_SetNavigationOrientation Parms{};

	Parms.NewNavigationOrientation = NewNavigationOrientation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ScrollBoxZion.SimulateNavigation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUINavigation                           InNavigation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBoxZion::SimulateNavigation(EUINavigation InNavigation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScrollBoxZion", "SimulateNavigation");

	Params::ScrollBoxZion_SimulateNavigation Parms{};

	Parms.InNavigation = InNavigation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ZionInputComponent.AddInputMappingContext
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UInputMappingContext*       InputMappingContext                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputMappingPriority                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UZionInputComponent::AddInputMappingContext(const class UInputMappingContext* InputMappingContext, EInputMappingPriority Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionInputComponent", "AddInputMappingContext");

	Params::ZionInputComponent_AddInputMappingContext Parms{};

	Parms.InputMappingContext = InputMappingContext;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ZionInputComponent.RemoveInputMappingContext
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UInputMappingContext*       InputMappingContext                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UZionInputComponent::RemoveInputMappingContext(const class UInputMappingContext* InputMappingContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZionInputComponent", "RemoveInputMappingContext");

	Params::ZionInputComponent_RemoveInputMappingContext Parms{};

	Parms.InputMappingContext = InputMappingContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ShakeComponent.LaunchShake
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FShakeData&                ShakeData                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UShakeComponent::LaunchShake(const struct FShakeData& ShakeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShakeComponent", "LaunchShake");

	Params::ShakeComponent_LaunchShake Parms{};

	Parms.ShakeData = std::move(ShakeData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ShopInfoComponent.AddShopHistory
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EShopType                               ShopType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       BoughtItem                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UShopInfoComponent::AddShopHistory(EShopType ShopType, const struct FDataTableRowHandle& BoughtItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInfoComponent", "AddShopHistory");

	Params::ShopInfoComponent_AddShopHistory Parms{};

	Parms.ShopType = ShopType;
	Parms.BoughtItem = std::move(BoughtItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ShopInfoComponent.GetItemsForShop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EShopType                               ShopType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDataTable*                 ShopDataTable                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FShopItemData>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FShopItemData> UShopInfoComponent::GetItemsForShop(EShopType ShopType, const class UDataTable* ShopDataTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInfoComponent", "GetItemsForShop");

	Params::ShopInfoComponent_GetItemsForShop Parms{};

	Parms.ShopType = ShopType;
	Parms.ShopDataTable = ShopDataTable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ShopInfoComponent.MarkSeen
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EShopType                               ShopType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FShopItemData&                   ShopItemData                                           (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UShopInfoComponent::MarkSeen(EShopType ShopType, struct FShopItemData& ShopItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInfoComponent", "MarkSeen");

	Params::ShopInfoComponent_MarkSeen Parms{};

	Parms.ShopType = ShopType;
	Parms.ShopItemData = std::move(ShopItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ShopItemData = std::move(Parms.ShopItemData);
}


// Function Zion.ShopInfoComponent.SetLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShopInfoComponent::SetLevel(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInfoComponent", "SetLevel");

	Params::ShopInfoComponent_SetLevel Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ShopInfoComponent.GetItemCost
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EShopType                               ShopType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCurrencyValue                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCurrencyValue UShopInfoComponent::GetItemCost(EShopType ShopType, const struct FDataTableRowHandle& Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInfoComponent", "GetItemCost");

	Params::ShopInfoComponent_GetItemCost Parms{};

	Parms.ShopType = ShopType;
	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ShopInfoComponent.GetLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShopInfoComponent::GetLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInfoComponent", "GetLevel");

	Params::ShopInfoComponent_GetLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ShopInfoComponent.GetMaxLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShopInfoComponent::GetMaxLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInfoComponent", "GetMaxLevel");

	Params::ShopInfoComponent_GetMaxLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ShopInfoComponent.GetMinLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShopInfoComponent::GetMinLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInfoComponent", "GetMinLevel");

	Params::ShopInfoComponent_GetMinLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SkillComponent.Equip
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ESkillSlot                              SkillSlot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      SkillID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToCurrentLoadout                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillComponent::Equip(ESkillSlot SkillSlot, const class FName& SkillID, bool bAddToCurrentLoadout, bool bAutoLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "Equip");

	Params::SkillComponent_Equip Parms{};

	Parms.SkillSlot = SkillSlot;
	Parms.SkillID = SkillID;
	Parms.bAddToCurrentLoadout = bAddToCurrentLoadout;
	Parms.bAutoLoad = bAutoLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SkillComponent.EquipSkillLoadout
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LoadoutIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillComponent::EquipSkillLoadout(int32 LoadoutIndex, bool bAutoLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "EquipSkillLoadout");

	Params::SkillComponent_EquipSkillLoadout Parms{};

	Parms.LoadoutIndex = LoadoutIndex;
	Parms.bAutoLoad = bAutoLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SkillComponent.LoadEquippedSkills
// (Final, Native, Public, BlueprintCallable)

void USkillComponent::LoadEquippedSkills()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "LoadEquippedSkills");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SkillComponent.UnEquip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESkillSlot                              SkillSlot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveFromCurrentLoadout                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillComponent::UnEquip(ESkillSlot SkillSlot, bool bRemoveFromCurrentLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "UnEquip");

	Params::SkillComponent_UnEquip Parms{};

	Parms.SkillSlot = SkillSlot;
	Parms.bRemoveFromCurrentLoadout = bRemoveFromCurrentLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SkillComponent.UnEquipAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bRemoveFromCurrentLoadout                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillComponent::UnEquipAll(bool bRemoveFromCurrentLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "UnEquipAll");

	Params::SkillComponent_UnEquipAll Parms{};

	Parms.bRemoveFromCurrentLoadout = bRemoveFromCurrentLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SkillComponent.GetCurrentSkillLoadoutIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkillComponent::GetCurrentSkillLoadoutIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "GetCurrentSkillLoadoutIndex");

	Params::SkillComponent_GetCurrentSkillLoadoutIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SkillComponent.GetEquippedCommandSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESkillSlot                              SkillSlot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCommandSet*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommandSet* USkillComponent::GetEquippedCommandSet(ESkillSlot SkillSlot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "GetEquippedCommandSet");

	Params::SkillComponent_GetEquippedCommandSet Parms{};

	Parms.SkillSlot = SkillSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SkillComponent.GetEquippedItemSkillData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESkillSlot                              SkillSlot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryItemSkillData    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FInventoryItemSkillData USkillComponent::GetEquippedItemSkillData(ESkillSlot SkillSlot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "GetEquippedItemSkillData");

	Params::SkillComponent_GetEquippedItemSkillData Parms{};

	Parms.SkillSlot = SkillSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SkillComponent.GetEquippedSkillID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESkillSlot                              SkillSlot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USkillComponent::GetEquippedSkillID(ESkillSlot SkillSlot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "GetEquippedSkillID");

	Params::SkillComponent_GetEquippedSkillID Parms{};

	Parms.SkillSlot = SkillSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SkillComponent.GetEquippedSkillInputActionFromSpirit
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FInventoryItemSpiritData&  SpiritData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UInputAction*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UInputAction* USkillComponent::GetEquippedSkillInputActionFromSpirit(const struct FInventoryItemSpiritData& SpiritData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "GetEquippedSkillInputActionFromSpirit");

	Params::SkillComponent_GetEquippedSkillInputActionFromSpirit Parms{};

	Parms.SpiritData = std::move(SpiritData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SkillComponent.GetEquippedSkillLevelData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESkillSlot                              SkillSlot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSkillLevelData            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FSkillLevelData USkillComponent::GetEquippedSkillLevelData(ESkillSlot SkillSlot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "GetEquippedSkillLevelData");

	Params::SkillComponent_GetEquippedSkillLevelData Parms{};

	Parms.SkillSlot = SkillSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SkillComponent.GetEquippedSkillSlotFromID
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      SkillID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillSlot                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESkillSlot USkillComponent::GetEquippedSkillSlotFromID(const class FName& SkillID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "GetEquippedSkillSlotFromID");

	Params::SkillComponent_GetEquippedSkillSlotFromID Parms{};

	Parms.SkillID = SkillID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SkillComponent.GetMinimumEquippedSPCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkillComponent::GetMinimumEquippedSPCost() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "GetMinimumEquippedSPCost");

	Params::SkillComponent_GetMinimumEquippedSPCost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SkillComponent.HasAnyEquippedSkill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkillComponent::HasAnyEquippedSkill() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "HasAnyEquippedSkill");

	Params::SkillComponent_HasAnyEquippedSkill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SkillComponent.HasEquippedSkill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESkillSlot                              SkillSlot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkillComponent::HasEquippedSkill(ESkillSlot SkillSlot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "HasEquippedSkill");

	Params::SkillComponent_HasEquippedSkill Parms{};

	Parms.SkillSlot = SkillSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SoundComponent.OnMovementModeChanged
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundComponent::OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundComponent", "OnMovementModeChanged");

	Params::SoundComponent_OnMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.DisableAllSnapshots
// (Final, Native, Public, BlueprintCallable)

void USoundSubsystem::DisableAllSnapshots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "DisableAllSnapshots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.DisableSnapshot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubsystem::DisableSnapshot(class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "DisableSnapshot");

	Params::SoundSubsystem_DisableSnapshot Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.EnableSnapshot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFMODEvent*                       Snapshot                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubsystem::EnableSnapshot(class UFMODEvent* Snapshot, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "EnableSnapshot");

	Params::SoundSubsystem_EnableSnapshot Parms{};

	Parms.Snapshot = Snapshot;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.PauseBGM
// (Final, Native, Public, BlueprintCallable)

void USoundSubsystem::PauseBGM()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "PauseBGM");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.PauseFamily
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESoundFamily                            SoundFamily                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubsystem::PauseFamily(ESoundFamily SoundFamily)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "PauseFamily");

	Params::SoundSubsystem_PauseFamily Parms{};

	Parms.SoundFamily = SoundFamily;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.PlayAmbience
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFMODEvent*                       SoundEvent                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubsystem::PlayAmbience(class UFMODEvent* SoundEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "PlayAmbience");

	Params::SoundSubsystem_PlayAmbience Parms{};

	Parms.SoundEvent = SoundEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.PlayBGM
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFMODEvent*                       SoundEvent                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubsystem::PlayBGM(class UFMODEvent* SoundEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "PlayBGM");

	Params::SoundSubsystem_PlayBGM Parms{};

	Parms.SoundEvent = SoundEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.PlaySoundEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFMODEvent*                       SoundEvent                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFMODEventInstance               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FFMODEventInstance USoundSubsystem::PlaySoundEvent(class UFMODEvent* SoundEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "PlaySoundEvent");

	Params::SoundSubsystem_PlaySoundEvent Parms{};

	Parms.SoundEvent = SoundEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SoundSubsystem.PlaySoundEventAttached
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFMODEvent*                       SoundEvent                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFMODAudioComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFMODAudioComponent* USoundSubsystem::PlaySoundEventAttached(class UFMODEvent* SoundEvent, class USceneComponent* AttachToComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "PlaySoundEventAttached");

	Params::SoundSubsystem_PlaySoundEventAttached Parms{};

	Parms.SoundEvent = SoundEvent;
	Parms.AttachToComponent = AttachToComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SoundSubsystem.PlaySoundEventAtWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UFMODEvent*                       SoundEvent                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFMODEventInstance               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FFMODEventInstance USoundSubsystem::PlaySoundEventAtWorldLocation(class UFMODEvent* SoundEvent, const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "PlaySoundEventAtWorldLocation");

	Params::SoundSubsystem_PlaySoundEventAtWorldLocation Parms{};

	Parms.SoundEvent = SoundEvent;
	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SoundSubsystem.PlayVoice
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    VoiceID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFMODAudioComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFMODAudioComponent* USoundSubsystem::PlayVoice(const class FString& VoiceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "PlayVoice");

	Params::SoundSubsystem_PlayVoice Parms{};

	Parms.VoiceID = std::move(VoiceID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SoundSubsystem.PlayVoiceFromText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FText&                      Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Speaker                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFMODAudioComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFMODAudioComponent* USoundSubsystem::PlayVoiceFromText(const class FText& Text, class AActor* Speaker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "PlayVoiceFromText");

	Params::SoundSubsystem_PlayVoiceFromText Parms{};

	Parms.Text = std::move(Text);
	Parms.Speaker = Speaker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SoundSubsystem.PlayVoiceOnActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    VoiceID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFMODAudioComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFMODAudioComponent* USoundSubsystem::PlayVoiceOnActor(class AActor* Actor, const class FString& VoiceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "PlayVoiceOnActor");

	Params::SoundSubsystem_PlayVoiceOnActor Parms{};

	Parms.Actor = Actor;
	Parms.VoiceID = std::move(VoiceID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SoundSubsystem.RefreshAudioVolumes
// (Final, Native, Public, BlueprintCallable)

void USoundSubsystem::RefreshAudioVolumes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "RefreshAudioVolumes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.ResetVolumes
// (Final, Native, Public, BlueprintCallable)

void USoundSubsystem::ResetVolumes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "ResetVolumes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.ResumeBGM
// (Final, Native, Public, BlueprintCallable)

void USoundSubsystem::ResumeBGM()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "ResumeBGM");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.ResumeFamily
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESoundFamily                            SoundFamily                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubsystem::ResumeFamily(ESoundFamily SoundFamily)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "ResumeFamily");

	Params::SoundSubsystem_ResumeFamily Parms{};

	Parms.SoundFamily = SoundFamily;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.SetParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubsystem::SetParameter(class FName Parameter, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "SetParameter");

	Params::SoundSubsystem_SetParameter Parms{};

	Parms.Parameter = Parameter;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.SetPauseGameFamilies
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPause                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubsystem::SetPauseGameFamilies(bool bPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "SetPauseGameFamilies");

	Params::SoundSubsystem_SetPauseGameFamilies Parms{};

	Parms.bPause = bPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.SetVoiceLanguage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Locale                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubsystem::SetVoiceLanguage(const class FString& Locale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "SetVoiceLanguage");

	Params::SoundSubsystem_SetVoiceLanguage Parms{};

	Parms.Locale = std::move(Locale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.SetVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESoundFamily                            SoundFamily                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewVolume                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubsystem::SetVolume(ESoundFamily SoundFamily, float NewVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "SetVolume");

	Params::SoundSubsystem_SetVolume Parms{};

	Parms.SoundFamily = SoundFamily;
	Parms.NewVolume = NewVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.StopAll
// (Final, Native, Public, BlueprintCallable)

void USoundSubsystem::StopAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "StopAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.StopAmbience
// (Final, Native, Public, BlueprintCallable)

void USoundSubsystem::StopAmbience()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "StopAmbience");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.StopBGM
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FadeOutTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubsystem::StopBGM(float FadeOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "StopBGM");

	Params::SoundSubsystem_StopBGM Parms{};

	Parms.FadeOutTime = FadeOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.StopSoundEventInstance
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FFMODEventInstance&        SoundInstance                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USoundSubsystem::StopSoundEventInstance(const struct FFMODEventInstance& SoundInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "StopSoundEventInstance");

	Params::SoundSubsystem_StopSoundEventInstance Parms{};

	Parms.SoundInstance = std::move(SoundInstance);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SoundSubsystem.GetCurrentAmbience
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFMODEvent*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFMODEvent* USoundSubsystem::GetCurrentAmbience() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "GetCurrentAmbience");

	Params::SoundSubsystem_GetCurrentAmbience Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SoundSubsystem.GetCurrentBGM
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFMODEvent*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFMODEvent* USoundSubsystem::GetCurrentBGM() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "GetCurrentBGM");

	Params::SoundSubsystem_GetCurrentBGM Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SoundSubsystem.GetVoiceLanguage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USoundSubsystem::GetVoiceLanguage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "GetVoiceLanguage");

	Params::SoundSubsystem_GetVoiceLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SoundSubsystem.GetVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESoundFamily                            SoundFamily                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USoundSubsystem::GetVolume(ESoundFamily SoundFamily) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundSubsystem", "GetVolume");

	Params::SoundSubsystem_GetVolume Parms{};

	Parms.SoundFamily = SoundFamily;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SpawnerComponent.KillAllSpawnedEntities
// (Final, Native, Public, BlueprintCallable)

void USpawnerComponent::KillAllSpawnedEntities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerComponent", "KillAllSpawnedEntities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpawnerComponent.OnDeathProcessStart
// (Final, Native, Private)

void USpawnerComponent::OnDeathProcessStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerComponent", "OnDeathProcessStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpawnerComponent.OnEntityDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           EntityActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpawnerComponent::OnEntityDestroyed(class AActor* EntityActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerComponent", "OnEntityDestroyed");

	Params::SpawnerComponent_OnEntityDestroyed Parms{};

	Parms.EntityActor = EntityActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpawnerComponent.Spawn
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSpawnData&                SpawnData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USpawnerComponent::Spawn(const struct FSpawnData& SpawnData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerComponent", "Spawn");

	Params::SpawnerComponent_Spawn Parms{};

	Parms.SpawnData = std::move(SpawnData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpawnerComponent.GetSpawnedEntityCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USpawnerComponent::GetSpawnedEntityCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerComponent", "GetSpawnedEntityCount");

	Params::SpawnerComponent_GetSpawnedEntityCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SpineActor.Activate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FSpineSimpleAnimationDefinition>&AnimationDefinitions                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASpineActor::Activate(const TArray<struct FSpineSimpleAnimationDefinition>& AnimationDefinitions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineActor", "Activate");

	Params::SpineActor_Activate Parms{};

	Parms.AnimationDefinitions = std::move(AnimationDefinitions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineActor.Deactivate
// (Final, Native, Public, BlueprintCallable)

void ASpineActor::Deactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineActor", "Deactivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineActor.OnActivate
// (Native, Event, Protected, BlueprintEvent)

void ASpineActor::OnActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineActor", "OnActivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAdditiveAccessoryComponent.OnAnimationStart
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      Entry                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineAdditiveAccessoryComponent::OnAnimationStart(class UTrackEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAdditiveAccessoryComponent", "OnAnimationStart");

	Params::SpineAdditiveAccessoryComponent_OnAnimationStart Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAdditiveComponent.OnAnimationStart
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      TrackEntry                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineAdditiveComponent::OnAnimationStart(class UTrackEntry* TrackEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAdditiveComponent", "OnAnimationStart");

	Params::SpineAdditiveComponent_OnAnimationStart Parms{};

	Parms.TrackEntry = TrackEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimationTransitionCondition.Evaluate
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class USpineAnimatorComponent*    Animator                                               (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    CurrAnimationName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NextAnimationName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpineAnimationTransitionCondition::Evaluate(const class USpineAnimatorComponent* Animator, const class FString& CurrAnimationName, const class FString& NextAnimationName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimationTransitionCondition", "Evaluate");

	Params::SpineAnimationTransitionCondition_Evaluate Parms{};

	Parms.Animator = Animator;
	Parms.CurrAnimationName = std::move(CurrAnimationName);
	Parms.NextAnimationName = std::move(NextAnimationName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SpineAnimatorComponent.OnAnimationComplete
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      TrackEntry                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineAnimatorComponent::OnAnimationComplete(class UTrackEntry* TrackEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "OnAnimationComplete");

	Params::SpineAnimatorComponent_OnAnimationComplete Parms{};

	Parms.TrackEntry = TrackEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.OnAnimationInterrupt
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      TrackEntry                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineAnimatorComponent::OnAnimationInterrupt(class UTrackEntry* TrackEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "OnAnimationInterrupt");

	Params::SpineAnimatorComponent_OnAnimationInterrupt Parms{};

	Parms.TrackEntry = TrackEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.OnAnyAnimationComplete
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      TrackEntry                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineAnimatorComponent::OnAnyAnimationComplete(class UTrackEntry* TrackEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "OnAnyAnimationComplete");

	Params::SpineAnimatorComponent_OnAnyAnimationComplete Parms{};

	Parms.TrackEntry = TrackEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.OnAnyAnimationInterrupt
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      TrackEntry                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineAnimatorComponent::OnAnyAnimationInterrupt(class UTrackEntry* TrackEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "OnAnyAnimationInterrupt");

	Params::SpineAnimatorComponent_OnAnyAnimationInterrupt Parms{};

	Parms.TrackEntry = TrackEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.OnFacingChanged
// (Final, Native, Private)

void USpineAnimatorComponent::OnFacingChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "OnFacingChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.OnLayerComplete
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      TrackEntry                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineAnimatorComponent::OnLayerComplete(class UTrackEntry* TrackEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "OnLayerComplete");

	Params::SpineAnimatorComponent_OnLayerComplete Parms{};

	Parms.TrackEntry = TrackEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.OnLayerInterrupt
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      TrackEntry                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineAnimatorComponent::OnLayerInterrupt(class UTrackEntry* TrackEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "OnLayerInterrupt");

	Params::SpineAnimatorComponent_OnLayerInterrupt Parms{};

	Parms.TrackEntry = TrackEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.PlayActionAnimation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSpineAnimationDefinition& AnimationDefinition                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USpineAnimatorComponent::PlayActionAnimation(const struct FSpineAnimationDefinition& AnimationDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "PlayActionAnimation");

	Params::SpineAnimatorComponent_PlayActionAnimation Parms{};

	Parms.AnimationDefinition = std::move(AnimationDefinition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.PlayActionAnimations
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FSpineAnimationDefinition>&AnimationDefinitions                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USpineAnimatorComponent::PlayActionAnimations(const TArray<struct FSpineAnimationDefinition>& AnimationDefinitions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "PlayActionAnimations");

	Params::SpineAnimatorComponent_PlayActionAnimations Parms{};

	Parms.AnimationDefinitions = std::move(AnimationDefinitions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.PlayActionAnimationsWithDelegate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FSpineAnimationDefinition>&AnimationDefinitions                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const TDelegate<void()>&                OnLayerEnd                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineAnimatorComponent::PlayActionAnimationsWithDelegate(const TArray<struct FSpineAnimationDefinition>& AnimationDefinitions, const TDelegate<void()>& OnLayerEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "PlayActionAnimationsWithDelegate");

	Params::SpineAnimatorComponent_PlayActionAnimationsWithDelegate Parms{};

	Parms.AnimationDefinitions = std::move(AnimationDefinitions);
	Parms.OnLayerEnd = OnLayerEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.PlayActionAnimationWithDelegate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSpineAnimationDefinition& AnimationDefinition                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const TDelegate<void()>&                OnLayerEnd                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineAnimatorComponent::PlayActionAnimationWithDelegate(const struct FSpineAnimationDefinition& AnimationDefinition, const TDelegate<void()>& OnLayerEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "PlayActionAnimationWithDelegate");

	Params::SpineAnimatorComponent_PlayActionAnimationWithDelegate Parms{};

	Parms.AnimationDefinition = std::move(AnimationDefinition);
	Parms.OnLayerEnd = OnLayerEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.PlayAnimations
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ESpineAnimatorLayer                     AnimatorLayer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FSpineAnimationDefinition>&AnimationDefinitions                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USpineAnimatorComponent::PlayAnimations(ESpineAnimatorLayer AnimatorLayer, const TArray<struct FSpineAnimationDefinition>& AnimationDefinitions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "PlayAnimations");

	Params::SpineAnimatorComponent_PlayAnimations Parms{};

	Parms.AnimatorLayer = AnimatorLayer;
	Parms.AnimationDefinitions = std::move(AnimationDefinitions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.PlayAnimationsWithDelegate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ESpineAnimatorLayer                     AnimatorLayer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FSpineAnimationDefinition>&AnimationDefinitions                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const TDelegate<void()>&                OnLayerEnd                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineAnimatorComponent::PlayAnimationsWithDelegate(ESpineAnimatorLayer AnimatorLayer, const TArray<struct FSpineAnimationDefinition>& AnimationDefinitions, const TDelegate<void()>& OnLayerEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "PlayAnimationsWithDelegate");

	Params::SpineAnimatorComponent_PlayAnimationsWithDelegate Parms{};

	Parms.AnimatorLayer = AnimatorLayer;
	Parms.AnimationDefinitions = std::move(AnimationDefinitions);
	Parms.OnLayerEnd = OnLayerEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.PlayTurnAnimations
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FSpineAnimationDefinition>&AnimationDefinitions                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USpineAnimatorComponent::PlayTurnAnimations(const TArray<struct FSpineAnimationDefinition>& AnimationDefinitions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "PlayTurnAnimations");

	Params::SpineAnimatorComponent_PlayTurnAnimations Parms{};

	Parms.AnimationDefinitions = std::move(AnimationDefinitions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.ResetAnimations
// (Final, Native, Public, BlueprintCallable)

void USpineAnimatorComponent::ResetAnimations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "ResetAnimations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.ResetLocomotionCycle
// (Final, Native, Public, BlueprintCallable)

void USpineAnimatorComponent::ResetLocomotionCycle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "ResetLocomotionCycle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.StopActionAnimations
// (Final, Native, Public, BlueprintCallable)

void USpineAnimatorComponent::StopActionAnimations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "StopActionAnimations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.StopAnimationAtLayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESpineAnimatorLayer                     Layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineAnimatorComponent::StopAnimationAtLayer(ESpineAnimatorLayer Layer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "StopAnimationAtLayer");

	Params::SpineAnimatorComponent_StopAnimationAtLayer Parms{};

	Parms.Layer = Layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineAnimatorComponent.GetCurrentAnimationName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USpineAnimatorComponent::GetCurrentAnimationName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "GetCurrentAnimationName");

	Params::SpineAnimatorComponent_GetCurrentAnimationName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SpineAnimatorComponent.GetCurrentAnimationPlayTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USpineAnimatorComponent::GetCurrentAnimationPlayTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "GetCurrentAnimationPlayTime");

	Params::SpineAnimatorComponent_GetCurrentAnimationPlayTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SpineAnimatorComponent.GetCurrentLayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESpineAnimatorLayer                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESpineAnimatorLayer USpineAnimatorComponent::GetCurrentLayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "GetCurrentLayer");

	Params::SpineAnimatorComponent_GetCurrentLayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SpineAnimatorComponent.GetCurrentTrackEntry
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTrackEntry*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTrackEntry* USpineAnimatorComponent::GetCurrentTrackEntry() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "GetCurrentTrackEntry");

	Params::SpineAnimatorComponent_GetCurrentTrackEntry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SpineAnimatorComponent.GetHistoryDataAtIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSpineAnimatorHistoryData*       out_Result                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpineAnimatorComponent::GetHistoryDataAtIndex(int32 Index_0, struct FSpineAnimatorHistoryData* out_Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "GetHistoryDataAtIndex");

	Params::SpineAnimatorComponent_GetHistoryDataAtIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_Result != nullptr)
		*out_Result = std::move(Parms.out_Result);

	return Parms.ReturnValue;
}


// Function Zion.SpineAnimatorComponent.GetLastVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USpineAnimatorComponent::GetLastVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "GetLastVelocity");

	Params::SpineAnimatorComponent_GetLastVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SpineAnimatorComponent.IsPlayingAnimationOnLayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESpineAnimatorLayer                     Layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpineAnimatorComponent::IsPlayingAnimationOnLayer(ESpineAnimatorLayer Layer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineAnimatorComponent", "IsPlayingAnimationOnLayer");

	Params::SpineAnimatorComponent_IsPlayingAnimationOnLayer Parms{};

	Parms.Layer = Layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SpineColorComponent.ClearColor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   LerpDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineColorComponent::ClearColor(float LerpDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineColorComponent", "ClearColor");

	Params::SpineColorComponent_ClearColor Parms{};

	Parms.LerpDuration = LerpDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineColorComponent.FlashColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLinearColor&              Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FlashDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineColorComponent::FlashColor(const struct FLinearColor& Color, float Alpha, float FlashDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineColorComponent", "FlashColor");

	Params::SpineColorComponent_FlashColor Parms{};

	Parms.Color = std::move(Color);
	Parms.Alpha = Alpha;
	Parms.FlashDuration = FlashDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineColorComponent.OnGotAbilityApplied
// (Final, Native, Private, HasOutParams)
// Parameters:
// class AAbility*                         Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitData&                  HitData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USpineColorComponent::OnGotAbilityApplied(class AAbility* Ability, class AActor* Source, const struct FHitData& HitData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineColorComponent", "OnGotAbilityApplied");

	Params::SpineColorComponent_OnGotAbilityApplied Parms{};

	Parms.Ability = Ability;
	Parms.Source = Source;
	Parms.HitData = std::move(HitData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineColorComponent.SetColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLinearColor&              Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineColorComponent::SetColor(const struct FLinearColor& Color, float Alpha, float LerpDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineColorComponent", "SetColor");

	Params::SpineColorComponent_SetColor Parms{};

	Parms.Color = std::move(Color);
	Parms.Alpha = Alpha;
	Parms.LerpDuration = LerpDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineHighlightComponent.OnAnimationStart
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      Entry                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpineHighlightComponent::OnAnimationStart(class UTrackEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineHighlightComponent", "OnAnimationStart");

	Params::SpineHighlightComponent_OnAnimationStart Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpineSkinFromFacing.OnFacingChanged
// (Final, Native, Private)

void USpineSkinFromFacing::OnFacingChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpineSkinFromFacing", "OnFacingChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetWorldSpaceGauge.SetCurrentRatio
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   CurrentRatio                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetWorldSpaceGauge::SetCurrentRatio(float CurrentRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpaceGauge", "SetCurrentRatio");

	Params::UserWidgetWorldSpaceGauge_SetCurrentRatio Parms{};

	Parms.CurrentRatio = CurrentRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetWorldSpaceGauge.SetTargetActor
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetWorldSpaceGauge::SetTargetActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpaceGauge", "SetTargetActor");

	Params::UserWidgetWorldSpaceGauge_SetTargetActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpiritAutoComponent.OnCommandQueueCleared
// (Final, Native, Private)

void USpiritAutoComponent::OnCommandQueueCleared()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritAutoComponent", "OnCommandQueueCleared");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpiritAutoComponent.OnSummonerDodge
// (Final, Native, Private)

void USpiritAutoComponent::OnSummonerDodge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritAutoComponent", "OnSummonerDodge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpiritAutoComponent.OnSummonerFacingChange
// (Final, Native, Private)

void USpiritAutoComponent::OnSummonerFacingChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritAutoComponent", "OnSummonerFacingChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpiritCooldown.OnCommandFinishCooldown
// (Final, Native, Private)
// Parameters:
// const class UCommandSet*                CommandSetFinished                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpiritCooldown::OnCommandFinishCooldown(const class UCommandSet* CommandSetFinished, bool bReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCooldown", "OnCommandFinishCooldown");

	Params::SpiritCooldown_OnCommandFinishCooldown Parms{};

	Parms.CommandSetFinished = CommandSetFinished;
	Parms.bReset = bReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpiritCooldown.OnCooldownCompleted
// (Event, Protected, BlueprintEvent)

void ASpiritCooldown::OnCooldownCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCooldown", "OnCooldownCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.SpiritCooldown.OnEventStarted
// (Final, Native, Private)

void ASpiritCooldown::OnEventStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCooldown", "OnEventStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpiritCooldown.OnEventStopped
// (Final, Native, Private)

void ASpiritCooldown::OnEventStopped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCooldown", "OnEventStopped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpiritCooldown.OnFinished
// (Event, Protected, BlueprintEvent)

void ASpiritCooldown::OnFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCooldown", "OnFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.SpiritCooldown.OnLaunch
// (Event, Protected, BlueprintEvent)

void ASpiritCooldown::OnLaunch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCooldown", "OnLaunch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.SpiritCooldown.OnNiagaraSystemFinished
// (Final, Native, Private)
// Parameters:
// class UNiagaraComponent*                PSystem                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpiritCooldown::OnNiagaraSystemFinished(class UNiagaraComponent* PSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCooldown", "OnNiagaraSystemFinished");

	Params::SpiritCooldown_OnNiagaraSystemFinished Parms{};

	Parms.PSystem = PSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpiritCooldown.OnUnPossessPlayer
// (Final, Native, Private)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpiritCooldown::OnUnPossessPlayer(class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCooldown", "OnUnPossessPlayer");

	Params::SpiritCooldown_OnUnPossessPlayer Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SpiritRepeatComponent.OnSummonerFacingChange
// (Final, Native, Private)

void USpiritRepeatComponent::OnSummonerFacingChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritRepeatComponent", "OnSummonerFacingChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StatComponent.Add
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ValueToAdd                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatComponent::Add(int32 ValueToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatComponent", "Add");

	Params::StatComponent_Add Parms{};

	Parms.ValueToAdd = ValueToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatComponent.FullyRestore
// (Native, Public, BlueprintCallable)

void UStatComponent::FullyRestore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatComponent", "FullyRestore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StatComponent.SetMaxValue
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewMaxValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatComponent::SetMaxValue(int32 NewMaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatComponent", "SetMaxValue");

	Params::StatComponent_SetMaxValue Parms{};

	Parms.NewMaxValue = NewMaxValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StatComponent.Subtract
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ValueToSubtract                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatComponent::Subtract(int32 ValueToSubtract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatComponent", "Subtract");

	Params::StatComponent_Subtract Parms{};

	Parms.ValueToSubtract = ValueToSubtract;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatComponent.GetCurrRatio
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStatComponent::GetCurrRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatComponent", "GetCurrRatio");

	Params::StatComponent_GetCurrRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatComponent.GetCurrValue
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatComponent::GetCurrValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatComponent", "GetCurrValue");

	Params::StatComponent_GetCurrValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatComponent.GetMaxValue
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatComponent::GetMaxValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatComponent", "GetMaxValue");

	Params::StatComponent_GetMaxValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.WallGrabComponent.OnMoveBlocked
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FHitResult&                Impact                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UWallGrabComponent::OnMoveBlocked(const struct FHitResult& Impact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WallGrabComponent", "OnMoveBlocked");

	Params::WallGrabComponent_OnMoveBlocked Parms{};

	Parms.Impact = std::move(Impact);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.WallGrabComponent.OnMovementModeChanged
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWallGrabComponent::OnMovementModeChanged(class ACharacter* InCharacter, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WallGrabComponent", "OnMovementModeChanged");

	Params::WallGrabComponent_OnMovementModeChanged Parms{};

	Parms.InCharacter = InCharacter;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.WallGrabComponent.OnStartAnimation
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      TrackEntry                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWallGrabComponent::OnStartAnimation(class UTrackEntry* TrackEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WallGrabComponent", "OnStartAnimation");

	Params::WallGrabComponent_OnStartAnimation Parms{};

	Parms.TrackEntry = TrackEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.WallGrabComponent.OnWallGrab
// (Native, Event, Protected, BlueprintEvent)

void UWallGrabComponent::OnWallGrab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WallGrabComponent", "OnWallGrab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.WallGrabComponent.RefreshWallGrab
// (Final, Native, Public, BlueprintCallable)

void UWallGrabComponent::RefreshWallGrab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WallGrabComponent", "RefreshWallGrab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.WallGrabComponent.IsGrabbingWall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWallGrabComponent::IsGrabbingWall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WallGrabComponent", "IsGrabbingWall");

	Params::WallGrabComponent_IsGrabbingWall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.WallGrabComponent.IsWallOnRight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWallGrabComponent::IsWallOnRight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WallGrabComponent", "IsWallOnRight");

	Params::WallGrabComponent_IsWallOnRight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatBreakableComponent.OnBreak
// (Native, Event, Protected, BlueprintEvent)

void UStatBreakableComponent::OnBreak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatBreakableComponent", "OnBreak");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StatBreakableComponent.SetIsImmune
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bImmune                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatBreakableComponent::SetIsImmune(bool bImmune)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatBreakableComponent", "SetIsImmune");

	Params::StatBreakableComponent_SetIsImmune Parms{};

	Parms.bImmune = bImmune;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatBreakableComponent.IsBroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatBreakableComponent::IsBroken() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatBreakableComponent", "IsBroken");

	Params::StatBreakableComponent_IsBroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatBreakableComponent.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatBreakableComponent::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatBreakableComponent", "IsEnabled");

	Params::StatBreakableComponent_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatBreakableComponent.IsInvincible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatBreakableComponent::IsInvincible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatBreakableComponent", "IsInvincible");

	Params::StatBreakableComponent_IsInvincible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StateComponent.AddState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TSubclassOf<class UState>         State                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateComponent::AddState(const TSubclassOf<class UState> State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "AddState");

	Params::StateComponent_AddState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StateComponent.AddStates
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<TSubclassOf<class UState>>&States                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

void UStateComponent::AddStates(const TArray<TSubclassOf<class UState>>& States)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "AddStates");

	Params::StateComponent_AddStates Parms{};

	Parms.States = std::move(States);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StateComponent.AddStatesForDuration
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<TSubclassOf<class UState>>&States                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateComponent::AddStatesForDuration(const TArray<TSubclassOf<class UState>>& States, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "AddStatesForDuration");

	Params::StateComponent_AddStatesForDuration Parms{};

	Parms.States = std::move(States);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StateComponent.AddStatesForFrameCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<TSubclassOf<class UState>>&States                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// int32                                   FrameCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateComponent::AddStatesForFrameCount(const TArray<TSubclassOf<class UState>>& States, int32 FrameCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "AddStatesForFrameCount");

	Params::StateComponent_AddStatesForFrameCount Parms{};

	Parms.States = std::move(States);
	Parms.FrameCount = FrameCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StateComponent.RemoveAllStates
// (Final, Native, Public, BlueprintCallable)

void UStateComponent::RemoveAllStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "RemoveAllStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StateComponent.RemoveState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TSubclassOf<class UState>         State                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateComponent::RemoveState(const TSubclassOf<class UState> State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "RemoveState");

	Params::StateComponent_RemoveState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StateComponent.RemoveStates
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<TSubclassOf<class UState>>&States                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

void UStateComponent::RemoveStates(const TArray<TSubclassOf<class UState>>& States)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "RemoveStates");

	Params::StateComponent_RemoveStates Parms{};

	Parms.States = std::move(States);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StateComponent.HasAllStates
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<TSubclassOf<class UState>>&States                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateComponent::HasAllStates(const TArray<TSubclassOf<class UState>>& States) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "HasAllStates");

	Params::StateComponent_HasAllStates Parms{};

	Parms.States = std::move(States);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StateComponent.HasAnyState
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<TSubclassOf<class UState>>&States                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateComponent::HasAnyState(const TArray<TSubclassOf<class UState>>& States) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "HasAnyState");

	Params::StateComponent_HasAnyState Parms{};

	Parms.States = std::move(States);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StateComponent.HasBusyState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateComponent::HasBusyState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "HasBusyState");

	Params::StateComponent_HasBusyState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StateComponent.HasState
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSubclassOf<class UState>&        State                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateComponent::HasState(const TSubclassOf<class UState>& State) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "HasState");

	Params::StateComponent_HasState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StateComponent.IsDebuffed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateComponent::IsDebuffed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "IsDebuffed");

	Params::StateComponent_IsDebuffed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StateComponent.IsFacingLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateComponent::IsFacingLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "IsFacingLocked");

	Params::StateComponent_IsFacingLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StateComponent.IsFreeCommandLayerLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateComponent::IsFreeCommandLayerLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "IsFreeCommandLayerLocked");

	Params::StateComponent_IsFreeCommandLayerLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StateComponent.IsInFreezeCritical
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateComponent::IsInFreezeCritical() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "IsInFreezeCritical");

	Params::StateComponent_IsInFreezeCritical Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StateComponent.IsInputActionLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UInputAction*               InputAction                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateComponent::IsInputActionLocked(const class UInputAction* InputAction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "IsInputActionLocked");

	Params::StateComponent_IsInputActionLocked Parms{};

	Parms.InputAction = InputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StateComponent.IsMovementLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateComponent::IsMovementLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "IsMovementLocked");

	Params::StateComponent_IsMovementLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StateComponent.IsStunned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateComponent::IsStunned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "IsStunned");

	Params::StateComponent_IsStunned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZoneSystemComponent.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UZoneSystemComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UZoneSystemComponent* UZoneSystemComponent::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ZoneSystemComponent", "Get");

	Params::ZoneSystemComponent_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZoneSystemComponent.BindActorToZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UZoneSystemComponent::BindActorToZone(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoneSystemComponent", "BindActorToZone");

	Params::ZoneSystemComponent_BindActorToZone Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ZoneSystemComponent.OnFadeOutFinished
// (Final, Native, Private)

void UZoneSystemComponent::OnFadeOutFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoneSystemComponent", "OnFadeOutFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.ZoneSystemComponent.GetActiveZoneLevelName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UZoneSystemComponent::GetActiveZoneLevelName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoneSystemComponent", "GetActiveZoneLevelName");

	Params::ZoneSystemComponent_GetActiveZoneLevelName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZoneSystemComponent.GetActiveZoneName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UZoneSystemComponent::GetActiveZoneName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoneSystemComponent", "GetActiveZoneName");

	Params::ZoneSystemComponent_GetActiveZoneName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ZoneSystemComponent.IsInAnyZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UZoneSystemComponent::IsInAnyZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoneSystemComponent", "IsInAnyZone");

	Params::ZoneSystemComponent_IsInAnyZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatHPComponent.DoDamage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageData&               DamageData                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatHPComponent::DoDamage(class AActor* Source, const struct FDamageData& DamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatHPComponent", "DoDamage");

	Params::StatHPComponent_DoDamage Parms{};

	Parms.Source = Source;
	Parms.DamageData = std::move(DamageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatHPComponent.DoHeal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatHPComponent::DoHeal(class AActor* Source, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatHPComponent", "DoHeal");

	Params::StatHPComponent_DoHeal Parms{};

	Parms.Source = Source;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatHPComponent.GetLastDamageSource
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UStatHPComponent::GetLastDamageSource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatHPComponent", "GetLastDamageSource");

	Params::StatHPComponent_GetLastDamageSource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StaticVolume_AddForce.OnCharacterMovementModeChanged
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStaticVolume_AddForce::OnCharacterMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaticVolume_AddForce", "OnCharacterMovementModeChanged");

	Params::StaticVolume_AddForce_OnCharacterMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StaticVolume_Audio.IsInfiniteExtent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AStaticVolume_Audio::IsInfiniteExtent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaticVolume_Audio", "IsInfiniteExtent");

	Params::StaticVolume_Audio_IsInfiniteExtent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StaticVolume_CameraModifier.Activate
// (Final, Native, Public, BlueprintCallable)

void AStaticVolume_CameraModifier::Activate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaticVolume_CameraModifier", "Activate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StaticVolume_CameraModifier.Deactivate
// (Final, Native, Public, BlueprintCallable)

void AStaticVolume_CameraModifier::Deactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaticVolume_CameraModifier", "Deactivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StaticVolume_CameraModifier.OnActivationBeginOverlap
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AStaticVolume_CameraModifier::OnActivationBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaticVolume_CameraModifier", "OnActivationBeginOverlap");

	Params::StaticVolume_CameraModifier_OnActivationBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StaticVolume_CameraModifier.OnActivationEndOverlap
// (Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStaticVolume_CameraModifier::OnActivationEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaticVolume_CameraModifier", "OnActivationEndOverlap");

	Params::StaticVolume_CameraModifier_OnActivationEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StaticVolume_CameraModifier.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AStaticVolume_CameraModifier::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaticVolume_CameraModifier", "IsActive");

	Params::StaticVolume_CameraModifier_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StaticVolume_Zone.SetZoneLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           InZoneLevel                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStaticVolume_Zone::SetZoneLevel(class UWorld* InZoneLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaticVolume_Zone", "SetZoneLevel");

	Params::StaticVolume_Zone_SetZoneLevel Parms{};

	Parms.InZoneLevel = InZoneLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapTransition.HideMapTransition
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UUserWidgetMapTransition::HideMapTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapTransition", "HideMapTransition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapTransition.OnSetIconsVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMapTransition::OnSetIconsVisibility(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapTransition", "OnSetIconsVisibility");

	Params::UserWidgetMapTransition_OnSetIconsVisibility Parms{};

	Parms.bVisible = bVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetMapTransition.OnSetScale
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   NewScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMapTransition::OnSetScale(float NewScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapTransition", "OnSetScale");

	Params::UserWidgetMapTransition_OnSetScale Parms{};

	Parms.NewScale = NewScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetMapTransition.SetIconsVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMapTransition::SetIconsVisibility(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapTransition", "SetIconsVisibility");

	Params::UserWidgetMapTransition_SetIconsVisibility Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapTransition.SetScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMapTransition::SetScale(float NewScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapTransition", "SetScale");

	Params::UserWidgetMapTransition_SetScale Parms{};

	Parms.NewScale = NewScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapTransition.ShowMapTransition
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UUserWidgetMapTransition::ShowMapTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapTransition", "ShowMapTransition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StatsControllerComponent.GetAppliedLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatsControllerComponent::GetAppliedLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsControllerComponent", "GetAppliedLevel");

	Params::StatsControllerComponent_GetAppliedLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatsControllerComponent.GetLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatsControllerComponent::GetLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsControllerComponent", "GetLevel");

	Params::StatsControllerComponent_GetLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatsControllerComponent.GetStatsLevelData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FStatsLevelData                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FStatsLevelData UStatsControllerComponent::GetStatsLevelData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsControllerComponent", "GetStatsLevelData");

	Params::StatsControllerComponent_GetStatsLevelData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatsControllerAIComponent.IncrementPhaseLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatsControllerAIComponent::IncrementPhaseLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsControllerAIComponent", "IncrementPhaseLevel");

	Params::StatsControllerAIComponent_IncrementPhaseLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatsControllerAIComponent.GetPhaseLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatsControllerAIComponent::GetPhaseLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsControllerAIComponent", "GetPhaseLevel");

	Params::StatsControllerAIComponent_GetPhaseLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatsControllerPlayerComponent.SetLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatsControllerPlayerComponent::SetLevel(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsControllerPlayerComponent", "SetLevel");

	Params::StatsControllerPlayerComponent_SetLevel Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StatsControllerPlayerComponent.GetExperiencePoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatsControllerPlayerComponent::GetExperiencePoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsControllerPlayerComponent", "GetExperiencePoints");

	Params::StatsControllerPlayerComponent_GetExperiencePoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatsControllerPlayerComponent.GetExperiencePointsRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStatsControllerPlayerComponent::GetExperiencePointsRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsControllerPlayerComponent", "GetExperiencePointsRatio");

	Params::StatsControllerPlayerComponent_GetExperiencePointsRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatsControllerPlayerComponent.GetExtendedStatsLevelDataWithBonuses
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FExtendedStatsData               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FExtendedStatsData UStatsControllerPlayerComponent::GetExtendedStatsLevelDataWithBonuses() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsControllerPlayerComponent", "GetExtendedStatsLevelDataWithBonuses");

	Params::StatsControllerPlayerComponent_GetExtendedStatsLevelDataWithBonuses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatsControllerPlayerComponent.GetNecessaryExperiencePointsForLevelUp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatsControllerPlayerComponent::GetNecessaryExperiencePointsForLevelUp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsControllerPlayerComponent", "GetNecessaryExperiencePointsForLevelUp");

	Params::StatsControllerPlayerComponent_GetNecessaryExperiencePointsForLevelUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatsControllerPlayerComponent.GetStatsLevelDataWithBonuses
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FStatsLevelData                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FStatsLevelData UStatsControllerPlayerComponent::GetStatsLevelDataWithBonuses() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsControllerPlayerComponent", "GetStatsLevelDataWithBonuses");

	Params::StatsControllerPlayerComponent_GetStatsLevelDataWithBonuses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatsControllerPlayerComponent.IsMaxLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatsControllerPlayerComponent::IsMaxLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsControllerPlayerComponent", "IsMaxLevel");

	Params::StatsControllerPlayerComponent_IsMaxLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetPlayerUI.HideUI
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetPlayerUI::HideUI(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "HideUI");

	Params::UserWidgetPlayerUI_HideUI Parms{};

	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetPlayerUI.OnDisplayPlayerUIChanged
// (Final, Native, Private)

void UUserWidgetPlayerUI::OnDisplayPlayerUIChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "OnDisplayPlayerUIChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetPlayerUI.OnLowHPFeedbackOpacityChanged
// (Final, Native, Private)

void UUserWidgetPlayerUI::OnLowHPFeedbackOpacityChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "OnLowHPFeedbackOpacityChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetPlayerUI.OnPlayerInputLocked
// (Event, Public, BlueprintEvent)

void UUserWidgetPlayerUI::OnPlayerInputLocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "OnPlayerInputLocked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetPlayerUI.OnPlayerInputUnlocked
// (Event, Public, BlueprintEvent)

void UUserWidgetPlayerUI::OnPlayerInputUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "OnPlayerInputUnlocked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetPlayerUI.OnRefreshLowHPFeedbackOpacity
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Opacity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetPlayerUI::OnRefreshLowHPFeedbackOpacity(float Opacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "OnRefreshLowHPFeedbackOpacity");

	Params::UserWidgetPlayerUI_OnRefreshLowHPFeedbackOpacity Parms{};

	Parms.Opacity = Opacity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetPlayerUI.OnRefreshPlayerUIVisibility
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetPlayerUI::OnRefreshPlayerUIVisibility(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "OnRefreshPlayerUIVisibility");

	Params::UserWidgetPlayerUI_OnRefreshPlayerUIVisibility Parms{};

	Parms.bVisible = bVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetPlayerUI.RefreshHealVisibility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UUserWidgetPlayerUI::RefreshHealVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "RefreshHealVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetPlayerUI.RefreshSPVisibility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UUserWidgetPlayerUI::RefreshSPVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "RefreshSPVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetPlayerUI.ShowUI
// (Native, Event, Public, BlueprintEvent)

void UUserWidgetPlayerUI::ShowUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "ShowUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetPlayerUI.TriggerAnimation_HealFailure_FullHP
// (Event, Public, BlueprintEvent)

void UUserWidgetPlayerUI::TriggerAnimation_HealFailure_FullHP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "TriggerAnimation_HealFailure_FullHP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetPlayerUI.TriggerAnimation_HealFailure_NoHeal
// (Event, Public, BlueprintEvent)

void UUserWidgetPlayerUI::TriggerAnimation_HealFailure_NoHeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "TriggerAnimation_HealFailure_NoHeal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetPlayerUI.CanShowHeal
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetPlayerUI::CanShowHeal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "CanShowHeal");

	Params::UserWidgetPlayerUI_CanShowHeal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetPlayerUI.CanShowSP
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetPlayerUI::CanShowSP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "CanShowSP");

	Params::UserWidgetPlayerUI_CanShowSP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetPlayerUI.GetController
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UUserWidgetPlayerUI::GetController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "GetController");

	Params::UserWidgetPlayerUI_GetController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetPlayerUI.GetFieldTalkHolder
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUserWidgetFieldTalkHolder*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidgetFieldTalkHolder* UUserWidgetPlayerUI::GetFieldTalkHolder() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "GetFieldTalkHolder");

	Params::UserWidgetPlayerUI_GetFieldTalkHolder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetPlayerUI.GetMinimapWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUserWidgetMinimap*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidgetMinimap* UUserWidgetPlayerUI::GetMinimapWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "GetMinimapWidget");

	Params::UserWidgetPlayerUI_GetMinimapWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetPlayerUI.GetPawn
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UUserWidgetPlayerUI::GetPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "GetPawn");

	Params::UserWidgetPlayerUI_GetPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetPlayerUI.RefreshCustomMarkers
// (Final, Native, Public, BlueprintCallable, Const)

void UUserWidgetPlayerUI::RefreshCustomMarkers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "RefreshCustomMarkers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetPlayerUI.RefreshMinimap
// (Final, Native, Public, BlueprintCallable, Const)

void UUserWidgetPlayerUI::RefreshMinimap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetPlayerUI", "RefreshMinimap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StatSPComponent.AddSPRegenPercentageBonus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SPRegenPercentBonusToAdd                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatSPComponent::AddSPRegenPercentageBonus(int32 SPRegenPercentBonusToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatSPComponent", "AddSPRegenPercentageBonus");

	Params::StatSPComponent_AddSPRegenPercentageBonus Parms{};

	Parms.SPRegenPercentBonusToAdd = SPRegenPercentBonusToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatSPComponent.SubSPRegenPercentageBonus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SPRegenPercentBonusToSub                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatSPComponent::SubSPRegenPercentageBonus(int32 SPRegenPercentBonusToSub)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatSPComponent", "SubSPRegenPercentageBonus");

	Params::StatSPComponent_SubSPRegenPercentageBonus Parms{};

	Parms.SPRegenPercentBonusToSub = SPRegenPercentBonusToSub;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StatSPComponent.GetFilledGaugeCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatSPComponent::GetFilledGaugeCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatSPComponent", "GetFilledGaugeCount");

	Params::StatSPComponent_GetFilledGaugeCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetRestPointListMapArea.GenerateRestPointListEntries
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class UUserWidgetMapIcon_RestPoint*>&RestPointIcons                                         (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UUserWidgetRestPointListMapArea::GenerateRestPointListEntries(const TArray<class UUserWidgetMapIcon_RestPoint*>& RestPointIcons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointListMapArea", "GenerateRestPointListEntries");

	Params::UserWidgetRestPointListMapArea_GenerateRestPointListEntries Parms{};

	Parms.RestPointIcons = std::move(RestPointIcons);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetRestPointListMapArea.RestPointEntryFocused
// (Final, Native, Private)
// Parameters:
// class UUserWidgetMapIcon_RestPoint*     RestPointIcon                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetRestPointListMapArea::RestPointEntryFocused(class UUserWidgetMapIcon_RestPoint* RestPointIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointListMapArea", "RestPointEntryFocused");

	Params::UserWidgetRestPointListMapArea_RestPointEntryFocused Parms{};

	Parms.RestPointIcon = RestPointIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetRestPointListMapArea.RestPointEntryPressed
// (Final, Native, Private)
// Parameters:
// const struct FMapRestPointData&         RestPointData                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidgetRestPointListMapArea::RestPointEntryPressed(const struct FMapRestPointData& RestPointData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointListMapArea", "RestPointEntryPressed");

	Params::UserWidgetRestPointListMapArea_RestPointEntryPressed Parms{};

	Parms.RestPointData = std::move(RestPointData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetRestPointListMapArea.SetCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsCompleted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetRestPointListMapArea::SetCompleted(bool bIsCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointListMapArea", "SetCompleted");

	Params::UserWidgetRestPointListMapArea_SetCompleted Parms{};

	Parms.bIsCompleted = bIsCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetRestPointListMapArea.SetMapAreaIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             NewMapAreaIndex                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetRestPointListMapArea::SetMapAreaIndex(const int32 NewMapAreaIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointListMapArea", "SetMapAreaIndex");

	Params::UserWidgetRestPointListMapArea_SetMapAreaIndex Parms{};

	Parms.NewMapAreaIndex = NewMapAreaIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetRestPointListMapArea.SetMapAreaName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FText&                      NewMapAreaName                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidgetRestPointListMapArea::SetMapAreaName(const class FText& NewMapAreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointListMapArea", "SetMapAreaName");

	Params::UserWidgetRestPointListMapArea_SetMapAreaName Parms{};

	Parms.NewMapAreaName = std::move(NewMapAreaName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StatusEffectComponent.LaunchStatusEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EStatusEffectType                       StatusEffectType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectComponent::LaunchStatusEffect(EStatusEffectType StatusEffectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectComponent", "LaunchStatusEffect");

	Params::StatusEffectComponent_LaunchStatusEffect Parms{};

	Parms.StatusEffectType = StatusEffectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StatusEffectComponent.LaunchStatusEffectFromClass
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TSubclassOf<class UStatusEffect>& StatusEffectClass                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectComponent::LaunchStatusEffectFromClass(const TSubclassOf<class UStatusEffect>& StatusEffectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectComponent", "LaunchStatusEffectFromClass");

	Params::StatusEffectComponent_LaunchStatusEffectFromClass Parms{};

	Parms.StatusEffectClass = StatusEffectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StatusEffectComponent.OnDeathProcessStart
// (Final, Native, Private)

void UStatusEffectComponent::OnDeathProcessStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectComponent", "OnDeathProcessStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetWorldSpace_InputEvent.OnPressConfirm
// (Event, Public, BlueprintEvent)

void UUserWidgetWorldSpace_InputEvent::OnPressConfirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpace_InputEvent", "OnPressConfirm");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.StatusEffect_BurnPlayer.OnDodged
// (Final, Native, Private)

void UStatusEffect_BurnPlayer::OnDodged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect_BurnPlayer", "OnDodged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StatusEffect_BurnPlayer.OnMovementModeChanged
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect_BurnPlayer::OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect_BurnPlayer", "OnMovementModeChanged");

	Params::StatusEffect_BurnPlayer_OnMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.StoryLevelComponent.GetStoryLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStoryLevelComponent::GetStoryLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoryLevelComponent", "GetStoryLevel");

	Params::StoryLevelComponent_GetStoryLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StoryLevelComponent.GetStoryLevelData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FStoryLevelData            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FStoryLevelData UStoryLevelComponent::GetStoryLevelData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoryLevelComponent", "GetStoryLevelData");

	Params::StoryLevelComponent_GetStoryLevelData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StringBPFLibrary.BossRushRecordTimeSecondsToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   TimeInSeconds                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UStringBPFLibrary::BossRushRecordTimeSecondsToString(float TimeInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StringBPFLibrary", "BossRushRecordTimeSecondsToString");

	Params::StringBPFLibrary_BossRushRecordTimeSecondsToString Parms{};

	Parms.TimeInSeconds = TimeInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StringBPFLibrary.ProcessSubtitle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FText&                      Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText*                            Name_0                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// class FText*                            Message                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UStringBPFLibrary::ProcessSubtitle(const class FText& Text, class FText* Name_0, class FText* Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StringBPFLibrary", "ProcessSubtitle");

	Params::StringBPFLibrary_ProcessSubtitle Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);

	if (Message != nullptr)
		*Message = std::move(Parms.Message);
}


// Function Zion.StringBPFLibrary.Sort
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>&                  Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UStringBPFLibrary::Sort(TArray<class FString>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StringBPFLibrary", "Sort");

	Params::StringBPFLibrary_Sort Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);

	return Parms.ReturnValue;
}


// Function Zion.StringBPFLibrary.TimeSecondsToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   TimeInSeconds                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UStringBPFLibrary::TimeSecondsToString(float TimeInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StringBPFLibrary", "TimeSecondsToString");

	Params::StringBPFLibrary_TimeSecondsToString Parms{};

	Parms.TimeInSeconds = TimeInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StructBPFLibrary.ExtendedStatsData_Add
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FExtendedStatsData&        A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FExtendedStatsData&        B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FExtendedStatsData               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FExtendedStatsData UStructBPFLibrary::ExtendedStatsData_Add(const struct FExtendedStatsData& A, const struct FExtendedStatsData& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StructBPFLibrary", "ExtendedStatsData_Add");

	Params::StructBPFLibrary_ExtendedStatsData_Add Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StructBPFLibrary.ExtendedStatsData_ClampToZero
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FExtendedStatsData&              ExtendedStatsData                                      (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UStructBPFLibrary::ExtendedStatsData_ClampToZero(struct FExtendedStatsData& ExtendedStatsData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StructBPFLibrary", "ExtendedStatsData_ClampToZero");

	Params::StructBPFLibrary_ExtendedStatsData_ClampToZero Parms{};

	Parms.ExtendedStatsData = std::move(ExtendedStatsData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ExtendedStatsData = std::move(Parms.ExtendedStatsData);
}


// Function Zion.StructBPFLibrary.ExtendedStatsData_Subtract
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FExtendedStatsData&        A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FExtendedStatsData&        B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FExtendedStatsData               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FExtendedStatsData UStructBPFLibrary::ExtendedStatsData_Subtract(const struct FExtendedStatsData& A, const struct FExtendedStatsData& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StructBPFLibrary", "ExtendedStatsData_Subtract");

	Params::StructBPFLibrary_ExtendedStatsData_Subtract Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StructBPFLibrary.GetTutorialVideo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FInventoryItemTutorialData&ItemTutorialData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class APlayerControllerZion*            PlayerControllerZion                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlatformMediaSource*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlatformMediaSource* UStructBPFLibrary::GetTutorialVideo(const struct FInventoryItemTutorialData& ItemTutorialData, class APlayerControllerZion* PlayerControllerZion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StructBPFLibrary", "GetTutorialVideo");

	Params::StructBPFLibrary_GetTutorialVideo Parms{};

	Parms.ItemTutorialData = std::move(ItemTutorialData);
	Parms.PlayerControllerZion = PlayerControllerZion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StructBPFLibrary.IsAbilityDataValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAbilityData&              AbilityData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStructBPFLibrary::IsAbilityDataValid(const struct FAbilityData& AbilityData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StructBPFLibrary", "IsAbilityDataValid");

	Params::StructBPFLibrary_IsAbilityDataValid Parms{};

	Parms.AbilityData = std::move(AbilityData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StructBPFLibrary.IsItemSkillDataValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FInventoryItemSkillData&   ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStructBPFLibrary::IsItemSkillDataValid(const struct FInventoryItemSkillData& ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StructBPFLibrary", "IsItemSkillDataValid");

	Params::StructBPFLibrary_IsItemSkillDataValid Parms{};

	Parms.ItemData = std::move(ItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StructBPFLibrary.MovementModeMatch
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UCharacterMovementComponent*CharacterMovementComponent                             (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMovementModeData&         MovementModeData                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStructBPFLibrary::MovementModeMatch(const class UCharacterMovementComponent* CharacterMovementComponent, const struct FMovementModeData& MovementModeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StructBPFLibrary", "MovementModeMatch");

	Params::StructBPFLibrary_MovementModeMatch Parms{};

	Parms.CharacterMovementComponent = CharacterMovementComponent;
	Parms.MovementModeData = std::move(MovementModeData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StructBPFLibrary.MovementModeMatchAny
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UCharacterMovementComponent*CharacterMovementComponent                             (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FMovementModeData>& MovementModeDataList                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStructBPFLibrary::MovementModeMatchAny(const class UCharacterMovementComponent* CharacterMovementComponent, const TArray<struct FMovementModeData>& MovementModeDataList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StructBPFLibrary", "MovementModeMatchAny");

	Params::StructBPFLibrary_MovementModeMatchAny Parms{};

	Parms.CharacterMovementComponent = CharacterMovementComponent;
	Parms.MovementModeDataList = std::move(MovementModeDataList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StructBPFLibrary.StatsLevelData_Add
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FStatsLevelData&           A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FStatsLevelData&           B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FStatsLevelData                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FStatsLevelData UStructBPFLibrary::StatsLevelData_Add(const struct FStatsLevelData& A, const struct FStatsLevelData& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StructBPFLibrary", "StatsLevelData_Add");

	Params::StructBPFLibrary_StatsLevelData_Add Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StructBPFLibrary.StatsLevelData_Subtract
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FStatsLevelData&           A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FStatsLevelData&           B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FStatsLevelData                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FStatsLevelData UStructBPFLibrary::StatsLevelData_Subtract(const struct FStatsLevelData& A, const struct FStatsLevelData& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StructBPFLibrary", "StatsLevelData_Subtract");

	Params::StructBPFLibrary_StatsLevelData_Subtract Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StructBPFLibrary.ToCurrencyValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCurrencyTransactionInfos& Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   AlreadyBoughtCount                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCurrencyValue                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCurrencyValue UStructBPFLibrary::ToCurrencyValue(const struct FCurrencyTransactionInfos& Info, int32 AlreadyBoughtCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StructBPFLibrary", "ToCurrencyValue");

	Params::StructBPFLibrary_ToCurrencyValue Parms{};

	Parms.Info = std::move(Info);
	Parms.AlreadyBoughtCount = AlreadyBoughtCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.StunComponent.OnBreakRecovery
// (Final, Native, Protected)

void UStunComponent::OnBreakRecovery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StunComponent", "OnBreakRecovery");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SummonComponent.FlushCachedSpirits
// (Final, Native, Public, BlueprintCallable)

void USummonComponent::FlushCachedSpirits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonComponent", "FlushCachedSpirits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SummonComponent.GetOrSpawnSpirit
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TSubclassOf<class ACharacterZionSpirit>&SpiritClass                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacterZionSpirit*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacterZionSpirit* USummonComponent::GetOrSpawnSpirit(const TSubclassOf<class ACharacterZionSpirit>& SpiritClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonComponent", "GetOrSpawnSpirit");

	Params::SummonComponent_GetOrSpawnSpirit Parms{};

	Parms.SpiritClass = SpiritClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SummonComponent.IsSpiritSummoned
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TSubclassOf<class ACharacterZionSpirit>&SpiritClass                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USummonComponent::IsSpiritSummoned(const TSubclassOf<class ACharacterZionSpirit>& SpiritClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonComponent", "IsSpiritSummoned");

	Params::SummonComponent_IsSpiritSummoned Parms{};

	Parms.SpiritClass = SpiritClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SummonComponent.OnControllerChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      OldController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      NewController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USummonComponent::OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonComponent", "OnControllerChanged");

	Params::SummonComponent_OnControllerChanged Parms{};

	Parms.Pawn = Pawn;
	Parms.OldController = OldController;
	Parms.NewController = NewController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SummonComponent.OnGameMapChanged
// (Final, Native, Private)

void USummonComponent::OnGameMapChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonComponent", "OnGameMapChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SummonComponent.SetForceSummonNextToggle
// (Final, Native, Public, BlueprintCallable)

void USummonComponent::SetForceSummonNextToggle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonComponent", "SetForceSummonNextToggle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SummonComponent.SummonSpirit
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TSubclassOf<class ACharacterZionSpirit>&SpiritClass                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<TSubclassOf<class UCommand>>&CommandClasses                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// const struct FSpiritSummonParameters&   SummonParameters                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class UInputAction*               InvokedByInputAction                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommandLayerType                       CommandLayerType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCommandSet*                FallbackCommandSet                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacterZionSpirit*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacterZionSpirit* USummonComponent::SummonSpirit(const TSubclassOf<class ACharacterZionSpirit>& SpiritClass, const TArray<TSubclassOf<class UCommand>>& CommandClasses, const struct FSpiritSummonParameters& SummonParameters, const class UInputAction* InvokedByInputAction, ECommandLayerType CommandLayerType, const class UCommandSet* FallbackCommandSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonComponent", "SummonSpirit");

	Params::SummonComponent_SummonSpirit Parms{};

	Parms.SpiritClass = SpiritClass;
	Parms.CommandClasses = std::move(CommandClasses);
	Parms.SummonParameters = std::move(SummonParameters);
	Parms.InvokedByInputAction = InvokedByInputAction;
	Parms.CommandLayerType = CommandLayerType;
	Parms.FallbackCommandSet = FallbackCommandSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SummonComponent.SummonSpiritFromCommand
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TSubclassOf<class ACharacterZionSpirit>&SpiritClass                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<TSubclassOf<class UCommand>>&CommandClasses                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// const struct FSpiritSummonParameters&   SummonParameters                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class UCommand*                   SourceCommand                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacterZionSpirit*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacterZionSpirit* USummonComponent::SummonSpiritFromCommand(const TSubclassOf<class ACharacterZionSpirit>& SpiritClass, const TArray<TSubclassOf<class UCommand>>& CommandClasses, const struct FSpiritSummonParameters& SummonParameters, const class UCommand* SourceCommand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonComponent", "SummonSpiritFromCommand");

	Params::SummonComponent_SummonSpiritFromCommand Parms{};

	Parms.SpiritClass = SpiritClass;
	Parms.CommandClasses = std::move(CommandClasses);
	Parms.SummonParameters = std::move(SummonParameters);
	Parms.SourceCommand = SourceCommand;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SummonIdleSpiritComponent.FlushCachedSpirits
// (Final, Native, Public, BlueprintCallable)

void USummonIdleSpiritComponent::FlushCachedSpirits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonIdleSpiritComponent", "FlushCachedSpirits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SummonIdleSpiritComponent.OnControllerChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      OldController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      NewController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USummonIdleSpiritComponent::OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonIdleSpiritComponent", "OnControllerChanged");

	Params::SummonIdleSpiritComponent_OnControllerChanged Parms{};

	Parms.Pawn = Pawn;
	Parms.OldController = OldController;
	Parms.NewController = NewController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SummonIdleSpiritComponent.OnGameMapChanged
// (Final, Native, Private)

void USummonIdleSpiritComponent::OnGameMapChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonIdleSpiritComponent", "OnGameMapChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SummonIdleSpiritComponent.OnJustTriggeredInputAction
// (Final, Native, Private)
// Parameters:
// const class UInputAction*               InputAction                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USummonIdleSpiritComponent::OnJustTriggeredInputAction(const class UInputAction* InputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonIdleSpiritComponent", "OnJustTriggeredInputAction");

	Params::SummonIdleSpiritComponent_OnJustTriggeredInputAction Parms{};

	Parms.InputAction = InputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SummonIdleSpiritComponent.OnPostStartCommand
// (Final, Native, Private)
// Parameters:
// const class UCommand*                   Command                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USummonIdleSpiritComponent::OnPostStartCommand(const class UCommand* Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonIdleSpiritComponent", "OnPostStartCommand");

	Params::SummonIdleSpiritComponent_OnPostStartCommand Parms{};

	Parms.Command = Command;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SummonRestPointSpiritComponent.FinishSummonRestPointSpirits
// (Final, Native, Public, BlueprintCallable)

void USummonRestPointSpiritComponent::FinishSummonRestPointSpirits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonRestPointSpiritComponent", "FinishSummonRestPointSpirits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SummonRestPointSpiritComponent.OnControllerChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      OldController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      NewController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USummonRestPointSpiritComponent::OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonRestPointSpiritComponent", "OnControllerChanged");

	Params::SummonRestPointSpiritComponent_OnControllerChanged Parms{};

	Parms.Pawn = Pawn;
	Parms.OldController = OldController;
	Parms.NewController = NewController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SummonRestPointSpiritComponent.RefreshRestPointSpirits
// (Final, Native, Public, BlueprintCallable)

void USummonRestPointSpiritComponent::RefreshRestPointSpirits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonRestPointSpiritComponent", "RefreshRestPointSpirits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SummonRestPointSpiritComponent.StartSummonRestPointSpirits
// (Final, Native, Public, BlueprintCallable)

void USummonRestPointSpiritComponent::StartSummonRestPointSpirits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonRestPointSpiritComponent", "StartSummonRestPointSpirits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SystemBPFLibrary.DoesGameVersionMatchesPakVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::DoesGameVersionMatchesPakVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "DoesGameVersionMatchesPakVersion");

	Params::SystemBPFLibrary_DoesGameVersionMatchesPakVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.FlushTextureStreaming
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bDeferToEndFrame                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USystemBPFLibrary::FlushTextureStreaming(bool bDeferToEndFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "FlushTextureStreaming");

	Params::SystemBPFLibrary_FlushTextureStreaming Parms{};

	Parms.bDeferToEndFrame = bDeferToEndFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.SystemBPFLibrary.GetBinkURLFromPlatformMediaSource
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UPlatformMediaSource*       PlatformMediaSource                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USystemBPFLibrary::GetBinkURLFromPlatformMediaSource(const class UPlatformMediaSource* PlatformMediaSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "GetBinkURLFromPlatformMediaSource");

	Params::SystemBPFLibrary_GetBinkURLFromPlatformMediaSource Parms{};

	Parms.PlatformMediaSource = PlatformMediaSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.GetBuildPlatformType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EBuildPlatformType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBuildPlatformType USystemBPFLibrary::GetBuildPlatformType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "GetBuildPlatformType");

	Params::SystemBPFLibrary_GetBuildPlatformType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.GetGameBuildNumber
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USystemBPFLibrary::GetGameBuildNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "GetGameBuildNumber");

	Params::SystemBPFLibrary_GetGameBuildNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.GetGameVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USystemBPFLibrary::GetGameVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "GetGameVersion");

	Params::SystemBPFLibrary_GetGameVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.GetMoviePathFromMovieName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    MovieName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USystemBPFLibrary::GetMoviePathFromMovieName(const class FString& MovieName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "GetMoviePathFromMovieName");

	Params::SystemBPFLibrary_GetMoviePathFromMovieName Parms{};

	Parms.MovieName = std::move(MovieName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.GetRHIName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USystemBPFLibrary::GetRHIName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "GetRHIName");

	Params::SystemBPFLibrary_GetRHIName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.GetRuntimeTextureInfos
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UTexture2D*                 Texture2D                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USystemBPFLibrary::GetRuntimeTextureInfos(const class UTexture2D* Texture2D)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "GetRuntimeTextureInfos");

	Params::SystemBPFLibrary_GetRuntimeTextureInfos Parms{};

	Parms.Texture2D = Texture2D;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.GetRuntimeTextureInfosFromGroup
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ETextureGroup&                    TextureGroup                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> USystemBPFLibrary::GetRuntimeTextureInfosFromGroup(const ETextureGroup& TextureGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "GetRuntimeTextureInfosFromGroup");

	Params::SystemBPFLibrary_GetRuntimeTextureInfosFromGroup Parms{};

	Parms.TextureGroup = TextureGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.GetWindowedResolutions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FIntPoint>*               OutResolutions                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::GetWindowedResolutions(TArray<struct FIntPoint>* OutResolutions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "GetWindowedResolutions");

	Params::SystemBPFLibrary_GetWindowedResolutions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResolutions != nullptr)
		*OutResolutions = std::move(Parms.OutResolutions);

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.IsBossRecollectionEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::IsBossRecollectionEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "IsBossRecollectionEnabled");

	Params::SystemBPFLibrary_IsBossRecollectionEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.IsCrashReportAllowedBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::IsCrashReportAllowedBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "IsCrashReportAllowedBuild");

	Params::SystemBPFLibrary_IsCrashReportAllowedBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.IsDemoBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::IsDemoBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "IsDemoBuild");

	Params::SystemBPFLibrary_IsDemoBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.IsEarlyAccessBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::IsEarlyAccessBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "IsEarlyAccessBuild");

	Params::SystemBPFLibrary_IsEarlyAccessBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.IsEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::IsEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "IsEditor");

	Params::SystemBPFLibrary_IsEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.IsNewGamePlusEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::IsNewGamePlusEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "IsNewGamePlusEnabled");

	Params::SystemBPFLibrary_IsNewGamePlusEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.IsPCBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::IsPCBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "IsPCBuild");

	Params::SystemBPFLibrary_IsPCBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.IsPlaystation4Build
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::IsPlaystation4Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "IsPlaystation4Build");

	Params::SystemBPFLibrary_IsPlaystation4Build Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.IsPlaystation5Build
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::IsPlaystation5Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "IsPlaystation5Build");

	Params::SystemBPFLibrary_IsPlaystation5Build Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.IsPlaystationBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::IsPlaystationBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "IsPlaystationBuild");

	Params::SystemBPFLibrary_IsPlaystationBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.IsShippingBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::IsShippingBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "IsShippingBuild");

	Params::SystemBPFLibrary_IsShippingBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.IsSwitchBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::IsSwitchBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "IsSwitchBuild");

	Params::SystemBPFLibrary_IsSwitchBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.IsUsing4KResolution
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::IsUsing4KResolution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "IsUsing4KResolution");

	Params::SystemBPFLibrary_IsUsing4KResolution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.IsXboxFamilyBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemBPFLibrary::IsXboxFamilyBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "IsXboxFamilyBuild");

	Params::SystemBPFLibrary_IsXboxFamilyBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.SystemBPFLibrary.UpdateUITexturesForCurrentResolution
// (Final, Native, Static, Public, BlueprintCallable)

void USystemBPFLibrary::UpdateUITexturesForCurrentResolution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemBPFLibrary", "UpdateUITexturesForCurrentResolution");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.TimeDilationAsyncAction.TimeDilation
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTimedDilationData&        TimedDilation                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UTimeDilationAsyncAction*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTimeDilationAsyncAction* UTimeDilationAsyncAction::TimeDilation(const class UObject* WorldContextObject, const struct FTimedDilationData& TimedDilation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TimeDilationAsyncAction", "TimeDilation");

	Params::TimeDilationAsyncAction_TimeDilation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TimedDilation = std::move(TimedDilation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.TimeDilationAsyncAction.OnTimedProcessFinished
// (Final, Native, Private)

void UTimeDilationAsyncAction::OnTimedProcessFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeDilationAsyncAction", "OnTimedProcessFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.TimeManagerComponent.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTimeManagerComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTimeManagerComponent* UTimeManagerComponent::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TimeManagerComponent", "Get");

	Params::TimeManagerComponent_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.TimeManagerComponent.AddDilation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   TimeDilationOverride                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Tag                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimeManagerComponent::AddDilation(float TimeDilationOverride, const class FName& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeManagerComponent", "AddDilation");

	Params::TimeManagerComponent_AddDilation Parms{};

	Parms.TimeDilationOverride = TimeDilationOverride;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.TimeManagerComponent.RemoveAllTimeDilation
// (Final, Native, Public, BlueprintCallable)

void UTimeManagerComponent::RemoveAllTimeDilation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeManagerComponent", "RemoveAllTimeDilation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.TimeManagerComponent.RemoveDilation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Tag                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimeManagerComponent::RemoveDilation(const class FName& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeManagerComponent", "RemoveDilation");

	Params::TimeManagerComponent_RemoveDilation Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.TimeManagerComponent.IsTimeDilationActive
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      Tag                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTimeManagerComponent::IsTimeDilationActive(const class FName& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeManagerComponent", "IsTimeDilationActive");

	Params::TimeManagerComponent_IsTimeDilationActive Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.ToggleActorInterface.OnActorToggle
// (Native, Event, Public, BlueprintEvent)

void IToggleActorInterface::OnActorToggle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ToggleActorInterface", "OnActorToggle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Trigger_Event.OnEventFinish
// (Event, Protected, BlueprintEvent)

void ATrigger_Event::OnEventFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trigger_Event", "OnEventFinish");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.Trigger_Event.OnEventFinished
// (Final, Native, Private)
// Parameters:
// class UEventPlayer*                     InEventPlayer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCompletedEvent                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEventPlayerResult                      EventResult                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrigger_Event::OnEventFinished(class UEventPlayer* InEventPlayer, bool bCompletedEvent, EEventPlayerResult EventResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trigger_Event", "OnEventFinished");

	Params::Trigger_Event_OnEventFinished Parms{};

	Parms.InEventPlayer = InEventPlayer;
	Parms.bCompletedEvent = bCompletedEvent;
	Parms.EventResult = EventResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Trigger_FieldMessageNPC.OnNPCDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrigger_FieldMessageNPC::OnNPCDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trigger_FieldMessageNPC", "OnNPCDestroyed");

	Params::Trigger_FieldMessageNPC_OnNPCDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.Trigger_FieldMessageNPC.GetCollisionComponent
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UShapeComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UShapeComponent* ATrigger_FieldMessageNPC::GetCollisionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trigger_FieldMessageNPC", "GetCollisionComponent");

	Params::Trigger_FieldMessageNPC_GetCollisionComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Zion.Trigger_RegisterRuntimeCheckpoint.OnPlayerEndOverlap
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           PlayerActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrigger_RegisterRuntimeCheckpoint::OnPlayerEndOverlap(class AActor* PlayerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trigger_RegisterRuntimeCheckpoint", "OnPlayerEndOverlap");

	Params::Trigger_RegisterRuntimeCheckpoint_OnPlayerEndOverlap Parms{};

	Parms.PlayerActor = PlayerActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.Trigger_RespawnToRuntimeCheckpoint.OnRespawnTimerFinished
// (Final, Native, Private)

void ATrigger_RespawnToRuntimeCheckpoint::OnRespawnTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trigger_RespawnToRuntimeCheckpoint", "OnRespawnTimerFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UIComponent.OnPawnDeath
// (Final, Native, Private)

void UUIComponent::OnPawnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIComponent", "OnPawnDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UIComponent.OnReceivedDamage
// (Final, Native, Private)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DamageValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIComponent::OnReceivedDamage(class AActor* Source, int32 DamageValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIComponent", "OnReceivedDamage");

	Params::UIComponent_OnReceivedDamage Parms{};

	Parms.Source = Source;
	Parms.DamageValue = DamageValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UIComponent.OnReceivedDamageData
// (Final, Native, Private, HasOutParams)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageData&               DamageData                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUIComponent::OnReceivedDamageData(class AActor* Source, const struct FDamageData& DamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIComponent", "OnReceivedDamageData");

	Params::UIComponent_OnReceivedDamageData Parms{};

	Parms.Source = Source;
	Parms.DamageData = std::move(DamageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UIComponent.OnReceivedHeal
// (Final, Native, Private)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HealValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIComponent::OnReceivedHeal(class AActor* Source, int32 HealValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIComponent", "OnReceivedHeal");

	Params::UIComponent_OnReceivedHeal Parms{};

	Parms.Source = Source;
	Parms.HealValue = HealValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGBPFLibrary.AddToViewportAtLayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUMGLayer                               UMGLayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBPFLibrary::AddToViewportAtLayer(class UUserWidget* Widget, EUMGLayer UMGLayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "AddToViewportAtLayer");

	Params::UMGBPFLibrary_AddToViewportAtLayer Parms{};

	Parms.Widget = Widget;
	Parms.UMGLayer = UMGLayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGBPFLibrary.GetCompletionPercentageForItemType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EInventoryItemType&               ItemType                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUMGBPFLibrary::GetCompletionPercentageForItemType(const class UObject* WorldContextObject, const EInventoryItemType& ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "GetCompletionPercentageForItemType");

	Params::UMGBPFLibrary_GetCompletionPercentageForItemType Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGBPFLibrary.GetFocusCause
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FFocusEvent&               FocusEvent                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EFocusCause                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFocusCause UUMGBPFLibrary::GetFocusCause(const struct FFocusEvent& FocusEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "GetFocusCause");

	Params::UMGBPFLibrary_GetFocusCause Parms{};

	Parms.FocusEvent = std::move(FocusEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGBPFLibrary.GetUMGZOrder
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUMGLayer                               UMGLayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUMGBPFLibrary::GetUMGZOrder(EUMGLayer UMGLayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "GetUMGZOrder");

	Params::UMGBPFLibrary_GetUMGZOrder Parms{};

	Parms.UMGLayer = UMGLayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGBPFLibrary.InvalidateAllWidgets
// (Final, Native, Static, Public, BlueprintCallable)

void UUMGBPFLibrary::InvalidateAllWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "InvalidateAllWidgets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGBPFLibrary.IsActionInputTypeKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EActionInputType&                 ActionInputType                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUMGBPFLibrary::IsActionInputTypeKey(const class UObject* WorldContextObject, const struct FKey& Key, const EActionInputType& ActionInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "IsActionInputTypeKey");

	Params::UMGBPFLibrary_IsActionInputTypeKey Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Key = std::move(Key);
	Parms.ActionInputType = ActionInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGBPFLibrary.IsKeyUIInputType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUIInputType                            UIInputType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUMGBPFLibrary::IsKeyUIInputType(const class UObject* WorldContextObject, const struct FKey& Key, EUIInputType UIInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "IsKeyUIInputType");

	Params::UMGBPFLibrary_IsKeyUIInputType Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Key = std::move(Key);
	Parms.UIInputType = UIInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGBPFLibrary.IsRepeatKeyEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKeyEvent&                 KeyEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUMGBPFLibrary::IsRepeatKeyEvent(const struct FKeyEvent& KeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "IsRepeatKeyEvent");

	Params::UMGBPFLibrary_IsRepeatKeyEvent Parms{};

	Parms.KeyEvent = std::move(KeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGBPFLibrary.IsUICancelKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUMGBPFLibrary::IsUICancelKey(const class UObject* WorldContextObject, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "IsUICancelKey");

	Params::UMGBPFLibrary_IsUICancelKey Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGBPFLibrary.IsUIConfirmKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUMGBPFLibrary::IsUIConfirmKey(const class UObject* WorldContextObject, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "IsUIConfirmKey");

	Params::UMGBPFLibrary_IsUIConfirmKey Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGBPFLibrary.IsUIContextAltKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUMGBPFLibrary::IsUIContextAltKey(const class UObject* WorldContextObject, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "IsUIContextAltKey");

	Params::UMGBPFLibrary_IsUIContextAltKey Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGBPFLibrary.IsUIContextKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUMGBPFLibrary::IsUIContextKey(const class UObject* WorldContextObject, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "IsUIContextKey");

	Params::UMGBPFLibrary_IsUIContextKey Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGBPFLibrary.ResetAllNiagaraWidgets
// (Final, Native, Static, Public, BlueprintCallable)

void UUMGBPFLibrary::ResetAllNiagaraWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "ResetAllNiagaraWidgets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGBPFLibrary.SetBrushFromSoftSprite
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UImage*                           Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UPaperSprite>      SoftSprite                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMatchSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBPFLibrary::SetBrushFromSoftSprite(class UImage* Target, TSoftObjectPtr<class UPaperSprite> SoftSprite, bool bMatchSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "SetBrushFromSoftSprite");

	Params::UMGBPFLibrary_SetBrushFromSoftSprite Parms{};

	Parms.Target = Target;
	Parms.SoftSprite = SoftSprite;
	Parms.bMatchSize = bMatchSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGBPFLibrary.SetBrushFromSoftSpriteAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UImage*                           Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UPaperSprite>      SoftSprite                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMatchSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBPFLibrary::SetBrushFromSoftSpriteAsync(class UImage* Target, TSoftObjectPtr<class UPaperSprite> SoftSprite, bool bMatchSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "SetBrushFromSoftSpriteAsync");

	Params::UMGBPFLibrary_SetBrushFromSoftSpriteAsync Parms{};

	Parms.Target = Target;
	Parms.SoftSprite = SoftSprite;
	Parms.bMatchSize = bMatchSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGBPFLibrary.SetBrushFromSprite
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UImage*                           Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPaperSprite*                     Sprite                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMatchSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBPFLibrary::SetBrushFromSprite(class UImage* Target, class UPaperSprite* Sprite, bool bMatchSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "SetBrushFromSprite");

	Params::UMGBPFLibrary_SetBrushFromSprite Parms{};

	Parms.Target = Target;
	Parms.Sprite = Sprite;
	Parms.bMatchSize = bMatchSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGBPFLibrary.ShouldDisplayCompletionWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUMGBPFLibrary::ShouldDisplayCompletionWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "ShouldDisplayCompletionWidget");

	Params::UMGBPFLibrary_ShouldDisplayCompletionWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGBPFLibrary.ShouldDisplayExtraUnavailableCharacters
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUMGBPFLibrary::ShouldDisplayExtraUnavailableCharacters(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGBPFLibrary", "ShouldDisplayExtraUnavailableCharacters");

	Params::UMGBPFLibrary_ShouldDisplayExtraUnavailableCharacters Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGSubsystem.Get
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUMGSubsystem*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUMGSubsystem* UUMGSubsystem::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UMGSubsystem", "Get");

	Params::UMGSubsystem_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGSubsystem.ClearActiveFooter
// (Final, Native, Public, BlueprintCallable)

void UUMGSubsystem::ClearActiveFooter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubsystem", "ClearActiveFooter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGSubsystem.LockNavigation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      LockSource                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSubsystem::LockNavigation(class UUserWidget* LockSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubsystem", "LockNavigation");

	Params::UMGSubsystem_LockNavigation Parms{};

	Parms.LockSource = LockSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGSubsystem.RefreshNavigationLockState
// (Final, Native, Public, BlueprintCallable)

void UUMGSubsystem::RefreshNavigationLockState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubsystem", "RefreshNavigationLockState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGSubsystem.RemapKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUIInputType                            UIInputType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSubsystem::RemapKey(EUIInputType UIInputType, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubsystem", "RemapKey");

	Params::UMGSubsystem_RemapKey Parms{};

	Parms.UIInputType = UIInputType;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGSubsystem.ResetNavigationLocks
// (Final, Native, Public, BlueprintCallable)

void UUMGSubsystem::ResetNavigationLocks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubsystem", "ResetNavigationLocks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGSubsystem.RestoreDefaultBindings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bGamepad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSubsystem::RestoreDefaultBindings(bool bGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubsystem", "RestoreDefaultBindings");

	Params::UMGSubsystem_RestoreDefaultBindings Parms{};

	Parms.bGamepad = bGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGSubsystem.SetActiveExplanationWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidgetExplanation*           ExplanationWidget                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSubsystem::SetActiveExplanationWidget(class UUserWidgetExplanation* ExplanationWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubsystem", "SetActiveExplanationWidget");

	Params::UMGSubsystem_SetActiveExplanationWidget Parms{};

	Parms.ExplanationWidget = ExplanationWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGSubsystem.SetActiveFooter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidgetFooter*                Footer                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSubsystem::SetActiveFooter(class UUserWidgetFooter* Footer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubsystem", "SetActiveFooter");

	Params::UMGSubsystem_SetActiveFooter Parms{};

	Parms.Footer = Footer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGSubsystem.UnlockNavigation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      LockSource                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSubsystem::UnlockNavigation(class UUserWidget* LockSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubsystem", "UnlockNavigation");

	Params::UMGSubsystem_UnlockNavigation Parms{};

	Parms.LockSource = LockSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UMGSubsystem.GetActiveExplanationWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUserWidgetExplanation*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidgetExplanation* UUMGSubsystem::GetActiveExplanationWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubsystem", "GetActiveExplanationWidget");

	Params::UMGSubsystem_GetActiveExplanationWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGSubsystem.GetActiveFooter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUserWidgetFooter*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidgetFooter* UUMGSubsystem::GetActiveFooter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubsystem", "GetActiveFooter");

	Params::UMGSubsystem_GetActiveFooter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGSubsystem.IsFocusingFromMouse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUMGSubsystem::IsFocusingFromMouse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubsystem", "IsFocusingFromMouse");

	Params::UMGSubsystem_IsFocusingFromMouse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UMGSubsystem.IsNavigationLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUMGSubsystem::IsNavigationLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubsystem", "IsNavigationLocked");

	Params::UMGSubsystem_IsNavigationLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UniformGridPanelZion.AddChildAuto
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUniformGridPanelZion::AddChildAuto(class UWidget* Content)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UniformGridPanelZion", "AddChildAuto");

	Params::UniformGridPanelZion_AddChildAuto Parms{};

	Parms.Content = Content;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UniformGridPanelZion.GetElementCountPerRow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUniformGridPanelZion::GetElementCountPerRow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UniformGridPanelZion", "GetElementCountPerRow");

	Params::UniformGridPanelZion_GetElementCountPerRow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetAchievementNotificationHolder.LaunchNextNotification
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetAchievementNotificationHolder::LaunchNextNotification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetAchievementNotificationHolder", "LaunchNextNotification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetAchievementNotificationHolder.OnDisplayAchievementNotificationsChanged
// (Final, Native, Private)

void UUserWidgetAchievementNotificationHolder::OnDisplayAchievementNotificationsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetAchievementNotificationHolder", "OnDisplayAchievementNotificationsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetAchievementNotificationHolder.OnLaunchAchievementNotification
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      AchievementID                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetAchievementNotificationHolder::OnLaunchAchievementNotification(const class FName& AchievementID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetAchievementNotificationHolder", "OnLaunchAchievementNotification");

	Params::UserWidgetAchievementNotificationHolder_OnLaunchAchievementNotification Parms{};

	Parms.AchievementID = AchievementID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetAchievementNotificationHolder.OnRefreshVisibility
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetAchievementNotificationHolder::OnRefreshVisibility(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetAchievementNotificationHolder", "OnRefreshVisibility");

	Params::UserWidgetAchievementNotificationHolder_OnRefreshVisibility Parms{};

	Parms.bVisible = bVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetAchievementNotificationHolder.QueueAchievementNotification
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      AchievementID                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetAchievementNotificationHolder::QueueAchievementNotification(const class FName& AchievementID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetAchievementNotificationHolder", "QueueAchievementNotification");

	Params::UserWidgetAchievementNotificationHolder_QueueAchievementNotification Parms{};

	Parms.AchievementID = AchievementID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetButton.OnFocusStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bFocused                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetButton::OnFocusStateChanged(bool bFocused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetButton", "OnFocusStateChanged");

	Params::UserWidgetButton_OnFocusStateChanged Parms{};

	Parms.bFocused = bFocused;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetCurrencyCounter.AccumulatingCurrencyTimerFinished
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetCurrencyCounter::AccumulatingCurrencyTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "AccumulatingCurrencyTimerFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetCurrencyCounter.AddCurrency
// (Final, Native, Private, HasOutParams)
// Parameters:
// const ECurrencyType&                    InCurrencyType                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             AddedCount                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             PreviousCount                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetCurrencyCounter::AddCurrency(const ECurrencyType& InCurrencyType, const int32 AddedCount, const int32 PreviousCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "AddCurrency");

	Params::UserWidgetCurrencyCounter_AddCurrency Parms{};

	Parms.InCurrencyType = InCurrencyType;
	Parms.AddedCount = AddedCount;
	Parms.PreviousCount = PreviousCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetCurrencyCounter.Hide
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetCurrencyCounter::Hide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "Hide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetCurrencyCounter.OnAccumulatingCurrencyTimerFinished
// (Event, Public, BlueprintEvent)

void UUserWidgetCurrencyCounter::OnAccumulatingCurrencyTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "OnAccumulatingCurrencyTimerFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetCurrencyCounter.OnHide
// (Event, Public, BlueprintEvent)

void UUserWidgetCurrencyCounter::OnHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "OnHide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetCurrencyCounter.OnSetAccumulatedCurrencyText
// (Event, Public, BlueprintEvent)
// Parameters:
// const int32                             Currency                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetCurrencyCounter::OnSetAccumulatedCurrencyText(const int32 Currency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "OnSetAccumulatedCurrencyText");

	Params::UserWidgetCurrencyCounter_OnSetAccumulatedCurrencyText Parms{};

	Parms.Currency = Currency;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetCurrencyCounter.OnSetCurrencyText
// (Event, Public, BlueprintEvent)
// Parameters:
// const int32                             Currency                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetCurrencyCounter::OnSetCurrencyText(const int32 Currency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "OnSetCurrencyText");

	Params::UserWidgetCurrencyCounter_OnSetCurrencyText Parms{};

	Parms.Currency = Currency;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetCurrencyCounter.OnShow
// (Event, Public, BlueprintEvent)

void UUserWidgetCurrencyCounter::OnShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "OnShow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetCurrencyCounter.OnStartAccumulatingCurrency
// (Event, Public, BlueprintEvent)

void UUserWidgetCurrencyCounter::OnStartAccumulatingCurrency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "OnStartAccumulatingCurrency");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetCurrencyCounter.SetAccumulatedCurrencyText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Currency                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetCurrencyCounter::SetAccumulatedCurrencyText(const int32 Currency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "SetAccumulatedCurrencyText");

	Params::UserWidgetCurrencyCounter_SetAccumulatedCurrencyText Parms{};

	Parms.Currency = Currency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetCurrencyCounter.SetCurrencyText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Currency                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetCurrencyCounter::SetCurrencyText(const int32 Currency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "SetCurrencyText");

	Params::UserWidgetCurrencyCounter_SetCurrencyText Parms{};

	Parms.Currency = Currency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetCurrencyCounter.Show
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bRefreshCurrencyText                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetCurrencyCounter::Show(const bool bRefreshCurrencyText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "Show");

	Params::UserWidgetCurrencyCounter_Show Parms{};

	Parms.bRefreshCurrencyText = bRefreshCurrencyText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetCurrencyCounter.StartAccumulatingCurrency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InAccumulatedCurrency                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetCurrencyCounter::StartAccumulatingCurrency(const int32 InAccumulatedCurrency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "StartAccumulatingCurrency");

	Params::UserWidgetCurrencyCounter_StartAccumulatingCurrency Parms{};

	Parms.InAccumulatedCurrency = InAccumulatedCurrency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetCurrencyCounter.StartAddingCurrency
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetCurrencyCounter::StartAddingCurrency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "StartAddingCurrency");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetCurrencyCounter.WaitingTimerFinished
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetCurrencyCounter::WaitingTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "WaitingTimerFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetCurrencyCounter.GetCurrencyFromInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserWidgetCurrencyCounter::GetCurrencyFromInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "GetCurrencyFromInventory");

	Params::UserWidgetCurrencyCounter_GetCurrencyFromInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetCurrencyCounter.GetCurrencyType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECurrencyType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECurrencyType UUserWidgetCurrencyCounter::GetCurrencyType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCurrencyCounter", "GetCurrencyType");

	Params::UserWidgetCurrencyCounter_GetCurrencyType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetCursor.OnCursorVisibilityChanged
// (Final, Native, Private)

void UUserWidgetCursor::OnCursorVisibilityChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCursor", "OnCursorVisibilityChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetCursor.SetVisible
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetCursor::SetVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetCursor", "SetVisible");

	Params::UserWidgetCursor_SetVisible Parms{};

	Parms.bVisible = bVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetEnemyUI.OnRequestRemoveFromParent
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bImmediate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetEnemyUI::OnRequestRemoveFromParent(bool bImmediate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEnemyUI", "OnRequestRemoveFromParent");

	Params::UserWidgetEnemyUI_OnRequestRemoveFromParent Parms{};

	Parms.bImmediate = bImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetEnemyUI.GetController
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AAIController*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAIController* UUserWidgetEnemyUI::GetController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEnemyUI", "GetController");

	Params::UserWidgetEnemyUI_GetController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetEnemyUI.GetEnemyData
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FEnemyData                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FEnemyData UUserWidgetEnemyUI::GetEnemyData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEnemyUI", "GetEnemyData");

	Params::UserWidgetEnemyUI_GetEnemyData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetEnemyUI.GetPawn
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UUserWidgetEnemyUI::GetPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEnemyUI", "GetPawn");

	Params::UserWidgetEnemyUI_GetPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetEvent.CompleteChoices
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   SelectedChoiceIndex                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetEvent::CompleteChoices(int32 SelectedChoiceIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEvent", "CompleteChoices");

	Params::UserWidgetEvent_CompleteChoices Parms{};

	Parms.SelectedChoiceIndex = SelectedChoiceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetEvent.CompleteTalk
// (Final, Native, Protected, BlueprintCallable)

void UUserWidgetEvent::CompleteTalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEvent", "CompleteTalk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetEvent.OnNotifyEventStartPlaying
// (Event, Protected, BlueprintEvent)

void UUserWidgetEvent::OnNotifyEventStartPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEvent", "OnNotifyEventStartPlaying");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetEvent.OnPlayChoices
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      SpeakerName                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class FText>&              Choices                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidgetEvent::OnPlayChoices(const class FText& SpeakerName, const class FText& Text, const TArray<class FText>& Choices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEvent", "OnPlayChoices");

	Params::UserWidgetEvent_OnPlayChoices Parms{};

	Parms.SpeakerName = std::move(SpeakerName);
	Parms.Text = std::move(Text);
	Parms.Choices = std::move(Choices);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetEvent.OnRequestRemoveFromParent
// (Native, Event, Protected, BlueprintEvent)

void UUserWidgetEvent::OnRequestRemoveFromParent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEvent", "OnRequestRemoveFromParent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetEvent.OnTalk
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      SpeakerName                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetEvent::OnTalk(const class FText& SpeakerName, const class FText& Text, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEvent", "OnTalk");

	Params::UserWidgetEvent_OnTalk Parms{};

	Parms.SpeakerName = std::move(SpeakerName);
	Parms.Text = std::move(Text);
	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetEvent.CanAutoSkipEvent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetEvent::CanAutoSkipEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEvent", "CanAutoSkipEvent");

	Params::UserWidgetEvent_CanAutoSkipEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetEvent.CanSkipEvent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetEvent::CanSkipEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEvent", "CanSkipEvent");

	Params::UserWidgetEvent_CanSkipEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetEvent.GetEventPlayer
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEventPlayer*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventPlayer* UUserWidgetEvent::GetEventPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEvent", "GetEventPlayer");

	Params::UserWidgetEvent_GetEventPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetEvent.IsEventAlreadySeen
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetEvent::IsEventAlreadySeen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEvent", "IsEventAlreadySeen");

	Params::UserWidgetEvent_IsEventAlreadySeen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetEvent.ShouldUsePostSkipFadeIn
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetEvent::ShouldUsePostSkipFadeIn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEvent", "ShouldUsePostSkipFadeIn");

	Params::UserWidgetEvent_ShouldUsePostSkipFadeIn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetEvent.ShouldUsePreSkipFadeOut
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetEvent::ShouldUsePreSkipFadeOut() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetEvent", "ShouldUsePreSkipFadeOut");

	Params::UserWidgetEvent_ShouldUsePreSkipFadeOut Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetExtraDialogGalleryImage.Clear
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetExtraDialogGalleryImage::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogGalleryImage", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExtraDialogGalleryImage.ClearInputs
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetExtraDialogGalleryImage::ClearInputs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogGalleryImage", "ClearInputs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExtraDialogGalleryImage.MoveImage
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 InMoveDelta                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetExtraDialogGalleryImage::MoveImage(const struct FVector2D& InMoveDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogGalleryImage", "MoveImage");

	Params::UserWidgetExtraDialogGalleryImage_MoveImage Parms{};

	Parms.InMoveDelta = std::move(InMoveDelta);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExtraDialogGalleryImage.PlaceImage
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 NewImagePosition                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetExtraDialogGalleryImage::PlaceImage(const struct FVector2D& NewImagePosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogGalleryImage", "PlaceImage");

	Params::UserWidgetExtraDialogGalleryImage_PlaceImage Parms{};

	Parms.NewImagePosition = std::move(NewImagePosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExtraDialogGalleryImage.SetupImageMinMaxPositions
// (Final, Native, Protected, BlueprintCallable)

void UUserWidgetExtraDialogGalleryImage::SetupImageMinMaxPositions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogGalleryImage", "SetupImageMinMaxPositions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExtraDialogGalleryImage.GetCurrentScaleFactor
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUserWidgetExtraDialogGalleryImage::GetCurrentScaleFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogGalleryImage", "GetCurrentScaleFactor");

	Params::UserWidgetExtraDialogGalleryImage_GetCurrentScaleFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetExtraDialogSpineViewer.ClearInputs
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetExtraDialogSpineViewer::ClearInputs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogSpineViewer", "ClearInputs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExtraDialogSpineViewer.ClearSpineAnimation
// (Final, Native, Protected, BlueprintCallable)

void UUserWidgetExtraDialogSpineViewer::ClearSpineAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogSpineViewer", "ClearSpineAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExtraDialogSpineViewer.HandleFocusAfterMouseClick
// (Event, Protected, BlueprintEvent)

void UUserWidgetExtraDialogSpineViewer::HandleFocusAfterMouseClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogSpineViewer", "HandleFocusAfterMouseClick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetExtraDialogSpineViewer.OnAfterUpdateWorldTransform
// (Final, Native, Protected)
// Parameters:
// class USpineWidget*                     Skeleton                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetExtraDialogSpineViewer::OnAfterUpdateWorldTransform(class USpineWidget* Skeleton)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogSpineViewer", "OnAfterUpdateWorldTransform");

	Params::UserWidgetExtraDialogSpineViewer_OnAfterUpdateWorldTransform Parms{};

	Parms.Skeleton = Skeleton;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExtraDialogSpineViewer.OnSpineAnimationFinished
// (Final, Native, Private)
// Parameters:
// class UTrackEntry*                      TrackEntry                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetExtraDialogSpineViewer::OnSpineAnimationFinished(class UTrackEntry* TrackEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogSpineViewer", "OnSpineAnimationFinished");

	Params::UserWidgetExtraDialogSpineViewer_OnSpineAnimationFinished Parms{};

	Parms.TrackEntry = TrackEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExtraDialogSpineViewer.PlayAdditionalAnimations
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FString>&            AdditionalAnimations                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidgetExtraDialogSpineViewer::PlayAdditionalAnimations(const TArray<class FString>& AdditionalAnimations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogSpineViewer", "PlayAdditionalAnimations");

	Params::UserWidgetExtraDialogSpineViewer_PlayAdditionalAnimations Parms{};

	Parms.AdditionalAnimations = std::move(AdditionalAnimations);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExtraDialogSpineViewer.PlaySpineAnimation
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimationNameData&        AnimationNameData                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EExtraAnimationRootMotionMode           RootMotionMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetExtraDialogSpineViewer::PlaySpineAnimation(const struct FAnimationNameData& AnimationNameData, EExtraAnimationRootMotionMode RootMotionMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogSpineViewer", "PlaySpineAnimation");

	Params::UserWidgetExtraDialogSpineViewer_PlaySpineAnimation Parms{};

	Parms.AnimationNameData = std::move(AnimationNameData);
	Parms.RootMotionMode = RootMotionMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExtraDialogSpineViewer.ReplaceSpineMaterials
// (Final, Native, Protected, BlueprintCallable)

void UUserWidgetExtraDialogSpineViewer::ReplaceSpineMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogSpineViewer", "ReplaceSpineMaterials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExtraDialogSpineViewer.ResetSpineViewerToDefaultLocation
// (Final, Native, Protected, BlueprintCallable)

void UUserWidgetExtraDialogSpineViewer::ResetSpineViewerToDefaultLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogSpineViewer", "ResetSpineViewerToDefaultLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExtraDialogSpineViewer.SetupMinMaxPositions
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   MinScaleFactor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetExtraDialogSpineViewer::SetupMinMaxPositions(float MinScaleFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogSpineViewer", "SetupMinMaxPositions");

	Params::UserWidgetExtraDialogSpineViewer_SetupMinMaxPositions Parms{};

	Parms.MinScaleFactor = MinScaleFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetExtraDialogSpineViewer.CanMoveSpineViewer
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetExtraDialogSpineViewer::CanMoveSpineViewer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetExtraDialogSpineViewer", "CanMoveSpineViewer");

	Params::UserWidgetExtraDialogSpineViewer_CanMoveSpineViewer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetFade.LaunchFadeIn
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FFadeParameters&           FadeParameters                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidgetFade::LaunchFadeIn(const struct FFadeParameters& FadeParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetFade", "LaunchFadeIn");

	Params::UserWidgetFade_LaunchFadeIn Parms{};

	Parms.FadeParameters = std::move(FadeParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetFade.LaunchFadeOut
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FFadeParameters&           FadeParameters                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidgetFade::LaunchFadeOut(const struct FFadeParameters& FadeParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetFade", "LaunchFadeOut");

	Params::UserWidgetFade_LaunchFadeOut Parms{};

	Parms.FadeParameters = std::move(FadeParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetFade.NotifyFadeInFinished
// (Final, Native, Protected, BlueprintCallable)

void UUserWidgetFade::NotifyFadeInFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetFade", "NotifyFadeInFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetFade.NotifyFadeOutFinished
// (Final, Native, Protected, BlueprintCallable)

void UUserWidgetFade::NotifyFadeOutFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetFade", "NotifyFadeOutFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetFade.SetupFadeIn
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FFadeParameters&           FadeParameters                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidgetFade::SetupFadeIn(const struct FFadeParameters& FadeParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetFade", "SetupFadeIn");

	Params::UserWidgetFade_SetupFadeIn Parms{};

	Parms.FadeParameters = std::move(FadeParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetFieldTalkHolder.OnFinishFieldTalk
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bSkipActiveFieldTalk                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetFieldTalkHolder::OnFinishFieldTalk(bool bSkipActiveFieldTalk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetFieldTalkHolder", "OnFinishFieldTalk");

	Params::UserWidgetFieldTalkHolder_OnFinishFieldTalk Parms{};

	Parms.bSkipActiveFieldTalk = bSkipActiveFieldTalk;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetFieldTalkHolder.OnLaunchFieldTalk
// (Event, Protected, BlueprintEvent)

void UUserWidgetFieldTalkHolder::OnLaunchFieldTalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetFieldTalkHolder", "OnLaunchFieldTalk");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetFieldTalkHolder.OnShowText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FFieldTalkEntry&           FieldTalkEntry                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidgetFieldTalkHolder::OnShowText(const struct FFieldTalkEntry& FieldTalkEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetFieldTalkHolder", "OnShowText");

	Params::UserWidgetFieldTalkHolder_OnShowText Parms{};

	Parms.FieldTalkEntry = std::move(FieldTalkEntry);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetFieldTalkHolder.IsUIReady
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetFieldTalkHolder::IsUIReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetFieldTalkHolder", "IsUIReady");

	Params::UserWidgetFieldTalkHolder_IsUIReady Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetFooter.AddEntries
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FFooterData>&       FooterDataList                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTemporary                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetFooter::AddEntries(const TArray<struct FFooterData>& FooterDataList, bool bTemporary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetFooter", "AddEntries");

	Params::UserWidgetFooter_AddEntries Parms{};

	Parms.FooterDataList = std::move(FooterDataList);
	Parms.bTemporary = bTemporary;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetFooter.AddEntry
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FFooterData&               FooterData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTemporary                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetFooter::AddEntry(const struct FFooterData& FooterData, bool bTemporary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetFooter", "AddEntry");

	Params::UserWidgetFooter_AddEntry Parms{};

	Parms.FooterData = std::move(FooterData);
	Parms.bTemporary = bTemporary;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetFooter.ClearEntries
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bTemporaryOnly                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetFooter::ClearEntries(bool bTemporaryOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetFooter", "ClearEntries");

	Params::UserWidgetFooter_ClearEntries Parms{};

	Parms.bTemporaryOnly = bTemporaryOnly;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetFooter.SetEntriesVisible
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetFooter::SetEntriesVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetFooter", "SetEntriesVisible");

	Params::UserWidgetFooter_SetEntriesVisible Parms{};

	Parms.bVisible = bVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetFooter.Setup
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FFooterData>&       FooterDataList                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidgetFooter::Setup(const TArray<struct FFooterData>& FooterDataList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetFooter", "Setup");

	Params::UserWidgetFooter_Setup Parms{};

	Parms.FooterDataList = std::move(FooterDataList);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetGameMenu.GoToPage
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   PageIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetGameMenu::GoToPage(int32 PageIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu", "GoToPage");

	Params::UserWidgetGameMenu_GoToPage Parms{};

	Parms.PageIndex = PageIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetGameMenu.NotifyFastTravelRequested
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      RestPointID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRestPointData&            RestPointData                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidgetGameMenu::NotifyFastTravelRequested(const class FName& RestPointID, const struct FRestPointData& RestPointData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu", "NotifyFastTravelRequested");

	Params::UserWidgetGameMenu_NotifyFastTravelRequested Parms{};

	Parms.RestPointID = RestPointID;
	Parms.RestPointData = std::move(RestPointData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetGameMenu.OnFastTravelRequested
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      RestPointID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRestPointData&            RestPointData                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidgetGameMenu::OnFastTravelRequested(const class FName& RestPointID, const struct FRestPointData& RestPointData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu", "OnFastTravelRequested");

	Params::UserWidgetGameMenu_OnFastTravelRequested Parms{};

	Parms.RestPointID = RestPointID;
	Parms.RestPointData = std::move(RestPointData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetGameMenu.OnPageChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   NewPageIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetGameMenu::OnPageChanged(int32 NewPageIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu", "OnPageChanged");

	Params::UserWidgetGameMenu_OnPageChanged Parms{};

	Parms.NewPageIndex = NewPageIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetGameMenu.CanSwitchEquipment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetGameMenu::CanSwitchEquipment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu", "CanSwitchEquipment");

	Params::UserWidgetGameMenu_CanSwitchEquipment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetGameMenu.GetCurrentPageIndex
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserWidgetGameMenu::GetCurrentPageIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu", "GetCurrentPageIndex");

	Params::UserWidgetGameMenu_GetCurrentPageIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetGameMenu.GetFooter
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UUserWidgetFooter*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidgetFooter* UUserWidgetGameMenu::GetFooter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu", "GetFooter");

	Params::UserWidgetGameMenu_GetFooter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetGameMenu.GetPageCount
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserWidgetGameMenu::GetPageCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu", "GetPageCount");

	Params::UserWidgetGameMenu_GetPageCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetGameMenu.IsAtRestPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetGameMenu::IsAtRestPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu", "IsAtRestPoint");

	Params::UserWidgetGameMenu_IsAtRestPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetGameMenu_Page.OnPageClosed
// (Event, Public, BlueprintEvent)

void UUserWidgetGameMenu_Page::OnPageClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu_Page", "OnPageClosed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetGameMenu_Page.OnPageOpened
// (Event, Public, BlueprintEvent)

void UUserWidgetGameMenu_Page::OnPageOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu_Page", "OnPageOpened");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetGameMenu_Page.CanSwitchEquipment
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetGameMenu_Page::CanSwitchEquipment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu_Page", "CanSwitchEquipment");

	Params::UserWidgetGameMenu_Page_CanSwitchEquipment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetGameMenu_Page.GetDefaultFooterEntries
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FFooterData>        ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FFooterData> UUserWidgetGameMenu_Page::GetDefaultFooterEntries() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu_Page", "GetDefaultFooterEntries");

	Params::UserWidgetGameMenu_Page_GetDefaultFooterEntries Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetGameMenu_Page.GetFooter
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUserWidgetFooter*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidgetFooter* UUserWidgetGameMenu_Page::GetFooter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu_Page", "GetFooter");

	Params::UserWidgetGameMenu_Page_GetFooter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetGameMenu_Page.GetGameMenu
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUserWidgetGameMenu*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidgetGameMenu* UUserWidgetGameMenu_Page::GetGameMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu_Page", "GetGameMenu");

	Params::UserWidgetGameMenu_Page_GetGameMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetGameMenu_Page.IsAtRestPoint
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetGameMenu_Page::IsAtRestPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetGameMenu_Page", "IsAtRestPoint");

	Params::UserWidgetGameMenu_Page_IsAtRestPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetLowHPFeedback.BindToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetLowHPFeedback::BindToActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetLowHPFeedback", "BindToActor");

	Params::UserWidgetLowHPFeedback_BindToActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMap.Clear
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetMap::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMap.ClearInputs
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetMap::ClearInputs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "ClearInputs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMap.DebugMarkAllMapIconsAsSeen
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetMap::DebugMarkAllMapIconsAsSeen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "DebugMarkAllMapIconsAsSeen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMap.DebugMarkAllMapZonesAsVisited
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetMap::DebugMarkAllMapZonesAsVisited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "DebugMarkAllMapZonesAsVisited");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMap.ForceTargetIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidgetMapIcon*               Icon                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMap::ForceTargetIcon(class UUserWidgetMapIcon* Icon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "ForceTargetIcon");

	Params::UserWidgetMap_ForceTargetIcon Parms{};

	Parms.Icon = Icon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMap.MoveMap
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 InMoveDelta                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMap::MoveMap(const struct FVector2D& InMoveDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "MoveMap");

	Params::UserWidgetMap_MoveMap Parms{};

	Parms.InMoveDelta = std::move(InMoveDelta);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMap.OnCalculateMapCompletionPercentage
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMap::OnCalculateMapCompletionPercentage(int32 Percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "OnCalculateMapCompletionPercentage");

	Params::UserWidgetMap_OnCalculateMapCompletionPercentage Parms{};

	Parms.Percentage = Percentage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetMap.OnChangeMapAreaUnderCursor
// (Event, Public, BlueprintEvent)
// Parameters:
// class UUserWidgetMapArea*               MapArea                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMap::OnChangeMapAreaUnderCursor(class UUserWidgetMapArea* MapArea)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "OnChangeMapAreaUnderCursor");

	Params::UserWidgetMap_OnChangeMapAreaUnderCursor Parms{};

	Parms.MapArea = MapArea;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetMap.OnNoCustomMarkerAvailable
// (Event, Public, BlueprintEvent)

void UUserWidgetMap::OnNoCustomMarkerAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "OnNoCustomMarkerAvailable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetMap.OnReachedTargetedIcon
// (Event, Public, BlueprintEvent)
// Parameters:
// class UUserWidgetMapIcon*               MapIcon                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMap::OnReachedTargetedIcon(class UUserWidgetMapIcon* MapIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "OnReachedTargetedIcon");

	Params::UserWidgetMap_OnReachedTargetedIcon Parms{};

	Parms.MapIcon = MapIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetMap.OnRefreshCustomMarkerAvailableCount
// (Event, Public, BlueprintEvent)

void UUserWidgetMap::OnRefreshCustomMarkerAvailableCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "OnRefreshCustomMarkerAvailableCount");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetMap.OnRefreshRemoveAllCustomMarkersHoldTime
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   CurrentHoldingTime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HoldingDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMap::OnRefreshRemoveAllCustomMarkersHoldTime(float CurrentHoldingTime, float HoldingDuration, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "OnRefreshRemoveAllCustomMarkersHoldTime");

	Params::UserWidgetMap_OnRefreshRemoveAllCustomMarkersHoldTime Parms{};

	Parms.CurrentHoldingTime = CurrentHoldingTime;
	Parms.HoldingDuration = HoldingDuration;
	Parms.Alpha = Alpha;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetMap.OnResetMapAreaUnderCursor
// (Event, Public, BlueprintEvent)
// Parameters:
// class UUserWidgetMapArea*               MapArea                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMap::OnResetMapAreaUnderCursor(class UUserWidgetMapArea* MapArea)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "OnResetMapAreaUnderCursor");

	Params::UserWidgetMap_OnResetMapAreaUnderCursor Parms{};

	Parms.MapArea = MapArea;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetMap.OnResetTargetedIcon
// (Event, Public, BlueprintEvent)
// Parameters:
// class UUserWidgetMapIcon*               MapIcon                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMap::OnResetTargetedIcon(class UUserWidgetMapIcon* MapIcon, bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "OnResetTargetedIcon");

	Params::UserWidgetMap_OnResetTargetedIcon Parms{};

	Parms.MapIcon = MapIcon;
	Parms.bInstant = bInstant;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetMap.OnRestPointListInitialized
// (Event, Public, BlueprintEvent)

void UUserWidgetMap::OnRestPointListInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "OnRestPointListInitialized");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetMap.OnToggleRestPointList
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bRestPointListOpened                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMap::OnToggleRestPointList(bool bRestPointListOpened, bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "OnToggleRestPointList");

	Params::UserWidgetMap_OnToggleRestPointList Parms{};

	Parms.bRestPointListOpened = bRestPointListOpened;
	Parms.bInstant = bInstant;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetMap.RemoveCustomMarkerUnderCursor
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UUserWidgetMapIcon_CustomMarker*  CustomMarkerIcon                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMap::RemoveCustomMarkerUnderCursor(class UUserWidgetMapIcon_CustomMarker* CustomMarkerIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "RemoveCustomMarkerUnderCursor");

	Params::UserWidgetMap_RemoveCustomMarkerUnderCursor Parms{};

	Parms.CustomMarkerIcon = CustomMarkerIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMap.SetNewZoomScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewZoomScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMap::SetNewZoomScale(float NewZoomScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "SetNewZoomScale");

	Params::UserWidgetMap_SetNewZoomScale Parms{};

	Parms.NewZoomScale = NewZoomScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMap.ShowAllMapIcons
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetMap::ShowAllMapIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "ShowAllMapIcons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMap.Zoom
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InZoomDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMap::Zoom(float InZoomDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "Zoom");

	Params::UserWidgetMap_Zoom Parms{};

	Parms.InZoomDelta = InZoomDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMap.GetCustomMarkerAvailableCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserWidgetMap::GetCustomMarkerAvailableCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "GetCustomMarkerAvailableCount");

	Params::UserWidgetMap_GetCustomMarkerAvailableCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMap.GetMapCompletionPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserWidgetMap::GetMapCompletionPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "GetMapCompletionPercentage");

	Params::UserWidgetMap_GetMapCompletionPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMap.HasValidData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetMap::HasValidData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "HasValidData");

	Params::UserWidgetMap_HasValidData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMap.IsMapAreaVisited
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UUserWidgetMapArea*         MapAreaWidget                                          (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetMap::IsMapAreaVisited(const class UUserWidgetMapArea* MapAreaWidget) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "IsMapAreaVisited");

	Params::UserWidgetMap_IsMapAreaVisited Parms{};

	Parms.MapAreaWidget = MapAreaWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMap.IsRestPointListOpened
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetMap::IsRestPointListOpened() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMap", "IsRestPointListOpened");

	Params::UserWidgetMap_IsRestPointListOpened Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIconDetails.OnRemoveIconDetails
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMapIconDetails::OnRemoveIconDetails(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIconDetails", "OnRemoveIconDetails");

	Params::UserWidgetMapIconDetails_OnRemoveIconDetails Parms{};

	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapIconDetails.OnShowIconDetails
// (Native, Event, Public, BlueprintEvent)

void UUserWidgetMapIconDetails::OnShowIconDetails()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIconDetails", "OnShowIconDetails");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapIconDetails.RemoveIconDetails
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMapIconDetails::RemoveIconDetails(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIconDetails", "RemoveIconDetails");

	Params::UserWidgetMapIconDetails_RemoveIconDetails Parms{};

	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapIconDetails.SetIsRestPointListOpened
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsOpened                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetMapIconDetails::SetIsRestPointListOpened(bool bIsOpened)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIconDetails", "SetIsRestPointListOpened");

	Params::UserWidgetMapIconDetails_SetIsRestPointListOpened Parms{};

	Parms.bIsOpened = bIsOpened;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIconDetails.ShowIconDetails
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetMapIconDetails::ShowIconDetails()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIconDetails", "ShowIconDetails");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapIcon.HideIcon
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UUserWidgetMapIcon::HideIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon", "HideIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapIcon.OnAptitudesChanged
// (Final, Native, Protected)

void UUserWidgetMapIcon::OnAptitudesChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon", "OnAptitudesChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapIcon.OnItemAdded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const class UInventory*                 Inventory                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddedCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMapIcon::OnItemAdded(const class UInventory* Inventory, const class FName& ItemId, int32 AddedCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon", "OnItemAdded");

	Params::UserWidgetMapIcon_OnItemAdded Parms{};

	Parms.Inventory = Inventory;
	Parms.ItemId = ItemId;
	Parms.AddedCount = AddedCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapIcon.SetIconFromSoftSprite
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UPaperSprite>      NewIcon                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMatchSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMapIcon::SetIconFromSoftSprite(TSoftObjectPtr<class UPaperSprite> NewIcon, bool bMatchSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon", "SetIconFromSoftSprite");

	Params::UserWidgetMapIcon_SetIconFromSoftSprite Parms{};

	Parms.NewIcon = NewIcon;
	Parms.bMatchSize = bMatchSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapIcon.ShowIcon
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UUserWidgetMapIcon::ShowIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon", "ShowIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapIcon.GetAptitudeRequired
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAptitudeType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAptitudeType UUserWidgetMapIcon::GetAptitudeRequired() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon", "GetAptitudeRequired");

	Params::UserWidgetMapIcon_GetAptitudeRequired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIcon.GetItemsRequired
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FDataTableRowHandle>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FDataTableRowHandle> UUserWidgetMapIcon::GetItemsRequired() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon", "GetItemsRequired");

	Params::UserWidgetMapIcon_GetItemsRequired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIcon.GetMapIconType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMapIconType                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMapIconType UUserWidgetMapIcon::GetMapIconType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon", "GetMapIconType");

	Params::UserWidgetMapIcon_GetMapIconType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIcon.GetWidgetIconDetailsClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UUserWidgetMapIconDetails>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UUserWidgetMapIconDetails> UUserWidgetMapIcon::GetWidgetIconDetailsClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon", "GetWidgetIconDetailsClass");

	Params::UserWidgetMapIcon_GetWidgetIconDetailsClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIcon.GetWidgetIconDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUserWidgetMapIcon::GetWidgetIconDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon", "GetWidgetIconDisplayName");

	Params::UserWidgetMapIcon_GetWidgetIconDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIcon_CustomMarker.OnSetCustomMarkerData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FMapCustomMarkerIconData&  NewCustomMarkerData                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMapIcon_CustomMarker::OnSetCustomMarkerData(const struct FMapCustomMarkerIconData& NewCustomMarkerData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon_CustomMarker", "OnSetCustomMarkerData");

	Params::UserWidgetMapIcon_CustomMarker_OnSetCustomMarkerData Parms{};

	Parms.NewCustomMarkerData = std::move(NewCustomMarkerData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetMapIcon_CustomMarker.OnSetScale
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   NewScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMapIcon_CustomMarker::OnSetScale(float NewScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon_CustomMarker", "OnSetScale");

	Params::UserWidgetMapIcon_CustomMarker_OnSetScale Parms{};

	Parms.NewScale = NewScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetMapIcon_CustomMarker.SetScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMapIcon_CustomMarker::SetScale(float NewScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon_CustomMarker", "SetScale");

	Params::UserWidgetMapIcon_CustomMarker_SetScale Parms{};

	Parms.NewScale = NewScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapIcon_CustomMarker.GetCustomMarkerDisplayID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserWidgetMapIcon_CustomMarker::GetCustomMarkerDisplayID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon_CustomMarker", "GetCustomMarkerDisplayID");

	Params::UserWidgetMapIcon_CustomMarker_GetCustomMarkerDisplayID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIcon_CustomMarker.GetCustomMarkerIconData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMapCustomMarkerIconData   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FMapCustomMarkerIconData UUserWidgetMapIcon_CustomMarker::GetCustomMarkerIconData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon_CustomMarker", "GetCustomMarkerIconData");

	Params::UserWidgetMapIcon_CustomMarker_GetCustomMarkerIconData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIcon_Actor.SetActorData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FClearActorData&           InActorData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMapIcon_Actor::SetActorData(const struct FClearActorData& InActorData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon_Actor", "SetActorData");

	Params::UserWidgetMapIcon_Actor_SetActorData Parms{};

	Parms.InActorData = std::move(InActorData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapIcon_Actor.GetActorData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FClearActorData            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FClearActorData UUserWidgetMapIcon_Actor::GetActorData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon_Actor", "GetActorData");

	Params::UserWidgetMapIcon_Actor_GetActorData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIcon_RestPoint.SetRestPointData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMapRestPointData&         InRestPointData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidgetMapIcon_RestPoint::SetRestPointData(const struct FMapRestPointData& InRestPointData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon_RestPoint", "SetRestPointData");

	Params::UserWidgetMapIcon_RestPoint_SetRestPointData Parms{};

	Parms.InRestPointData = std::move(InRestPointData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapIcon_RestPoint.GetRestPointData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMapRestPointData                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMapRestPointData UUserWidgetMapIcon_RestPoint::GetRestPointData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon_RestPoint", "GetRestPointData");

	Params::UserWidgetMapIcon_RestPoint_GetRestPointData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIcon_Teleport.GetDestinationWorldLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UUserWidgetMapIcon_Teleport::GetDestinationWorldLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon_Teleport", "GetDestinationWorldLocation");

	Params::UserWidgetMapIcon_Teleport_GetDestinationWorldLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIcon_Teleport.GetMapTransitionHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDataTableRowHandle              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDataTableRowHandle UUserWidgetMapIcon_Teleport::GetMapTransitionHandle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon_Teleport", "GetMapTransitionHandle");

	Params::UserWidgetMapIcon_Teleport_GetMapTransitionHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIcon_Teleport.GetStartWorldLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UUserWidgetMapIcon_Teleport::GetStartWorldLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon_Teleport", "GetStartWorldLocation");

	Params::UserWidgetMapIcon_Teleport_GetStartWorldLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIcon_Teleport.GetToDestination_MapSpace
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UUserWidgetMapIcon_Teleport::GetToDestination_MapSpace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon_Teleport", "GetToDestination_MapSpace");

	Params::UserWidgetMapIcon_Teleport_GetToDestination_MapSpace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapIcon_Clearable.ClearIcon
// (Native, Event, Public, BlueprintEvent)

void UUserWidgetMapIcon_Clearable::ClearIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapIcon_Clearable", "ClearIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapZone.CompleteZone
// (Native, Event, Public, BlueprintEvent)

void UUserWidgetMapZone::CompleteZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapZone", "CompleteZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapZone.HideZone
// (Native, Event, Public, BlueprintEvent)

void UUserWidgetMapZone::HideZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapZone", "HideZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapZone.RevealZone
// (Native, Event, Public, BlueprintEvent)

void UUserWidgetMapZone::RevealZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapZone", "RevealZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapZone.ShowZone
// (Native, Event, Public, BlueprintEvent)

void UUserWidgetMapZone::ShowZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapZone", "ShowZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapZone.VisitZone
// (Native, Event, Public, BlueprintEvent)

void UUserWidgetMapZone::VisitZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapZone", "VisitZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapZone.IsCleared
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetMapZone::IsCleared() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapZone", "IsCleared");

	Params::UserWidgetMapZone_IsCleared Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapArea.ShowAllMapAreaIcons
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetMapArea::ShowAllMapAreaIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapArea", "ShowAllMapAreaIcons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetMapArea.GetClearedZoneCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserWidgetMapArea::GetClearedZoneCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapArea", "GetClearedZoneCount");

	Params::UserWidgetMapArea_GetClearedZoneCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapArea.GetCompletionPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserWidgetMapArea::GetCompletionPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapArea", "GetCompletionPercentage");

	Params::UserWidgetMapArea_GetCompletionPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapArea.GetMapName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UUserWidgetMapArea::GetMapName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapArea", "GetMapName");

	Params::UserWidgetMapArea_GetMapName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapArea.GetZoneCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserWidgetMapArea::GetZoneCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapArea", "GetZoneCount");

	Params::UserWidgetMapArea_GetZoneCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetMapArea.OnZoneVisited
// (Final, Native, Private, Const)
// Parameters:
// class AStaticVolume_Zone*               ZoneVisited                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetMapArea::OnZoneVisited(class AStaticVolume_Zone* ZoneVisited) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetMapArea", "OnZoneVisited");

	Params::UserWidgetMapArea_OnZoneVisited Parms{};

	Parms.ZoneVisited = ZoneVisited;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetNotificationHolder.OnDisplayHolder
// (Event, Protected, BlueprintEvent)

void UUserWidgetNotificationHolder::OnDisplayHolder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetNotificationHolder", "OnDisplayHolder");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetNotificationHolder.OnHide
// (Event, Protected, BlueprintEvent)

void UUserWidgetNotificationHolder::OnHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetNotificationHolder", "OnHide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Zion.UserWidgetNotificationHolder.OnLaunchNotification
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FNotificationData&         NotificationData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidgetNotificationHolder::OnLaunchNotification(const struct FNotificationData& NotificationData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetNotificationHolder", "OnLaunchNotification");

	Params::UserWidgetNotificationHolder_OnLaunchNotification Parms{};

	Parms.NotificationData = std::move(NotificationData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetNotificationHolder.IsUIReady
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetNotificationHolder::IsUIReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetNotificationHolder", "IsUIReady");

	Params::UserWidgetNotificationHolder_IsUIReady Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetRestPointList.ChangeMapArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   IndexOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidgetMapIcon_RestPoint*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidgetMapIcon_RestPoint* UUserWidgetRestPointList::ChangeMapArea(int32 IndexOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "ChangeMapArea");

	Params::UserWidgetRestPointList_ChangeMapArea Parms{};

	Parms.IndexOffset = IndexOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetRestPointList.Close
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetRestPointList::Close(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "Close");

	Params::UserWidgetRestPointList_Close Parms{};

	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetRestPointList.FindNearestRestPointIcon
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 CurrentMapPosition                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutMapAreaIndex                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidgetMapIcon_RestPoint*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidgetMapIcon_RestPoint* UUserWidgetRestPointList::FindNearestRestPointIcon(const struct FVector2D& CurrentMapPosition, int32* OutMapAreaIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "FindNearestRestPointIcon");

	Params::UserWidgetRestPointList_FindNearestRestPointIcon Parms{};

	Parms.CurrentMapPosition = std::move(CurrentMapPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapAreaIndex != nullptr)
		*OutMapAreaIndex = Parms.OutMapAreaIndex;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetRestPointList.GoToMapAreaFromIndex
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   MapAreaIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidgetMapIcon_RestPoint*     NearestRestPointIcon                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetRestPointList::GoToMapAreaFromIndex(int32 MapAreaIndex, class UUserWidgetMapIcon_RestPoint* NearestRestPointIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "GoToMapAreaFromIndex");

	Params::UserWidgetRestPointList_GoToMapAreaFromIndex Parms{};

	Parms.MapAreaIndex = MapAreaIndex;
	Parms.NearestRestPointIcon = NearestRestPointIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetRestPointList.GoToNextMapArea
// (Final, Native, Protected, BlueprintCallable)

void UUserWidgetRestPointList::GoToNextMapArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "GoToNextMapArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetRestPointList.GoToPreviousMapArea
// (Final, Native, Protected, BlueprintCallable)

void UUserWidgetRestPointList::GoToPreviousMapArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "GoToPreviousMapArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetRestPointList.InstantiateRestPointList
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FRestPointListData>&ListData                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UUserWidgetRestPointList::InstantiateRestPointList(const TArray<struct FRestPointListData>& ListData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "InstantiateRestPointList");

	Params::UserWidgetRestPointList_InstantiateRestPointList Parms{};

	Parms.ListData = std::move(ListData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetRestPointList.OnClosed
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetRestPointList::OnClosed(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "OnClosed");

	Params::UserWidgetRestPointList_OnClosed Parms{};

	Parms.bInstant = bInstant;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetRestPointList.OnOpened
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetRestPointList::OnOpened(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "OnOpened");

	Params::UserWidgetRestPointList_OnOpened Parms{};

	Parms.bInstant = bInstant;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Zion.UserWidgetRestPointList.Open
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 CurrentMapPosition                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetRestPointList::Open(const struct FVector2D& CurrentMapPosition, bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "Open");

	Params::UserWidgetRestPointList_Open Parms{};

	Parms.CurrentMapPosition = std::move(CurrentMapPosition);
	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetRestPointList.RestPointEntryFocused
// (Final, Native, Private)
// Parameters:
// int32                                   MapAreaIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidgetMapIcon_RestPoint*     RestPointIcon                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetRestPointList::RestPointEntryFocused(int32 MapAreaIndex, class UUserWidgetMapIcon_RestPoint* RestPointIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "RestPointEntryFocused");

	Params::UserWidgetRestPointList_RestPointEntryFocused Parms{};

	Parms.MapAreaIndex = MapAreaIndex;
	Parms.RestPointIcon = RestPointIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetRestPointList.RestPointEntryPressed
// (Final, Native, Private)
// Parameters:
// const struct FMapRestPointData&         RestPointData                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidgetRestPointList::RestPointEntryPressed(const struct FMapRestPointData& RestPointData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "RestPointEntryPressed");

	Params::UserWidgetRestPointList_RestPointEntryPressed Parms{};

	Parms.RestPointData = std::move(RestPointData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetRestPointList.SetCurrentMapAreaIndex
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NewMapAreaIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserWidgetRestPointList::SetCurrentMapAreaIndex(int32 NewMapAreaIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "SetCurrentMapAreaIndex");

	Params::UserWidgetRestPointList_SetCurrentMapAreaIndex Parms{};

	Parms.NewMapAreaIndex = NewMapAreaIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetRestPointList.CanBeOpened
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetRestPointList::CanBeOpened() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "CanBeOpened");

	Params::UserWidgetRestPointList_CanBeOpened Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetRestPointList.CanChangeMapArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetRestPointList::CanChangeMapArea() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "CanChangeMapArea");

	Params::UserWidgetRestPointList_CanChangeMapArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetRestPointList.GetIndexFromMapAreaName
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      MapAreaName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserWidgetRestPointList::GetIndexFromMapAreaName(const class FName& MapAreaName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "GetIndexFromMapAreaName");

	Params::UserWidgetRestPointList_GetIndexFromMapAreaName Parms{};

	Parms.MapAreaName = MapAreaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetRestPointList.GetNewMapAreaIndex
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   IndexOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserWidgetRestPointList::GetNewMapAreaIndex(int32 IndexOffset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "GetNewMapAreaIndex");

	Params::UserWidgetRestPointList_GetNewMapAreaIndex Parms{};

	Parms.IndexOffset = IndexOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetRestPointList.IsOpened
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetRestPointList::IsOpened() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetRestPointList", "IsOpened");

	Params::UserWidgetRestPointList_IsOpened Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetWorldSpaceText_Interact.SetAvailable
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bAvailable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetWorldSpaceText_Interact::SetAvailable(bool bAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWorldSpaceText_Interact", "SetAvailable");

	Params::UserWidgetWorldSpaceText_Interact_SetAvailable Parms{};

	Parms.bAvailable = bAvailable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetWrapBox.AddChild
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidgetWrapBox::AddChild(class UWidget* Content)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWrapBox", "AddChild");

	Params::UserWidgetWrapBox_AddChild Parms{};

	Parms.Content = Content;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetWrapBox.ClearChildren
// (Final, Native, Public, BlueprintCallable)

void UUserWidgetWrapBox::ClearChildren()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWrapBox", "ClearChildren");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Zion.UserWidgetWrapBox.RemoveChild
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetWrapBox::RemoveChild(class UWidget* Content)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWrapBox", "RemoveChild");

	Params::UserWidgetWrapBox_RemoveChild Parms{};

	Parms.Content = Content;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetWrapBox.RemoveChildAt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetWrapBox::RemoveChildAt(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWrapBox", "RemoveChildAt");

	Params::UserWidgetWrapBox_RemoveChildAt Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetWrapBox.GetAllChildren
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UWidget*>                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UWidget*> UUserWidgetWrapBox::GetAllChildren() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWrapBox", "GetAllChildren");

	Params::UserWidgetWrapBox_GetAllChildren Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetWrapBox.GetChildAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UUserWidgetWrapBox::GetChildAt(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWrapBox", "GetChildAt");

	Params::UserWidgetWrapBox_GetChildAt Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetWrapBox.GetChildIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UWidget*                    Content                                                (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserWidgetWrapBox::GetChildIndex(const class UWidget* Content) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWrapBox", "GetChildIndex");

	Params::UserWidgetWrapBox_GetChildIndex Parms{};

	Parms.Content = Content;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetWrapBox.GetChildrenCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserWidgetWrapBox::GetChildrenCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWrapBox", "GetChildrenCount");

	Params::UserWidgetWrapBox_GetChildrenCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetWrapBox.GetWrapNavigationWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bWrapToTop                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UUserWidgetWrapBox::GetWrapNavigationWidget(bool bWrapToTop) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWrapBox", "GetWrapNavigationWidget");

	Params::UserWidgetWrapBox_GetWrapNavigationWidget Parms{};

	Parms.bWrapToTop = bWrapToTop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetWrapBox.HasAnyChildren
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetWrapBox::HasAnyChildren() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWrapBox", "HasAnyChildren");

	Params::UserWidgetWrapBox_HasAnyChildren Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.UserWidgetWrapBox.HasChild
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidgetWrapBox::HasChild(class UWidget* Content) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserWidgetWrapBox", "HasChild");

	Params::UserWidgetWrapBox_HasChild Parms{};

	Parms.Content = Content;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.WaitGameUnpaused.WaitGameUnpaused
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWaitGameUnpaused*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWaitGameUnpaused* UWaitGameUnpaused::WaitGameUnpaused(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WaitGameUnpaused", "WaitGameUnpaused");

	Params::WaitGameUnpaused_WaitGameUnpaused Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Zion.WorldSpaceWidgetHolder.CreateWorldSpaceWidgetHolder
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldObjectContext                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSubclassOf<class UUserWidgetWorldSpace>&UserWidgetWorldSpaceClass                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWidgetReleaseMode                      ReleaseMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWorldSpaceWidgetHolder*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWorldSpaceWidgetHolder* AWorldSpaceWidgetHolder::CreateWorldSpaceWidgetHolder(const class UObject* WorldObjectContext, const TSubclassOf<class UUserWidgetWorldSpace>& UserWidgetWorldSpaceClass, EWidgetReleaseMode ReleaseMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WorldSpaceWidgetHolder", "CreateWorldSpaceWidgetHolder");

	Params::WorldSpaceWidgetHolder_CreateWorldSpaceWidgetHolder Parms{};

	Parms.WorldObjectContext = WorldObjectContext;
	Parms.UserWidgetWorldSpaceClass = UserWidgetWorldSpaceClass;
	Parms.ReleaseMode = ReleaseMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

