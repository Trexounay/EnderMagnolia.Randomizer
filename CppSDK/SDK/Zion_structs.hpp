#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Zion

#include "Basic.hpp"

#include "InputCore_structs.hpp"
#include "Engine_structs.hpp"
#include "EventSystem_structs.hpp"
#include "SpineExtension_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "EnhancedInput_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "GameplayCameras_structs.hpp"


namespace SDK
{

// Enum Zion.EBreakType
// NumValues: 0x000A
enum class EBreakType : uint8
{
	None                                     = 0,
	PileAttack                               = 1,
	Dash                                     = 2,
	DiveDash                                 = 3,
	WallDash                                 = 4,
	HighJump                                 = 5,
	SPAttack                                 = 6,
	Fall                                     = 7,
	SwimDeath                                = 8,
	EBreakType_MAX                           = 9,
};

// Enum Zion.EClearStatus
// NumValues: 0x0004
enum class EClearStatus : uint8
{
	Undefined                                = 0,
	NotCleared                               = 1,
	Cleared                                  = 2,
	EClearStatus_MAX                         = 3,
};

// Enum Zion.ESkillSlot
// NumValues: 0x0006
enum class ESkillSlot : uint8
{
	Invalid                                  = 0,
	A                                        = 1,
	B                                        = 2,
	C                                        = 3,
	D                                        = 4,
	ESkillSlot_MAX                           = 5,
};

// Enum Zion.ECommandFinishType
// NumValues: 0x0004
enum class ECommandFinishType : uint8
{
	Normal                                   = 0,
	Override                                 = 1,
	Abort                                    = 2,
	ECommandFinishType_MAX                   = 3,
};

// Enum Zion.EAttackType
// NumValues: 0x0003
enum class EAttackType : uint8
{
	Physic                                   = 0,
	Magic                                    = 5,
	EAttackType_MAX                          = 6,
};

// Enum Zion.EAttackElement
// NumValues: 0x000A
enum class EAttackElement : uint8
{
	None                                     = 0,
	Fire                                     = 10,
	Ice                                      = 15,
	Electric                                 = 20,
	Dash                                     = 50,
	HighJump                                 = 55,
	WallDash                                 = 60,
	PileAttackLv1                            = 65,
	PileAttackLv2                            = 66,
	EAttackElement_MAX                       = 67,
};

// Enum Zion.ESaveExistsType
// NumValues: 0x0006
enum class ESaveExistsType : uint8
{
	OK                                       = 0,
	DoesNotExist                             = 1,
	Corrupt                                  = 2,
	UnspecifiedError                         = 3,
	IncompatibleVersion                      = 4,
	ESaveExistsType_MAX                      = 5,
};

// Enum Zion.ECurrencyType
// NumValues: 0x0004
enum class ECurrencyType : uint8
{
	Default                                  = 0,
	Rare                                     = 5,
	GradePoints                              = 10,
	ECurrencyType_MAX                        = 11,
};

// Enum Zion.EDirectionSource
// NumValues: 0x0003
enum class EDirectionSource : uint8
{
	SourceActorLocation                      = 0,
	AbilityLocation                          = 1,
	EDirectionSource_MAX                     = 2,
};

// Enum Zion.EDamageEffectType
// NumValues: 0x0004
enum class EDamageEffectType : uint32
{
	AttackParameter                          = 0,
	Absolute                                 = 1,
	TargetPercentage                         = 2,
	EDamageEffectType_MAX                    = 3,
};

// Enum Zion.EHealEffectType
// NumValues: 0x0003
enum class EHealEffectType : uint32
{
	Absolute                                 = 0,
	TargetPercentage                         = 1,
	EHealEffectType_MAX                      = 2,
};

// Enum Zion.EKnockbackTriggerCondition
// NumValues: 0x0003
enum class EKnockbackTriggerCondition : uint32
{
	Always                                   = 0,
	StaminaBroken                            = 1,
	EKnockbackTriggerCondition_MAX           = 2,
};

// Enum Zion.EKnockbackDirectionMode
// NumValues: 0x0005
enum class EKnockbackDirectionMode : uint32
{
	FrontalAbility                           = 0,
	Location                                 = 1,
	OppositeTargetForward                    = 2,
	Absolute                                 = 3,
	EKnockbackDirectionMode_MAX              = 4,
};

// Enum Zion.ESetFacingMode
// NumValues: 0x0003
enum class ESetFacingMode : uint8
{
	FaceAttacker                             = 0,
	FaceAbility                              = 1,
	ESetFacingMode_MAX                       = 2,
};

// Enum Zion.EHitBoxTargetType
// NumValues: 0x0006
enum class EHitBoxTargetType : uint8
{
	Opponents                                = 0,
	Allies                                   = 10,
	All                                      = 20,
	None                                     = 25,
	Custom                                   = 30,
	EHitBoxTargetType_MAX                    = 31,
};

// Enum Zion.EAbilityWeightCategory
// NumValues: 0x0005
enum class EAbilityWeightCategory : uint8
{
	None                                     = 0,
	Light                                    = 10,
	Medium                                   = 20,
	Heavy                                    = 30,
	EAbilityWeightCategory_MAX               = 31,
};

// Enum Zion.EAbilityDirectionMode
// NumValues: 0x0006
enum class EAbilityDirectionMode : uint32
{
	SourceLocation                           = 0,
	AbilityLocation                          = 1,
	SourceForward                            = 2,
	AbilityForward                           = 3,
	AlwaysFrontal                            = 4,
	EAbilityDirectionMode_MAX                = 5,
};

// Enum Zion.EAbilityOriginActorType
// NumValues: 0x0004
enum class EAbilityOriginActorType : uint32
{
	Source                                   = 0,
	ClosestEnemy                             = 1,
	Spawner                                  = 2,
	EAbilityOriginActorType_MAX              = 3,
};

// Enum Zion.EZionAchievement
// NumValues: 0x002A
enum class EZionAchievement : uint8
{
	Invalid                                  = 0,
	SpiritGet_s5000                          = 1,
	SpiritGet_s5010                          = 2,
	SpiritGet_s5030                          = 3,
	SpiritGet_s5040                          = 4,
	SpiritGet_s5050                          = 5,
	SpiritGet_s5060                          = 6,
	SpiritGet_s5070                          = 7,
	SpiritGet_s5080                          = 8,
	SpiritGet_s5090                          = 9,
	SpiritGet_s5110                          = 10,
	SpiritAptGet_s5200_PileAttack            = 11,
	SpiritAptGet_s5200_HighJump              = 12,
	SpiritAptGet_s5210_FastTravel            = 13,
	SpiritAptGet_s5210_DashCharge            = 14,
	SpiritAptGet_s5220_Hook                  = 15,
	SpiritAptGet_s5220_UnderwaterCharge      = 16,
	SpiritAptGet_s5230_WallGrab              = 17,
	SpiritAptGet_s5230_WallCharge            = 18,
	AptGet_Dive                              = 19,
	AptGet_SP                                = 20,
	Skill_Count_All                          = 21,
	Skill_MaxLevel_All                       = 22,
	Passive_Count_1                          = 23,
	Passive_Count_All                        = 24,
	Passive_Upgrade_1                        = 25,
	Equipment_Default_Count_1                = 26,
	Equipment_Default_Count_All              = 27,
	Equipment_Extra_Count_1                  = 28,
	Equipment_Extra_Count_All                = 29,
	Assist_Count_1                           = 30,
	Assist_Count_All                         = 31,
	Tip_Count_All                            = 32,
	Stats_HPUp_All                           = 33,
	Stats_ShopLevelUp_All                    = 34,
	Story_Progress_1                         = 35,
	Story_Progress_2                         = 36,
	Story_Progress_3                         = 37,
	Story_Progress_4                         = 38,
	Ending_A                                 = 39,
	Ending_B                                 = 40,
	EZionAchievement_MAX                     = 41,
};

// Enum Zion.EAfterImageType
// NumValues: 0x0004
enum class EAfterImageType : uint8
{
	None                                     = 0,
	FX                                       = 1,
	Texture                                  = 2,
	EAfterImageType_MAX                      = 3,
};

// Enum Zion.EAptitudeType
// NumValues: 0x0013
enum class EAptitudeType : uint8
{
	None                                     = 0,
	Crouch                                   = 1,
	Heal                                     = 2,
	Dodge                                    = 5,
	DodgeWeak                                = 6,
	Jump                                     = 10,
	DoubleJump                               = 11,
	Dash                                     = 30,
	DashCharge                               = 31,
	DashChargeUnderwater                     = 32,
	PileAttack                               = 40,
	HighJump                                 = 50,
	WallGrab                                 = 60,
	WallCharge                               = 65,
	Dive                                     = 75,
	Hook                                     = 100,
	SP                                       = 110,
	FastTravel                               = 150,
	EAptitudeType_MAX                        = 151,
};

// Enum Zion.EConstraintCameraAspectRatio
// NumValues: 0x0007
enum class EConstraintCameraAspectRatio : uint8
{
	CameraAR_Off                             = 0,
	CameraAR_16_9                            = 1,
	CameraAR_21_9                            = 2,
	CameraAR_32_9                            = 3,
	CameraAR_4_3                             = 4,
	CameraAR_16_10                           = 5,
	CameraAR_MAX                             = 6,
};

// Enum Zion.EAutoClimbDirectionMode
// NumValues: 0x0005
enum class EAutoClimbDirectionMode : uint8
{
	None                                     = 0,
	Upward                                   = 1,
	UpwardNeutral                            = 2,
	UpwardNeutralDownward                    = 3,
	EAutoClimbDirectionMode_MAX              = 4,
};

// Enum Zion.EAutoClimbType
// NumValues: 0x0007
enum class EAutoClimbType : uint8
{
	None                                     = 0,
	Low                                      = 1,
	Middle                                   = 2,
	High                                     = 3,
	Dash                                     = 4,
	DashCharge                               = 5,
	EAutoClimbType_MAX                       = 6,
};

// Enum Zion.EConditionType
// NumValues: 0x0006
enum class EConditionType : uint8
{
	Superior                                 = 0,
	SuperiorOrEqual                          = 1,
	Equal                                    = 2,
	InferiorOrEqual                          = 3,
	Inferior                                 = 4,
	EConditionType_MAX                       = 5,
};

// Enum Zion.EBorderType
// NumValues: 0x000B
enum class EBorderType : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	LeftOrRight                              = 3,
	Top                                      = 4,
	Bottom                                   = 5,
	TopOrBottom                              = 6,
	Any                                      = 7,
	TargetForward                            = 8,
	TargetBackward                           = 9,
	EBorderType_MAX                          = 10,
};

// Enum Zion.ELocalDirection
// NumValues: 0x000A
enum class ELocalDirection : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Down                                     = 2,
	Forward                                  = 3,
	ForwardUp                                = 4,
	ForwardDown                              = 5,
	Backward                                 = 6,
	BackwardUp                               = 7,
	BackwardDown                             = 8,
	ELocalDirection_MAX                      = 9,
};

// Enum Zion.EDecoratorNearGroundDirection
// NumValues: 0x0004
enum class EDecoratorNearGroundDirection : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Backward                                 = 2,
	EDecoratorNearGroundDirection_MAX        = 3,
};

// Enum Zion.EDecoratorNearGroundUpVectorMode
// NumValues: 0x0003
enum class EDecoratorNearGroundUpVectorMode : uint8
{
	World                                    = 0,
	Actor                                    = 1,
	EDecoratorNearGroundUpVectorMode_MAX     = 2,
};

// Enum Zion.EDecoratorNearWallDirection
// NumValues: 0x000A
enum class EDecoratorNearWallDirection : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Backward                                 = 2,
	Up                                       = 3,
	Down                                     = 4,
	WorldRight                               = 5,
	WorldLeft                                = 6,
	WorldUp                                  = 7,
	WorldDown                                = 8,
	EDecoratorNearWallDirection_MAX          = 9,
};

// Enum Zion.ERandomRuntimeLinearBlendType
// NumValues: 0x0005
enum class ERandomRuntimeLinearBlendType : uint8
{
	Linear                                   = 0,
	EaseIn                                   = 1,
	EaseOut                                  = 2,
	EaseInOut                                = 3,
	ERandomRuntimeLinearBlendType_MAX        = 4,
};

// Enum Zion.ECustomMoveToAcceptableRadiusType
// NumValues: 0x0004
enum class ECustomMoveToAcceptableRadiusType : uint8
{
	None                                     = 0,
	Absolute                                 = 1,
	Random                                   = 2,
	ECustomMoveToAcceptableRadiusType_MAX    = 3,
};

// Enum Zion.EWarpOffsetMode
// NumValues: 0x0004
enum class EWarpOffsetMode : uint8
{
	None                                     = 0,
	Absolute                                 = 1,
	Random                                   = 2,
	EWarpOffsetMode_MAX                      = 3,
};

// Enum Zion.EFlyToTargetOffsetType
// NumValues: 0x0004
enum class EFlyToTargetOffsetType : uint8
{
	None                                     = 0,
	Absolute                                 = 1,
	RandomBox                                = 2,
	EFlyToTargetOffsetType_MAX               = 3,
};

// Enum Zion.EWarpWorldSpaceOffsetType
// NumValues: 0x0004
enum class EWarpWorldSpaceOffsetType : uint8
{
	None                                     = 0,
	Constant                                 = 1,
	RandomRange                              = 2,
	EWarpWorldSpaceOffsetType_MAX            = 3,
};

// Enum Zion.ECollisionProfile
// NumValues: 0x0008
enum class ECollisionProfile : uint8
{
	NoCollision                              = 0,
	Player                                   = 1,
	Enemy                                    = 2,
	NPC                                      = 3,
	Spirit                                   = 4,
	PlayerDead                               = 5,
	EnemyDead                                = 6,
	ECollisionProfile_MAX                    = 7,
};

// Enum Zion.ECommandMinimumChargeType
// NumValues: 0x0004
enum class ECommandMinimumChargeType : uint8
{
	None                                     = 0,
	FirstChargeLevel                         = 1,
	Custom                                   = 2,
	ECommandMinimumChargeType_MAX            = 3,
};

// Enum Zion.EFallingExecutionCountType
// NumValues: 0x0003
enum class EFallingExecutionCountType : uint8
{
	Command                                  = 0,
	Category                                 = 1,
	EFallingExecutionCountType_MAX           = 2,
};

// Enum Zion.EHasStateConditionType
// NumValues: 0x0003
enum class EHasStateConditionType : uint32
{
	AllStates                                = 0,
	AnyState                                 = 1,
	EHasStateConditionType_MAX               = 2,
};

// Enum Zion.ESpiritActivationCheckMode
// NumValues: 0x0003
enum class ESpiritActivationCheckMode : uint8
{
	Active                                   = 0,
	Category                                 = 1,
	ESpiritActivationCheckMode_MAX           = 2,
};

// Enum Zion.EAbilityInstantTarget
// NumValues: 0x0004
enum class EAbilityInstantTarget : uint8
{
	None                                     = 0,
	Player                                   = 1,
	OverlapSphere                            = 2,
	EAbilityInstantTarget_MAX                = 3,
};

// Enum Zion.EAbilityInstantTriggerCondition
// NumValues: 0x0003
enum class EAbilityInstantTriggerCondition : uint8
{
	None                                     = 0,
	ParriedActorFaction                      = 1,
	EAbilityInstantTriggerCondition_MAX      = 2,
};

// Enum Zion.ECommandModuleActiveType
// NumValues: 0x0004
enum class ECommandModuleActiveType : uint8
{
	Always                                   = 0,
	UntilCommandEnd                          = 1,
	UntilEndTime                             = 2,
	ECommandModuleActiveType_MAX             = 3,
};

// Enum Zion.EEnableCustomHurtboxActiveType
// NumValues: 0x0003
enum class EEnableCustomHurtboxActiveType : uint8
{
	UntilCommandEnd                          = 0,
	UntilEndTime                             = 1,
	EEnableCustomHurtboxActiveType_MAX       = 2,
};

// Enum Zion.ERotationBlendMode
// NumValues: 0x0004
enum class ERotationBlendMode : uint8
{
	None                                     = 0,
	InjectionByDT                            = 1,
	ConstantRotation                         = 2,
	ERotationBlendMode_MAX                   = 3,
};

// Enum Zion.EDismissType
// NumValues: 0x0005
enum class EDismissType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Instant                                  = 2,
	Delayed                                  = 3,
	EDismissType_MAX                         = 4,
};

// Enum Zion.EAbilityOffsetMode
// NumValues: 0x0004
enum class EAbilityOffsetMode : uint8
{
	None                                     = 0,
	InputDirection                           = 1,
	InputDirectionAbsoluteX                  = 2,
	EAbilityOffsetMode_MAX                   = 3,
};

// Enum Zion.EMoveTimelineMovementModeChangeBehavior
// NumValues: 0x0004
enum class EMoveTimelineMovementModeChangeBehavior : uint8
{
	None                                     = 0,
	Finish                                   = 1,
	Abort                                    = 2,
	EMoveTimelineMovementModeChangeBehavior_MAX = 3,
};

// Enum Zion.EMoveTimelineRotation
// NumValues: 0x0003
enum class EMoveTimelineRotation : uint8
{
	None                                     = 0,
	FollowInput                              = 1,
	EMoveTimelineRotation_MAX                = 2,
};

// Enum Zion.EPlayerUIAnimation
// NumValues: 0x0004
enum class EPlayerUIAnimation : uint8
{
	None                                     = 0,
	HealFailure_NoHeal                       = 1,
	HealFailure_FullHP                       = 2,
	EPlayerUIAnimation_MAX                   = 3,
};

// Enum Zion.ECommandSetCategory
// NumValues: 0x0008
enum class ECommandSetCategory : uint8
{
	None                                     = 0,
	Combo                                    = 1,
	Repeat                                   = 2,
	Recast                                   = 3,
	Auto                                     = 4,
	Defense                                  = 5,
	Special                                  = 6,
	ECommandSetCategory_MAX                  = 7,
};

// Enum Zion.ECommandPriorityType
// NumValues: 0x0009
enum class ECommandPriorityType : uint8
{
	Override                                 = 10,
	Aptitudes                                = 15,
	OverrideParryActions                     = 16,
	OverrideDodgeActions                     = 17,
	DodgeActions                             = 20,
	SpecialSkills                            = 45,
	Skills                                   = 50,
	Default                                  = 100,
	ECommandPriorityType_MAX                 = 101,
};

// Enum Zion.ECommandLayerType
// NumValues: 0x0006
enum class ECommandLayerType : uint8
{
	Default                                  = 0,
	Alternative                              = 1,
	RepeatA                                  = 2,
	RepeatB                                  = 3,
	Free                                     = 4,
	ECommandLayerType_MAX                    = 5,
};

// Enum Zion.ECommandCategory
// NumValues: 0x0005
enum class ECommandCategory : uint8
{
	Default                                  = 0,
	Jump                                     = 1,
	Summon                                   = 2,
	Dodge                                    = 3,
	ECommandCategory_MAX                     = 4,
};

// Enum Zion.ECommandState
// NumValues: 0x0004
enum class ECommandState : uint8
{
	None                                     = 0,
	Running                                  = 1,
	Finished                                 = 2,
	ECommandState_MAX                        = 3,
};

// Enum Zion.ECommandResult
// NumValues: 0x0004
enum class ECommandResult : uint8
{
	None                                     = 0,
	InProgress                               = 1,
	Finished                                 = 2,
	ECommandResult_MAX                       = 3,
};

// Enum Zion.ECommandModuleResult
// NumValues: 0x0004
enum class ECommandModuleResult : uint8
{
	None                                     = 0,
	InProgress                               = 1,
	Finished                                 = 2,
	ECommandModuleResult_MAX                 = 3,
};

// Enum Zion.EWarpLocationComputationTiming
// NumValues: 0x0003
enum class EWarpLocationComputationTiming : uint8
{
	AtStart                                  = 0,
	AtWarp                                   = 1,
	EWarpLocationComputationTiming_MAX       = 2,
};

// Enum Zion.EWarpExecutionTiming
// NumValues: 0x0004
enum class EWarpExecutionTiming : uint8
{
	AtStart                                  = 0,
	AtTime                                   = 1,
	AtAnimationStart                         = 2,
	EWarpExecutionTiming_MAX                 = 3,
};

// Enum Zion.EWarpFacingMode
// NumValues: 0x0005
enum class EWarpFacingMode : uint8
{
	None                                     = 0,
	WarpTarget                               = 1,
	EnemyTarget                              = 2,
	SpawnLocation                            = 3,
	EWarpFacingMode_MAX                      = 4,
};

// Enum Zion.EHighJumpStopCondition
// NumValues: 0x0004
enum class EHighJumpStopCondition : uint8
{
	None                                     = 0,
	Distance                                 = 1,
	Duration                                 = 2,
	EHighJumpStopCondition_MAX               = 3,
};

// Enum Zion.EDistanceComparisonType
// NumValues: 0x0005
enum class EDistanceComparisonType : uint8
{
	Distance3D                               = 0,
	DistanceX                                = 1,
	DistanceY                                = 2,
	DistanceZ                                = 3,
	EDistanceComparisonType_MAX              = 4,
};

// Enum Zion.EConditionOperator
// NumValues: 0x0003
enum class EConditionOperator : uint8
{
	And                                      = 0,
	Or                                       = 1,
	EConditionOperator_MAX                   = 2,
};

// Enum Zion.ECommonOperator
// NumValues: 0x0008
enum class ECommonOperator : uint8
{
	None                                     = 0,
	Superior                                 = 1,
	SuperiorOrEqual                          = 2,
	Inferior                                 = 3,
	InferiorOrEqual                          = 4,
	Equal                                    = 5,
	NotEqual                                 = 6,
	ECommonOperator_MAX                      = 7,
};

// Enum Zion.ECommonDirection
// NumValues: 0x0004
enum class ECommonDirection : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	ECommonDirection_MAX                     = 3,
};

// Enum Zion.EConditionDestroyMode
// NumValues: 0x0003
enum class EConditionDestroyMode : uint8
{
	DestroyOnSuccess                         = 0,
	DestroyOnFailure                         = 1,
	EConditionDestroyMode_MAX                = 2,
};

// Enum Zion.EValueType
// NumValues: 0x0005
enum class EValueType : uint8
{
	Fixed                                    = 0,
	Curve                                    = 1,
	Random                                   = 2,
	RandomCurve                              = 3,
	EValueType_MAX                           = 4,
};

// Enum Zion.EDashChargeAnimationMode
// NumValues: 0x0004
enum class EDashChargeAnimationMode : uint32
{
	None                                     = 0,
	Mirror                                   = 1,
	Orientation                              = 2,
	EDashChargeAnimationMode_MAX             = 3,
};

// Enum Zion.EDashChargeOrientationMode
// NumValues: 0x0005
enum class EDashChargeOrientationMode : uint32
{
	None                                     = 0,
	GroundNormal                             = 1,
	Velocity                                 = 2,
	Input                                    = 3,
	EDashChargeOrientationMode_MAX           = 4,
};

// Enum Zion.EDeathFacingMode
// NumValues: 0x0006
enum class EDeathFacingMode : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	TowardEnemySpawner                       = 3,
	FallbackTowardEnemySpawner               = 4,
	EDeathFacingMode_MAX                     = 5,
};

// Enum Zion.EDebugDisplayFilter
// NumValues: 0x0005
enum class EDebugDisplayFilter : uint8
{
	None                                     = 0,
	Player                                   = 1,
	Spirit                                   = 2,
	Enemy                                    = 3,
	EDebugDisplayFilter_MAX                  = 4,
};

// Enum Zion.EDifficultyMode
// NumValues: 0x0003
enum class EDifficultyMode : uint8
{
	DefaultGame                              = 0,
	BossRush                                 = 1,
	EDifficultyMode_MAX                      = 2,
};

// Enum Zion.EDifficultyPreset
// NumValues: 0x0006
enum class EDifficultyPreset : uint8
{
	None                                     = 0,
	Easy                                     = 1,
	Normal                                   = 2,
	Hard                                     = 3,
	Custom                                   = 100,
	EDifficultyPreset_MAX                    = 101,
};

// Enum Zion.EDropType
// NumValues: 0x0005
enum class EDropType : uint8
{
	None                                     = 0,
	Currency                                 = 1,
	Item                                     = 2,
	CollectableGameplayEffect                = 3,
	EDropType_MAX                            = 4,
};

// Enum Zion.EEffectAttackType
// NumValues: 0x0005
enum class EEffectAttackType : uint8
{
	None                                     = 0,
	Light                                    = 1,
	Medium                                   = 2,
	Heavy                                    = 3,
	EEffectAttackType_MAX                    = 4,
};

// Enum Zion.EEffectMaterialType
// NumValues: 0x0004
enum class EEffectMaterialType : uint8
{
	None                                     = 0,
	Iron                                     = 1,
	Meat                                     = 2,
	EEffectMaterialType_MAX                  = 3,
};

// Enum Zion.EEffectActionType
// NumValues: 0x0006
enum class EEffectActionType : uint8
{
	None                                     = 0,
	Cut                                      = 1,
	Blow                                     = 2,
	MagicBullet                              = 3,
	Magic                                    = 4,
	EEffectActionType_MAX                    = 5,
};

// Enum Zion.EEffectGuardMaterialType
// NumValues: 0x0005
enum class EEffectGuardMaterialType : uint8
{
	None                                     = 0,
	Iron                                     = 1,
	Meat                                     = 2,
	Magic                                    = 3,
	EEffectGuardMaterialType_MAX             = 4,
};

// Enum Zion.EElevatorState
// NumValues: 0x0004
enum class EElevatorState : uint8
{
	Undefined                                = 0,
	Origin                                   = 1,
	Destination                              = 2,
	EElevatorState_MAX                       = 3,
};

// Enum Zion.EEmulatedFogBlendType
// NumValues: 0x0003
enum class EEmulatedFogBlendType : uint32
{
	TwoColors                                = 0,
	Gradient                                 = 1,
	EEmulatedFogBlendType_MAX                = 2,
};

// Enum Zion.EGameEndingType
// NumValues: 0x0004
enum class EGameEndingType : uint8
{
	None                                     = 0,
	EndingA                                  = 1,
	EndingB                                  = 2,
	EGameEndingType_MAX                      = 3,
};

// Enum Zion.EEquipmentSlot
// NumValues: 0x0004
enum class EEquipmentSlot : uint8
{
	A                                        = 0,
	B                                        = 1,
	Extra                                    = 2,
	EEquipmentSlot_MAX                       = 3,
};

// Enum Zion.EActorHideMode
// NumValues: 0x0005
enum class EActorHideMode : uint8
{
	None                                     = 0,
	SetHiddenInGame                          = 1,
	Destroy                                  = 2,
	Animation                                = 3,
	EActorHideMode_MAX                       = 4,
};

// Enum Zion.EMaterialParameterMode
// NumValues: 0x0003
enum class EMaterialParameterMode : uint8
{
	Direct                                   = 0,
	Curve                                    = 1,
	EMaterialParameterMode_MAX               = 2,
};

// Enum Zion.EMoveToTalkDistanceMovementType
// NumValues: 0x0007
enum class EMoveToTalkDistanceMovementType : uint8
{
	None                                     = 0,
	Closer                                   = 1,
	Left                                     = 2,
	Right                                    = 3,
	FrontOfTarget                            = 4,
	BackOfTarget                             = 5,
	EMoveToTalkDistanceMovementType_MAX      = 6,
};

// Enum Zion.EMoveToTalkDistanceTargetFacingType
// NumValues: 0x0004
enum class EMoveToTalkDistanceTargetFacingType : uint8
{
	None                                     = 0,
	BeforeSubjectMovement                    = 1,
	AfterSubjectMovement                     = 2,
	EMoveToTalkDistanceTargetFacingType_MAX  = 3,
};

// Enum Zion.EFacingAnimationType
// NumValues: 0x0005
enum class EFacingAnimationType : uint32
{
	Auto                                     = 1,
	IdleTurn                                 = 2,
	EventIdleTurn                            = 3,
	Custom                                   = 4,
	EFacingAnimationType_MAX                 = 5,
};

// Enum Zion.ETalkDesign
// NumValues: 0x0003
enum class ETalkDesign : uint8
{
	Arrow                                    = 0,
	Line                                     = 1,
	ETalkDesign_MAX                          = 2,
};

// Enum Zion.EWidgetActorAnchor
// NumValues: 0x0004
enum class EWidgetActorAnchor : uint32
{
	Origin                                   = 0,
	Top                                      = 1,
	Bottom                                   = 2,
	EWidgetActorAnchor_MAX                   = 3,
};

// Enum Zion.ETalkAnimationType
// NumValues: 0x0005
enum class ETalkAnimationType : uint8
{
	None                                     = 0,
	TalkA                                    = 1,
	TalkB                                    = 2,
	Custom                                   = 3,
	ETalkAnimationType_MAX                   = 4,
};

// Enum Zion.EEventClearedCheckMode
// NumValues: 0x0004
enum class EEventClearedCheckMode : uint8
{
	AnyGameGeneration                        = 0,
	CurrentGameGenerationOnly                = 1,
	PreviousGameGenerationsOnly              = 2,
	EEventClearedCheckMode_MAX               = 3,
};

// Enum Zion.EFaction
// NumValues: 0x0009
enum class EFaction : uint8
{
	None                                     = 0,
	Player                                   = 1,
	Spirit                                   = 2,
	Enemy                                    = 3,
	NPC                                      = 4,
	BreakableBlock                           = 5,
	BreakableDrop                            = 6,
	LevelHazard                              = 7,
	EFaction_MAX                             = 8,
};

// Enum Zion.EFadeState
// NumValues: 0x0006
enum class EFadeState : uint8
{
	None                                     = 0,
	FadingIn                                 = 1,
	FadedIn                                  = 2,
	FadingOut                                = 3,
	FadedOut                                 = 4,
	EFadeState_MAX                           = 5,
};

// Enum Zion.EFadeType
// NumValues: 0x0003
enum class EFadeType : uint8
{
	FadeIn                                   = 0,
	FadeOut                                  = 1,
	EFadeType_MAX                            = 2,
};

// Enum Zion.EFadeLayer
// NumValues: 0x0006
enum class EFadeLayer : uint8
{
	None                                     = 0,
	Default                                  = 1,
	WorldLoader                              = 2,
	Zone                                     = 3,
	Event                                    = 4,
	EFadeLayer_MAX                           = 5,
};

// Enum Zion.EFieldMessageType
// NumValues: 0x0003
enum class EFieldMessageType : uint32
{
	FirstValid                               = 0,
	Random                                   = 1,
	EFieldMessageType_MAX                    = 2,
};

// Enum Zion.ESplashSize
// NumValues: 0x0005
enum class ESplashSize : uint8
{
	None                                     = 0,
	Small                                    = 1,
	Medium                                   = 2,
	Large                                    = 3,
	ESplashSize_MAX                          = 4,
};

// Enum Zion.EFluidMeshType
// NumValues: 0x0005
enum class EFluidMeshType : uint8
{
	None                                     = 0,
	XY                                       = 1,
	YZ                                       = 2,
	XYZ                                      = 3,
	EFluidMeshType_MAX                       = 4,
};

// Enum Zion.EFollowGeometryMovementPhase
// NumValues: 0x0005
enum class EFollowGeometryMovementPhase : uint8
{
	None                                     = 0,
	Moving                                   = 1,
	Falling                                  = 2,
	Turning                                  = 3,
	EFollowGeometryMovementPhase_MAX         = 4,
};

// Enum Zion.EFollowTargetBlendSpeedMode
// NumValues: 0x0004
enum class EFollowTargetBlendSpeedMode : uint8
{
	None                                     = 0,
	Value                                    = 1,
	Curve                                    = 2,
	EFollowTargetBlendSpeedMode_MAX          = 3,
};

// Enum Zion.EAuraFXDeactivateTiming
// NumValues: 0x0003
enum class EAuraFXDeactivateTiming : uint8
{
	None                                     = 0,
	OnDeathProcessStart                      = 1,
	EAuraFXDeactivateTiming_MAX              = 2,
};

// Enum Zion.ELaunchGameIntent
// NumValues: 0x0006
enum class ELaunchGameIntent : uint8
{
	Unknown                                  = 0,
	NewGame                                  = 1,
	Continue                                 = 2,
	NewGamePlus                              = 3,
	Demo                                     = 4,
	ELaunchGameIntent_MAX                    = 5,
};

// Enum Zion.EBreadcrumbType
// NumValues: 0x0006
enum class EBreadcrumbType : uint8
{
	Default                                  = 0,
	World                                    = 1,
	Event                                    = 2,
	Zone                                     = 3,
	Save                                     = 4,
	EBreadcrumbType_MAX                      = 5,
};

// Enum Zion.ESkillUnlockResultType
// NumValues: 0x0005
enum class ESkillUnlockResultType : uint8
{
	Invalid                                  = 0,
	Success                                  = 1,
	NotEnoughMaterial                        = 2,
	AlreadyMaxLevel                          = 3,
	ESkillUnlockResultType_MAX               = 4,
};

// Enum Zion.EMapIconType
// NumValues: 0x0014
enum class EMapIconType : uint8
{
	None                                     = 0,
	PlayerLocation                           = 1,
	RestPoint                                = 2,
	Switch                                   = 3,
	Door                                     = 4,
	MagicBarrier                             = 5,
	MagicDoor                                = 6,
	Breakable                                = 7,
	Tumor                                    = 8,
	Locked                                   = 9,
	Shop                                     = 10,
	Item                                     = 11,
	AreaChange                               = 12,
	Warp                                     = 13,
	LilyLock                                 = 14,
	ZoneIncomplete                           = 15,
	ZoneComplete                             = 16,
	AreaIncomplete                           = 17,
	AreaComplete                             = 18,
	EMapIconType_MAX                         = 19,
};

// Enum Zion.EGameModeType
// NumValues: 0x0004
enum class EGameModeType : uint8
{
	Default                                  = 0,
	RecollectionBoss                         = 1,
	BossRush                                 = 2,
	EGameModeType_MAX                        = 3,
};

// Enum Zion.EGameSettingsType
// NumValues: 0x0005
enum class EGameSettingsType : uint8
{
	All                                      = 0,
	Game                                     = 1,
	Input                                    = 2,
	Video                                    = 3,
	EGameSettingsType_MAX                    = 4,
};

// Enum Zion.EHomingPropertyType
// NumValues: 0x0003
enum class EHomingPropertyType : uint8
{
	Direct                                   = 0,
	Random                                   = 1,
	EHomingPropertyType_MAX                  = 2,
};

// Enum Zion.EHookType
// NumValues: 0x0005
enum class EHookType : uint8
{
	None                                     = 0,
	Point                                    = 1,
	OverrideLocation                         = 2,
	Attach                                   = 3,
	EHookType_MAX                            = 4,
};

// Enum Zion.EIKBoneDriver
// NumValues: 0x0006
enum class EIKBoneDriver : uint8
{
	None                                     = 0,
	AttackTarget                             = 1,
	FootLeft                                 = 2,
	FootRight                                = 3,
	HookTarget                               = 100,
	EIKBoneDriver_MAX                        = 101,
};

// Enum Zion.EIKBoneReferenceVectorMode
// NumValues: 0x0003
enum class EIKBoneReferenceVectorMode : uint8
{
	Forward                                  = 0,
	Upward                                   = 1,
	EIKBoneReferenceVectorMode_MAX           = 2,
};

// Enum Zion.EIKBoneBlendMode
// NumValues: 0x0004
enum class EIKBoneBlendMode : uint8
{
	None                                     = 0,
	InjectionByDT                            = 1,
	ConstantRotation                         = 2,
	EIKBoneBlendMode_MAX                     = 3,
};

// Enum Zion.ERichTextDecoratorMode
// NumValues: 0x0004
enum class ERichTextDecoratorMode : uint8
{
	Auto                                     = 0,
	ForceKeyboard                            = 1,
	ForceGamepad                             = 2,
	ERichTextDecoratorMode_MAX               = 3,
};

// Enum Zion.EInputActionTriggerMode
// NumValues: 0x0004
enum class EInputActionTriggerMode : uint8
{
	None                                     = 0,
	JustTriggered                            = 1,
	Triggering                               = 2,
	EInputActionTriggerMode_MAX              = 3,
};

// Enum Zion.EInputMappingPriority
// NumValues: 0x0006
enum class EInputMappingPriority : uint8
{
	BelowDefault                             = 0,
	Default                                  = 10,
	AboveDefault                             = 20,
	Interactable                             = 50,
	Debug                                    = 200,
	EInputMappingPriority_MAX                = 201,
};

// Enum Zion.EInputDirection
// NumValues: 0x000A
enum class EInputDirection : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Down                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	UpLeft                                   = 5,
	UpRight                                  = 6,
	DownRight                                = 7,
	DownLeft                                 = 8,
	EInputDirection_MAX                      = 9,
};

// Enum Zion.EUIInputType
// NumValues: 0x000E
enum class EUIInputType : uint8
{
	None                                     = 0,
	Confirm                                  = 1,
	Cancel                                   = 2,
	Context                                  = 3,
	ContextAlt                               = 4,
	Next                                     = 5,
	Previous                                 = 6,
	NextAlt                                  = 7,
	PreviousAlt                              = 8,
	Up                                       = 9,
	Down                                     = 10,
	Left                                     = 11,
	Right                                    = 12,
	EUIInputType_MAX                         = 13,
};

// Enum Zion.EActionInputType
// NumValues: 0x0021
enum class EActionInputType : uint8
{
	None                                     = 0,
	Jump                                     = 1,
	Move                                     = 2,
	Move_Right                               = 3,
	Move_Left                                = 4,
	Move_Up                                  = 5,
	Move_Down                                = 6,
	Dodge                                    = 7,
	Pause                                    = 8,
	CameraOffset                             = 9,
	CameraOffset_Right                       = 10,
	CameraOffset_Left                        = 11,
	CameraOffset_Up                          = 12,
	CameraOffset_Down                        = 13,
	Attack_A                                 = 14,
	Attack_B                                 = 15,
	Attack_C                                 = 16,
	Attack_D                                 = 17,
	AttackSpecial_A                          = 18,
	AttackSpecial_B                          = 19,
	AttackSpecial_C                          = 20,
	AttackSpecial_D                          = 21,
	Menu                                     = 22,
	Hook                                     = 23,
	Heal                                     = 24,
	Interact                                 = 25,
	Special_Modifier                         = 26,
	Minimap                                  = 27,
	Shortcut_AttackSpecial_A                 = 28,
	Shortcut_AttackSpecial_B                 = 29,
	Shortcut_AttackSpecial_C                 = 30,
	Shortcut_AttackSpecial_D                 = 31,
	EActionInputType_MAX                     = 32,
};

// Enum Zion.EInputStyle
// NumValues: 0x000B
enum class EInputStyle : uint8
{
	None                                     = 0,
	MouseAndKeyboard                         = 1,
	Xbox360                                  = 10,
	XboxOne                                  = 11,
	PS4                                      = 20,
	PS5                                      = 21,
	Switch                                   = 30,
	PC_PS4                                   = 100,
	PC_PS5                                   = 101,
	PC_Switch                                = 102,
	EInputStyle_MAX                          = 103,
};

// Enum Zion.EInputStick
// NumValues: 0x0003
enum class EInputStick : uint8
{
	LeftStick                                = 0,
	RightStick                               = 1,
	EInputStick_MAX                          = 2,
};

// Enum Zion.EInputType
// NumValues: 0x0004
enum class EInputType : uint8
{
	UI                                       = 0,
	Action                                   = 1,
	InputAction                              = 2,
	EInputType_MAX                           = 3,
};

// Enum Zion.ERestEventSkipTarget
// NumValues: 0x0005
enum class ERestEventSkipTarget : uint8
{
	None                                     = 0,
	FadeIn                                   = 1,
	BossRush                                 = 2,
	BossRecollection                         = 3,
	ERestEventSkipTarget_MAX                 = 4,
};

// Enum Zion.EInventoryItemType
// NumValues: 0x0013
enum class EInventoryItemType : uint8
{
	None                                     = 0,
	Currency                                 = 1,
	Stats                                    = 2,
	Aptitude                                 = 3,
	Spirit                                   = 4,
	Skill                                    = 5,
	Passive                                  = 6,
	Tip                                      = 7,
	Key                                      = 8,
	Quest                                    = 9,
	Material                                 = 10,
	Equipment                                = 11,
	Assist                                   = 12,
	Tutorial                                 = 13,
	Costume                                  = 14,
	EnemyInfo                                = 15,
	NPCInfo                                  = 16,
	Gallery                                  = 17,
	EInventoryItemType_MAX                   = 18,
};

// Enum Zion.EEquipmentType
// NumValues: 0x0004
enum class EEquipmentType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Extra                                    = 2,
	EEquipmentType_MAX                       = 3,
};

// Enum Zion.EPassiveCountType
// NumValues: 0x0004
enum class EPassiveCountType : uint8
{
	None                                     = 0,
	Finding                                  = 1,
	Upgrade                                  = 2,
	EPassiveCountType_MAX                    = 3,
};

// Enum Zion.EExtraInfoLocomotionMode
// NumValues: 0x0005
enum class EExtraInfoLocomotionMode : uint8
{
	Grounded                                 = 0,
	Airborne                                 = 1,
	Underwater                               = 2,
	UnderwaterGrounded                       = 3,
	EExtraInfoLocomotionMode_MAX             = 4,
};

// Enum Zion.EExtraAnimationRootMotionMode
// NumValues: 0x0005
enum class EExtraAnimationRootMotionMode : uint8
{
	None                                     = 0,
	On                                       = 1,
	XAxis                                    = 2,
	YAxis                                    = 3,
	EExtraAnimationRootMotionMode_MAX        = 4,
};

// Enum Zion.EKnockbackPhase
// NumValues: 0x0008
enum class EKnockbackPhase : uint8
{
	None                                     = 0,
	Starting                                 = 1,
	Launch                                   = 2,
	WaitForLanding                           = 3,
	Stagger                                  = 4,
	Recovery                                 = 5,
	Finish                                   = 6,
	EKnockbackPhase_MAX                      = 7,
};

// Enum Zion.EWidgetMinimapDisplayMode
// NumValues: 0x0004
enum class EWidgetMinimapDisplayMode : uint8
{
	Default                                  = 0,
	Fullscreen                               = 1,
	Hidden                                   = 2,
	EWidgetMinimapDisplayMode_MAX            = 3,
};

// Enum Zion.EFacingType
// NumValues: 0x0004
enum class EFacingType : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	EFacingType_MAX                          = 3,
};

// Enum Zion.EMovementModeCustom
// NumValues: 0x0006
enum class EMovementModeCustom : uint8
{
	None                                     = 0,
	WallGrabbing                             = 1,
	Sliding                                  = 2,
	HookAttach                               = 3,
	WallScaling                              = 4,
	EMovementModeCustom_MAX                  = 5,
};

// Enum Zion.EMovementSpeedMode
// NumValues: 0x0006
enum class EMovementSpeedMode : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Slow                                     = 2,
	Fast                                     = 3,
	Fastest                                  = 4,
	EMovementSpeedMode_MAX                   = 5,
};

// Enum Zion.EDashChargeMode
// NumValues: 0x0004
enum class EDashChargeMode : uint8
{
	None                                     = 0,
	Ground                                   = 1,
	Swim                                     = 2,
	EDashChargeMode_MAX                      = 3,
};

// Enum Zion.ENotificationTypes
// NumValues: 0x0003
enum class ENotificationTypes : uint8
{
	None                                     = 0,
	ItemReceived                             = 1,
	ENotificationTypes_MAX                   = 2,
};

// Enum Zion.EOrientTargetType
// NumValues: 0x0005
enum class EOrientTargetType : uint8
{
	None                                     = 0,
	Actor                                    = 1,
	Component                                = 2,
	VisualPivot                              = 3,
	EOrientTargetType_MAX                    = 4,
};

// Enum Zion.EOrientToTargetBlendMode
// NumValues: 0x0004
enum class EOrientToTargetBlendMode : uint8
{
	None                                     = 0,
	InjectionByDT                            = 1,
	ConstantRotation                         = 2,
	EOrientToTargetBlendMode_MAX             = 3,
};

// Enum Zion.EPassiveEquipResult
// NumValues: 0x0005
enum class EPassiveEquipResult : uint8
{
	Success                                  = 0,
	InsufficientFreeSlotCount                = 1,
	PassiveEquipLimitReached                 = 2,
	InvalidPassive                           = 3,
	EPassiveEquipResult_MAX                  = 4,
};

// Enum Zion.EPassiveOnAttackRestoreType
// NumValues: 0x0005
enum class EPassiveOnAttackRestoreType : uint8
{
	None                                     = 0,
	FlatAmount                               = 1,
	DamagePercentage                         = 2,
	StatPercentage                           = 3,
	EPassiveOnAttackRestoreType_MAX          = 4,
};

// Enum Zion.EPassiveOnKillRestoreType
// NumValues: 0x0004
enum class EPassiveOnKillRestoreType : uint8
{
	None                                     = 0,
	FlatAmount                               = 1,
	StatPercentage                           = 2,
	EPassiveOnKillRestoreType_MAX            = 3,
};

// Enum Zion.ECameraModifierVolumeProcessAction
// NumValues: 0x0004
enum class ECameraModifierVolumeProcessAction : uint8
{
	None                                     = 0,
	Add                                      = 1,
	Remove                                   = 2,
	ECameraModifierVolumeProcessAction_MAX   = 3,
};

// Enum Zion.EPlayerCostumeFX
// NumValues: 0x0003
enum class EPlayerCostumeFX : uint8
{
	None                                     = 0,
	DoubleJump                               = 1,
	EPlayerCostumeFX_MAX                     = 2,
};

// Enum Zion.ERecollectionPageType
// NumValues: 0x0004
enum class ERecollectionPageType : uint8
{
	Movies                                   = 0,
	Bosses                                   = 1,
	BossRush                                 = 2,
	ERecollectionPageType_MAX                = 3,
};

// Enum Zion.ERecollectionItemType
// NumValues: 0x0003
enum class ERecollectionItemType : uint8
{
	Boss                                     = 0,
	Movie                                    = 1,
	ERecollectionItemType_MAX                = 2,
};

// Enum Zion.EEnemyRepulsionOrigin
// NumValues: 0x0004
enum class EEnemyRepulsionOrigin : uint8
{
	ColliderCenter                           = 0,
	ActorCenter                              = 1,
	ActorLocation                            = 2,
	EEnemyRepulsionOrigin_MAX                = 3,
};

// Enum Zion.ERespawnReason
// NumValues: 0x000A
enum class ERespawnReason : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Death                                    = 2,
	FastTravel                               = 3,
	BackToRestpoint                          = 4,
	ExitBossRush                             = 5,
	ExitBossRecollection                     = 6,
	RetryBossRush                            = 7,
	RetryBossRecollection                    = 8,
	ERespawnReason_MAX                       = 9,
};

// Enum Zion.ERestPointEventPriority
// NumValues: 0x0003
enum class ERestPointEventPriority : uint8
{
	Default                                  = 0,
	High                                     = 1,
	ERestPointEventPriority_MAX              = 2,
};

// Enum Zion.ERichPresenceType
// NumValues: 0x0005
enum class ERichPresenceType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Title                                    = 2,
	StoryLevel                               = 3,
	ERichPresenceType_MAX                    = 4,
};

// Enum Zion.ESaveCopyResult
// NumValues: 0x0004
enum class ESaveCopyResult : uint8
{
	Undefined                                = 0,
	Success                                  = 1,
	NoEmptySlot                              = 2,
	ESaveCopyResult_MAX                      = 3,
};

// Enum Zion.EShopType
// NumValues: 0x0003
enum class EShopType : uint8
{
	None                                     = 0,
	Main                                     = 1,
	EShopType_MAX                            = 2,
};

// Enum Zion.EUpgradeType
// NumValues: 0x0005
enum class EUpgradeType : uint8
{
	None                                     = 0,
	AttackUp                                 = 1,
	SpeedUp                                  = 2,
	ComboCountUp                             = 3,
	EUpgradeType_MAX                         = 4,
};

// Enum Zion.ESoundFamily
// NumValues: 0x0008
enum class ESoundFamily : uint8
{
	None                                     = 0,
	BGM                                      = 1,
	SE_UI                                    = 2,
	SE_Game                                  = 3,
	Ambience                                 = 4,
	Voice                                    = 5,
	Master                                   = 100,
	ESoundFamily_MAX                         = 101,
};

// Enum Zion.EEnemySpawnerClearTiming
// NumValues: 0x0004
enum class EEnemySpawnerClearTiming : uint8
{
	None                                     = 0,
	OnDeathProcessStart                      = 1,
	OnDeathProcessEnd                        = 2,
	EEnemySpawnerClearTiming_MAX             = 3,
};

// Enum Zion.ESpineAnimationPlayType
// NumValues: 0x0004
enum class ESpineAnimationPlayType : uint8
{
	Once                                     = 0,
	Loop                                     = 1,
	Hold                                     = 2,
	ESpineAnimationPlayType_MAX              = 3,
};

// Enum Zion.ESpineAnimatorLayer
// NumValues: 0x0005
enum class ESpineAnimatorLayer : uint8
{
	None                                     = 0,
	Locomotion                               = 1,
	Action                                   = 2,
	Death                                    = 30,
	ESpineAnimatorLayer_MAX                  = 31,
};

// Enum Zion.ESpineLocomotionType
// NumValues: 0x0033
enum class ESpineLocomotionType : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Walk                                     = 2,
	Run                                      = 3,
	Dash                                     = 4,
	Ride                                     = 5,
	FallingUp                                = 6,
	FallingNeutral                           = 7,
	FallingDown                              = 8,
	DashFallingUp                            = 9,
	DashFallingNeutral                       = 10,
	DashFallingDown                          = 11,
	RideFallingUp                            = 12,
	RideFallingNeutral                       = 13,
	RideFallingDown                          = 14,
	FallingKnockbackUp_Backward              = 15,
	FallingKnockbackNeutral_Backward         = 16,
	FallingKnockbackDown_Backward            = 17,
	FallingKnockbackUp_Forward               = 18,
	FallingKnockbackNeutral_Forward          = 19,
	FallingKnockbackDown_Forward             = 20,
	WallGrab                                 = 21,
	Slide                                    = 22,
	HookAttach                               = 23,
	SwimIdle                                 = 24,
	SwimMove                                 = 25,
	UnderWaterIdle                           = 26,
	UnderWaterUp                             = 27,
	UnderWaterUpLateral                      = 28,
	UnderWaterDown                           = 29,
	UnderWaterDownLateral                    = 30,
	UnderWaterLateral                        = 31,
	UnderWaterDashUp                         = 32,
	UnderWaterDashUpLateral                  = 33,
	UnderWaterDashDown                       = 34,
	UnderWaterDashDownLateral                = 35,
	UnderWaterDashLateral                    = 36,
	UnderWaterRideUp                         = 37,
	UnderWaterRideUpLateral                  = 38,
	UnderWaterRideDown                       = 39,
	UnderWaterRideDownLateral                = 40,
	UnderWaterRideLateral                    = 41,
	FlyIdle                                  = 42,
	Fly                                      = 43,
	FlyUp                                    = 44,
	FlyDown                                  = 45,
	WallScaling_Idle                         = 46,
	WallScaling_Forward                      = 47,
	WallScaling_Backward                     = 48,
	Stun                                     = 49,
	ESpineLocomotionType_MAX                 = 50,
};

// Enum Zion.EDamageAdditiveType
// NumValues: 0x0004
enum class EDamageAdditiveType : uint8
{
	Never                                    = 0,
	Always                                   = 1,
	GroundedOnly                             = 2,
	EDamageAdditiveType_MAX                  = 3,
};

// Enum Zion.EFallbackMovementModeUse
// NumValues: 0x0004
enum class EFallbackMovementModeUse : uint8
{
	MovementNull                             = 0,
	MovementNullOrInactive                   = 1,
	Always                                   = 2,
	EFallbackMovementModeUse_MAX             = 3,
};

// Enum Zion.ELocomotionMoveSource
// NumValues: 0x0003
enum class ELocomotionMoveSource : uint8
{
	PendingInputVector                       = 0,
	Velocity                                 = 1,
	ELocomotionMoveSource_MAX                = 2,
};

// Enum Zion.EStepHeavinessCategory
// NumValues: 0x0005
enum class EStepHeavinessCategory : uint8
{
	None                                     = 0,
	Light                                    = 1,
	Medium                                   = 2,
	Heavy                                    = 3,
	EStepHeavinessCategory_MAX               = 4,
};

// Enum Zion.EStepOrientation
// NumValues: 0x0004
enum class EStepOrientation : uint8
{
	Default                                  = 0,
	Wall                                     = 1,
	Ceiling                                  = 2,
	EStepOrientation_MAX                     = 3,
};

// Enum Zion.ESpiritSummonLocationType
// NumValues: 0x0005
enum class ESpiritSummonLocationType : uint8
{
	Reset                                    = 0,
	Keep                                     = 1,
	Blend                                    = 2,
	KeepOrBlendOnFacingChange                = 3,
	ESpiritSummonLocationType_MAX            = 4,
};

// Enum Zion.ESpiritSummonRotationType
// NumValues: 0x0004
enum class ESpiritSummonRotationType : uint8
{
	Keep                                     = 0,
	Reset                                    = 1,
	Absolute                                 = 2,
	ESpiritSummonRotationType_MAX            = 3,
};

// Enum Zion.ESpiritSummonType
// NumValues: 0x0003
enum class ESpiritSummonType : uint8
{
	AlwaysSummon                             = 0,
	Toggle                                   = 1,
	ESpiritSummonType_MAX                    = 2,
};

// Enum Zion.ESpiritDetachType
// NumValues: 0x0003
enum class ESpiritDetachType : uint8
{
	OnDeactivate                             = 0,
	OnDismiss                                = 1,
	ESpiritDetachType_MAX                    = 2,
};

// Enum Zion.ESpiritDismissType
// NumValues: 0x0004
enum class ESpiritDismissType : uint8
{
	Manual                                   = 0,
	CommandQueueEnd                          = 1,
	SummonInputActionReleased                = 2,
	ESpiritDismissType_MAX                   = 3,
};

// Enum Zion.ESpiritAttachType
// NumValues: 0x0004
enum class ESpiritAttachType : uint8
{
	None                                     = 0,
	ActorOrigin                              = 1,
	VisualPivot                              = 2,
	ESpiritAttachType_MAX                    = 3,
};

// Enum Zion.ESpiritLocationValidityOriginMode
// NumValues: 0x0004
enum class ESpiritLocationValidityOriginMode : uint8
{
	GroundedSpiritOrigin                     = 0,
	TargetHeightSpiritOrigin                 = 1,
	SummonerOrigin                           = 2,
	ESpiritLocationValidityOriginMode_MAX    = 3,
};

// Enum Zion.ESpiritRepeatAbilityUseType
// NumValues: 0x0003
enum class ESpiritRepeatAbilityUseType : uint8
{
	Sequence                                 = 0,
	Random                                   = 1,
	ESpiritRepeatAbilityUseType_MAX          = 2,
};

// Enum Zion.ESpiritAutoType
// NumValues: 0x0004
enum class ESpiritAutoType : uint8
{
	None                                     = 0,
	AI                                       = 1,
	SummonerDodge                            = 2,
	ESpiritAutoType_MAX                      = 3,
};

// Enum Zion.ECameraModifierActivationType
// NumValues: 0x0004
enum class ECameraModifierActivationType : uint8
{
	None                                     = 0,
	ActivationBox                            = 1,
	Manual                                   = 2,
	ECameraModifierActivationType_MAX        = 3,
};

// Enum Zion.EStatusEffectType
// NumValues: 0x0009
enum class EStatusEffectType : uint8
{
	None                                     = 0,
	Burn                                     = 1,
	Freeze                                   = 2,
	Shock                                    = 3,
	AttackUpAssist                           = 4,
	AttackUpSpirit                           = 5,
	DamageCutAssist                          = 6,
	DamageCutSpirit                          = 7,
	EStatusEffectType_MAX                    = 8,
};

// Enum Zion.EStencilCategory
// NumValues: 0x0008
enum class EStencilCategory : uint32
{
	None                                     = 0,
	Player                                   = 5,
	Spirit                                   = 6,
	Enemy                                    = 10,
	Boss                                     = 11,
	NPC                                      = 20,
	Object                                   = 50,
	EStencilCategory_MAX                     = 51,
};

// Enum Zion.ESummonIdleSpiritState
// NumValues: 0x0004
enum class ESummonIdleSpiritState : uint8
{
	WaitForIdle                              = 0,
	WaitForSummon                            = 1,
	SummonCooldown                           = 2,
	ESummonIdleSpiritState_MAX               = 3,
};

// Enum Zion.EBuildPlatformType
// NumValues: 0x0005
enum class EBuildPlatformType : uint8
{
	Default                                  = 0,
	Playstation                              = 1,
	Switch                                   = 2,
	Xbox                                     = 3,
	EBuildPlatformType_MAX                   = 4,
};

// Enum Zion.ETimelineResult
// NumValues: 0x0004
enum class ETimelineResult : uint8
{
	None                                     = 0,
	InProgress                               = 1,
	Finished                                 = 2,
	ETimelineResult_MAX                      = 3,
};

// Enum Zion.ETimelineEntryActiveType
// NumValues: 0x0004
enum class ETimelineEntryActiveType : uint8
{
	OneShot                                  = 0,
	UntilEndTime                             = 1,
	UntilTimelineStop                        = 2,
	ETimelineEntryActiveType_MAX             = 3,
};

// Enum Zion.EFieldMessageNPCMode
// NumValues: 0x0003
enum class EFieldMessageNPCMode : uint8
{
	Default                                  = 0,
	AI                                       = 1,
	EFieldMessageNPCMode_MAX                 = 2,
};

// Enum Zion.ETutorialHook
// NumValues: 0x0005
enum class ETutorialHook : uint8
{
	None                                     = 0,
	RestPoint                                = 1,
	Difficulty                               = 2,
	Extra                                    = 3,
	ETutorialHook_MAX                        = 4,
};

// Enum Zion.EUMGLayer
// NumValues: 0x000C
enum class EUMGLayer : uint8
{
	Default                                  = 0,
	Event                                    = 1,
	Menu                                     = 2,
	MenuOverlay                              = 3,
	Notification                             = 4,
	Movie                                    = 5,
	Fade                                     = 6,
	Dialog                                   = 7,
	System_InputDevice                       = 8,
	System_Profile                           = 9,
	SaveLoad                                 = 10,
	EUMGLayer_MAX                            = 11,
};

// Enum Zion.EMapIconGenerationType
// NumValues: 0x0004
enum class EMapIconGenerationType : uint8
{
	MatchActorLocation                       = 0,
	MatchActorCenter                         = 1,
	MatchActorBounds                         = 2,
	EMapIconGenerationType_MAX               = 3,
};

// Enum Zion.EWidgetReleaseMode
// NumValues: 0x0005
enum class EWidgetReleaseMode : uint8
{
	Manual                                   = 0,
	AutoReleaseHolder                        = 1,
	AutoReleaseWidget                        = 2,
	AutoReleaseHolderAndWidget               = 3,
	EWidgetReleaseMode_MAX                   = 4,
};

// Enum Zion.EAITargetDetectionType
// NumValues: 0x0004
enum class EAITargetDetectionType : uint8
{
	None                                     = 0,
	PlayerOnly                               = 1,
	ClosestTarget                            = 2,
	EAITargetDetectionType_MAX               = 3,
};

// Enum Zion.ECameraLocalOffsetBlendType
// NumValues: 0x0006
enum class ECameraLocalOffsetBlendType : uint8
{
	None                                     = 0,
	Lerp                                     = 1,
	EaseIn                                   = 2,
	EaseOut                                  = 3,
	EaseInOut                                = 4,
	ECameraLocalOffsetBlendType_MAX          = 5,
};

// Enum Zion.ECameraClampLocation
// NumValues: 0x0006
enum class ECameraClampLocation : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Down                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	ECameraClampLocation_MAX                 = 5,
};

// Enum Zion.ECameraModifierType
// NumValues: 0x0006
enum class ECameraModifierType : uint8
{
	None                                     = 0,
	OverrideSettings                         = 1,
	CameraClamp                              = 2,
	FixedCamera                              = 3,
	LimitControl                             = 4,
	ECameraModifierType_MAX                  = 5,
};

// Enum Zion.EFixedCameraType
// NumValues: 0x0003
enum class EFixedCameraType : uint8
{
	FixedFOV                                 = 0,
	FixedZoomOffset                          = 1,
	EFixedCameraType_MAX                     = 2,
};

// Enum Zion.EFixedCameraMatch
// NumValues: 0x0003
enum class EFixedCameraMatch : uint8
{
	Width                                    = 0,
	Height                                   = 1,
	EFixedCameraMatch_MAX                    = 2,
};

// Enum Zion.ECameraModuleOverrideType
// NumValues: 0x0003
enum class ECameraModuleOverrideType : uint8
{
	AbsoluteValue                            = 0,
	Factor                                   = 1,
	ECameraModuleOverrideType_MAX            = 2,
};

// Enum Zion.EPathFollowingMode
// NumValues: 0x0004
enum class EPathFollowingMode : uint32
{
	Default                                  = 0,
	QuadraticBezier                          = 1,
	Step                                     = 2,
	EPathFollowingMode_MAX                   = 3,
};

// ScriptStruct Zion.IgnoredPlatformData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FIgnoredPlatformData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIgnoredPlatformData) == 0x000004, "Wrong alignment on FIgnoredPlatformData");
static_assert(sizeof(FIgnoredPlatformData) == 0x00000C, "Wrong size on FIgnoredPlatformData");

// ScriptStruct Zion.NPCAIData
// 0x0058 (0x0058 - 0x0000)
struct FNPCAIData final
{
public:
	TSoftObjectPtr<class UBlackboardData>         BlackboardData;                                    // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBehaviorTree>           BehaviorTree;                                      // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolRange;                                       // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCAIData) == 0x000008, "Wrong alignment on FNPCAIData");
static_assert(sizeof(FNPCAIData) == 0x000058, "Wrong size on FNPCAIData");
static_assert(offsetof(FNPCAIData, BlackboardData) == 0x000000, "Member 'FNPCAIData::BlackboardData' has a wrong offset!");
static_assert(offsetof(FNPCAIData, BehaviorTree) == 0x000028, "Member 'FNPCAIData::BehaviorTree' has a wrong offset!");
static_assert(offsetof(FNPCAIData, PatrolRange) == 0x000050, "Member 'FNPCAIData::PatrolRange' has a wrong offset!");

// ScriptStruct Zion.AbilityContextData
// 0x0180 (0x0180 - 0x0000)
struct alignas(0x08) FAbilityContextData final
{
public:
	uint8                                         Pad_0[0x180];                                      // 0x0000(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityContextData) == 0x000008, "Wrong alignment on FAbilityContextData");
static_assert(sizeof(FAbilityContextData) == 0x000180, "Wrong size on FAbilityContextData");

// ScriptStruct Zion.HitData
// 0x02D0 (0x02D0 - 0x0000)
struct alignas(0x10) FHitData final
{
public:
	uint8                                         Pad_0[0x2D0];                                      // 0x0000(0x02D0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitData) == 0x000010, "Wrong alignment on FHitData");
static_assert(sizeof(FHitData) == 0x0002D0, "Wrong size on FHitData");

// ScriptStruct Zion.EquippedItem
// 0x01F0 (0x01F0 - 0x0000)
struct alignas(0x08) FEquippedItem final
{
public:
	uint8                                         Pad_0[0x1F0];                                      // 0x0000(0x01F0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEquippedItem) == 0x000008, "Wrong alignment on FEquippedItem");
static_assert(sizeof(FEquippedItem) == 0x0001F0, "Wrong size on FEquippedItem");

// ScriptStruct Zion.AbilityEffectProcessCollection
// 0x0010 (0x0010 - 0x0000)
struct FAbilityEffectProcessCollection final
{
public:
	TArray<class UAbilityEffectProcess*>          Processes;                                         // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityEffectProcessCollection) == 0x000008, "Wrong alignment on FAbilityEffectProcessCollection");
static_assert(sizeof(FAbilityEffectProcessCollection) == 0x000010, "Wrong size on FAbilityEffectProcessCollection");
static_assert(offsetof(FAbilityEffectProcessCollection, Processes) == 0x000000, "Member 'FAbilityEffectProcessCollection::Processes' has a wrong offset!");

// ScriptStruct Zion.Drop
// 0x01F0 (0x01F0 - 0x0000)
struct FDrop final
{
public:
	EDropType                                     Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    Item;                                              // 0x0008(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	ECurrencyType                                 CurrencyType;                                      // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   CollectableGameplayEffectClass;                    // 0x0020(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueType                                    CountType;                                         // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     CountCurve;                                        // 0x0050(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int32                                         RandomMinCount;                                    // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RandomMaxCount;                                    // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     RandomMinCountCurve;                               // 0x00E0(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     RandomMaxCountCurve;                               // 0x0168(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDrop) == 0x000008, "Wrong alignment on FDrop");
static_assert(sizeof(FDrop) == 0x0001F0, "Wrong size on FDrop");
static_assert(offsetof(FDrop, Type) == 0x000000, "Member 'FDrop::Type' has a wrong offset!");
static_assert(offsetof(FDrop, Item) == 0x000008, "Member 'FDrop::Item' has a wrong offset!");
static_assert(offsetof(FDrop, CurrencyType) == 0x000018, "Member 'FDrop::CurrencyType' has a wrong offset!");
static_assert(offsetof(FDrop, CollectableGameplayEffectClass) == 0x000020, "Member 'FDrop::CollectableGameplayEffectClass' has a wrong offset!");
static_assert(offsetof(FDrop, CountType) == 0x000048, "Member 'FDrop::CountType' has a wrong offset!");
static_assert(offsetof(FDrop, Count) == 0x00004C, "Member 'FDrop::Count' has a wrong offset!");
static_assert(offsetof(FDrop, CountCurve) == 0x000050, "Member 'FDrop::CountCurve' has a wrong offset!");
static_assert(offsetof(FDrop, RandomMinCount) == 0x0000D8, "Member 'FDrop::RandomMinCount' has a wrong offset!");
static_assert(offsetof(FDrop, RandomMaxCount) == 0x0000DC, "Member 'FDrop::RandomMaxCount' has a wrong offset!");
static_assert(offsetof(FDrop, RandomMinCountCurve) == 0x0000E0, "Member 'FDrop::RandomMinCountCurve' has a wrong offset!");
static_assert(offsetof(FDrop, RandomMaxCountCurve) == 0x000168, "Member 'FDrop::RandomMaxCountCurve' has a wrong offset!");

// ScriptStruct Zion.DropGroup
// 0x0018 (0x0018 - 0x0000)
struct FDropGroup final
{
public:
	float                                         DropRatio;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDrop>                          Drops;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDropGroup) == 0x000008, "Wrong alignment on FDropGroup");
static_assert(sizeof(FDropGroup) == 0x000018, "Wrong size on FDropGroup");
static_assert(offsetof(FDropGroup, DropRatio) == 0x000000, "Member 'FDropGroup::DropRatio' has a wrong offset!");
static_assert(offsetof(FDropGroup, Drops) == 0x000008, "Member 'FDropGroup::Drops' has a wrong offset!");

// ScriptStruct Zion.DropData
// 0x0010 (0x0018 - 0x0008)
struct FDropData final : public FTableRowBase
{
public:
	TArray<struct FDropGroup>                     Drops;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDropData) == 0x000008, "Wrong alignment on FDropData");
static_assert(sizeof(FDropData) == 0x000018, "Wrong size on FDropData");
static_assert(offsetof(FDropData, Drops) == 0x000008, "Member 'FDropData::Drops' has a wrong offset!");

// ScriptStruct Zion.InputBindingData
// 0x0020 (0x0020 - 0x0000)
struct FInputBindingData final
{
public:
	class FName                                   Mapping_Name;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Mapping_Key;                                       // 0x0008(0x0018)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputBindingData) == 0x000008, "Wrong alignment on FInputBindingData");
static_assert(sizeof(FInputBindingData) == 0x000020, "Wrong size on FInputBindingData");
static_assert(offsetof(FInputBindingData, Mapping_Name) == 0x000000, "Member 'FInputBindingData::Mapping_Name' has a wrong offset!");
static_assert(offsetof(FInputBindingData, Mapping_Key) == 0x000008, "Member 'FInputBindingData::Mapping_Key' has a wrong offset!");

// ScriptStruct Zion.GameInputSettingsData
// 0x0018 (0x0018 - 0x0000)
struct FGameInputSettingsData final
{
public:
	int32                                         Version;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInputBindingData>              BindingsData;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameInputSettingsData) == 0x000008, "Wrong alignment on FGameInputSettingsData");
static_assert(sizeof(FGameInputSettingsData) == 0x000018, "Wrong size on FGameInputSettingsData");
static_assert(offsetof(FGameInputSettingsData, Version) == 0x000000, "Member 'FGameInputSettingsData::Version' has a wrong offset!");
static_assert(offsetof(FGameInputSettingsData, BindingsData) == 0x000008, "Member 'FGameInputSettingsData::BindingsData' has a wrong offset!");

// ScriptStruct Zion.DamageData
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FDamageData final
{
public:
	int32                                         Damage;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackElement                                Element;                                           // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackType                                   Type;                                              // 0x0005(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AppliedRate;                                       // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AppliedDamagePercentageBonus;                      // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AppliedDamageCutPercentage;                        // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x44];                                      // 0x0014(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageData) == 0x000008, "Wrong alignment on FDamageData");
static_assert(sizeof(FDamageData) == 0x000058, "Wrong size on FDamageData");
static_assert(offsetof(FDamageData, Damage) == 0x000000, "Member 'FDamageData::Damage' has a wrong offset!");
static_assert(offsetof(FDamageData, Element) == 0x000004, "Member 'FDamageData::Element' has a wrong offset!");
static_assert(offsetof(FDamageData, Type) == 0x000005, "Member 'FDamageData::Type' has a wrong offset!");
static_assert(offsetof(FDamageData, AppliedRate) == 0x000008, "Member 'FDamageData::AppliedRate' has a wrong offset!");
static_assert(offsetof(FDamageData, AppliedDamagePercentageBonus) == 0x00000C, "Member 'FDamageData::AppliedDamagePercentageBonus' has a wrong offset!");
static_assert(offsetof(FDamageData, AppliedDamageCutPercentage) == 0x000010, "Member 'FDamageData::AppliedDamageCutPercentage' has a wrong offset!");

// ScriptStruct Zion.SpiritSummonParameters
// 0x0038 (0x0038 - 0x0000)
struct FSpiritSummonParameters final
{
public:
	ESpiritSummonLocationType                     SummonLocationType;                                // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLocationResetFallback;                         // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceForLocationResetFallback;                  // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpiritSummonRotationType                     SummonRotationType;                                // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFacingType                                   AbsoluteFacing;                                    // 0x0009(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalSpaceOffset;                                  // 0x0010(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckLocationValidityWithLinecast;                // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpiritLocationValidityOriginMode             LocationValidityOrigin;                            // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTargetHeight;                                  // 0x002A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapToGround;                                     // 0x002B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpiritAttachType                             AttachType;                                        // 0x002C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AttachmentRule;                                    // 0x002D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpiritDetachType                             DetachType;                                        // 0x002E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpiritSummonType                             SummonType;                                        // 0x002F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpiritDismissType                            DismissType;                                       // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstantSummon;                                    // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpiritSummonParameters) == 0x000008, "Wrong alignment on FSpiritSummonParameters");
static_assert(sizeof(FSpiritSummonParameters) == 0x000038, "Wrong size on FSpiritSummonParameters");
static_assert(offsetof(FSpiritSummonParameters, SummonLocationType) == 0x000000, "Member 'FSpiritSummonParameters::SummonLocationType' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, bUseLocationResetFallback) == 0x000001, "Member 'FSpiritSummonParameters::bUseLocationResetFallback' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, DistanceForLocationResetFallback) == 0x000004, "Member 'FSpiritSummonParameters::DistanceForLocationResetFallback' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, SummonRotationType) == 0x000008, "Member 'FSpiritSummonParameters::SummonRotationType' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, AbsoluteFacing) == 0x000009, "Member 'FSpiritSummonParameters::AbsoluteFacing' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, LocalSpaceOffset) == 0x000010, "Member 'FSpiritSummonParameters::LocalSpaceOffset' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, bCheckLocationValidityWithLinecast) == 0x000028, "Member 'FSpiritSummonParameters::bCheckLocationValidityWithLinecast' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, LocationValidityOrigin) == 0x000029, "Member 'FSpiritSummonParameters::LocationValidityOrigin' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, bUseTargetHeight) == 0x00002A, "Member 'FSpiritSummonParameters::bUseTargetHeight' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, bSnapToGround) == 0x00002B, "Member 'FSpiritSummonParameters::bSnapToGround' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, AttachType) == 0x00002C, "Member 'FSpiritSummonParameters::AttachType' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, AttachmentRule) == 0x00002D, "Member 'FSpiritSummonParameters::AttachmentRule' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, DetachType) == 0x00002E, "Member 'FSpiritSummonParameters::DetachType' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, SummonType) == 0x00002F, "Member 'FSpiritSummonParameters::SummonType' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, DismissType) == 0x000030, "Member 'FSpiritSummonParameters::DismissType' has a wrong offset!");
static_assert(offsetof(FSpiritSummonParameters, bInstantSummon) == 0x000031, "Member 'FSpiritSummonParameters::bInstantSummon' has a wrong offset!");

// ScriptStruct Zion.AbilityModifiers
// 0x001C (0x001C - 0x0000)
struct FAbilityModifiers final
{
public:
	bool                                          bDirectionModeOverride;                            // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAbilityDirectionMode                         DirectionModeOverride;                             // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageHPFactor;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTypeOverride;                                     // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackType                                   TypeOverride;                                      // 0x000D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bElementOverride;                                  // 0x000E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackElement                                ElementOverride;                                   // 0x000F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeightCategoryOverride;                           // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityWeightCategory                        WeightCategoryOverride;                            // 0x0011(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoStopTimeOverride;                             // 0x0012(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoStopTimeOverride;                              // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarnLongExecution;                                // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityModifiers) == 0x000004, "Wrong alignment on FAbilityModifiers");
static_assert(sizeof(FAbilityModifiers) == 0x00001C, "Wrong size on FAbilityModifiers");
static_assert(offsetof(FAbilityModifiers, bDirectionModeOverride) == 0x000000, "Member 'FAbilityModifiers::bDirectionModeOverride' has a wrong offset!");
static_assert(offsetof(FAbilityModifiers, DirectionModeOverride) == 0x000004, "Member 'FAbilityModifiers::DirectionModeOverride' has a wrong offset!");
static_assert(offsetof(FAbilityModifiers, DamageHPFactor) == 0x000008, "Member 'FAbilityModifiers::DamageHPFactor' has a wrong offset!");
static_assert(offsetof(FAbilityModifiers, bTypeOverride) == 0x00000C, "Member 'FAbilityModifiers::bTypeOverride' has a wrong offset!");
static_assert(offsetof(FAbilityModifiers, TypeOverride) == 0x00000D, "Member 'FAbilityModifiers::TypeOverride' has a wrong offset!");
static_assert(offsetof(FAbilityModifiers, bElementOverride) == 0x00000E, "Member 'FAbilityModifiers::bElementOverride' has a wrong offset!");
static_assert(offsetof(FAbilityModifiers, ElementOverride) == 0x00000F, "Member 'FAbilityModifiers::ElementOverride' has a wrong offset!");
static_assert(offsetof(FAbilityModifiers, bWeightCategoryOverride) == 0x000010, "Member 'FAbilityModifiers::bWeightCategoryOverride' has a wrong offset!");
static_assert(offsetof(FAbilityModifiers, WeightCategoryOverride) == 0x000011, "Member 'FAbilityModifiers::WeightCategoryOverride' has a wrong offset!");
static_assert(offsetof(FAbilityModifiers, bAutoStopTimeOverride) == 0x000012, "Member 'FAbilityModifiers::bAutoStopTimeOverride' has a wrong offset!");
static_assert(offsetof(FAbilityModifiers, AutoStopTimeOverride) == 0x000014, "Member 'FAbilityModifiers::AutoStopTimeOverride' has a wrong offset!");
static_assert(offsetof(FAbilityModifiers, bWarnLongExecution) == 0x000018, "Member 'FAbilityModifiers::bWarnLongExecution' has a wrong offset!");

// ScriptStruct Zion.ActorSearchParameters
// 0x000C (0x000C - 0x0000)
struct FActorSearchParameters final
{
public:
	float                                         MinDistance;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedLineOfSight;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             VisibilityChannel;                                 // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFrontCheck;                                       // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorSearchParameters) == 0x000004, "Wrong alignment on FActorSearchParameters");
static_assert(sizeof(FActorSearchParameters) == 0x00000C, "Wrong size on FActorSearchParameters");
static_assert(offsetof(FActorSearchParameters, MinDistance) == 0x000000, "Member 'FActorSearchParameters::MinDistance' has a wrong offset!");
static_assert(offsetof(FActorSearchParameters, MaxDistance) == 0x000004, "Member 'FActorSearchParameters::MaxDistance' has a wrong offset!");
static_assert(offsetof(FActorSearchParameters, bNeedLineOfSight) == 0x000008, "Member 'FActorSearchParameters::bNeedLineOfSight' has a wrong offset!");
static_assert(offsetof(FActorSearchParameters, VisibilityChannel) == 0x000009, "Member 'FActorSearchParameters::VisibilityChannel' has a wrong offset!");
static_assert(offsetof(FActorSearchParameters, bFrontCheck) == 0x00000A, "Member 'FActorSearchParameters::bFrontCheck' has a wrong offset!");

// ScriptStruct Zion.AbilityData
// 0x00E0 (0x00E0 - 0x0000)
struct FAbilityData final
{
public:
	TSubclassOf<class AAbility>                   AbilityClass;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityEffectProcess>      AbilityEffectProcessClass;                         // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAbilityModifiers                      AbilityModifiers;                                  // 0x0010(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EAbilityOriginActorType                       OriginActorType;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActorSearchParameters                 ClosestEnemySearchParameters;                      // 0x0030(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ESpineBone                                    SpawnBone;                                         // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpawnBoneCustomName;                               // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpineBoneRotationMode                        RotationMode;                                      // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToBone;                                     // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalSpaceOffset;                                  // 0x0050(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapToGround;                                     // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideZOffsetFromGround;                        // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZOverrideOffsetFromGround;                         // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             GroundCollisionChannel;                            // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundMaxDistance;                                 // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoGroundCancelAbility;                            // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineFXData>                   FXDataList;                                        // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityData) == 0x000010, "Wrong alignment on FAbilityData");
static_assert(sizeof(FAbilityData) == 0x0000E0, "Wrong size on FAbilityData");
static_assert(offsetof(FAbilityData, AbilityClass) == 0x000000, "Member 'FAbilityData::AbilityClass' has a wrong offset!");
static_assert(offsetof(FAbilityData, AbilityEffectProcessClass) == 0x000008, "Member 'FAbilityData::AbilityEffectProcessClass' has a wrong offset!");
static_assert(offsetof(FAbilityData, AbilityModifiers) == 0x000010, "Member 'FAbilityData::AbilityModifiers' has a wrong offset!");
static_assert(offsetof(FAbilityData, OriginActorType) == 0x00002C, "Member 'FAbilityData::OriginActorType' has a wrong offset!");
static_assert(offsetof(FAbilityData, ClosestEnemySearchParameters) == 0x000030, "Member 'FAbilityData::ClosestEnemySearchParameters' has a wrong offset!");
static_assert(offsetof(FAbilityData, SpawnBone) == 0x00003C, "Member 'FAbilityData::SpawnBone' has a wrong offset!");
static_assert(offsetof(FAbilityData, SpawnBoneCustomName) == 0x000040, "Member 'FAbilityData::SpawnBoneCustomName' has a wrong offset!");
static_assert(offsetof(FAbilityData, RotationMode) == 0x000048, "Member 'FAbilityData::RotationMode' has a wrong offset!");
static_assert(offsetof(FAbilityData, bAttachToBone) == 0x000049, "Member 'FAbilityData::bAttachToBone' has a wrong offset!");
static_assert(offsetof(FAbilityData, LocalSpaceOffset) == 0x000050, "Member 'FAbilityData::LocalSpaceOffset' has a wrong offset!");
static_assert(offsetof(FAbilityData, bSnapToGround) == 0x0000B0, "Member 'FAbilityData::bSnapToGround' has a wrong offset!");
static_assert(offsetof(FAbilityData, bOverrideZOffsetFromGround) == 0x0000B1, "Member 'FAbilityData::bOverrideZOffsetFromGround' has a wrong offset!");
static_assert(offsetof(FAbilityData, ZOverrideOffsetFromGround) == 0x0000B4, "Member 'FAbilityData::ZOverrideOffsetFromGround' has a wrong offset!");
static_assert(offsetof(FAbilityData, GroundCollisionChannel) == 0x0000B8, "Member 'FAbilityData::GroundCollisionChannel' has a wrong offset!");
static_assert(offsetof(FAbilityData, GroundMaxDistance) == 0x0000BC, "Member 'FAbilityData::GroundMaxDistance' has a wrong offset!");
static_assert(offsetof(FAbilityData, bNoGroundCancelAbility) == 0x0000C0, "Member 'FAbilityData::bNoGroundCancelAbility' has a wrong offset!");
static_assert(offsetof(FAbilityData, FXDataList) == 0x0000C8, "Member 'FAbilityData::FXDataList' has a wrong offset!");

// ScriptStruct Zion.SpineAnimationDefinition
// 0x0068 (0x0068 - 0x0000)
struct FSpineAnimationDefinition final
{
public:
	class FString                                 AnimationName;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpineAnimationPlayType                       PlayType;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMixDuration;                              // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MixDurationOverride;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideStartTime;                                // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTimeOverride;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideEndTime;                                  // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndTimeOverride;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRootMotion;                                    // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRootMotionSettings                    RootMotionSettings;                                // 0x0030(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnAnimationEnd;                                    // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpineAnimationDefinition) == 0x000008, "Wrong alignment on FSpineAnimationDefinition");
static_assert(sizeof(FSpineAnimationDefinition) == 0x000068, "Wrong size on FSpineAnimationDefinition");
static_assert(offsetof(FSpineAnimationDefinition, AnimationName) == 0x000000, "Member 'FSpineAnimationDefinition::AnimationName' has a wrong offset!");
static_assert(offsetof(FSpineAnimationDefinition, PlayType) == 0x000010, "Member 'FSpineAnimationDefinition::PlayType' has a wrong offset!");
static_assert(offsetof(FSpineAnimationDefinition, bOverrideMixDuration) == 0x000011, "Member 'FSpineAnimationDefinition::bOverrideMixDuration' has a wrong offset!");
static_assert(offsetof(FSpineAnimationDefinition, MixDurationOverride) == 0x000014, "Member 'FSpineAnimationDefinition::MixDurationOverride' has a wrong offset!");
static_assert(offsetof(FSpineAnimationDefinition, bOverrideStartTime) == 0x000018, "Member 'FSpineAnimationDefinition::bOverrideStartTime' has a wrong offset!");
static_assert(offsetof(FSpineAnimationDefinition, StartTimeOverride) == 0x00001C, "Member 'FSpineAnimationDefinition::StartTimeOverride' has a wrong offset!");
static_assert(offsetof(FSpineAnimationDefinition, bOverrideEndTime) == 0x000020, "Member 'FSpineAnimationDefinition::bOverrideEndTime' has a wrong offset!");
static_assert(offsetof(FSpineAnimationDefinition, EndTimeOverride) == 0x000024, "Member 'FSpineAnimationDefinition::EndTimeOverride' has a wrong offset!");
static_assert(offsetof(FSpineAnimationDefinition, bUseRootMotion) == 0x000028, "Member 'FSpineAnimationDefinition::bUseRootMotion' has a wrong offset!");
static_assert(offsetof(FSpineAnimationDefinition, RootMotionSettings) == 0x000030, "Member 'FSpineAnimationDefinition::RootMotionSettings' has a wrong offset!");
static_assert(offsetof(FSpineAnimationDefinition, OnAnimationEnd) == 0x000058, "Member 'FSpineAnimationDefinition::OnAnimationEnd' has a wrong offset!");

// ScriptStruct Zion.SoundData
// 0x0028 (0x0028 - 0x0000)
struct FSoundData final
{
public:
	class UFMODEvent*                             Event;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToActor;                                    // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalSpaceOffset;                                  // 0x0010(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundData) == 0x000008, "Wrong alignment on FSoundData");
static_assert(sizeof(FSoundData) == 0x000028, "Wrong size on FSoundData");
static_assert(offsetof(FSoundData, Event) == 0x000000, "Member 'FSoundData::Event' has a wrong offset!");
static_assert(offsetof(FSoundData, bAttachToActor) == 0x000008, "Member 'FSoundData::bAttachToActor' has a wrong offset!");
static_assert(offsetof(FSoundData, LocalSpaceOffset) == 0x000010, "Member 'FSoundData::LocalSpaceOffset' has a wrong offset!");

// ScriptStruct Zion.DashChargeSettings
// 0x04C0 (0x04C0 - 0x0000)
struct FDashChargeSettings final
{
public:
	EDashChargeMode                               Mode;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityData                           AbilityData;                                       // 0x0010(0x00E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class ACharacterZionSpirit>       SpiritClass;                                       // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpiritSummonParameters                SummonParameters;                                  // 0x00F8(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EDashChargeOrientationMode                    OrientationMode;                                   // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendOrientation;                                 // 0x0134(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendOrientationSpeed;                             // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineAnimationDefinition              RideStartAnimation;                                // 0x0140(0x0068)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FSpineAnimationDefinition>      DefaultSpiritAnimations;                           // 0x01A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EDashChargeAnimationMode                      SpiritAnimationMode;                               // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FSpineAnimationDefinition> AnimationDataForNames;                     // 0x01C0(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSpineAnimationDefinition              SpiritAnimation_Up;                                // 0x0210(0x0068)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSpineAnimationDefinition              SpiritAnimation_UpLateral;                         // 0x0278(0x0068)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSpineAnimationDefinition              SpiritAnimation_Lateral;                           // 0x02E0(0x0068)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSpineAnimationDefinition              SpiritAnimation_DownLateral;                       // 0x0348(0x0068)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSpineAnimationDefinition              SpiritAnimation_Down;                              // 0x03B0(0x0068)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSet<EMovementMode>                           ValidMovementModes;                                // 0x0418(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoundData                             DashChargeSoundData;                               // 0x0468(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSoundData                             DashChargeLoopSoundData;                           // 0x0490(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDashChargeSettings) == 0x000010, "Wrong alignment on FDashChargeSettings");
static_assert(sizeof(FDashChargeSettings) == 0x0004C0, "Wrong size on FDashChargeSettings");
static_assert(offsetof(FDashChargeSettings, Mode) == 0x000000, "Member 'FDashChargeSettings::Mode' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, AbilityData) == 0x000010, "Member 'FDashChargeSettings::AbilityData' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, SpiritClass) == 0x0000F0, "Member 'FDashChargeSettings::SpiritClass' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, SummonParameters) == 0x0000F8, "Member 'FDashChargeSettings::SummonParameters' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, OrientationMode) == 0x000130, "Member 'FDashChargeSettings::OrientationMode' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, bBlendOrientation) == 0x000134, "Member 'FDashChargeSettings::bBlendOrientation' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, BlendOrientationSpeed) == 0x000138, "Member 'FDashChargeSettings::BlendOrientationSpeed' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, RideStartAnimation) == 0x000140, "Member 'FDashChargeSettings::RideStartAnimation' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, DefaultSpiritAnimations) == 0x0001A8, "Member 'FDashChargeSettings::DefaultSpiritAnimations' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, SpiritAnimationMode) == 0x0001B8, "Member 'FDashChargeSettings::SpiritAnimationMode' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, AnimationDataForNames) == 0x0001C0, "Member 'FDashChargeSettings::AnimationDataForNames' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, SpiritAnimation_Up) == 0x000210, "Member 'FDashChargeSettings::SpiritAnimation_Up' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, SpiritAnimation_UpLateral) == 0x000278, "Member 'FDashChargeSettings::SpiritAnimation_UpLateral' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, SpiritAnimation_Lateral) == 0x0002E0, "Member 'FDashChargeSettings::SpiritAnimation_Lateral' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, SpiritAnimation_DownLateral) == 0x000348, "Member 'FDashChargeSettings::SpiritAnimation_DownLateral' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, SpiritAnimation_Down) == 0x0003B0, "Member 'FDashChargeSettings::SpiritAnimation_Down' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, ValidMovementModes) == 0x000418, "Member 'FDashChargeSettings::ValidMovementModes' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, DashChargeSoundData) == 0x000468, "Member 'FDashChargeSettings::DashChargeSoundData' has a wrong offset!");
static_assert(offsetof(FDashChargeSettings, DashChargeLoopSoundData) == 0x000490, "Member 'FDashChargeSettings::DashChargeLoopSoundData' has a wrong offset!");

// ScriptStruct Zion.CustomRuntimeFloatCurve
// 0x0000 (0x0088 - 0x0088)
struct FCustomRuntimeFloatCurve final : public FRuntimeFloatCurve
{
};
static_assert(alignof(FCustomRuntimeFloatCurve) == 0x000008, "Wrong alignment on FCustomRuntimeFloatCurve");
static_assert(sizeof(FCustomRuntimeFloatCurve) == 0x000088, "Wrong size on FCustomRuntimeFloatCurve");

// ScriptStruct Zion.CurrencyTransactionInfos
// 0x0090 (0x0090 - 0x0000)
struct FCurrencyTransactionInfos final
{
public:
	ECurrencyType                                 CurrencyType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueType                                    CostType;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FixedValue;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCustomRuntimeFloatCurve               ValueCurve;                                        // 0x0008(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurrencyTransactionInfos) == 0x000008, "Wrong alignment on FCurrencyTransactionInfos");
static_assert(sizeof(FCurrencyTransactionInfos) == 0x000090, "Wrong size on FCurrencyTransactionInfos");
static_assert(offsetof(FCurrencyTransactionInfos, CurrencyType) == 0x000000, "Member 'FCurrencyTransactionInfos::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCurrencyTransactionInfos, CostType) == 0x000001, "Member 'FCurrencyTransactionInfos::CostType' has a wrong offset!");
static_assert(offsetof(FCurrencyTransactionInfos, FixedValue) == 0x000004, "Member 'FCurrencyTransactionInfos::FixedValue' has a wrong offset!");
static_assert(offsetof(FCurrencyTransactionInfos, ValueCurve) == 0x000008, "Member 'FCurrencyTransactionInfos::ValueCurve' has a wrong offset!");

// ScriptStruct Zion.InputDescription
// 0x0010 (0x0010 - 0x0000)
struct FInputDescription final
{
public:
	EInputType                                    InputType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIInputType                                  UIInputType;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionInputType                              ActionInputType;                                   // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           InputAction;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputDescription) == 0x000008, "Wrong alignment on FInputDescription");
static_assert(sizeof(FInputDescription) == 0x000010, "Wrong size on FInputDescription");
static_assert(offsetof(FInputDescription, InputType) == 0x000000, "Member 'FInputDescription::InputType' has a wrong offset!");
static_assert(offsetof(FInputDescription, UIInputType) == 0x000001, "Member 'FInputDescription::UIInputType' has a wrong offset!");
static_assert(offsetof(FInputDescription, ActionInputType) == 0x000002, "Member 'FInputDescription::ActionInputType' has a wrong offset!");
static_assert(offsetof(FInputDescription, InputAction) == 0x000008, "Member 'FInputDescription::InputAction' has a wrong offset!");

// ScriptStruct Zion.RichTextInputElement
// 0x0048 (0x0048 - 0x0000)
struct FRichTextInputElement final
{
public:
	struct FInputDescription                      InputDescription;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideInputDescription;                         // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InputOverride;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVerticalCenter;                                   // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRichTextInputElement) == 0x000008, "Wrong alignment on FRichTextInputElement");
static_assert(sizeof(FRichTextInputElement) == 0x000048, "Wrong size on FRichTextInputElement");
static_assert(offsetof(FRichTextInputElement, InputDescription) == 0x000000, "Member 'FRichTextInputElement::InputDescription' has a wrong offset!");
static_assert(offsetof(FRichTextInputElement, bOverrideInputDescription) == 0x000010, "Member 'FRichTextInputElement::bOverrideInputDescription' has a wrong offset!");
static_assert(offsetof(FRichTextInputElement, InputOverride) == 0x000018, "Member 'FRichTextInputElement::InputOverride' has a wrong offset!");
static_assert(offsetof(FRichTextInputElement, Color) == 0x000028, "Member 'FRichTextInputElement::Color' has a wrong offset!");
static_assert(offsetof(FRichTextInputElement, Width) == 0x000038, "Member 'FRichTextInputElement::Width' has a wrong offset!");
static_assert(offsetof(FRichTextInputElement, Height) == 0x00003C, "Member 'FRichTextInputElement::Height' has a wrong offset!");
static_assert(offsetof(FRichTextInputElement, bVerticalCenter) == 0x000040, "Member 'FRichTextInputElement::bVerticalCenter' has a wrong offset!");

// ScriptStruct Zion.InventoryItemUpgradeInfo
// 0x0030 (0x0030 - 0x0000)
struct FInventoryItemUpgradeInfo final
{
public:
	class FText                                   UpgradeText;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FRichTextInputElement>          UpgradeTextFormatElements;                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         UpgradeTextStringElements;                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemUpgradeInfo) == 0x000008, "Wrong alignment on FInventoryItemUpgradeInfo");
static_assert(sizeof(FInventoryItemUpgradeInfo) == 0x000030, "Wrong size on FInventoryItemUpgradeInfo");
static_assert(offsetof(FInventoryItemUpgradeInfo, UpgradeText) == 0x000000, "Member 'FInventoryItemUpgradeInfo::UpgradeText' has a wrong offset!");
static_assert(offsetof(FInventoryItemUpgradeInfo, UpgradeTextFormatElements) == 0x000010, "Member 'FInventoryItemUpgradeInfo::UpgradeTextFormatElements' has a wrong offset!");
static_assert(offsetof(FInventoryItemUpgradeInfo, UpgradeTextStringElements) == 0x000020, "Member 'FInventoryItemUpgradeInfo::UpgradeTextStringElements' has a wrong offset!");

// ScriptStruct Zion.PassiveUpgradeData
// 0x00B8 (0x00B8 - 0x0000)
struct FPassiveUpgradeData final
{
public:
	bool                                          bNewGamePlusOnly;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    UpgradePassive;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCurrencyTransactionInfos              UpgradePrice;                                      // 0x0018(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FInventoryItemUpgradeInfo>      UpgradeInfos;                                      // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPassiveUpgradeData) == 0x000008, "Wrong alignment on FPassiveUpgradeData");
static_assert(sizeof(FPassiveUpgradeData) == 0x0000B8, "Wrong size on FPassiveUpgradeData");
static_assert(offsetof(FPassiveUpgradeData, bNewGamePlusOnly) == 0x000000, "Member 'FPassiveUpgradeData::bNewGamePlusOnly' has a wrong offset!");
static_assert(offsetof(FPassiveUpgradeData, UpgradePassive) == 0x000008, "Member 'FPassiveUpgradeData::UpgradePassive' has a wrong offset!");
static_assert(offsetof(FPassiveUpgradeData, UpgradePrice) == 0x000018, "Member 'FPassiveUpgradeData::UpgradePrice' has a wrong offset!");
static_assert(offsetof(FPassiveUpgradeData, UpgradeInfos) == 0x0000A8, "Member 'FPassiveUpgradeData::UpgradeInfos' has a wrong offset!");

// ScriptStruct Zion.InventoryItemData
// 0x0160 (0x0168 - 0x0008)
struct FInventoryItemData : public FTableRowBase
{
public:
	EInventoryItemType                            ItemType;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEquipmentType                                EquipmentType;                                     // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPaperSprite>            Icon;                                              // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FRichTextInputElement>          DescriptionFormatElements;                         // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         DescriptionStringElements;                         // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FRichTextInputElement>          FlavorTextFormatElements;                          // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         FlavorStringElements;                              // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayCondition>         InventoryHideCondition;                            // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CollectableDropClass;                              // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurrencyTransactionInfos              BuyInfo;                                           // 0x00D8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemData) == 0x000008, "Wrong alignment on FInventoryItemData");
static_assert(sizeof(FInventoryItemData) == 0x000168, "Wrong size on FInventoryItemData");
static_assert(offsetof(FInventoryItemData, ItemType) == 0x000008, "Member 'FInventoryItemData::ItemType' has a wrong offset!");
static_assert(offsetof(FInventoryItemData, EquipmentType) == 0x000009, "Member 'FInventoryItemData::EquipmentType' has a wrong offset!");
static_assert(offsetof(FInventoryItemData, Icon) == 0x000010, "Member 'FInventoryItemData::Icon' has a wrong offset!");
static_assert(offsetof(FInventoryItemData, Name) == 0x000038, "Member 'FInventoryItemData::Name' has a wrong offset!");
static_assert(offsetof(FInventoryItemData, Description) == 0x000048, "Member 'FInventoryItemData::Description' has a wrong offset!");
static_assert(offsetof(FInventoryItemData, DescriptionFormatElements) == 0x000058, "Member 'FInventoryItemData::DescriptionFormatElements' has a wrong offset!");
static_assert(offsetof(FInventoryItemData, DescriptionStringElements) == 0x000068, "Member 'FInventoryItemData::DescriptionStringElements' has a wrong offset!");
static_assert(offsetof(FInventoryItemData, FlavorText) == 0x000078, "Member 'FInventoryItemData::FlavorText' has a wrong offset!");
static_assert(offsetof(FInventoryItemData, FlavorTextFormatElements) == 0x000088, "Member 'FInventoryItemData::FlavorTextFormatElements' has a wrong offset!");
static_assert(offsetof(FInventoryItemData, FlavorStringElements) == 0x000098, "Member 'FInventoryItemData::FlavorStringElements' has a wrong offset!");
static_assert(offsetof(FInventoryItemData, InventoryHideCondition) == 0x0000A8, "Member 'FInventoryItemData::InventoryHideCondition' has a wrong offset!");
static_assert(offsetof(FInventoryItemData, CollectableDropClass) == 0x0000B0, "Member 'FInventoryItemData::CollectableDropClass' has a wrong offset!");
static_assert(offsetof(FInventoryItemData, BuyInfo) == 0x0000D8, "Member 'FInventoryItemData::BuyInfo' has a wrong offset!");

// ScriptStruct Zion.InventoryItemGrantData
// 0x0008 (0x0170 - 0x0168)
struct FInventoryItemGrantData : public FInventoryItemData
{
public:
	bool                                          bGrantOnNewGame;                                   // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryItemGrantData) == 0x000008, "Wrong alignment on FInventoryItemGrantData");
static_assert(sizeof(FInventoryItemGrantData) == 0x000170, "Wrong size on FInventoryItemGrantData");
static_assert(offsetof(FInventoryItemGrantData, bGrantOnNewGame) == 0x000168, "Member 'FInventoryItemGrantData::bGrantOnNewGame' has a wrong offset!");

// ScriptStruct Zion.InventoryItemPassiveData
// 0x00F8 (0x0268 - 0x0170)
struct FInventoryItemPassiveData final : public FInventoryItemGrantData
{
public:
	int32                                         SlotCost;                                          // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PassiveClass;                                      // 0x0178(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeUpgraded;                                    // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPassiveUpgradeData                    UpgradeData;                                       // 0x01A8(0x00B8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EPassiveCountType                             CountType;                                         // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryItemPassiveData) == 0x000008, "Wrong alignment on FInventoryItemPassiveData");
static_assert(sizeof(FInventoryItemPassiveData) == 0x000268, "Wrong size on FInventoryItemPassiveData");
static_assert(offsetof(FInventoryItemPassiveData, SlotCost) == 0x000170, "Member 'FInventoryItemPassiveData::SlotCost' has a wrong offset!");
static_assert(offsetof(FInventoryItemPassiveData, PassiveClass) == 0x000178, "Member 'FInventoryItemPassiveData::PassiveClass' has a wrong offset!");
static_assert(offsetof(FInventoryItemPassiveData, bCanBeUpgraded) == 0x0001A0, "Member 'FInventoryItemPassiveData::bCanBeUpgraded' has a wrong offset!");
static_assert(offsetof(FInventoryItemPassiveData, UpgradeData) == 0x0001A8, "Member 'FInventoryItemPassiveData::UpgradeData' has a wrong offset!");
static_assert(offsetof(FInventoryItemPassiveData, CountType) == 0x000260, "Member 'FInventoryItemPassiveData::CountType' has a wrong offset!");

// ScriptStruct Zion.MapRestPointData
// 0x0008 (0x0008 - 0x0000)
struct FMapRestPointData final
{
public:
	class FName                                   RowName;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapRestPointData) == 0x000004, "Wrong alignment on FMapRestPointData");
static_assert(sizeof(FMapRestPointData) == 0x000008, "Wrong size on FMapRestPointData");
static_assert(offsetof(FMapRestPointData, RowName) == 0x000000, "Member 'FMapRestPointData::RowName' has a wrong offset!");

// ScriptStruct Zion.AIData
// 0x0090 (0x0090 - 0x0000)
struct FAIData final
{
public:
	TSoftObjectPtr<class UBlackboardData>         BlackboardData;                                    // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBehaviorTree>           BehaviorTree_Aggression;                           // 0x0028(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBehaviorTree>           BehaviorTree_Idle;                                 // 0x0050(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITargetDetectionType                        TargetDetectionType;                               // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDetectionDistance;                              // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDetectionDistance;                              // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckFront;                                       // 0x0084(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckLineOfSight;                                 // 0x0085(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInAmbush;                                         // 0x0086(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87[0x1];                                       // 0x0087(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PatrolRange;                                       // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIData) == 0x000008, "Wrong alignment on FAIData");
static_assert(sizeof(FAIData) == 0x000090, "Wrong size on FAIData");
static_assert(offsetof(FAIData, BlackboardData) == 0x000000, "Member 'FAIData::BlackboardData' has a wrong offset!");
static_assert(offsetof(FAIData, BehaviorTree_Aggression) == 0x000028, "Member 'FAIData::BehaviorTree_Aggression' has a wrong offset!");
static_assert(offsetof(FAIData, BehaviorTree_Idle) == 0x000050, "Member 'FAIData::BehaviorTree_Idle' has a wrong offset!");
static_assert(offsetof(FAIData, TargetDetectionType) == 0x000078, "Member 'FAIData::TargetDetectionType' has a wrong offset!");
static_assert(offsetof(FAIData, MinDetectionDistance) == 0x00007C, "Member 'FAIData::MinDetectionDistance' has a wrong offset!");
static_assert(offsetof(FAIData, MaxDetectionDistance) == 0x000080, "Member 'FAIData::MaxDetectionDistance' has a wrong offset!");
static_assert(offsetof(FAIData, bCheckFront) == 0x000084, "Member 'FAIData::bCheckFront' has a wrong offset!");
static_assert(offsetof(FAIData, bCheckLineOfSight) == 0x000085, "Member 'FAIData::bCheckLineOfSight' has a wrong offset!");
static_assert(offsetof(FAIData, bInAmbush) == 0x000086, "Member 'FAIData::bInAmbush' has a wrong offset!");
static_assert(offsetof(FAIData, PatrolRange) == 0x000088, "Member 'FAIData::PatrolRange' has a wrong offset!");

// ScriptStruct Zion.EnemyData
// 0x0128 (0x0130 - 0x0008)
struct FEnemyData final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CharacterClass;                                    // 0x0018(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AIControllerClass;                                 // 0x0040(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              LevelTable;                                        // 0x0068(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIData                                AIData;                                            // 0x0090(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FDataTableRowHandle>            ExtraEnemyInfo;                                    // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyData) == 0x000008, "Wrong alignment on FEnemyData");
static_assert(sizeof(FEnemyData) == 0x000130, "Wrong size on FEnemyData");
static_assert(offsetof(FEnemyData, Name) == 0x000008, "Member 'FEnemyData::Name' has a wrong offset!");
static_assert(offsetof(FEnemyData, CharacterClass) == 0x000018, "Member 'FEnemyData::CharacterClass' has a wrong offset!");
static_assert(offsetof(FEnemyData, AIControllerClass) == 0x000040, "Member 'FEnemyData::AIControllerClass' has a wrong offset!");
static_assert(offsetof(FEnemyData, LevelTable) == 0x000068, "Member 'FEnemyData::LevelTable' has a wrong offset!");
static_assert(offsetof(FEnemyData, AIData) == 0x000090, "Member 'FEnemyData::AIData' has a wrong offset!");
static_assert(offsetof(FEnemyData, ExtraEnemyInfo) == 0x000120, "Member 'FEnemyData::ExtraEnemyInfo' has a wrong offset!");

// ScriptStruct Zion.ExtraItemZoomData
// 0x0018 (0x0018 - 0x0000)
struct FExtraItemZoomData final
{
public:
	bool                                          bOverrideDefaultZoom;                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultZoom;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMinZoom;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinZoom;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMaxZoom;                                  // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxZoom;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtraItemZoomData) == 0x000004, "Wrong alignment on FExtraItemZoomData");
static_assert(sizeof(FExtraItemZoomData) == 0x000018, "Wrong size on FExtraItemZoomData");
static_assert(offsetof(FExtraItemZoomData, bOverrideDefaultZoom) == 0x000000, "Member 'FExtraItemZoomData::bOverrideDefaultZoom' has a wrong offset!");
static_assert(offsetof(FExtraItemZoomData, DefaultZoom) == 0x000004, "Member 'FExtraItemZoomData::DefaultZoom' has a wrong offset!");
static_assert(offsetof(FExtraItemZoomData, bOverrideMinZoom) == 0x000008, "Member 'FExtraItemZoomData::bOverrideMinZoom' has a wrong offset!");
static_assert(offsetof(FExtraItemZoomData, MinZoom) == 0x00000C, "Member 'FExtraItemZoomData::MinZoom' has a wrong offset!");
static_assert(offsetof(FExtraItemZoomData, bOverrideMaxZoom) == 0x000010, "Member 'FExtraItemZoomData::bOverrideMaxZoom' has a wrong offset!");
static_assert(offsetof(FExtraItemZoomData, MaxZoom) == 0x000014, "Member 'FExtraItemZoomData::MaxZoom' has a wrong offset!");

// ScriptStruct Zion.AnimationNameData
// 0x0030 (0x0030 - 0x0000)
struct FAnimationNameData final
{
public:
	TArray<class FString>                         AnimationNames;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   AnimationDisplayName;                              // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FString>                         AdditionalAnimations;                              // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationNameData) == 0x000008, "Wrong alignment on FAnimationNameData");
static_assert(sizeof(FAnimationNameData) == 0x000030, "Wrong size on FAnimationNameData");
static_assert(offsetof(FAnimationNameData, AnimationNames) == 0x000000, "Member 'FAnimationNameData::AnimationNames' has a wrong offset!");
static_assert(offsetof(FAnimationNameData, AnimationDisplayName) == 0x000010, "Member 'FAnimationNameData::AnimationDisplayName' has a wrong offset!");
static_assert(offsetof(FAnimationNameData, AdditionalAnimations) == 0x000020, "Member 'FAnimationNameData::AdditionalAnimations' has a wrong offset!");

// ScriptStruct Zion.ItemGenericAnimationSpiritLevelConditionData
// 0x0020 (0x0020 - 0x0000)
struct FItemGenericAnimationSpiritLevelConditionData final
{
public:
	ECommonOperator                               ConditionOperator;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    SpiritRowHandle;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         SpiritLevel;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemGenericAnimationSpiritLevelConditionData) == 0x000008, "Wrong alignment on FItemGenericAnimationSpiritLevelConditionData");
static_assert(sizeof(FItemGenericAnimationSpiritLevelConditionData) == 0x000020, "Wrong size on FItemGenericAnimationSpiritLevelConditionData");
static_assert(offsetof(FItemGenericAnimationSpiritLevelConditionData, ConditionOperator) == 0x000000, "Member 'FItemGenericAnimationSpiritLevelConditionData::ConditionOperator' has a wrong offset!");
static_assert(offsetof(FItemGenericAnimationSpiritLevelConditionData, SpiritRowHandle) == 0x000008, "Member 'FItemGenericAnimationSpiritLevelConditionData::SpiritRowHandle' has a wrong offset!");
static_assert(offsetof(FItemGenericAnimationSpiritLevelConditionData, SpiritLevel) == 0x000018, "Member 'FItemGenericAnimationSpiritLevelConditionData::SpiritLevel' has a wrong offset!");

// ScriptStruct Zion.ItemGenericAnimationConditionData
// 0x0020 (0x0020 - 0x0000)
struct FItemGenericAnimationConditionData final
{
public:
	TArray<struct FItemGenericAnimationSpiritLevelConditionData> SpiritLevelConditions;              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EAptitudeType>                         RequiredAptitudes;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemGenericAnimationConditionData) == 0x000008, "Wrong alignment on FItemGenericAnimationConditionData");
static_assert(sizeof(FItemGenericAnimationConditionData) == 0x000020, "Wrong size on FItemGenericAnimationConditionData");
static_assert(offsetof(FItemGenericAnimationConditionData, SpiritLevelConditions) == 0x000000, "Member 'FItemGenericAnimationConditionData::SpiritLevelConditions' has a wrong offset!");
static_assert(offsetof(FItemGenericAnimationConditionData, RequiredAptitudes) == 0x000010, "Member 'FItemGenericAnimationConditionData::RequiredAptitudes' has a wrong offset!");

// ScriptStruct Zion.InventoryItemGenericAnimationData
// 0x00A0 (0x00A0 - 0x0000)
struct FInventoryItemGenericAnimationData final
{
public:
	struct FAnimationNameData                     AnimationNameData;                                 // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bOverrideSkins;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Skins;                                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bOverrideLocomotionMode;                           // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExtraInfoLocomotionMode                      LocomotionMode;                                    // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSceneOffset;                              // 0x004A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SceneOffset;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSpineWidgetOffset;                        // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SpineWidgetOffset;                                 // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideRootMotionMode;                           // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExtraAnimationRootMotionMode                 RootMotionMode;                                    // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemGenericAnimationConditionData     AnimationDisplayConditions;                        // 0x0080(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemGenericAnimationData) == 0x000008, "Wrong alignment on FInventoryItemGenericAnimationData");
static_assert(sizeof(FInventoryItemGenericAnimationData) == 0x0000A0, "Wrong size on FInventoryItemGenericAnimationData");
static_assert(offsetof(FInventoryItemGenericAnimationData, AnimationNameData) == 0x000000, "Member 'FInventoryItemGenericAnimationData::AnimationNameData' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericAnimationData, bOverrideSkins) == 0x000030, "Member 'FInventoryItemGenericAnimationData::bOverrideSkins' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericAnimationData, Skins) == 0x000038, "Member 'FInventoryItemGenericAnimationData::Skins' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericAnimationData, bOverrideLocomotionMode) == 0x000048, "Member 'FInventoryItemGenericAnimationData::bOverrideLocomotionMode' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericAnimationData, LocomotionMode) == 0x000049, "Member 'FInventoryItemGenericAnimationData::LocomotionMode' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericAnimationData, bOverrideSceneOffset) == 0x00004A, "Member 'FInventoryItemGenericAnimationData::bOverrideSceneOffset' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericAnimationData, SceneOffset) == 0x000050, "Member 'FInventoryItemGenericAnimationData::SceneOffset' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericAnimationData, bOverrideSpineWidgetOffset) == 0x000060, "Member 'FInventoryItemGenericAnimationData::bOverrideSpineWidgetOffset' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericAnimationData, SpineWidgetOffset) == 0x000068, "Member 'FInventoryItemGenericAnimationData::SpineWidgetOffset' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericAnimationData, bOverrideRootMotionMode) == 0x000078, "Member 'FInventoryItemGenericAnimationData::bOverrideRootMotionMode' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericAnimationData, RootMotionMode) == 0x000079, "Member 'FInventoryItemGenericAnimationData::RootMotionMode' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericAnimationData, AnimationDisplayConditions) == 0x000080, "Member 'FInventoryItemGenericAnimationData::AnimationDisplayConditions' has a wrong offset!");

// ScriptStruct Zion.InventoryItemGenericInfoData
// 0x00D0 (0x0238 - 0x0168)
struct FInventoryItemGenericInfoData : public FInventoryItemData
{
public:
	bool                                          bIsPlayer;                                         // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USpineAtlasAsset>        Atlas;                                             // 0x0170(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USpineSkeletonDataAsset> SkeletonData;                                      // 0x0198(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideNormalBlendMaterial;                      // 0x01C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     NormalBlendMaterial;                               // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideScreenBlendMaterial;                      // 0x01D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ScreenBlendMaterial;                               // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExtraInfoLocomotionMode                      LocomotionMode;                                    // 0x01E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x3];                                      // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExtraItemZoomData                     ZoomData;                                          // 0x01E4(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SceneOffset;                                       // 0x0200(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SpineWidgetOffset;                                 // 0x0210(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExtraAnimationRootMotionMode                 RootMotionMode;                                    // 0x0220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInventoryItemGenericAnimationData> Animations;                                    // 0x0228(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemGenericInfoData) == 0x000008, "Wrong alignment on FInventoryItemGenericInfoData");
static_assert(sizeof(FInventoryItemGenericInfoData) == 0x000238, "Wrong size on FInventoryItemGenericInfoData");
static_assert(offsetof(FInventoryItemGenericInfoData, bIsPlayer) == 0x000168, "Member 'FInventoryItemGenericInfoData::bIsPlayer' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericInfoData, Atlas) == 0x000170, "Member 'FInventoryItemGenericInfoData::Atlas' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericInfoData, SkeletonData) == 0x000198, "Member 'FInventoryItemGenericInfoData::SkeletonData' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericInfoData, bOverrideNormalBlendMaterial) == 0x0001C0, "Member 'FInventoryItemGenericInfoData::bOverrideNormalBlendMaterial' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericInfoData, NormalBlendMaterial) == 0x0001C8, "Member 'FInventoryItemGenericInfoData::NormalBlendMaterial' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericInfoData, bOverrideScreenBlendMaterial) == 0x0001D0, "Member 'FInventoryItemGenericInfoData::bOverrideScreenBlendMaterial' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericInfoData, ScreenBlendMaterial) == 0x0001D8, "Member 'FInventoryItemGenericInfoData::ScreenBlendMaterial' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericInfoData, LocomotionMode) == 0x0001E0, "Member 'FInventoryItemGenericInfoData::LocomotionMode' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericInfoData, ZoomData) == 0x0001E4, "Member 'FInventoryItemGenericInfoData::ZoomData' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericInfoData, SceneOffset) == 0x000200, "Member 'FInventoryItemGenericInfoData::SceneOffset' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericInfoData, SpineWidgetOffset) == 0x000210, "Member 'FInventoryItemGenericInfoData::SpineWidgetOffset' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericInfoData, RootMotionMode) == 0x000220, "Member 'FInventoryItemGenericInfoData::RootMotionMode' has a wrong offset!");
static_assert(offsetof(FInventoryItemGenericInfoData, Animations) == 0x000228, "Member 'FInventoryItemGenericInfoData::Animations' has a wrong offset!");

// ScriptStruct Zion.ItemConditionData
// 0x0038 (0x0038 - 0x0000)
struct FItemConditionData final
{
public:
	TArray<TSoftObjectPtr<class UEventAsset>>     ClearedEvents;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	EEventClearedCheckMode                        EventCheckMode;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDataTableRowHandle>            OwnedItems;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EGameEndingType>                       ReachedEndings;                                    // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemConditionData) == 0x000008, "Wrong alignment on FItemConditionData");
static_assert(sizeof(FItemConditionData) == 0x000038, "Wrong size on FItemConditionData");
static_assert(offsetof(FItemConditionData, ClearedEvents) == 0x000000, "Member 'FItemConditionData::ClearedEvents' has a wrong offset!");
static_assert(offsetof(FItemConditionData, EventCheckMode) == 0x000010, "Member 'FItemConditionData::EventCheckMode' has a wrong offset!");
static_assert(offsetof(FItemConditionData, OwnedItems) == 0x000018, "Member 'FItemConditionData::OwnedItems' has a wrong offset!");
static_assert(offsetof(FItemConditionData, ReachedEndings) == 0x000028, "Member 'FItemConditionData::ReachedEndings' has a wrong offset!");

// ScriptStruct Zion.InventoryItemNPCInfoData
// 0x0038 (0x0270 - 0x0238)
struct FInventoryItemNPCInfoData final : public FInventoryItemGenericInfoData
{
public:
	struct FItemConditionData                     Conditions;                                        // 0x0238(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemNPCInfoData) == 0x000008, "Wrong alignment on FInventoryItemNPCInfoData");
static_assert(sizeof(FInventoryItemNPCInfoData) == 0x000270, "Wrong size on FInventoryItemNPCInfoData");
static_assert(offsetof(FInventoryItemNPCInfoData, Conditions) == 0x000238, "Member 'FInventoryItemNPCInfoData::Conditions' has a wrong offset!");

// ScriptStruct Zion.AbilityArray
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAbilityArray final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityArray) == 0x000008, "Wrong alignment on FAbilityArray");
static_assert(sizeof(FAbilityArray) == 0x000010, "Wrong size on FAbilityArray");

// ScriptStruct Zion.AbilityAdditionalData
// 0x0010 (0x0010 - 0x0000)
struct FAbilityAdditionalData final
{
public:
	ECommandSetCategory                           CommandSetCategory;                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SourceOverride;                                    // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityAdditionalData) == 0x000008, "Wrong alignment on FAbilityAdditionalData");
static_assert(sizeof(FAbilityAdditionalData) == 0x000010, "Wrong size on FAbilityAdditionalData");
static_assert(offsetof(FAbilityAdditionalData, CommandSetCategory) == 0x000000, "Member 'FAbilityAdditionalData::CommandSetCategory' has a wrong offset!");
static_assert(offsetof(FAbilityAdditionalData, SourceOverride) == 0x000008, "Member 'FAbilityAdditionalData::SourceOverride' has a wrong offset!");

// ScriptStruct Zion.RestPointData
// 0x0080 (0x0088 - 0x0008)
struct FRestPointData final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    GameMapID;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   PlayerStartTag;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRespawnAnimations;                          // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowBackToRestPoint;                             // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPaperSprite>            ThumbnailIcon;                                     // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SaveIcon;                                          // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRestPointData) == 0x000008, "Wrong alignment on FRestPointData");
static_assert(sizeof(FRestPointData) == 0x000088, "Wrong size on FRestPointData");
static_assert(offsetof(FRestPointData, Name) == 0x000008, "Member 'FRestPointData::Name' has a wrong offset!");
static_assert(offsetof(FRestPointData, GameMapID) == 0x000018, "Member 'FRestPointData::GameMapID' has a wrong offset!");
static_assert(offsetof(FRestPointData, PlayerStartTag) == 0x000028, "Member 'FRestPointData::PlayerStartTag' has a wrong offset!");
static_assert(offsetof(FRestPointData, bEnableRespawnAnimations) == 0x000030, "Member 'FRestPointData::bEnableRespawnAnimations' has a wrong offset!");
static_assert(offsetof(FRestPointData, bAllowBackToRestPoint) == 0x000031, "Member 'FRestPointData::bAllowBackToRestPoint' has a wrong offset!");
static_assert(offsetof(FRestPointData, ThumbnailIcon) == 0x000038, "Member 'FRestPointData::ThumbnailIcon' has a wrong offset!");
static_assert(offsetof(FRestPointData, SaveIcon) == 0x000060, "Member 'FRestPointData::SaveIcon' has a wrong offset!");

// ScriptStruct Zion.ObjectArray
// 0x0010 (0x0010 - 0x0000)
struct FObjectArray final
{
public:
	TArray<class UObject*>                        Entries;                                           // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectArray) == 0x000008, "Wrong alignment on FObjectArray");
static_assert(sizeof(FObjectArray) == 0x000010, "Wrong size on FObjectArray");
static_assert(offsetof(FObjectArray, Entries) == 0x000000, "Member 'FObjectArray::Entries' has a wrong offset!");

// ScriptStruct Zion.AchievementData
// 0x0080 (0x0088 - 0x0008)
struct FAchievementData final : public FTableRowBase
{
public:
	EZionAchievement                              Achievement;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            LockedIcon;                                        // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            UnlockedIcon;                                      // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHidden;                                         // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAchievementData) == 0x000008, "Wrong alignment on FAchievementData");
static_assert(sizeof(FAchievementData) == 0x000088, "Wrong size on FAchievementData");
static_assert(offsetof(FAchievementData, Achievement) == 0x000008, "Member 'FAchievementData::Achievement' has a wrong offset!");
static_assert(offsetof(FAchievementData, Name) == 0x000010, "Member 'FAchievementData::Name' has a wrong offset!");
static_assert(offsetof(FAchievementData, Description) == 0x000020, "Member 'FAchievementData::Description' has a wrong offset!");
static_assert(offsetof(FAchievementData, LockedIcon) == 0x000030, "Member 'FAchievementData::LockedIcon' has a wrong offset!");
static_assert(offsetof(FAchievementData, UnlockedIcon) == 0x000058, "Member 'FAchievementData::UnlockedIcon' has a wrong offset!");
static_assert(offsetof(FAchievementData, bIsHidden) == 0x000080, "Member 'FAchievementData::bIsHidden' has a wrong offset!");

// ScriptStruct Zion.EquippedAssist
// 0x0220 (0x0220 - 0x0000)
struct FEquippedAssist final
{
public:
	uint8                                         Pad_0[0x210];                                      // 0x0000(0x0210)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssist*                                AssistInstance;                                    // 0x0210(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAssistVisual*                          AssistVisual;                                      // 0x0218(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquippedAssist) == 0x000008, "Wrong alignment on FEquippedAssist");
static_assert(sizeof(FEquippedAssist) == 0x000220, "Wrong size on FEquippedAssist");
static_assert(offsetof(FEquippedAssist, AssistInstance) == 0x000210, "Member 'FEquippedAssist::AssistInstance' has a wrong offset!");
static_assert(offsetof(FEquippedAssist, AssistVisual) == 0x000218, "Member 'FEquippedAssist::AssistVisual' has a wrong offset!");

// ScriptStruct Zion.FadeParameters
// 0x0014 (0x0014 - 0x0000)
struct FFadeParameters final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFadeParameters) == 0x000004, "Wrong alignment on FFadeParameters");
static_assert(sizeof(FFadeParameters) == 0x000014, "Wrong size on FFadeParameters");
static_assert(offsetof(FFadeParameters, Time) == 0x000000, "Member 'FFadeParameters::Time' has a wrong offset!");
static_assert(offsetof(FFadeParameters, Color) == 0x000004, "Member 'FFadeParameters::Color' has a wrong offset!");

// ScriptStruct Zion.NotificationData
// 0x0040 (0x0040 - 0x0000)
struct FNotificationData final
{
public:
	TSoftObjectPtr<class UPaperSprite>            Icon;                                              // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNotificationData) == 0x000008, "Wrong alignment on FNotificationData");
static_assert(sizeof(FNotificationData) == 0x000040, "Wrong size on FNotificationData");
static_assert(offsetof(FNotificationData, Icon) == 0x000000, "Member 'FNotificationData::Icon' has a wrong offset!");
static_assert(offsetof(FNotificationData, Text) == 0x000028, "Member 'FNotificationData::Text' has a wrong offset!");
static_assert(offsetof(FNotificationData, Duration) == 0x000038, "Member 'FNotificationData::Duration' has a wrong offset!");

// ScriptStruct Zion.DecoratorNearGroundDirectionData
// 0x0008 (0x0008 - 0x0000)
struct FDecoratorNearGroundDirectionData final
{
public:
	float                                         GroundCheckDirectionOffset;                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckDistance;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDecoratorNearGroundDirectionData) == 0x000004, "Wrong alignment on FDecoratorNearGroundDirectionData");
static_assert(sizeof(FDecoratorNearGroundDirectionData) == 0x000008, "Wrong size on FDecoratorNearGroundDirectionData");
static_assert(offsetof(FDecoratorNearGroundDirectionData, GroundCheckDirectionOffset) == 0x000000, "Member 'FDecoratorNearGroundDirectionData::GroundCheckDirectionOffset' has a wrong offset!");
static_assert(offsetof(FDecoratorNearGroundDirectionData, GroundCheckDistance) == 0x000004, "Member 'FDecoratorNearGroundDirectionData::GroundCheckDistance' has a wrong offset!");

// ScriptStruct Zion.GameplayConditionChecker
// 0x0018 (0x0018 - 0x0000)
struct FGameplayConditionChecker final
{
public:
	EConditionOperator                            Operator;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGameplayCondition*>             GameplayConditions;                                // 0x0008(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayConditionChecker) == 0x000008, "Wrong alignment on FGameplayConditionChecker");
static_assert(sizeof(FGameplayConditionChecker) == 0x000018, "Wrong size on FGameplayConditionChecker");
static_assert(offsetof(FGameplayConditionChecker, Operator) == 0x000000, "Member 'FGameplayConditionChecker::Operator' has a wrong offset!");
static_assert(offsetof(FGameplayConditionChecker, GameplayConditions) == 0x000008, "Member 'FGameplayConditionChecker::GameplayConditions' has a wrong offset!");

// ScriptStruct Zion.ConditionedTexture
// 0x0040 (0x0040 - 0x0000)
struct FConditionedTexture final
{
public:
	struct FGameplayConditionChecker              Condition;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Texture;                                           // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionedTexture) == 0x000008, "Wrong alignment on FConditionedTexture");
static_assert(sizeof(FConditionedTexture) == 0x000040, "Wrong size on FConditionedTexture");
static_assert(offsetof(FConditionedTexture, Condition) == 0x000000, "Member 'FConditionedTexture::Condition' has a wrong offset!");
static_assert(offsetof(FConditionedTexture, Texture) == 0x000018, "Member 'FConditionedTexture::Texture' has a wrong offset!");

// ScriptStruct Zion.FindClosestEnemySettings
// 0x0010 (0x0010 - 0x0000)
struct FFindClosestEnemySettings final
{
public:
	EAITargetDetectionType                        TargetDetectionType;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDetectionDistance;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDetectionDistance;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckFront;                                       // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckLineOfSight;                                 // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFindClosestEnemySettings) == 0x000004, "Wrong alignment on FFindClosestEnemySettings");
static_assert(sizeof(FFindClosestEnemySettings) == 0x000010, "Wrong size on FFindClosestEnemySettings");
static_assert(offsetof(FFindClosestEnemySettings, TargetDetectionType) == 0x000000, "Member 'FFindClosestEnemySettings::TargetDetectionType' has a wrong offset!");
static_assert(offsetof(FFindClosestEnemySettings, MinDetectionDistance) == 0x000004, "Member 'FFindClosestEnemySettings::MinDetectionDistance' has a wrong offset!");
static_assert(offsetof(FFindClosestEnemySettings, MaxDetectionDistance) == 0x000008, "Member 'FFindClosestEnemySettings::MaxDetectionDistance' has a wrong offset!");
static_assert(offsetof(FFindClosestEnemySettings, bCheckFront) == 0x00000C, "Member 'FFindClosestEnemySettings::bCheckFront' has a wrong offset!");
static_assert(offsetof(FFindClosestEnemySettings, bCheckLineOfSight) == 0x00000D, "Member 'FFindClosestEnemySettings::bCheckLineOfSight' has a wrong offset!");

// ScriptStruct Zion.EnemyRepulsionData
// 0x0098 (0x0098 - 0x0000)
struct FEnemyRepulsionData final
{
public:
	float                                         MaxSpeedReductionFactor;                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinForceFactor;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxForceFactor;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     ForceFactorCurve;                                  // 0x0010(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyRepulsionData) == 0x000008, "Wrong alignment on FEnemyRepulsionData");
static_assert(sizeof(FEnemyRepulsionData) == 0x000098, "Wrong size on FEnemyRepulsionData");
static_assert(offsetof(FEnemyRepulsionData, MaxSpeedReductionFactor) == 0x000000, "Member 'FEnemyRepulsionData::MaxSpeedReductionFactor' has a wrong offset!");
static_assert(offsetof(FEnemyRepulsionData, MinForceFactor) == 0x000004, "Member 'FEnemyRepulsionData::MinForceFactor' has a wrong offset!");
static_assert(offsetof(FEnemyRepulsionData, MaxForceFactor) == 0x000008, "Member 'FEnemyRepulsionData::MaxForceFactor' has a wrong offset!");
static_assert(offsetof(FEnemyRepulsionData, ForceFactorCurve) == 0x000010, "Member 'FEnemyRepulsionData::ForceFactorCurve' has a wrong offset!");

// ScriptStruct Zion.NameSet
// 0x0050 (0x0050 - 0x0000)
struct FNameSet final
{
public:
	TSet<class FName>                             Set;                                               // 0x0000(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNameSet) == 0x000008, "Wrong alignment on FNameSet");
static_assert(sizeof(FNameSet) == 0x000050, "Wrong size on FNameSet");
static_assert(offsetof(FNameSet, Set) == 0x000000, "Member 'FNameSet::Set' has a wrong offset!");

// ScriptStruct Zion.ClearActorData
// 0x0010 (0x0010 - 0x0000)
struct FClearActorData final
{
public:
	class FName                                   WorldName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorID;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClearActorData) == 0x000004, "Wrong alignment on FClearActorData");
static_assert(sizeof(FClearActorData) == 0x000010, "Wrong size on FClearActorData");
static_assert(offsetof(FClearActorData, WorldName) == 0x000000, "Member 'FClearActorData::WorldName' has a wrong offset!");
static_assert(offsetof(FClearActorData, ActorID) == 0x000008, "Member 'FClearActorData::ActorID' has a wrong offset!");

// ScriptStruct Zion.RecollectionBossRushRecordData
// 0x0004 (0x0004 - 0x0000)
struct FRecollectionBossRushRecordData final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecollectionBossRushRecordData) == 0x000004, "Wrong alignment on FRecollectionBossRushRecordData");
static_assert(sizeof(FRecollectionBossRushRecordData) == 0x000004, "Wrong size on FRecollectionBossRushRecordData");
static_assert(offsetof(FRecollectionBossRushRecordData, Time) == 0x000000, "Member 'FRecollectionBossRushRecordData::Time' has a wrong offset!");

// ScriptStruct Zion.ChargeReleaseData
// 0x0018 (0x0018 - 0x0000)
struct FChargeReleaseData final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChargeReleaseData) == 0x000008, "Wrong alignment on FChargeReleaseData");
static_assert(sizeof(FChargeReleaseData) == 0x000018, "Wrong size on FChargeReleaseData");
static_assert(offsetof(FChargeReleaseData, Time) == 0x000000, "Member 'FChargeReleaseData::Time' has a wrong offset!");
static_assert(offsetof(FChargeReleaseData, CommandClasses) == 0x000008, "Member 'FChargeReleaseData::CommandClasses' has a wrong offset!");

// ScriptStruct Zion.CommandSettings
// 0x0020 (0x0020 - 0x0000)
struct FCommandSettings final
{
public:
	ECommandCategory                              Category;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommandPriorityType                          Priority;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommandLayerType                             CommandLayer;                                      // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           InputAction;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveOnStartFailure;                             // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputActionTriggerMode                       InputActionTriggerMode;                            // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BufferTTL;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCommand>                   CommandClass;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommandSettings) == 0x000008, "Wrong alignment on FCommandSettings");
static_assert(sizeof(FCommandSettings) == 0x000020, "Wrong size on FCommandSettings");
static_assert(offsetof(FCommandSettings, Category) == 0x000000, "Member 'FCommandSettings::Category' has a wrong offset!");
static_assert(offsetof(FCommandSettings, Priority) == 0x000001, "Member 'FCommandSettings::Priority' has a wrong offset!");
static_assert(offsetof(FCommandSettings, CommandLayer) == 0x000002, "Member 'FCommandSettings::CommandLayer' has a wrong offset!");
static_assert(offsetof(FCommandSettings, InputAction) == 0x000008, "Member 'FCommandSettings::InputAction' has a wrong offset!");
static_assert(offsetof(FCommandSettings, bRemoveOnStartFailure) == 0x000010, "Member 'FCommandSettings::bRemoveOnStartFailure' has a wrong offset!");
static_assert(offsetof(FCommandSettings, InputActionTriggerMode) == 0x000011, "Member 'FCommandSettings::InputActionTriggerMode' has a wrong offset!");
static_assert(offsetof(FCommandSettings, BufferTTL) == 0x000014, "Member 'FCommandSettings::BufferTTL' has a wrong offset!");
static_assert(offsetof(FCommandSettings, CommandClass) == 0x000018, "Member 'FCommandSettings::CommandClass' has a wrong offset!");

// ScriptStruct Zion.CommandSettingsContainer
// 0x0028 (0x0028 - 0x0000)
struct FCommandSettingsContainer final
{
public:
	struct FCommandSettings                       CommandSettings;                                   // 0x0000(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	class UCommandSet*                            CommandSet;                                        // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommandSettingsContainer) == 0x000008, "Wrong alignment on FCommandSettingsContainer");
static_assert(sizeof(FCommandSettingsContainer) == 0x000028, "Wrong size on FCommandSettingsContainer");
static_assert(offsetof(FCommandSettingsContainer, CommandSettings) == 0x000000, "Member 'FCommandSettingsContainer::CommandSettings' has a wrong offset!");
static_assert(offsetof(FCommandSettingsContainer, CommandSet) == 0x000020, "Member 'FCommandSettingsContainer::CommandSet' has a wrong offset!");

// ScriptStruct Zion.RuntimeCheckpointData
// 0x0018 (0x0018 - 0x0000)
struct FRuntimeCheckpointData final
{
public:
	struct FDataTableRowHandle                    GameMapID;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   PlayerStartTag;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuntimeCheckpointData) == 0x000008, "Wrong alignment on FRuntimeCheckpointData");
static_assert(sizeof(FRuntimeCheckpointData) == 0x000018, "Wrong size on FRuntimeCheckpointData");
static_assert(offsetof(FRuntimeCheckpointData, GameMapID) == 0x000000, "Member 'FRuntimeCheckpointData::GameMapID' has a wrong offset!");
static_assert(offsetof(FRuntimeCheckpointData, PlayerStartTag) == 0x000010, "Member 'FRuntimeCheckpointData::PlayerStartTag' has a wrong offset!");

// ScriptStruct Zion.PileAttackChargeLevel
// 0x0310 (0x0310 - 0x0000)
struct FPileAttackChargeLevel final
{
public:
	float                                         ChargeTime;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             States;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           LaunchFXData;                                      // 0x0020(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSpineFXData                           LoopFXData;                                        // 0x0120(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAbilityData                           AbilityData;                                       // 0x0220(0x00E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCommand>>           Commands;                                          // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPileAttackChargeLevel) == 0x000010, "Wrong alignment on FPileAttackChargeLevel");
static_assert(sizeof(FPileAttackChargeLevel) == 0x000310, "Wrong size on FPileAttackChargeLevel");
static_assert(offsetof(FPileAttackChargeLevel, ChargeTime) == 0x000000, "Member 'FPileAttackChargeLevel::ChargeTime' has a wrong offset!");
static_assert(offsetof(FPileAttackChargeLevel, States) == 0x000008, "Member 'FPileAttackChargeLevel::States' has a wrong offset!");
static_assert(offsetof(FPileAttackChargeLevel, LaunchFXData) == 0x000020, "Member 'FPileAttackChargeLevel::LaunchFXData' has a wrong offset!");
static_assert(offsetof(FPileAttackChargeLevel, LoopFXData) == 0x000120, "Member 'FPileAttackChargeLevel::LoopFXData' has a wrong offset!");
static_assert(offsetof(FPileAttackChargeLevel, AbilityData) == 0x000220, "Member 'FPileAttackChargeLevel::AbilityData' has a wrong offset!");
static_assert(offsetof(FPileAttackChargeLevel, Commands) == 0x000300, "Member 'FPileAttackChargeLevel::Commands' has a wrong offset!");

// ScriptStruct Zion.CachedCommands
// 0x0010 (0x0010 - 0x0000)
struct FCachedCommands final
{
public:
	TArray<class UCommand*>                       Commands;                                          // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCachedCommands) == 0x000008, "Wrong alignment on FCachedCommands");
static_assert(sizeof(FCachedCommands) == 0x000010, "Wrong size on FCachedCommands");
static_assert(offsetof(FCachedCommands, Commands) == 0x000000, "Member 'FCachedCommands::Commands' has a wrong offset!");

// ScriptStruct Zion.RecollectionItemData
// 0x0070 (0x0078 - 0x0008)
struct FRecollectionItemData : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            ThumbnailIcon;                                     // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemConditionData                     Conditions;                                        // 0x0040(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecollectionItemData) == 0x000008, "Wrong alignment on FRecollectionItemData");
static_assert(sizeof(FRecollectionItemData) == 0x000078, "Wrong size on FRecollectionItemData");
static_assert(offsetof(FRecollectionItemData, Name) == 0x000008, "Member 'FRecollectionItemData::Name' has a wrong offset!");
static_assert(offsetof(FRecollectionItemData, ThumbnailIcon) == 0x000018, "Member 'FRecollectionItemData::ThumbnailIcon' has a wrong offset!");
static_assert(offsetof(FRecollectionItemData, Conditions) == 0x000040, "Member 'FRecollectionItemData::Conditions' has a wrong offset!");

// ScriptStruct Zion.RecollectionBossData
// 0x0018 (0x0090 - 0x0078)
struct FRecollectionBossData final : public FRecollectionItemData
{
public:
	struct FDataTableRowHandle                    Map;                                               // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   PlayerStartTag;                                    // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecollectionBossData) == 0x000008, "Wrong alignment on FRecollectionBossData");
static_assert(sizeof(FRecollectionBossData) == 0x000090, "Wrong size on FRecollectionBossData");
static_assert(offsetof(FRecollectionBossData, Map) == 0x000078, "Member 'FRecollectionBossData::Map' has a wrong offset!");
static_assert(offsetof(FRecollectionBossData, PlayerStartTag) == 0x000088, "Member 'FRecollectionBossData::PlayerStartTag' has a wrong offset!");

// ScriptStruct Zion.CommandLayer
// 0x0020 (0x0020 - 0x0000)
struct FCommandLayer final
{
public:
	class UCommand*                               CurrCommand;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCommand*>                       CommandQueue;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, Transient, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	ECommandLayerType                             LayerType;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCommandLayer) == 0x000008, "Wrong alignment on FCommandLayer");
static_assert(sizeof(FCommandLayer) == 0x000020, "Wrong size on FCommandLayer");
static_assert(offsetof(FCommandLayer, CurrCommand) == 0x000000, "Member 'FCommandLayer::CurrCommand' has a wrong offset!");
static_assert(offsetof(FCommandLayer, CommandQueue) == 0x000008, "Member 'FCommandLayer::CommandQueue' has a wrong offset!");
static_assert(offsetof(FCommandLayer, LayerType) == 0x000018, "Member 'FCommandLayer::LayerType' has a wrong offset!");

// ScriptStruct Zion.AnimationDefinitionList
// 0x0010 (0x0010 - 0x0000)
struct FAnimationDefinitionList final
{
public:
	TArray<struct FSpineAnimationDefinition>      AnimationDefinitions;                              // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationDefinitionList) == 0x000008, "Wrong alignment on FAnimationDefinitionList");
static_assert(sizeof(FAnimationDefinitionList) == 0x000010, "Wrong size on FAnimationDefinitionList");
static_assert(offsetof(FAnimationDefinitionList, AnimationDefinitions) == 0x000000, "Member 'FAnimationDefinitionList::AnimationDefinitions' has a wrong offset!");

// ScriptStruct Zion.SpineSimpleAnimationDefinition
// 0x0018 (0x0018 - 0x0000)
struct FSpineSimpleAnimationDefinition final
{
public:
	class FString                                 AnimationName;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpineSimpleAnimationDefinition) == 0x000008, "Wrong alignment on FSpineSimpleAnimationDefinition");
static_assert(sizeof(FSpineSimpleAnimationDefinition) == 0x000018, "Wrong size on FSpineSimpleAnimationDefinition");
static_assert(offsetof(FSpineSimpleAnimationDefinition, AnimationName) == 0x000000, "Member 'FSpineSimpleAnimationDefinition::AnimationName' has a wrong offset!");
static_assert(offsetof(FSpineSimpleAnimationDefinition, bLoop) == 0x000010, "Member 'FSpineSimpleAnimationDefinition::bLoop' has a wrong offset!");

// ScriptStruct Zion.SimpleAnimationDefinitionList
// 0x0010 (0x0010 - 0x0000)
struct FSimpleAnimationDefinitionList final
{
public:
	TArray<struct FSpineSimpleAnimationDefinition> AnimationDefinitions;                             // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleAnimationDefinitionList) == 0x000008, "Wrong alignment on FSimpleAnimationDefinitionList");
static_assert(sizeof(FSimpleAnimationDefinitionList) == 0x000010, "Wrong size on FSimpleAnimationDefinitionList");
static_assert(offsetof(FSimpleAnimationDefinitionList, AnimationDefinitions) == 0x000000, "Member 'FSimpleAnimationDefinitionList::AnimationDefinitions' has a wrong offset!");

// ScriptStruct Zion.DashToData
// 0x0078 (0x0078 - 0x0000)
struct FDashToData final
{
public:
	float                                         MoveDelay;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MoveVelocity;                                      // 0x0008(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MoveFactorCurve;                                   // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRootMotionFinishVelocitySettingsBP    FinishVelocitySettings;                            // 0x0028(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bToggleFacingOnStop;                               // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      DashAnimations;                                    // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FSpineAnimationDefinition>      DashStopAnimations;                                // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDashToData) == 0x000008, "Wrong alignment on FDashToData");
static_assert(sizeof(FDashToData) == 0x000078, "Wrong size on FDashToData");
static_assert(offsetof(FDashToData, MoveDelay) == 0x000000, "Member 'FDashToData::MoveDelay' has a wrong offset!");
static_assert(offsetof(FDashToData, MoveVelocity) == 0x000008, "Member 'FDashToData::MoveVelocity' has a wrong offset!");
static_assert(offsetof(FDashToData, MoveFactorCurve) == 0x000020, "Member 'FDashToData::MoveFactorCurve' has a wrong offset!");
static_assert(offsetof(FDashToData, FinishVelocitySettings) == 0x000028, "Member 'FDashToData::FinishVelocitySettings' has a wrong offset!");
static_assert(offsetof(FDashToData, bToggleFacingOnStop) == 0x000050, "Member 'FDashToData::bToggleFacingOnStop' has a wrong offset!");
static_assert(offsetof(FDashToData, DashAnimations) == 0x000058, "Member 'FDashToData::DashAnimations' has a wrong offset!");
static_assert(offsetof(FDashToData, DashStopAnimations) == 0x000068, "Member 'FDashToData::DashStopAnimations' has a wrong offset!");

// ScriptStruct Zion.TextIntStruct
// 0x0018 (0x0018 - 0x0000)
struct FTextIntStruct final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTextIntStruct) == 0x000008, "Wrong alignment on FTextIntStruct");
static_assert(sizeof(FTextIntStruct) == 0x000018, "Wrong size on FTextIntStruct");
static_assert(offsetof(FTextIntStruct, Text) == 0x000000, "Member 'FTextIntStruct::Text' has a wrong offset!");
static_assert(offsetof(FTextIntStruct, Value) == 0x000010, "Member 'FTextIntStruct::Value' has a wrong offset!");

// ScriptStruct Zion.CurrencyValue
// 0x0008 (0x0008 - 0x0000)
struct FCurrencyValue final
{
public:
	ECurrencyType                                 CurrencyType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurrencyValue) == 0x000004, "Wrong alignment on FCurrencyValue");
static_assert(sizeof(FCurrencyValue) == 0x000008, "Wrong size on FCurrencyValue");
static_assert(offsetof(FCurrencyValue, CurrencyType) == 0x000000, "Member 'FCurrencyValue::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCurrencyValue, Value) == 0x000004, "Member 'FCurrencyValue::Value' has a wrong offset!");

// ScriptStruct Zion.DataTableRowHandleKey
// 0x0030 (0x0030 - 0x0000)
struct FDataTableRowHandleKey final
{
public:
	TSoftObjectPtr<class UDataTable>              DataTable;                                         // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataTableRowHandleKey) == 0x000008, "Wrong alignment on FDataTableRowHandleKey");
static_assert(sizeof(FDataTableRowHandleKey) == 0x000030, "Wrong size on FDataTableRowHandleKey");
static_assert(offsetof(FDataTableRowHandleKey, DataTable) == 0x000000, "Member 'FDataTableRowHandleKey::DataTable' has a wrong offset!");
static_assert(offsetof(FDataTableRowHandleKey, Name) == 0x000028, "Member 'FDataTableRowHandleKey::Name' has a wrong offset!");

// ScriptStruct Zion.DifficultySettings
// 0x0018 (0x0018 - 0x0000)
struct FDifficultySettings final
{
public:
	float                                         EnemyMaxHPFactor;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyAttackFactor;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyActionFrequency;                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyStaminaFactor;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyStaminaRecoverySpeedFactor;                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerOneShotKill;                                // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerNoHeal;                                     // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnemyNoLeadFX;                                    // 0x0016(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDifficultySettings) == 0x000004, "Wrong alignment on FDifficultySettings");
static_assert(sizeof(FDifficultySettings) == 0x000018, "Wrong size on FDifficultySettings");
static_assert(offsetof(FDifficultySettings, EnemyMaxHPFactor) == 0x000000, "Member 'FDifficultySettings::EnemyMaxHPFactor' has a wrong offset!");
static_assert(offsetof(FDifficultySettings, EnemyAttackFactor) == 0x000004, "Member 'FDifficultySettings::EnemyAttackFactor' has a wrong offset!");
static_assert(offsetof(FDifficultySettings, EnemyActionFrequency) == 0x000008, "Member 'FDifficultySettings::EnemyActionFrequency' has a wrong offset!");
static_assert(offsetof(FDifficultySettings, EnemyStaminaFactor) == 0x00000C, "Member 'FDifficultySettings::EnemyStaminaFactor' has a wrong offset!");
static_assert(offsetof(FDifficultySettings, EnemyStaminaRecoverySpeedFactor) == 0x000010, "Member 'FDifficultySettings::EnemyStaminaRecoverySpeedFactor' has a wrong offset!");
static_assert(offsetof(FDifficultySettings, bPlayerOneShotKill) == 0x000014, "Member 'FDifficultySettings::bPlayerOneShotKill' has a wrong offset!");
static_assert(offsetof(FDifficultySettings, bPlayerNoHeal) == 0x000015, "Member 'FDifficultySettings::bPlayerNoHeal' has a wrong offset!");
static_assert(offsetof(FDifficultySettings, bEnemyNoLeadFX) == 0x000016, "Member 'FDifficultySettings::bEnemyNoLeadFX' has a wrong offset!");

// ScriptStruct Zion.DropSourceID
// 0x0018 (0x0018 - 0x0000)
struct FDropSourceID final
{
public:
	class FName                                   WorldName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorID;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DropTag;                                           // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDropSourceID) == 0x000004, "Wrong alignment on FDropSourceID");
static_assert(sizeof(FDropSourceID) == 0x000018, "Wrong size on FDropSourceID");
static_assert(offsetof(FDropSourceID, WorldName) == 0x000000, "Member 'FDropSourceID::WorldName' has a wrong offset!");
static_assert(offsetof(FDropSourceID, ActorID) == 0x000008, "Member 'FDropSourceID::ActorID' has a wrong offset!");
static_assert(offsetof(FDropSourceID, DropTag) == 0x000010, "Member 'FDropSourceID::DropTag' has a wrong offset!");

// ScriptStruct Zion.DropHistoryElement
// 0x0020 (0x0020 - 0x0000)
struct FDropHistoryElement final
{
public:
	struct FDropSourceID                          DropSourceID;                                      // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	double                                        DropTime;                                          // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDropHistoryElement) == 0x000008, "Wrong alignment on FDropHistoryElement");
static_assert(sizeof(FDropHistoryElement) == 0x000020, "Wrong size on FDropHistoryElement");
static_assert(offsetof(FDropHistoryElement, DropSourceID) == 0x000000, "Member 'FDropHistoryElement::DropSourceID' has a wrong offset!");
static_assert(offsetof(FDropHistoryElement, DropTime) == 0x000018, "Member 'FDropHistoryElement::DropTime' has a wrong offset!");

// ScriptStruct Zion.BreakDropData
// 0x0050 (0x0058 - 0x0008)
struct FBreakDropData final : public FTableRowBase
{
public:
	TMap<EBreakType, struct FDataTableRowHandle>  DropForBreakTypes;                                 // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBreakDropData) == 0x000008, "Wrong alignment on FBreakDropData");
static_assert(sizeof(FBreakDropData) == 0x000058, "Wrong size on FBreakDropData");
static_assert(offsetof(FBreakDropData, DropForBreakTypes) == 0x000008, "Member 'FBreakDropData::DropForBreakTypes' has a wrong offset!");

// ScriptStruct Zion.ActionToFXMap
// 0x0050 (0x0050 - 0x0000)
struct FActionToFXMap final
{
public:
	TMap<EEffectActionType, struct FSpineFXData>  Actions;                                           // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActionToFXMap) == 0x000008, "Wrong alignment on FActionToFXMap");
static_assert(sizeof(FActionToFXMap) == 0x000050, "Wrong size on FActionToFXMap");
static_assert(offsetof(FActionToFXMap, Actions) == 0x000000, "Member 'FActionToFXMap::Actions' has a wrong offset!");

// ScriptStruct Zion.SoundDataGroup
// 0x0028 (0x0028 - 0x0000)
struct FSoundDataGroup final
{
public:
	struct FSoundData                             Default;                                           // 0x0000(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundDataGroup) == 0x000008, "Wrong alignment on FSoundDataGroup");
static_assert(sizeof(FSoundDataGroup) == 0x000028, "Wrong size on FSoundDataGroup");
static_assert(offsetof(FSoundDataGroup, Default) == 0x000000, "Member 'FSoundDataGroup::Default' has a wrong offset!");

// ScriptStruct Zion.MaterialToSoundMap
// 0x0050 (0x0050 - 0x0000)
struct FMaterialToSoundMap final
{
public:
	TMap<EEffectMaterialType, struct FSoundDataGroup> Materials;                                     // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialToSoundMap) == 0x000008, "Wrong alignment on FMaterialToSoundMap");
static_assert(sizeof(FMaterialToSoundMap) == 0x000050, "Wrong size on FMaterialToSoundMap");
static_assert(offsetof(FMaterialToSoundMap, Materials) == 0x000000, "Member 'FMaterialToSoundMap::Materials' has a wrong offset!");

// ScriptStruct Zion.GuardMaterialToSoundMap
// 0x0050 (0x0050 - 0x0000)
struct FGuardMaterialToSoundMap final
{
public:
	TMap<EEffectGuardMaterialType, struct FSoundDataGroup> GuardMaterials;                           // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGuardMaterialToSoundMap) == 0x000008, "Wrong alignment on FGuardMaterialToSoundMap");
static_assert(sizeof(FGuardMaterialToSoundMap) == 0x000050, "Wrong size on FGuardMaterialToSoundMap");
static_assert(offsetof(FGuardMaterialToSoundMap, GuardMaterials) == 0x000000, "Member 'FGuardMaterialToSoundMap::GuardMaterials' has a wrong offset!");

// ScriptStruct Zion.ActionToMaterialMap
// 0x0050 (0x0050 - 0x0000)
struct FActionToMaterialMap final
{
public:
	TMap<EEffectActionType, struct FMaterialToSoundMap> Actions;                                     // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActionToMaterialMap) == 0x000008, "Wrong alignment on FActionToMaterialMap");
static_assert(sizeof(FActionToMaterialMap) == 0x000050, "Wrong size on FActionToMaterialMap");
static_assert(offsetof(FActionToMaterialMap, Actions) == 0x000000, "Member 'FActionToMaterialMap::Actions' has a wrong offset!");

// ScriptStruct Zion.EmulatedFogAxisSettings
// 0x0034 (0x0034 - 0x0000)
struct FEmulatedFogAxisSettings final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Opacity;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEmulatedFogBlendType                         BlendType;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MinColor;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MaxColor;                                          // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GradientRow;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmulatedFogAxisSettings) == 0x000004, "Wrong alignment on FEmulatedFogAxisSettings");
static_assert(sizeof(FEmulatedFogAxisSettings) == 0x000034, "Wrong size on FEmulatedFogAxisSettings");
static_assert(offsetof(FEmulatedFogAxisSettings, Min) == 0x000000, "Member 'FEmulatedFogAxisSettings::Min' has a wrong offset!");
static_assert(offsetof(FEmulatedFogAxisSettings, Max) == 0x000004, "Member 'FEmulatedFogAxisSettings::Max' has a wrong offset!");
static_assert(offsetof(FEmulatedFogAxisSettings, Opacity) == 0x000008, "Member 'FEmulatedFogAxisSettings::Opacity' has a wrong offset!");
static_assert(offsetof(FEmulatedFogAxisSettings, BlendType) == 0x00000C, "Member 'FEmulatedFogAxisSettings::BlendType' has a wrong offset!");
static_assert(offsetof(FEmulatedFogAxisSettings, MinColor) == 0x000010, "Member 'FEmulatedFogAxisSettings::MinColor' has a wrong offset!");
static_assert(offsetof(FEmulatedFogAxisSettings, MaxColor) == 0x000020, "Member 'FEmulatedFogAxisSettings::MaxColor' has a wrong offset!");
static_assert(offsetof(FEmulatedFogAxisSettings, GradientRow) == 0x000030, "Member 'FEmulatedFogAxisSettings::GradientRow' has a wrong offset!");

// ScriptStruct Zion.EmulatedFogWindSettings
// 0x0038 (0x0038 - 0x0000)
struct FEmulatedFogWindSettings final
{
public:
	struct FVector                                WindScale;                                         // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WindDirection;                                     // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindStrength;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmulatedFogWindSettings) == 0x000008, "Wrong alignment on FEmulatedFogWindSettings");
static_assert(sizeof(FEmulatedFogWindSettings) == 0x000038, "Wrong size on FEmulatedFogWindSettings");
static_assert(offsetof(FEmulatedFogWindSettings, WindScale) == 0x000000, "Member 'FEmulatedFogWindSettings::WindScale' has a wrong offset!");
static_assert(offsetof(FEmulatedFogWindSettings, WindDirection) == 0x000018, "Member 'FEmulatedFogWindSettings::WindDirection' has a wrong offset!");
static_assert(offsetof(FEmulatedFogWindSettings, WindStrength) == 0x000030, "Member 'FEmulatedFogWindSettings::WindStrength' has a wrong offset!");

// ScriptStruct Zion.EmulatedFogSettings
// 0x00A0 (0x00A0 - 0x0000)
struct FEmulatedFogSettings final
{
public:
	struct FEmulatedFogAxisSettings               DepthFog;                                          // 0x0000(0x0034)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FEmulatedFogAxisSettings               HeightFog;                                         // 0x0034(0x0034)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FEmulatedFogWindSettings               WindSettings;                                      // 0x0068(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmulatedFogSettings) == 0x000008, "Wrong alignment on FEmulatedFogSettings");
static_assert(sizeof(FEmulatedFogSettings) == 0x0000A0, "Wrong size on FEmulatedFogSettings");
static_assert(offsetof(FEmulatedFogSettings, DepthFog) == 0x000000, "Member 'FEmulatedFogSettings::DepthFog' has a wrong offset!");
static_assert(offsetof(FEmulatedFogSettings, HeightFog) == 0x000034, "Member 'FEmulatedFogSettings::HeightFog' has a wrong offset!");
static_assert(offsetof(FEmulatedFogSettings, WindSettings) == 0x000068, "Member 'FEmulatedFogSettings::WindSettings' has a wrong offset!");

// ScriptStruct Zion.BlendEmulatedFogSettings
// 0x0140 (0x0140 - 0x0000)
struct FBlendEmulatedFogSettings final
{
public:
	struct FEmulatedFogSettings                   FirstFog;                                          // 0x0000(0x00A0)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FEmulatedFogSettings                   SecondFog;                                         // 0x00A0(0x00A0)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlendEmulatedFogSettings) == 0x000008, "Wrong alignment on FBlendEmulatedFogSettings");
static_assert(sizeof(FBlendEmulatedFogSettings) == 0x000140, "Wrong size on FBlendEmulatedFogSettings");
static_assert(offsetof(FBlendEmulatedFogSettings, FirstFog) == 0x000000, "Member 'FBlendEmulatedFogSettings::FirstFog' has a wrong offset!");
static_assert(offsetof(FBlendEmulatedFogSettings, SecondFog) == 0x0000A0, "Member 'FBlendEmulatedFogSettings::SecondFog' has a wrong offset!");

// ScriptStruct Zion.ChoiceEntryData
// 0x0018 (0x0018 - 0x0000)
struct FChoiceEntryData final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0010)(Edit, NativeAccessSpecifierPrivate)
	class FName                                   Value;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FChoiceEntryData) == 0x000008, "Wrong alignment on FChoiceEntryData");
static_assert(sizeof(FChoiceEntryData) == 0x000018, "Wrong size on FChoiceEntryData");
static_assert(offsetof(FChoiceEntryData, Text) == 0x000000, "Member 'FChoiceEntryData::Text' has a wrong offset!");
static_assert(offsetof(FChoiceEntryData, Value) == 0x000010, "Member 'FChoiceEntryData::Value' has a wrong offset!");

// ScriptStruct Zion.ItemHandleCount
// 0x0018 (0x0018 - 0x0000)
struct FItemHandleCount final
{
public:
	struct FDataTableRowHandle                    ItemHandle;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemHandleCount) == 0x000008, "Wrong alignment on FItemHandleCount");
static_assert(sizeof(FItemHandleCount) == 0x000018, "Wrong size on FItemHandleCount");
static_assert(offsetof(FItemHandleCount, ItemHandle) == 0x000000, "Member 'FItemHandleCount::ItemHandle' has a wrong offset!");
static_assert(offsetof(FItemHandleCount, Count) == 0x000010, "Member 'FItemHandleCount::Count' has a wrong offset!");

// ScriptStruct Zion.TalkData
// 0x0050 (0x0050 - 0x0000)
struct FTalkData final
{
public:
	bool                                          bOverrideSpeakerName;                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SpeakerNameOverride;                               // 0x0008(0x0010)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bOverrideSpeakerAnimationDefinitions;              // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      AnimationDefinitionsOverride;                      // 0x0020(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	ETalkDesign                                   TalkDesign;                                        // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0038(0x0010)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bAutoComplete;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoCompleteTime;                                  // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTalkData) == 0x000008, "Wrong alignment on FTalkData");
static_assert(sizeof(FTalkData) == 0x000050, "Wrong size on FTalkData");
static_assert(offsetof(FTalkData, bOverrideSpeakerName) == 0x000000, "Member 'FTalkData::bOverrideSpeakerName' has a wrong offset!");
static_assert(offsetof(FTalkData, SpeakerNameOverride) == 0x000008, "Member 'FTalkData::SpeakerNameOverride' has a wrong offset!");
static_assert(offsetof(FTalkData, bOverrideSpeakerAnimationDefinitions) == 0x000018, "Member 'FTalkData::bOverrideSpeakerAnimationDefinitions' has a wrong offset!");
static_assert(offsetof(FTalkData, AnimationDefinitionsOverride) == 0x000020, "Member 'FTalkData::AnimationDefinitionsOverride' has a wrong offset!");
static_assert(offsetof(FTalkData, TalkDesign) == 0x000030, "Member 'FTalkData::TalkDesign' has a wrong offset!");
static_assert(offsetof(FTalkData, Text) == 0x000038, "Member 'FTalkData::Text' has a wrong offset!");
static_assert(offsetof(FTalkData, bAutoComplete) == 0x000048, "Member 'FTalkData::bAutoComplete' has a wrong offset!");
static_assert(offsetof(FTalkData, AutoCompleteTime) == 0x00004C, "Member 'FTalkData::AutoCompleteTime' has a wrong offset!");

// ScriptStruct Zion.FadeRuntimeData
// 0x00D0 (0x00D0 - 0x0000)
struct FFadeRuntimeData final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class UUserWidgetFade>, TWeakObjectPtr<class UUserWidgetFade>> InstanceForFadeClasses; // 0x0070(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFadeRuntimeData) == 0x000008, "Wrong alignment on FFadeRuntimeData");
static_assert(sizeof(FFadeRuntimeData) == 0x0000D0, "Wrong size on FFadeRuntimeData");
static_assert(offsetof(FFadeRuntimeData, InstanceForFadeClasses) == 0x000070, "Member 'FFadeRuntimeData::InstanceForFadeClasses' has a wrong offset!");

// ScriptStruct Zion.FadeDescriptionData
// 0x0020 (0x0020 - 0x0000)
struct FFadeDescriptionData final
{
public:
	TSubclassOf<class UUserWidgetFade>            FadeClass;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFadeParameters                        FadeParameters;                                    // 0x0008(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EUMGLayer                                     Layer;                                             // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFadeDescriptionData) == 0x000008, "Wrong alignment on FFadeDescriptionData");
static_assert(sizeof(FFadeDescriptionData) == 0x000020, "Wrong size on FFadeDescriptionData");
static_assert(offsetof(FFadeDescriptionData, FadeClass) == 0x000000, "Member 'FFadeDescriptionData::FadeClass' has a wrong offset!");
static_assert(offsetof(FFadeDescriptionData, FadeParameters) == 0x000008, "Member 'FFadeDescriptionData::FadeParameters' has a wrong offset!");
static_assert(offsetof(FFadeDescriptionData, Layer) == 0x00001C, "Member 'FFadeDescriptionData::Layer' has a wrong offset!");

// ScriptStruct Zion.FieldMessageData
// 0x0028 (0x0028 - 0x0000)
struct FFieldMessageData final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0010)(Edit, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      ActorAnimations;                                   // 0x0018(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFieldMessageData) == 0x000008, "Wrong alignment on FFieldMessageData");
static_assert(sizeof(FFieldMessageData) == 0x000028, "Wrong size on FFieldMessageData");
static_assert(offsetof(FFieldMessageData, Text) == 0x000000, "Member 'FFieldMessageData::Text' has a wrong offset!");
static_assert(offsetof(FFieldMessageData, Duration) == 0x000010, "Member 'FFieldMessageData::Duration' has a wrong offset!");
static_assert(offsetof(FFieldMessageData, ActorAnimations) == 0x000018, "Member 'FFieldMessageData::ActorAnimations' has a wrong offset!");

// ScriptStruct Zion.ConditionedFieldMessageData
// 0x0028 (0x0028 - 0x0000)
struct FConditionedFieldMessageData final
{
public:
	struct FGameplayConditionChecker              ConditionChecker;                                  // 0x0000(0x0018)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FFieldMessageData>              Messages;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionedFieldMessageData) == 0x000008, "Wrong alignment on FConditionedFieldMessageData");
static_assert(sizeof(FConditionedFieldMessageData) == 0x000028, "Wrong size on FConditionedFieldMessageData");
static_assert(offsetof(FConditionedFieldMessageData, ConditionChecker) == 0x000000, "Member 'FConditionedFieldMessageData::ConditionChecker' has a wrong offset!");
static_assert(offsetof(FConditionedFieldMessageData, Messages) == 0x000018, "Member 'FConditionedFieldMessageData::Messages' has a wrong offset!");

// ScriptStruct Zion.FieldTalkEntry
// 0x0028 (0x0028 - 0x0000)
struct FFieldTalkEntry final
{
public:
	class FText                                   ActorName;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         TextDuration;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFieldTalkEntry) == 0x000008, "Wrong alignment on FFieldTalkEntry");
static_assert(sizeof(FFieldTalkEntry) == 0x000028, "Wrong size on FFieldTalkEntry");
static_assert(offsetof(FFieldTalkEntry, ActorName) == 0x000000, "Member 'FFieldTalkEntry::ActorName' has a wrong offset!");
static_assert(offsetof(FFieldTalkEntry, Text) == 0x000010, "Member 'FFieldTalkEntry::Text' has a wrong offset!");
static_assert(offsetof(FFieldTalkEntry, TextDuration) == 0x000020, "Member 'FFieldTalkEntry::TextDuration' has a wrong offset!");

// ScriptStruct Zion.FieldTalkData
// 0x0018 (0x0018 - 0x0000)
struct FFieldTalkData final
{
public:
	bool                                          bCanBeSkipped;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartDelay;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFieldTalkEntry>                Entries;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFieldTalkData) == 0x000008, "Wrong alignment on FFieldTalkData");
static_assert(sizeof(FFieldTalkData) == 0x000018, "Wrong size on FFieldTalkData");
static_assert(offsetof(FFieldTalkData, bCanBeSkipped) == 0x000000, "Member 'FFieldTalkData::bCanBeSkipped' has a wrong offset!");
static_assert(offsetof(FFieldTalkData, StartDelay) == 0x000004, "Member 'FFieldTalkData::StartDelay' has a wrong offset!");
static_assert(offsetof(FFieldTalkData, Entries) == 0x000008, "Member 'FFieldTalkData::Entries' has a wrong offset!");

// ScriptStruct Zion.SplashSettings
// 0x000C (0x000C - 0x0000)
struct FSplashSettings final
{
public:
	float                                         SplashStrength;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplashSize;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateSplashFX;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSplashSettings) == 0x000004, "Wrong alignment on FSplashSettings");
static_assert(sizeof(FSplashSettings) == 0x00000C, "Wrong size on FSplashSettings");
static_assert(offsetof(FSplashSettings, SplashStrength) == 0x000000, "Member 'FSplashSettings::SplashStrength' has a wrong offset!");
static_assert(offsetof(FSplashSettings, SplashSize) == 0x000004, "Member 'FSplashSettings::SplashSize' has a wrong offset!");
static_assert(offsetof(FSplashSettings, bGenerateSplashFX) == 0x000008, "Member 'FSplashSettings::bGenerateSplashFX' has a wrong offset!");

// ScriptStruct Zion.RenderTargetData
// 0x0058 (0x0058 - 0x0000)
struct FRenderTargetData final
{
public:
	class UMaterialInstanceDynamic*               MapAreaTextureMID;                                 // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 FogOfWarMaskRT;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 FogOfWarBlockerRT;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 ZonesClearedMaskRT;                                // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x38];                                      // 0x0020(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRenderTargetData) == 0x000008, "Wrong alignment on FRenderTargetData");
static_assert(sizeof(FRenderTargetData) == 0x000058, "Wrong size on FRenderTargetData");
static_assert(offsetof(FRenderTargetData, MapAreaTextureMID) == 0x000000, "Member 'FRenderTargetData::MapAreaTextureMID' has a wrong offset!");
static_assert(offsetof(FRenderTargetData, FogOfWarMaskRT) == 0x000008, "Member 'FRenderTargetData::FogOfWarMaskRT' has a wrong offset!");
static_assert(offsetof(FRenderTargetData, FogOfWarBlockerRT) == 0x000010, "Member 'FRenderTargetData::FogOfWarBlockerRT' has a wrong offset!");
static_assert(offsetof(FRenderTargetData, ZonesClearedMaskRT) == 0x000018, "Member 'FRenderTargetData::ZonesClearedMaskRT' has a wrong offset!");

// ScriptStruct Zion.FollowGeometryMovementData
// 0x0030 (0x0030 - 0x0000)
struct FFollowGeometryMovementData final
{
public:
	struct FVector                                InitialLocalSpaceVelocity;                         // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfWidth;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionSphereRadius;                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundDetectionRange;                              // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x002C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeleportType                                 TeleportType;                                      // 0x002D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFollowGeometryMovementData) == 0x000008, "Wrong alignment on FFollowGeometryMovementData");
static_assert(sizeof(FFollowGeometryMovementData) == 0x000030, "Wrong size on FFollowGeometryMovementData");
static_assert(offsetof(FFollowGeometryMovementData, InitialLocalSpaceVelocity) == 0x000000, "Member 'FFollowGeometryMovementData::InitialLocalSpaceVelocity' has a wrong offset!");
static_assert(offsetof(FFollowGeometryMovementData, HalfWidth) == 0x000018, "Member 'FFollowGeometryMovementData::HalfWidth' has a wrong offset!");
static_assert(offsetof(FFollowGeometryMovementData, HalfHeight) == 0x00001C, "Member 'FFollowGeometryMovementData::HalfHeight' has a wrong offset!");
static_assert(offsetof(FFollowGeometryMovementData, DetectionSphereRadius) == 0x000020, "Member 'FFollowGeometryMovementData::DetectionSphereRadius' has a wrong offset!");
static_assert(offsetof(FFollowGeometryMovementData, GroundDetectionRange) == 0x000024, "Member 'FFollowGeometryMovementData::GroundDetectionRange' has a wrong offset!");
static_assert(offsetof(FFollowGeometryMovementData, MaxSpeed) == 0x000028, "Member 'FFollowGeometryMovementData::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FFollowGeometryMovementData, bSweep) == 0x00002C, "Member 'FFollowGeometryMovementData::bSweep' has a wrong offset!");
static_assert(offsetof(FFollowGeometryMovementData, TeleportType) == 0x00002D, "Member 'FFollowGeometryMovementData::TeleportType' has a wrong offset!");

// ScriptStruct Zion.FootIKSettings
// 0x0018 (0x0018 - 0x0000)
struct FFootIKSettings final
{
public:
	float                                         MinHeightOffset;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeightOffset;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValidSlopeAngle;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinecastYAxisOffset_Left;                          // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinecastYAxisOffset_Right;                         // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFootIKSettings) == 0x000004, "Wrong alignment on FFootIKSettings");
static_assert(sizeof(FFootIKSettings) == 0x000018, "Wrong size on FFootIKSettings");
static_assert(offsetof(FFootIKSettings, MinHeightOffset) == 0x000000, "Member 'FFootIKSettings::MinHeightOffset' has a wrong offset!");
static_assert(offsetof(FFootIKSettings, MaxHeightOffset) == 0x000004, "Member 'FFootIKSettings::MaxHeightOffset' has a wrong offset!");
static_assert(offsetof(FFootIKSettings, ValidSlopeAngle) == 0x000008, "Member 'FFootIKSettings::ValidSlopeAngle' has a wrong offset!");
static_assert(offsetof(FFootIKSettings, LinecastYAxisOffset_Left) == 0x00000C, "Member 'FFootIKSettings::LinecastYAxisOffset_Left' has a wrong offset!");
static_assert(offsetof(FFootIKSettings, LinecastYAxisOffset_Right) == 0x000010, "Member 'FFootIKSettings::LinecastYAxisOffset_Right' has a wrong offset!");

// ScriptStruct Zion.AuraFXData
// 0x0110 (0x0110 - 0x0000)
struct FAuraFXData final
{
public:
	struct FSpineFXData                           FXData;                                            // 0x0000(0x0100)(Edit, NativeAccessSpecifierPublic)
	EAuraFXDeactivateTiming                       DeactivateTiming;                                  // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0xF];                                      // 0x0101(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAuraFXData) == 0x000010, "Wrong alignment on FAuraFXData");
static_assert(sizeof(FAuraFXData) == 0x000110, "Wrong size on FAuraFXData");
static_assert(offsetof(FAuraFXData, FXData) == 0x000000, "Member 'FAuraFXData::FXData' has a wrong offset!");
static_assert(offsetof(FAuraFXData, DeactivateTiming) == 0x000100, "Member 'FAuraFXData::DeactivateTiming' has a wrong offset!");

// ScriptStruct Zion.AuraFXDataList
// 0x0010 (0x0010 - 0x0000)
struct FAuraFXDataList final
{
public:
	TArray<struct FAuraFXData>                    AuraFXList;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAuraFXDataList) == 0x000008, "Wrong alignment on FAuraFXDataList");
static_assert(sizeof(FAuraFXDataList) == 0x000010, "Wrong size on FAuraFXDataList");
static_assert(offsetof(FAuraFXDataList, AuraFXList) == 0x000000, "Member 'FAuraFXDataList::AuraFXList' has a wrong offset!");

// ScriptStruct Zion.AuraFXRuntimeData
// 0x0018 (0x0018 - 0x0000)
struct FAuraFXRuntimeData final
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAuraFXRuntimeData) == 0x000008, "Wrong alignment on FAuraFXRuntimeData");
static_assert(sizeof(FAuraFXRuntimeData) == 0x000018, "Wrong size on FAuraFXRuntimeData");
static_assert(offsetof(FAuraFXRuntimeData, NiagaraComponent) == 0x000000, "Member 'FAuraFXRuntimeData::NiagaraComponent' has a wrong offset!");

// ScriptStruct Zion.GameMapChangeProviderData
// 0x0040 (0x0040 - 0x0000)
struct FGameMapChangeProviderData final
{
public:
	struct FDataTableRowHandle                    MapTransitionHandle;                               // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                StartWorldLocation;                                // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestinationWorldLocation;                          // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameMapChangeProviderData) == 0x000008, "Wrong alignment on FGameMapChangeProviderData");
static_assert(sizeof(FGameMapChangeProviderData) == 0x000040, "Wrong size on FGameMapChangeProviderData");
static_assert(offsetof(FGameMapChangeProviderData, MapTransitionHandle) == 0x000000, "Member 'FGameMapChangeProviderData::MapTransitionHandle' has a wrong offset!");
static_assert(offsetof(FGameMapChangeProviderData, StartWorldLocation) == 0x000010, "Member 'FGameMapChangeProviderData::StartWorldLocation' has a wrong offset!");
static_assert(offsetof(FGameMapChangeProviderData, DestinationWorldLocation) == 0x000028, "Member 'FGameMapChangeProviderData::DestinationWorldLocation' has a wrong offset!");

// ScriptStruct Zion.MapAreaData
// 0x0038 (0x0038 - 0x0000)
struct FMapAreaData final
{
public:
	struct FVector2D                              MapSize;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterWorldLocation;                               // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              MapResolution;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              PixelAddedToMod4;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapAreaData) == 0x000008, "Wrong alignment on FMapAreaData");
static_assert(sizeof(FMapAreaData) == 0x000038, "Wrong size on FMapAreaData");
static_assert(offsetof(FMapAreaData, MapSize) == 0x000000, "Member 'FMapAreaData::MapSize' has a wrong offset!");
static_assert(offsetof(FMapAreaData, CenterWorldLocation) == 0x000010, "Member 'FMapAreaData::CenterWorldLocation' has a wrong offset!");
static_assert(offsetof(FMapAreaData, MapResolution) == 0x000028, "Member 'FMapAreaData::MapResolution' has a wrong offset!");
static_assert(offsetof(FMapAreaData, PixelAddedToMod4) == 0x000030, "Member 'FMapAreaData::PixelAddedToMod4' has a wrong offset!");

// ScriptStruct Zion.MapAreaZoneData
// 0x00A0 (0x00A0 - 0x0000)
struct FMapAreaZoneData final
{
public:
	TMap<class FName, struct FNameSet>            ClearablesPerZones;                                // 0x0000(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, struct FNameSet>            ClearablesForRevealPerZones;                       // 0x0050(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapAreaZoneData) == 0x000008, "Wrong alignment on FMapAreaZoneData");
static_assert(sizeof(FMapAreaZoneData) == 0x0000A0, "Wrong size on FMapAreaZoneData");
static_assert(offsetof(FMapAreaZoneData, ClearablesPerZones) == 0x000000, "Member 'FMapAreaZoneData::ClearablesPerZones' has a wrong offset!");
static_assert(offsetof(FMapAreaZoneData, ClearablesForRevealPerZones) == 0x000050, "Member 'FMapAreaZoneData::ClearablesForRevealPerZones' has a wrong offset!");

// ScriptStruct Zion.GameMapData
// 0x0138 (0x0140 - 0x0008)
struct FGameMapData final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UWorld>                  World;                                             // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WidgetMapArea;                                     // 0x0030(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MapAreaDisplayName;                                // 0x0058(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMapAreaData                           MapAreaData;                                       // 0x0068(0x0038)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FMapAreaZoneData                       MapAreaZoneData;                                   // 0x00A0(0x00A0)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameMapData) == 0x000008, "Wrong alignment on FGameMapData");
static_assert(sizeof(FGameMapData) == 0x000140, "Wrong size on FGameMapData");
static_assert(offsetof(FGameMapData, World) == 0x000008, "Member 'FGameMapData::World' has a wrong offset!");
static_assert(offsetof(FGameMapData, WidgetMapArea) == 0x000030, "Member 'FGameMapData::WidgetMapArea' has a wrong offset!");
static_assert(offsetof(FGameMapData, MapAreaDisplayName) == 0x000058, "Member 'FGameMapData::MapAreaDisplayName' has a wrong offset!");
static_assert(offsetof(FGameMapData, MapAreaData) == 0x000068, "Member 'FGameMapData::MapAreaData' has a wrong offset!");
static_assert(offsetof(FGameMapData, MapAreaZoneData) == 0x0000A0, "Member 'FGameMapData::MapAreaZoneData' has a wrong offset!");

// ScriptStruct Zion.WidgetMapStoryEventDirectionData
// 0x0010 (0x0010 - 0x0000)
struct FWidgetMapStoryEventDirectionData final
{
public:
	TWeakObjectPtr<class UUserWidgetMapIcon_StoryEvent> StoryEventIcon;                              // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidgetZionShowHide*                StoryEventDirection;                               // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWidgetMapStoryEventDirectionData) == 0x000008, "Wrong alignment on FWidgetMapStoryEventDirectionData");
static_assert(sizeof(FWidgetMapStoryEventDirectionData) == 0x000010, "Wrong size on FWidgetMapStoryEventDirectionData");
static_assert(offsetof(FWidgetMapStoryEventDirectionData, StoryEventIcon) == 0x000000, "Member 'FWidgetMapStoryEventDirectionData::StoryEventIcon' has a wrong offset!");
static_assert(offsetof(FWidgetMapStoryEventDirectionData, StoryEventDirection) == 0x000008, "Member 'FWidgetMapStoryEventDirectionData::StoryEventDirection' has a wrong offset!");

// ScriptStruct Zion.MapCustomMarkerIconData
// 0x0028 (0x0028 - 0x0000)
struct FMapCustomMarkerIconData final
{
public:
	class FName                                   MapName;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MarkerID;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapCustomMarkerIconData) == 0x000008, "Wrong alignment on FMapCustomMarkerIconData");
static_assert(sizeof(FMapCustomMarkerIconData) == 0x000028, "Wrong size on FMapCustomMarkerIconData");
static_assert(offsetof(FMapCustomMarkerIconData, MapName) == 0x000000, "Member 'FMapCustomMarkerIconData::MapName' has a wrong offset!");
static_assert(offsetof(FMapCustomMarkerIconData, WorldLocation) == 0x000008, "Member 'FMapCustomMarkerIconData::WorldLocation' has a wrong offset!");
static_assert(offsetof(FMapCustomMarkerIconData, MarkerID) == 0x000020, "Member 'FMapCustomMarkerIconData::MarkerID' has a wrong offset!");

// ScriptStruct Zion.InputSnapshot
// 0x00B8 (0x00B8 - 0x0000)
struct FInputSnapshot final
{
public:
	struct FVector2D                              MoveInput;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDirection                               InputDirection;                                    // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UInputAction*, struct FInputActionValue> TriggeringInputs;                            // 0x0018(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class UInputAction*, struct FInputActionValue> JustTriggeredInputs;                         // 0x0068(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputSnapshot) == 0x000008, "Wrong alignment on FInputSnapshot");
static_assert(sizeof(FInputSnapshot) == 0x0000B8, "Wrong size on FInputSnapshot");
static_assert(offsetof(FInputSnapshot, MoveInput) == 0x000000, "Member 'FInputSnapshot::MoveInput' has a wrong offset!");
static_assert(offsetof(FInputSnapshot, InputDirection) == 0x000010, "Member 'FInputSnapshot::InputDirection' has a wrong offset!");
static_assert(offsetof(FInputSnapshot, TriggeringInputs) == 0x000018, "Member 'FInputSnapshot::TriggeringInputs' has a wrong offset!");
static_assert(offsetof(FInputSnapshot, JustTriggeredInputs) == 0x000068, "Member 'FInputSnapshot::JustTriggeredInputs' has a wrong offset!");

// ScriptStruct Zion.TimedInputSnapshot
// 0x0118 (0x0118 - 0x0000)
struct FTimedInputSnapshot final
{
public:
	struct FInputSnapshot                         InputSnapshot;                                     // 0x0000(0x00B8)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             ProcessedTags;                                     // 0x00C0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bProcessedExactly;                                 // 0x0110(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProcessedTime;                                     // 0x0114(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTimedInputSnapshot) == 0x000008, "Wrong alignment on FTimedInputSnapshot");
static_assert(sizeof(FTimedInputSnapshot) == 0x000118, "Wrong size on FTimedInputSnapshot");
static_assert(offsetof(FTimedInputSnapshot, InputSnapshot) == 0x000000, "Member 'FTimedInputSnapshot::InputSnapshot' has a wrong offset!");
static_assert(offsetof(FTimedInputSnapshot, Time) == 0x0000B8, "Member 'FTimedInputSnapshot::Time' has a wrong offset!");
static_assert(offsetof(FTimedInputSnapshot, ProcessedTags) == 0x0000C0, "Member 'FTimedInputSnapshot::ProcessedTags' has a wrong offset!");
static_assert(offsetof(FTimedInputSnapshot, bProcessedExactly) == 0x000110, "Member 'FTimedInputSnapshot::bProcessedExactly' has a wrong offset!");
static_assert(offsetof(FTimedInputSnapshot, ProcessedTime) == 0x000114, "Member 'FTimedInputSnapshot::ProcessedTime' has a wrong offset!");

// ScriptStruct Zion.UIBinding
// 0x0010 (0x0010 - 0x0000)
struct FUIBinding final
{
public:
	TArray<struct FKey>                           KeyBindings;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIBinding) == 0x000008, "Wrong alignment on FUIBinding");
static_assert(sizeof(FUIBinding) == 0x000010, "Wrong size on FUIBinding");
static_assert(offsetof(FUIBinding, KeyBindings) == 0x000000, "Member 'FUIBinding::KeyBindings' has a wrong offset!");

// ScriptStruct Zion.InteractableNPCData
// 0x0068 (0x0068 - 0x0000)
struct FInteractableNPCData final
{
public:
	struct FGameplayConditionChecker              Conditions;                                        // 0x0000(0x0018)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bOverrideEventAsset;                               // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UEventAsset>             EventAsset;                                        // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAnimations;                               // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      IdleAnimations;                                    // 0x0050(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bOverrideFacing;                                   // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFacingType                                   Facing;                                            // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractableNPCData) == 0x000008, "Wrong alignment on FInteractableNPCData");
static_assert(sizeof(FInteractableNPCData) == 0x000068, "Wrong size on FInteractableNPCData");
static_assert(offsetof(FInteractableNPCData, Conditions) == 0x000000, "Member 'FInteractableNPCData::Conditions' has a wrong offset!");
static_assert(offsetof(FInteractableNPCData, bOverrideEventAsset) == 0x000018, "Member 'FInteractableNPCData::bOverrideEventAsset' has a wrong offset!");
static_assert(offsetof(FInteractableNPCData, EventAsset) == 0x000020, "Member 'FInteractableNPCData::EventAsset' has a wrong offset!");
static_assert(offsetof(FInteractableNPCData, bOverrideAnimations) == 0x000048, "Member 'FInteractableNPCData::bOverrideAnimations' has a wrong offset!");
static_assert(offsetof(FInteractableNPCData, IdleAnimations) == 0x000050, "Member 'FInteractableNPCData::IdleAnimations' has a wrong offset!");
static_assert(offsetof(FInteractableNPCData, bOverrideFacing) == 0x000060, "Member 'FInteractableNPCData::bOverrideFacing' has a wrong offset!");
static_assert(offsetof(FInteractableNPCData, Facing) == 0x000061, "Member 'FInteractableNPCData::Facing' has a wrong offset!");

// ScriptStruct Zion.InventoryItemCurrencyData
// 0x0008 (0x0170 - 0x0168)
struct FInventoryItemCurrencyData final : public FInventoryItemData
{
public:
	ECurrencyType                                 Currency;                                          // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryItemCurrencyData) == 0x000008, "Wrong alignment on FInventoryItemCurrencyData");
static_assert(sizeof(FInventoryItemCurrencyData) == 0x000170, "Wrong size on FInventoryItemCurrencyData");
static_assert(offsetof(FInventoryItemCurrencyData, Currency) == 0x000168, "Member 'FInventoryItemCurrencyData::Currency' has a wrong offset!");

// ScriptStruct Zion.InventoryItemAptitudeData
// 0x0008 (0x0178 - 0x0170)
struct FInventoryItemAptitudeData final : public FInventoryItemGrantData
{
public:
	EAptitudeType                                 AptitudeType;                                      // 0x0170(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryItemAptitudeData) == 0x000008, "Wrong alignment on FInventoryItemAptitudeData");
static_assert(sizeof(FInventoryItemAptitudeData) == 0x000178, "Wrong size on FInventoryItemAptitudeData");
static_assert(offsetof(FInventoryItemAptitudeData, AptitudeType) == 0x000170, "Member 'FInventoryItemAptitudeData::AptitudeType' has a wrong offset!");

// ScriptStruct Zion.StatsLevelData
// 0x0038 (0x0040 - 0x0008)
struct FStatsLevelData : public FTableRowBase
{
public:
	int32                                         HP;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SP;                                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Defense;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageCutPercentage_Physic;                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageCutPercentage_Magic;                         // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StaminaCutPercentage_Physic;                       // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StaminaCutPercentage_Magic;                        // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Burn;                                              // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Freeze;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shock;                                             // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatsLevelData) == 0x000008, "Wrong alignment on FStatsLevelData");
static_assert(sizeof(FStatsLevelData) == 0x000040, "Wrong size on FStatsLevelData");
static_assert(offsetof(FStatsLevelData, HP) == 0x000008, "Member 'FStatsLevelData::HP' has a wrong offset!");
static_assert(offsetof(FStatsLevelData, SP) == 0x00000C, "Member 'FStatsLevelData::SP' has a wrong offset!");
static_assert(offsetof(FStatsLevelData, Attack) == 0x000010, "Member 'FStatsLevelData::Attack' has a wrong offset!");
static_assert(offsetof(FStatsLevelData, Defense) == 0x000014, "Member 'FStatsLevelData::Defense' has a wrong offset!");
static_assert(offsetof(FStatsLevelData, DamageCutPercentage_Physic) == 0x000018, "Member 'FStatsLevelData::DamageCutPercentage_Physic' has a wrong offset!");
static_assert(offsetof(FStatsLevelData, DamageCutPercentage_Magic) == 0x00001C, "Member 'FStatsLevelData::DamageCutPercentage_Magic' has a wrong offset!");
static_assert(offsetof(FStatsLevelData, StaminaCutPercentage_Physic) == 0x000020, "Member 'FStatsLevelData::StaminaCutPercentage_Physic' has a wrong offset!");
static_assert(offsetof(FStatsLevelData, StaminaCutPercentage_Magic) == 0x000024, "Member 'FStatsLevelData::StaminaCutPercentage_Magic' has a wrong offset!");
static_assert(offsetof(FStatsLevelData, Stamina) == 0x000028, "Member 'FStatsLevelData::Stamina' has a wrong offset!");
static_assert(offsetof(FStatsLevelData, Burn) == 0x00002C, "Member 'FStatsLevelData::Burn' has a wrong offset!");
static_assert(offsetof(FStatsLevelData, Freeze) == 0x000030, "Member 'FStatsLevelData::Freeze' has a wrong offset!");
static_assert(offsetof(FStatsLevelData, Shock) == 0x000034, "Member 'FStatsLevelData::Shock' has a wrong offset!");

// ScriptStruct Zion.ExtendedStatsData
// 0x0050 (0x0050 - 0x0000)
struct FExtendedStatsData final
{
public:
	struct FStatsLevelData                        Stats;                                             // 0x0000(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         HealCount;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HealPower;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PassiveSlot;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShopLevel;                                         // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtendedStatsData) == 0x000008, "Wrong alignment on FExtendedStatsData");
static_assert(sizeof(FExtendedStatsData) == 0x000050, "Wrong size on FExtendedStatsData");
static_assert(offsetof(FExtendedStatsData, Stats) == 0x000000, "Member 'FExtendedStatsData::Stats' has a wrong offset!");
static_assert(offsetof(FExtendedStatsData, HealCount) == 0x000040, "Member 'FExtendedStatsData::HealCount' has a wrong offset!");
static_assert(offsetof(FExtendedStatsData, HealPower) == 0x000044, "Member 'FExtendedStatsData::HealPower' has a wrong offset!");
static_assert(offsetof(FExtendedStatsData, PassiveSlot) == 0x000048, "Member 'FExtendedStatsData::PassiveSlot' has a wrong offset!");
static_assert(offsetof(FExtendedStatsData, ShopLevel) == 0x00004C, "Member 'FExtendedStatsData::ShopLevel' has a wrong offset!");

// ScriptStruct Zion.InventoryItemStatsData
// 0x0050 (0x01C0 - 0x0170)
struct FInventoryItemStatsData final : public FInventoryItemGrantData
{
public:
	struct FExtendedStatsData                     BonusStats;                                        // 0x0170(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemStatsData) == 0x000008, "Wrong alignment on FInventoryItemStatsData");
static_assert(sizeof(FInventoryItemStatsData) == 0x0001C0, "Wrong size on FInventoryItemStatsData");
static_assert(offsetof(FInventoryItemStatsData, BonusStats) == 0x000170, "Member 'FInventoryItemStatsData::BonusStats' has a wrong offset!");

// ScriptStruct Zion.InventoryItemSpiritData
// 0x0098 (0x0208 - 0x0170)
struct FInventoryItemSpiritData final : public FInventoryItemGrantData
{
public:
	TArray<struct FDataTableRowHandle>            Skills;                                            // 0x0170(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDataTableRowHandle>            AutoGrantSkills;                                   // 0x0180(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              MenuBackgroundImage;                               // 0x0190(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            SpiritSkillIcon;                                   // 0x01B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            SpiritEquippedSkillIcon;                           // 0x01E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemSpiritData) == 0x000008, "Wrong alignment on FInventoryItemSpiritData");
static_assert(sizeof(FInventoryItemSpiritData) == 0x000208, "Wrong size on FInventoryItemSpiritData");
static_assert(offsetof(FInventoryItemSpiritData, Skills) == 0x000170, "Member 'FInventoryItemSpiritData::Skills' has a wrong offset!");
static_assert(offsetof(FInventoryItemSpiritData, AutoGrantSkills) == 0x000180, "Member 'FInventoryItemSpiritData::AutoGrantSkills' has a wrong offset!");
static_assert(offsetof(FInventoryItemSpiritData, MenuBackgroundImage) == 0x000190, "Member 'FInventoryItemSpiritData::MenuBackgroundImage' has a wrong offset!");
static_assert(offsetof(FInventoryItemSpiritData, SpiritSkillIcon) == 0x0001B8, "Member 'FInventoryItemSpiritData::SpiritSkillIcon' has a wrong offset!");
static_assert(offsetof(FInventoryItemSpiritData, SpiritEquippedSkillIcon) == 0x0001E0, "Member 'FInventoryItemSpiritData::SpiritEquippedSkillIcon' has a wrong offset!");

// ScriptStruct Zion.InventoryItemSkillData
// 0x0120 (0x0288 - 0x0168)
struct FInventoryItemSkillData final : public FInventoryItemData
{
public:
	class UDataTable*                             SkillLevelTable;                                   // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialLevel;                                      // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   RestPointSpiritClass;                              // 0x0178(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   IdleSpiritClass;                                   // 0x01A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AssociatedSpiritClass;                             // 0x01C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            SpecialIcon;                                       // 0x01F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SpecialName;                                       // 0x0218(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   SpecialDescription;                                // 0x0228(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FRichTextInputElement>          SpecialDescriptionFormatElements;                  // 0x0238(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         SpecialDescriptionStringElements;                  // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   SpecialFlavorText;                                 // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FRichTextInputElement>          SpecialFlavorTextFormatElements;                   // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         SpecialFlavorStringElements;                       // 0x0278(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemSkillData) == 0x000008, "Wrong alignment on FInventoryItemSkillData");
static_assert(sizeof(FInventoryItemSkillData) == 0x000288, "Wrong size on FInventoryItemSkillData");
static_assert(offsetof(FInventoryItemSkillData, SkillLevelTable) == 0x000168, "Member 'FInventoryItemSkillData::SkillLevelTable' has a wrong offset!");
static_assert(offsetof(FInventoryItemSkillData, InitialLevel) == 0x000170, "Member 'FInventoryItemSkillData::InitialLevel' has a wrong offset!");
static_assert(offsetof(FInventoryItemSkillData, RestPointSpiritClass) == 0x000178, "Member 'FInventoryItemSkillData::RestPointSpiritClass' has a wrong offset!");
static_assert(offsetof(FInventoryItemSkillData, IdleSpiritClass) == 0x0001A0, "Member 'FInventoryItemSkillData::IdleSpiritClass' has a wrong offset!");
static_assert(offsetof(FInventoryItemSkillData, AssociatedSpiritClass) == 0x0001C8, "Member 'FInventoryItemSkillData::AssociatedSpiritClass' has a wrong offset!");
static_assert(offsetof(FInventoryItemSkillData, SpecialIcon) == 0x0001F0, "Member 'FInventoryItemSkillData::SpecialIcon' has a wrong offset!");
static_assert(offsetof(FInventoryItemSkillData, SpecialName) == 0x000218, "Member 'FInventoryItemSkillData::SpecialName' has a wrong offset!");
static_assert(offsetof(FInventoryItemSkillData, SpecialDescription) == 0x000228, "Member 'FInventoryItemSkillData::SpecialDescription' has a wrong offset!");
static_assert(offsetof(FInventoryItemSkillData, SpecialDescriptionFormatElements) == 0x000238, "Member 'FInventoryItemSkillData::SpecialDescriptionFormatElements' has a wrong offset!");
static_assert(offsetof(FInventoryItemSkillData, SpecialDescriptionStringElements) == 0x000248, "Member 'FInventoryItemSkillData::SpecialDescriptionStringElements' has a wrong offset!");
static_assert(offsetof(FInventoryItemSkillData, SpecialFlavorText) == 0x000258, "Member 'FInventoryItemSkillData::SpecialFlavorText' has a wrong offset!");
static_assert(offsetof(FInventoryItemSkillData, SpecialFlavorTextFormatElements) == 0x000268, "Member 'FInventoryItemSkillData::SpecialFlavorTextFormatElements' has a wrong offset!");
static_assert(offsetof(FInventoryItemSkillData, SpecialFlavorStringElements) == 0x000278, "Member 'FInventoryItemSkillData::SpecialFlavorStringElements' has a wrong offset!");

// ScriptStruct Zion.InventoryItemBaseEquipmentData
// 0x0050 (0x01B8 - 0x0168)
struct FInventoryItemBaseEquipmentData : public FInventoryItemData
{
public:
	struct FExtendedStatsData                     Stats;                                             // 0x0168(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemBaseEquipmentData) == 0x000008, "Wrong alignment on FInventoryItemBaseEquipmentData");
static_assert(sizeof(FInventoryItemBaseEquipmentData) == 0x0001B8, "Wrong size on FInventoryItemBaseEquipmentData");
static_assert(offsetof(FInventoryItemBaseEquipmentData, Stats) == 0x000168, "Member 'FInventoryItemBaseEquipmentData::Stats' has a wrong offset!");

// ScriptStruct Zion.InventoryItemEquipmentData
// 0x0030 (0x01E8 - 0x01B8)
struct FInventoryItemEquipmentData final : public FInventoryItemBaseEquipmentData
{
public:
	TSoftObjectPtr<class UCommandSet>             CommandSet;                                        // 0x01B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputAction*                           InputAction;                                       // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemEquipmentData) == 0x000008, "Wrong alignment on FInventoryItemEquipmentData");
static_assert(sizeof(FInventoryItemEquipmentData) == 0x0001E8, "Wrong size on FInventoryItemEquipmentData");
static_assert(offsetof(FInventoryItemEquipmentData, CommandSet) == 0x0001B8, "Member 'FInventoryItemEquipmentData::CommandSet' has a wrong offset!");
static_assert(offsetof(FInventoryItemEquipmentData, InputAction) == 0x0001E0, "Member 'FInventoryItemEquipmentData::InputAction' has a wrong offset!");

// ScriptStruct Zion.InventoryItemAssistData
// 0x0050 (0x0208 - 0x01B8)
struct FInventoryItemAssistData final : public FInventoryItemBaseEquipmentData
{
public:
	TSoftClassPtr<class UClass>                   AssistClass;                                       // 0x01B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AssistActorClass;                                  // 0x01E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemAssistData) == 0x000008, "Wrong alignment on FInventoryItemAssistData");
static_assert(sizeof(FInventoryItemAssistData) == 0x000208, "Wrong size on FInventoryItemAssistData");
static_assert(offsetof(FInventoryItemAssistData, AssistClass) == 0x0001B8, "Member 'FInventoryItemAssistData::AssistClass' has a wrong offset!");
static_assert(offsetof(FInventoryItemAssistData, AssistActorClass) == 0x0001E0, "Member 'FInventoryItemAssistData::AssistActorClass' has a wrong offset!");

// ScriptStruct Zion.InventoryItemMaterialData
// 0x0000 (0x0168 - 0x0168)
struct FInventoryItemMaterialData final : public FInventoryItemData
{
};
static_assert(alignof(FInventoryItemMaterialData) == 0x000008, "Wrong alignment on FInventoryItemMaterialData");
static_assert(sizeof(FInventoryItemMaterialData) == 0x000168, "Wrong size on FInventoryItemMaterialData");

// ScriptStruct Zion.InventoryItemTipData
// 0x0000 (0x0168 - 0x0168)
struct FInventoryItemTipData final : public FInventoryItemData
{
};
static_assert(alignof(FInventoryItemTipData) == 0x000008, "Wrong alignment on FInventoryItemTipData");
static_assert(sizeof(FInventoryItemTipData) == 0x000168, "Wrong size on FInventoryItemTipData");

// ScriptStruct Zion.InventoryItemTutorialVideoOverrideData
// 0x0040 (0x0040 - 0x0000)
struct FInventoryItemTutorialVideoOverrideData final
{
public:
	struct FItemConditionData                     Conditions;                                        // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UPlatformMediaSource*                   VideoOverride;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemTutorialVideoOverrideData) == 0x000008, "Wrong alignment on FInventoryItemTutorialVideoOverrideData");
static_assert(sizeof(FInventoryItemTutorialVideoOverrideData) == 0x000040, "Wrong size on FInventoryItemTutorialVideoOverrideData");
static_assert(offsetof(FInventoryItemTutorialVideoOverrideData, Conditions) == 0x000000, "Member 'FInventoryItemTutorialVideoOverrideData::Conditions' has a wrong offset!");
static_assert(offsetof(FInventoryItemTutorialVideoOverrideData, VideoOverride) == 0x000038, "Member 'FInventoryItemTutorialVideoOverrideData::VideoOverride' has a wrong offset!");

// ScriptStruct Zion.InventoryItemTutorialData
// 0x0028 (0x0190 - 0x0168)
struct FInventoryItemTutorialData final : public FInventoryItemData
{
public:
	ETutorialHook                                 Hook;                                              // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayCondition>         Condition;                                         // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlatformMediaSource*                   Video;                                             // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInventoryItemTutorialVideoOverrideData> VideoOverrides;                           // 0x0180(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemTutorialData) == 0x000008, "Wrong alignment on FInventoryItemTutorialData");
static_assert(sizeof(FInventoryItemTutorialData) == 0x000190, "Wrong size on FInventoryItemTutorialData");
static_assert(offsetof(FInventoryItemTutorialData, Hook) == 0x000168, "Member 'FInventoryItemTutorialData::Hook' has a wrong offset!");
static_assert(offsetof(FInventoryItemTutorialData, Condition) == 0x000170, "Member 'FInventoryItemTutorialData::Condition' has a wrong offset!");
static_assert(offsetof(FInventoryItemTutorialData, Video) == 0x000178, "Member 'FInventoryItemTutorialData::Video' has a wrong offset!");
static_assert(offsetof(FInventoryItemTutorialData, VideoOverrides) == 0x000180, "Member 'FInventoryItemTutorialData::VideoOverrides' has a wrong offset!");

// ScriptStruct Zion.InventoryItemKeyData
// 0x0000 (0x0168 - 0x0168)
struct FInventoryItemKeyData final : public FInventoryItemData
{
};
static_assert(alignof(FInventoryItemKeyData) == 0x000008, "Wrong alignment on FInventoryItemKeyData");
static_assert(sizeof(FInventoryItemKeyData) == 0x000168, "Wrong size on FInventoryItemKeyData");

// ScriptStruct Zion.InventoryItemQuestData
// 0x0000 (0x0168 - 0x0168)
struct FInventoryItemQuestData final : public FInventoryItemData
{
};
static_assert(alignof(FInventoryItemQuestData) == 0x000008, "Wrong alignment on FInventoryItemQuestData");
static_assert(sizeof(FInventoryItemQuestData) == 0x000168, "Wrong size on FInventoryItemQuestData");

// ScriptStruct Zion.InventoryItemCostumeData
// 0x0108 (0x0278 - 0x0170)
struct FInventoryItemCostumeData final : public FInventoryItemGrantData
{
public:
	bool                                          bCanBeBought;                                      // 0x0170(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemConditionData                     Conditions;                                        // 0x0178(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USpineNotifyAsset>       NotifyAsset;                                       // 0x01B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USpineAtlasAsset>        AtlasAsset;                                        // 0x01D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USpineSkeletonDataAsset> SkeletonDataAsset;                                 // 0x0200(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPlayerCostumeFX, TSoftObjectPtr<class UNiagaraSystem>> CostumeFXs;                         // 0x0228(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemCostumeData) == 0x000008, "Wrong alignment on FInventoryItemCostumeData");
static_assert(sizeof(FInventoryItemCostumeData) == 0x000278, "Wrong size on FInventoryItemCostumeData");
static_assert(offsetof(FInventoryItemCostumeData, bCanBeBought) == 0x000170, "Member 'FInventoryItemCostumeData::bCanBeBought' has a wrong offset!");
static_assert(offsetof(FInventoryItemCostumeData, Conditions) == 0x000178, "Member 'FInventoryItemCostumeData::Conditions' has a wrong offset!");
static_assert(offsetof(FInventoryItemCostumeData, NotifyAsset) == 0x0001B0, "Member 'FInventoryItemCostumeData::NotifyAsset' has a wrong offset!");
static_assert(offsetof(FInventoryItemCostumeData, AtlasAsset) == 0x0001D8, "Member 'FInventoryItemCostumeData::AtlasAsset' has a wrong offset!");
static_assert(offsetof(FInventoryItemCostumeData, SkeletonDataAsset) == 0x000200, "Member 'FInventoryItemCostumeData::SkeletonDataAsset' has a wrong offset!");
static_assert(offsetof(FInventoryItemCostumeData, CostumeFXs) == 0x000228, "Member 'FInventoryItemCostumeData::CostumeFXs' has a wrong offset!");

// ScriptStruct Zion.InventoryItemEnemyInfoData
// 0x0008 (0x0240 - 0x0238)
struct FInventoryItemEnemyInfoData final : public FInventoryItemGenericInfoData
{
public:
	bool                                          bAvailableOnNewGame;                               // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryItemEnemyInfoData) == 0x000008, "Wrong alignment on FInventoryItemEnemyInfoData");
static_assert(sizeof(FInventoryItemEnemyInfoData) == 0x000240, "Wrong size on FInventoryItemEnemyInfoData");
static_assert(offsetof(FInventoryItemEnemyInfoData, bAvailableOnNewGame) == 0x000238, "Member 'FInventoryItemEnemyInfoData::bAvailableOnNewGame' has a wrong offset!");

// ScriptStruct Zion.InventoryItemGalleryData
// 0x0078 (0x01E0 - 0x0168)
struct FInventoryItemGalleryData final : public FInventoryItemData
{
public:
	TSoftObjectPtr<class UTexture2D>              DisplayImage;                                      // 0x0168(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FExtraItemZoomData                     ZoomData;                                          // 0x0190(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemConditionData                     Conditions;                                        // 0x01A8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemGalleryData) == 0x000008, "Wrong alignment on FInventoryItemGalleryData");
static_assert(sizeof(FInventoryItemGalleryData) == 0x0001E0, "Wrong size on FInventoryItemGalleryData");
static_assert(offsetof(FInventoryItemGalleryData, DisplayImage) == 0x000168, "Member 'FInventoryItemGalleryData::DisplayImage' has a wrong offset!");
static_assert(offsetof(FInventoryItemGalleryData, ZoomData) == 0x000190, "Member 'FInventoryItemGalleryData::ZoomData' has a wrong offset!");
static_assert(offsetof(FInventoryItemGalleryData, Conditions) == 0x0001A8, "Member 'FInventoryItemGalleryData::Conditions' has a wrong offset!");

// ScriptStruct Zion.KnockbackData
// 0x0058 (0x0058 - 0x0000)
struct FKnockbackData final
{
public:
	struct FVector                                LocalSpaceImpulse_Grounded;                        // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalSpaceImpulse_Airborne;                        // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalSpaceImpulse_Swim;                            // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaggerTime;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLaunchAutoRecovery;                               // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LaunchAutoRecoveryTime;                            // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanImpulseForceBeReduced;                         // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyPostKnockbackStates;                         // 0x0055(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKnockbackData) == 0x000008, "Wrong alignment on FKnockbackData");
static_assert(sizeof(FKnockbackData) == 0x000058, "Wrong size on FKnockbackData");
static_assert(offsetof(FKnockbackData, LocalSpaceImpulse_Grounded) == 0x000000, "Member 'FKnockbackData::LocalSpaceImpulse_Grounded' has a wrong offset!");
static_assert(offsetof(FKnockbackData, LocalSpaceImpulse_Airborne) == 0x000018, "Member 'FKnockbackData::LocalSpaceImpulse_Airborne' has a wrong offset!");
static_assert(offsetof(FKnockbackData, LocalSpaceImpulse_Swim) == 0x000030, "Member 'FKnockbackData::LocalSpaceImpulse_Swim' has a wrong offset!");
static_assert(offsetof(FKnockbackData, StaggerTime) == 0x000048, "Member 'FKnockbackData::StaggerTime' has a wrong offset!");
static_assert(offsetof(FKnockbackData, bLaunchAutoRecovery) == 0x00004C, "Member 'FKnockbackData::bLaunchAutoRecovery' has a wrong offset!");
static_assert(offsetof(FKnockbackData, LaunchAutoRecoveryTime) == 0x000050, "Member 'FKnockbackData::LaunchAutoRecoveryTime' has a wrong offset!");
static_assert(offsetof(FKnockbackData, bCanImpulseForceBeReduced) == 0x000054, "Member 'FKnockbackData::bCanImpulseForceBeReduced' has a wrong offset!");
static_assert(offsetof(FKnockbackData, bApplyPostKnockbackStates) == 0x000055, "Member 'FKnockbackData::bApplyPostKnockbackStates' has a wrong offset!");

// ScriptStruct Zion.MapIconProviderData
// 0x0018 (0x0018 - 0x0000)
struct FMapIconProviderData final
{
public:
	class AActor*                                 MainActor;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         DependentActors;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapIconProviderData) == 0x000008, "Wrong alignment on FMapIconProviderData");
static_assert(sizeof(FMapIconProviderData) == 0x000018, "Wrong size on FMapIconProviderData");
static_assert(offsetof(FMapIconProviderData, MainActor) == 0x000000, "Member 'FMapIconProviderData::MainActor' has a wrong offset!");
static_assert(offsetof(FMapIconProviderData, DependentActors) == 0x000008, "Member 'FMapIconProviderData::DependentActors' has a wrong offset!");

// ScriptStruct Zion.MapTransitionSpawnPointData
// 0x0010 (0x0010 - 0x0000)
struct FMapTransitionSpawnPointData final
{
public:
	class FName                                   GameMapID;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayerStartTag;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapTransitionSpawnPointData) == 0x000004, "Wrong alignment on FMapTransitionSpawnPointData");
static_assert(sizeof(FMapTransitionSpawnPointData) == 0x000010, "Wrong size on FMapTransitionSpawnPointData");
static_assert(offsetof(FMapTransitionSpawnPointData, GameMapID) == 0x000000, "Member 'FMapTransitionSpawnPointData::GameMapID' has a wrong offset!");
static_assert(offsetof(FMapTransitionSpawnPointData, PlayerStartTag) == 0x000008, "Member 'FMapTransitionSpawnPointData::PlayerStartTag' has a wrong offset!");

// ScriptStruct Zion.MapTransitionData
// 0x0018 (0x0018 - 0x0000)
struct FMapTransitionData final
{
public:
	struct FDataTableRowHandle                    GameMapID;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   PlayerStartTag;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapTransitionData) == 0x000008, "Wrong alignment on FMapTransitionData");
static_assert(sizeof(FMapTransitionData) == 0x000018, "Wrong size on FMapTransitionData");
static_assert(offsetof(FMapTransitionData, GameMapID) == 0x000000, "Member 'FMapTransitionData::GameMapID' has a wrong offset!");
static_assert(offsetof(FMapTransitionData, PlayerStartTag) == 0x000010, "Member 'FMapTransitionData::PlayerStartTag' has a wrong offset!");

// ScriptStruct Zion.MapTransitionRowData
// 0x0010 (0x0018 - 0x0008)
struct FMapTransitionRowData final : public FTableRowBase
{
public:
	TArray<struct FMapTransitionData>             TransitionSpawnPoints;                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapTransitionRowData) == 0x000008, "Wrong alignment on FMapTransitionRowData");
static_assert(sizeof(FMapTransitionRowData) == 0x000018, "Wrong size on FMapTransitionRowData");
static_assert(offsetof(FMapTransitionRowData, TransitionSpawnPoints) == 0x000008, "Member 'FMapTransitionRowData::TransitionSpawnPoints' has a wrong offset!");

// ScriptStruct Zion.MovementModeData
// 0x0002 (0x0002 - 0x0000)
struct FMovementModeData final
{
public:
	EMovementMode                                 MovementMode;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementModeCustom                           MovementModeCustom;                                // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovementModeData) == 0x000001, "Wrong alignment on FMovementModeData");
static_assert(sizeof(FMovementModeData) == 0x000002, "Wrong size on FMovementModeData");
static_assert(offsetof(FMovementModeData, MovementMode) == 0x000000, "Member 'FMovementModeData::MovementMode' has a wrong offset!");
static_assert(offsetof(FMovementModeData, MovementModeCustom) == 0x000001, "Member 'FMovementModeData::MovementModeCustom' has a wrong offset!");

// ScriptStruct Zion.SpawnerNPCData
// 0x0090 (0x0090 - 0x0000)
struct FSpawnerNPCData final
{
public:
	struct FGameplayConditionChecker              Conditions;                                        // 0x0000(0x0018)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bOverrideAnimations;                               // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      IdleAnimations;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bOverrideFacing;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFacingType                                   Facing;                                            // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAI;                                            // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNPCAIData                             AIData;                                            // 0x0038(0x0058)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnerNPCData) == 0x000008, "Wrong alignment on FSpawnerNPCData");
static_assert(sizeof(FSpawnerNPCData) == 0x000090, "Wrong size on FSpawnerNPCData");
static_assert(offsetof(FSpawnerNPCData, Conditions) == 0x000000, "Member 'FSpawnerNPCData::Conditions' has a wrong offset!");
static_assert(offsetof(FSpawnerNPCData, bOverrideAnimations) == 0x000018, "Member 'FSpawnerNPCData::bOverrideAnimations' has a wrong offset!");
static_assert(offsetof(FSpawnerNPCData, IdleAnimations) == 0x000020, "Member 'FSpawnerNPCData::IdleAnimations' has a wrong offset!");
static_assert(offsetof(FSpawnerNPCData, bOverrideFacing) == 0x000030, "Member 'FSpawnerNPCData::bOverrideFacing' has a wrong offset!");
static_assert(offsetof(FSpawnerNPCData, Facing) == 0x000031, "Member 'FSpawnerNPCData::Facing' has a wrong offset!");
static_assert(offsetof(FSpawnerNPCData, bUseAI) == 0x000032, "Member 'FSpawnerNPCData::bUseAI' has a wrong offset!");
static_assert(offsetof(FSpawnerNPCData, AIData) == 0x000038, "Member 'FSpawnerNPCData::AIData' has a wrong offset!");

// ScriptStruct Zion.PassiveRuntimeData
// 0x0018 (0x0018 - 0x0000)
struct FPassiveRuntimeData final
{
public:
	class FName                                   PassiveID;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotCost;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPassive*                               PassiveInstance;                                   // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPassiveRuntimeData) == 0x000008, "Wrong alignment on FPassiveRuntimeData");
static_assert(sizeof(FPassiveRuntimeData) == 0x000018, "Wrong size on FPassiveRuntimeData");
static_assert(offsetof(FPassiveRuntimeData, PassiveID) == 0x000000, "Member 'FPassiveRuntimeData::PassiveID' has a wrong offset!");
static_assert(offsetof(FPassiveRuntimeData, SlotCost) == 0x000008, "Member 'FPassiveRuntimeData::SlotCost' has a wrong offset!");
static_assert(offsetof(FPassiveRuntimeData, PassiveInstance) == 0x000010, "Member 'FPassiveRuntimeData::PassiveInstance' has a wrong offset!");

// ScriptStruct Zion.SummonStashElement
// 0x0010 (0x0010 - 0x0000)
struct FSummonStashElement final
{
public:
	class UInputAction*                           InputAction;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCommandSet*                            CommandSet;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSummonStashElement) == 0x000008, "Wrong alignment on FSummonStashElement");
static_assert(sizeof(FSummonStashElement) == 0x000010, "Wrong size on FSummonStashElement");
static_assert(offsetof(FSummonStashElement, InputAction) == 0x000000, "Member 'FSummonStashElement::InputAction' has a wrong offset!");
static_assert(offsetof(FSummonStashElement, CommandSet) == 0x000008, "Member 'FSummonStashElement::CommandSet' has a wrong offset!");

// ScriptStruct Zion.PlayerTrailData
// 0x0038 (0x0038 - 0x0000)
struct FPlayerTrailData final
{
public:
	bool                                          bIsSet;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldLocation;                                     // 0x0008(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0020(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerTrailData) == 0x000008, "Wrong alignment on FPlayerTrailData");
static_assert(sizeof(FPlayerTrailData) == 0x000038, "Wrong size on FPlayerTrailData");
static_assert(offsetof(FPlayerTrailData, bIsSet) == 0x000000, "Member 'FPlayerTrailData::bIsSet' has a wrong offset!");
static_assert(offsetof(FPlayerTrailData, WorldLocation) == 0x000008, "Member 'FPlayerTrailData::WorldLocation' has a wrong offset!");
static_assert(offsetof(FPlayerTrailData, Velocity) == 0x000020, "Member 'FPlayerTrailData::Velocity' has a wrong offset!");

// ScriptStruct Zion.RecollectionMovieData
// 0x0008 (0x0080 - 0x0078)
struct FRecollectionMovieData final : public FRecollectionItemData
{
public:
	class UPlatformMediaSource*                   MediaSource;                                       // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecollectionMovieData) == 0x000008, "Wrong alignment on FRecollectionMovieData");
static_assert(sizeof(FRecollectionMovieData) == 0x000080, "Wrong size on FRecollectionMovieData");
static_assert(offsetof(FRecollectionMovieData, MediaSource) == 0x000078, "Member 'FRecollectionMovieData::MediaSource' has a wrong offset!");

// ScriptStruct Zion.EnemyRepulsionSetupData
// 0x00C8 (0x00C8 - 0x0000)
struct FEnemyRepulsionSetupData final
{
public:
	struct FComponentReference                    RepulsionColliderReference;                        // 0x0000(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDefaultValues;                            // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEnemyRepulsionData                    RepulsionData;                                     // 0x0030(0x0098)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyRepulsionSetupData) == 0x000008, "Wrong alignment on FEnemyRepulsionSetupData");
static_assert(sizeof(FEnemyRepulsionSetupData) == 0x0000C8, "Wrong size on FEnemyRepulsionSetupData");
static_assert(offsetof(FEnemyRepulsionSetupData, RepulsionColliderReference) == 0x000000, "Member 'FEnemyRepulsionSetupData::RepulsionColliderReference' has a wrong offset!");
static_assert(offsetof(FEnemyRepulsionSetupData, bOverrideDefaultValues) == 0x000028, "Member 'FEnemyRepulsionSetupData::bOverrideDefaultValues' has a wrong offset!");
static_assert(offsetof(FEnemyRepulsionSetupData, RepulsionData) == 0x000030, "Member 'FEnemyRepulsionSetupData::RepulsionData' has a wrong offset!");

// ScriptStruct Zion.RestPointEventData
// 0x0088 (0x0090 - 0x0008)
struct FRestPointEventData final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UEventAsset>             EventAsset;                                        // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            Icon;                                              // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDataTableRowHandle>            NecessaryItems;                                    // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UEventAsset>>     NecessaryEvents;                                   // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	ERestPointEventPriority                       Priority;                                          // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRestPointEventData) == 0x000008, "Wrong alignment on FRestPointEventData");
static_assert(sizeof(FRestPointEventData) == 0x000090, "Wrong size on FRestPointEventData");
static_assert(offsetof(FRestPointEventData, Name) == 0x000008, "Member 'FRestPointEventData::Name' has a wrong offset!");
static_assert(offsetof(FRestPointEventData, EventAsset) == 0x000018, "Member 'FRestPointEventData::EventAsset' has a wrong offset!");
static_assert(offsetof(FRestPointEventData, Icon) == 0x000040, "Member 'FRestPointEventData::Icon' has a wrong offset!");
static_assert(offsetof(FRestPointEventData, NecessaryItems) == 0x000068, "Member 'FRestPointEventData::NecessaryItems' has a wrong offset!");
static_assert(offsetof(FRestPointEventData, NecessaryEvents) == 0x000078, "Member 'FRestPointEventData::NecessaryEvents' has a wrong offset!");
static_assert(offsetof(FRestPointEventData, Priority) == 0x000088, "Member 'FRestPointEventData::Priority' has a wrong offset!");

// ScriptStruct Zion.GameStatsSaveData
// 0x0010 (0x0010 - 0x0000)
struct FGameStatsSaveData final
{
public:
	int32                                         PlayTime;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        PlayTimeDecimal;                                   // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameStatsSaveData) == 0x000008, "Wrong alignment on FGameStatsSaveData");
static_assert(sizeof(FGameStatsSaveData) == 0x000010, "Wrong size on FGameStatsSaveData");
static_assert(offsetof(FGameStatsSaveData, PlayTime) == 0x000000, "Member 'FGameStatsSaveData::PlayTime' has a wrong offset!");
static_assert(offsetof(FGameStatsSaveData, PlayTimeDecimal) == 0x000008, "Member 'FGameStatsSaveData::PlayTimeDecimal' has a wrong offset!");

// ScriptStruct Zion.ClearManagerSaveData
// 0x00A0 (0x00A0 - 0x0000)
struct FClearManagerSaveData final
{
public:
	TMap<class FName, struct FNameSet>            ClearedActors;                                     // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, struct FNameSet>            PreviousRunsClearedSavedActors;                    // 0x0050(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FClearManagerSaveData) == 0x000008, "Wrong alignment on FClearManagerSaveData");
static_assert(sizeof(FClearManagerSaveData) == 0x0000A0, "Wrong size on FClearManagerSaveData");
static_assert(offsetof(FClearManagerSaveData, ClearedActors) == 0x000000, "Member 'FClearManagerSaveData::ClearedActors' has a wrong offset!");
static_assert(offsetof(FClearManagerSaveData, PreviousRunsClearedSavedActors) == 0x000050, "Member 'FClearManagerSaveData::PreviousRunsClearedSavedActors' has a wrong offset!");

// ScriptStruct Zion.DropSystemSaveData
// 0x0018 (0x0018 - 0x0000)
struct FDropSystemSaveData final
{
public:
	double                                        CurrentTime;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDropHistoryElement>            History;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDropSystemSaveData) == 0x000008, "Wrong alignment on FDropSystemSaveData");
static_assert(sizeof(FDropSystemSaveData) == 0x000018, "Wrong size on FDropSystemSaveData");
static_assert(offsetof(FDropSystemSaveData, CurrentTime) == 0x000000, "Member 'FDropSystemSaveData::CurrentTime' has a wrong offset!");
static_assert(offsetof(FDropSystemSaveData, History) == 0x000008, "Member 'FDropSystemSaveData::History' has a wrong offset!");

// ScriptStruct Zion.RenderStateManagerSaveData
// 0x0050 (0x0050 - 0x0000)
struct FRenderStateManagerSaveData final
{
public:
	TMap<class FName, struct FNameSet>            SeenActors;                                        // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRenderStateManagerSaveData) == 0x000008, "Wrong alignment on FRenderStateManagerSaveData");
static_assert(sizeof(FRenderStateManagerSaveData) == 0x000050, "Wrong size on FRenderStateManagerSaveData");
static_assert(offsetof(FRenderStateManagerSaveData, SeenActors) == 0x000000, "Member 'FRenderStateManagerSaveData::SeenActors' has a wrong offset!");

// ScriptStruct Zion.DifficultySystemSaveData
// 0x0038 (0x0038 - 0x0000)
struct FDifficultySystemSaveData final
{
public:
	EDifficultyPreset                             DifficultyPreset;                                  // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDifficultySettings                    DifficultySettings;                                // 0x0004(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	EDifficultyPreset                             BossRushDifficultyPreset;                          // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDifficultySettings                    BossRushDifficultySettings;                        // 0x0020(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDifficultySystemSaveData) == 0x000004, "Wrong alignment on FDifficultySystemSaveData");
static_assert(sizeof(FDifficultySystemSaveData) == 0x000038, "Wrong size on FDifficultySystemSaveData");
static_assert(offsetof(FDifficultySystemSaveData, DifficultyPreset) == 0x000000, "Member 'FDifficultySystemSaveData::DifficultyPreset' has a wrong offset!");
static_assert(offsetof(FDifficultySystemSaveData, DifficultySettings) == 0x000004, "Member 'FDifficultySystemSaveData::DifficultySettings' has a wrong offset!");
static_assert(offsetof(FDifficultySystemSaveData, BossRushDifficultyPreset) == 0x00001C, "Member 'FDifficultySystemSaveData::BossRushDifficultyPreset' has a wrong offset!");
static_assert(offsetof(FDifficultySystemSaveData, BossRushDifficultySettings) == 0x000020, "Member 'FDifficultySystemSaveData::BossRushDifficultySettings' has a wrong offset!");

// ScriptStruct Zion.RecollectionBossRushRecordsData
// 0x0018 (0x0018 - 0x0000)
struct FRecollectionBossRushRecordsData final
{
public:
	int32                                         MaxBossesDefeatedCount;                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRecollectionBossRushRecordData> Records;                                          // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecollectionBossRushRecordsData) == 0x000008, "Wrong alignment on FRecollectionBossRushRecordsData");
static_assert(sizeof(FRecollectionBossRushRecordsData) == 0x000018, "Wrong size on FRecollectionBossRushRecordsData");
static_assert(offsetof(FRecollectionBossRushRecordsData, MaxBossesDefeatedCount) == 0x000000, "Member 'FRecollectionBossRushRecordsData::MaxBossesDefeatedCount' has a wrong offset!");
static_assert(offsetof(FRecollectionBossRushRecordsData, Records) == 0x000008, "Member 'FRecollectionBossRushRecordsData::Records' has a wrong offset!");

// ScriptStruct Zion.RecollectionBossRushSaveData
// 0x00A8 (0x00A8 - 0x0000)
struct FRecollectionBossRushSaveData final
{
public:
	int32                                         NewGameGenerationOverride;                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDifficultyPreset, struct FRecollectionBossRushRecordsData> NewGameRecords;                 // 0x0008(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EDifficultyPreset, struct FRecollectionBossRushRecordsData> NewGamePlusRecords;             // 0x0058(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecollectionBossRushSaveData) == 0x000008, "Wrong alignment on FRecollectionBossRushSaveData");
static_assert(sizeof(FRecollectionBossRushSaveData) == 0x0000A8, "Wrong size on FRecollectionBossRushSaveData");
static_assert(offsetof(FRecollectionBossRushSaveData, NewGameGenerationOverride) == 0x000000, "Member 'FRecollectionBossRushSaveData::NewGameGenerationOverride' has a wrong offset!");
static_assert(offsetof(FRecollectionBossRushSaveData, NewGameRecords) == 0x000008, "Member 'FRecollectionBossRushSaveData::NewGameRecords' has a wrong offset!");
static_assert(offsetof(FRecollectionBossRushSaveData, NewGamePlusRecords) == 0x000058, "Member 'FRecollectionBossRushSaveData::NewGamePlusRecords' has a wrong offset!");

// ScriptStruct Zion.RecollectionBossSaveData
// 0x0004 (0x0004 - 0x0000)
struct FRecollectionBossSaveData final
{
public:
	int32                                         NewGameGenerationOverride;                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecollectionBossSaveData) == 0x000004, "Wrong alignment on FRecollectionBossSaveData");
static_assert(sizeof(FRecollectionBossSaveData) == 0x000004, "Wrong size on FRecollectionBossSaveData");
static_assert(offsetof(FRecollectionBossSaveData, NewGameGenerationOverride) == 0x000000, "Member 'FRecollectionBossSaveData::NewGameGenerationOverride' has a wrong offset!");

// ScriptStruct Zion.GameModeSaveData
// 0x0300 (0x0300 - 0x0000)
struct FGameModeSaveData final
{
public:
	int32                                         EnvironmentLevel;                                  // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGameEndingType, int32>                  ReachedGameEndings;                                // 0x0008(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EGameEndingType, int32>                  PreviousCumulatedReachedGameEndings;               // 0x0058(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         NewGamePlusGeneration;                             // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      EnvironmentLevelForGameMaps;                       // 0x00B0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameStatsSaveData                     GameStats;                                         // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FClearManagerSaveData                  ClearManager;                                      // 0x0110(0x00A0)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRenderStateManagerSaveData            RenderStateManager;                                // 0x01B0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDifficultySystemSaveData              DifficultySystem;                                  // 0x0200(0x0038)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FDropSystemSaveData                    DropSystem;                                        // 0x0238(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRecollectionBossRushSaveData          BossRush;                                          // 0x0250(0x00A8)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRecollectionBossSaveData              RecollectionBoss;                                  // 0x02F8(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameModeSaveData) == 0x000008, "Wrong alignment on FGameModeSaveData");
static_assert(sizeof(FGameModeSaveData) == 0x000300, "Wrong size on FGameModeSaveData");
static_assert(offsetof(FGameModeSaveData, EnvironmentLevel) == 0x000000, "Member 'FGameModeSaveData::EnvironmentLevel' has a wrong offset!");
static_assert(offsetof(FGameModeSaveData, ReachedGameEndings) == 0x000008, "Member 'FGameModeSaveData::ReachedGameEndings' has a wrong offset!");
static_assert(offsetof(FGameModeSaveData, PreviousCumulatedReachedGameEndings) == 0x000058, "Member 'FGameModeSaveData::PreviousCumulatedReachedGameEndings' has a wrong offset!");
static_assert(offsetof(FGameModeSaveData, NewGamePlusGeneration) == 0x0000A8, "Member 'FGameModeSaveData::NewGamePlusGeneration' has a wrong offset!");
static_assert(offsetof(FGameModeSaveData, EnvironmentLevelForGameMaps) == 0x0000B0, "Member 'FGameModeSaveData::EnvironmentLevelForGameMaps' has a wrong offset!");
static_assert(offsetof(FGameModeSaveData, GameStats) == 0x000100, "Member 'FGameModeSaveData::GameStats' has a wrong offset!");
static_assert(offsetof(FGameModeSaveData, ClearManager) == 0x000110, "Member 'FGameModeSaveData::ClearManager' has a wrong offset!");
static_assert(offsetof(FGameModeSaveData, RenderStateManager) == 0x0001B0, "Member 'FGameModeSaveData::RenderStateManager' has a wrong offset!");
static_assert(offsetof(FGameModeSaveData, DifficultySystem) == 0x000200, "Member 'FGameModeSaveData::DifficultySystem' has a wrong offset!");
static_assert(offsetof(FGameModeSaveData, DropSystem) == 0x000238, "Member 'FGameModeSaveData::DropSystem' has a wrong offset!");
static_assert(offsetof(FGameModeSaveData, BossRush) == 0x000250, "Member 'FGameModeSaveData::BossRush' has a wrong offset!");
static_assert(offsetof(FGameModeSaveData, RecollectionBoss) == 0x0002F8, "Member 'FGameModeSaveData::RecollectionBoss' has a wrong offset!");

// ScriptStruct Zion.PlayerSkillLoadoutData
// 0x0050 (0x0050 - 0x0000)
struct FPlayerSkillLoadoutData final
{
public:
	TMap<ESkillSlot, class FName>                 SkillIDForSkillSlots;                              // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSkillLoadoutData) == 0x000008, "Wrong alignment on FPlayerSkillLoadoutData");
static_assert(sizeof(FPlayerSkillLoadoutData) == 0x000050, "Wrong size on FPlayerSkillLoadoutData");
static_assert(offsetof(FPlayerSkillLoadoutData, SkillIDForSkillSlots) == 0x000000, "Member 'FPlayerSkillLoadoutData::SkillIDForSkillSlots' has a wrong offset!");

// ScriptStruct Zion.PlayerSkillSaveData
// 0x0068 (0x0068 - 0x0000)
struct FPlayerSkillSaveData final
{
public:
	TMap<ESkillSlot, class FName>                 SkillIDForSkillSlots;                              // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	int32                                         CurrentLoadoutIndex;                               // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerSkillLoadoutData>        Loadouts;                                          // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSkillSaveData) == 0x000008, "Wrong alignment on FPlayerSkillSaveData");
static_assert(sizeof(FPlayerSkillSaveData) == 0x000068, "Wrong size on FPlayerSkillSaveData");
static_assert(offsetof(FPlayerSkillSaveData, SkillIDForSkillSlots) == 0x000000, "Member 'FPlayerSkillSaveData::SkillIDForSkillSlots' has a wrong offset!");
static_assert(offsetof(FPlayerSkillSaveData, CurrentLoadoutIndex) == 0x000050, "Member 'FPlayerSkillSaveData::CurrentLoadoutIndex' has a wrong offset!");
static_assert(offsetof(FPlayerSkillSaveData, Loadouts) == 0x000058, "Member 'FPlayerSkillSaveData::Loadouts' has a wrong offset!");

// ScriptStruct Zion.PlayerEquipmentLoadoutData
// 0x0050 (0x0050 - 0x0000)
struct FPlayerEquipmentLoadoutData final
{
public:
	TMap<EEquipmentSlot, class FName>             EquippedItems;                                     // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerEquipmentLoadoutData) == 0x000008, "Wrong alignment on FPlayerEquipmentLoadoutData");
static_assert(sizeof(FPlayerEquipmentLoadoutData) == 0x000050, "Wrong size on FPlayerEquipmentLoadoutData");
static_assert(offsetof(FPlayerEquipmentLoadoutData, EquippedItems) == 0x000000, "Member 'FPlayerEquipmentLoadoutData::EquippedItems' has a wrong offset!");

// ScriptStruct Zion.PlayerEquipmentSaveData
// 0x0068 (0x0068 - 0x0000)
struct FPlayerEquipmentSaveData final
{
public:
	TMap<EEquipmentSlot, class FName>             EquippedItems;                                     // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	int32                                         CurrentLoadoutIndex;                               // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerEquipmentLoadoutData>    Loadouts;                                          // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerEquipmentSaveData) == 0x000008, "Wrong alignment on FPlayerEquipmentSaveData");
static_assert(sizeof(FPlayerEquipmentSaveData) == 0x000068, "Wrong size on FPlayerEquipmentSaveData");
static_assert(offsetof(FPlayerEquipmentSaveData, EquippedItems) == 0x000000, "Member 'FPlayerEquipmentSaveData::EquippedItems' has a wrong offset!");
static_assert(offsetof(FPlayerEquipmentSaveData, CurrentLoadoutIndex) == 0x000050, "Member 'FPlayerEquipmentSaveData::CurrentLoadoutIndex' has a wrong offset!");
static_assert(offsetof(FPlayerEquipmentSaveData, Loadouts) == 0x000058, "Member 'FPlayerEquipmentSaveData::Loadouts' has a wrong offset!");

// ScriptStruct Zion.PlayerAssistLoadoutData
// 0x0008 (0x0008 - 0x0000)
struct FPlayerAssistLoadoutData final
{
public:
	class FName                                   AssistID;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerAssistLoadoutData) == 0x000004, "Wrong alignment on FPlayerAssistLoadoutData");
static_assert(sizeof(FPlayerAssistLoadoutData) == 0x000008, "Wrong size on FPlayerAssistLoadoutData");
static_assert(offsetof(FPlayerAssistLoadoutData, AssistID) == 0x000000, "Member 'FPlayerAssistLoadoutData::AssistID' has a wrong offset!");

// ScriptStruct Zion.PlayerAssistSaveData
// 0x0020 (0x0020 - 0x0000)
struct FPlayerAssistSaveData final
{
public:
	class FName                                   AssistID;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentLoadoutIndex;                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerAssistLoadoutData>       Loadouts;                                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerAssistSaveData) == 0x000008, "Wrong alignment on FPlayerAssistSaveData");
static_assert(sizeof(FPlayerAssistSaveData) == 0x000020, "Wrong size on FPlayerAssistSaveData");
static_assert(offsetof(FPlayerAssistSaveData, AssistID) == 0x000000, "Member 'FPlayerAssistSaveData::AssistID' has a wrong offset!");
static_assert(offsetof(FPlayerAssistSaveData, CurrentLoadoutIndex) == 0x000008, "Member 'FPlayerAssistSaveData::CurrentLoadoutIndex' has a wrong offset!");
static_assert(offsetof(FPlayerAssistSaveData, Loadouts) == 0x000010, "Member 'FPlayerAssistSaveData::Loadouts' has a wrong offset!");

// ScriptStruct Zion.PlayerPassiveLoadoutData
// 0x0010 (0x0010 - 0x0000)
struct FPlayerPassiveLoadoutData final
{
public:
	TArray<class FName>                           ItemIDs;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerPassiveLoadoutData) == 0x000008, "Wrong alignment on FPlayerPassiveLoadoutData");
static_assert(sizeof(FPlayerPassiveLoadoutData) == 0x000010, "Wrong size on FPlayerPassiveLoadoutData");
static_assert(offsetof(FPlayerPassiveLoadoutData, ItemIDs) == 0x000000, "Member 'FPlayerPassiveLoadoutData::ItemIDs' has a wrong offset!");

// ScriptStruct Zion.PlayerPassiveSaveData
// 0x0028 (0x0028 - 0x0000)
struct FPlayerPassiveSaveData final
{
public:
	TArray<class FName>                           ItemIDs;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CurrentLoadoutIndex;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerPassiveLoadoutData>      Loadouts;                                          // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerPassiveSaveData) == 0x000008, "Wrong alignment on FPlayerPassiveSaveData");
static_assert(sizeof(FPlayerPassiveSaveData) == 0x000028, "Wrong size on FPlayerPassiveSaveData");
static_assert(offsetof(FPlayerPassiveSaveData, ItemIDs) == 0x000000, "Member 'FPlayerPassiveSaveData::ItemIDs' has a wrong offset!");
static_assert(offsetof(FPlayerPassiveSaveData, CurrentLoadoutIndex) == 0x000010, "Member 'FPlayerPassiveSaveData::CurrentLoadoutIndex' has a wrong offset!");
static_assert(offsetof(FPlayerPassiveSaveData, Loadouts) == 0x000018, "Member 'FPlayerPassiveSaveData::Loadouts' has a wrong offset!");

// ScriptStruct Zion.PlayerCostumeSaveData
// 0x0008 (0x0008 - 0x0000)
struct FPlayerCostumeSaveData final
{
public:
	class FName                                   EquippedCostumeID;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCostumeSaveData) == 0x000004, "Wrong alignment on FPlayerCostumeSaveData");
static_assert(sizeof(FPlayerCostumeSaveData) == 0x000008, "Wrong size on FPlayerCostumeSaveData");
static_assert(offsetof(FPlayerCostumeSaveData, EquippedCostumeID) == 0x000000, "Member 'FPlayerCostumeSaveData::EquippedCostumeID' has a wrong offset!");

// ScriptStruct Zion.ShopBuyHistory
// 0x0050 (0x0050 - 0x0000)
struct FShopBuyHistory final
{
public:
	TMap<struct FDataTableRowHandleKey, int32>    Items;                                             // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopBuyHistory) == 0x000008, "Wrong alignment on FShopBuyHistory");
static_assert(sizeof(FShopBuyHistory) == 0x000050, "Wrong size on FShopBuyHistory");
static_assert(offsetof(FShopBuyHistory, Items) == 0x000000, "Member 'FShopBuyHistory::Items' has a wrong offset!");

// ScriptStruct Zion.ShopSeenHistory
// 0x0050 (0x0050 - 0x0000)
struct FShopSeenHistory final
{
public:
	TMap<struct FDataTableRowHandleKey, int32>    Items;                                             // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopSeenHistory) == 0x000008, "Wrong alignment on FShopSeenHistory");
static_assert(sizeof(FShopSeenHistory) == 0x000050, "Wrong size on FShopSeenHistory");
static_assert(offsetof(FShopSeenHistory, Items) == 0x000000, "Member 'FShopSeenHistory::Items' has a wrong offset!");

// ScriptStruct Zion.ShopInfoSaveData
// 0x00A0 (0x00A0 - 0x0000)
struct FShopInfoSaveData final
{
public:
	TMap<EShopType, struct FShopBuyHistory>       ShopHistories;                                     // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TMap<EShopType, struct FShopSeenHistory>      SeenHistories;                                     // 0x0050(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopInfoSaveData) == 0x000008, "Wrong alignment on FShopInfoSaveData");
static_assert(sizeof(FShopInfoSaveData) == 0x0000A0, "Wrong size on FShopInfoSaveData");
static_assert(offsetof(FShopInfoSaveData, ShopHistories) == 0x000000, "Member 'FShopInfoSaveData::ShopHistories' has a wrong offset!");
static_assert(offsetof(FShopInfoSaveData, SeenHistories) == 0x000050, "Member 'FShopInfoSaveData::SeenHistories' has a wrong offset!");

// ScriptStruct Zion.InventorySaveData
// 0x00A0 (0x00A0 - 0x0000)
struct FInventorySaveData final
{
public:
	TMap<class FName, int32>                      Items;                                             // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TSet<class FName>                             Checked;                                           // 0x0050(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventorySaveData) == 0x000008, "Wrong alignment on FInventorySaveData");
static_assert(sizeof(FInventorySaveData) == 0x0000A0, "Wrong size on FInventorySaveData");
static_assert(offsetof(FInventorySaveData, Items) == 0x000000, "Member 'FInventorySaveData::Items' has a wrong offset!");
static_assert(offsetof(FInventorySaveData, Checked) == 0x000050, "Member 'FInventorySaveData::Checked' has a wrong offset!");

// ScriptStruct Zion.PlayerInventorySaveData
// 0x0AF0 (0x0AF0 - 0x0000)
struct FPlayerInventorySaveData final
{
public:
	struct FInventorySaveData                     CurrencyInventory;                                 // 0x0000(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     AptitudeInventory;                                 // 0x00A0(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     SpiritInventory;                                   // 0x0140(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     SkillInventory;                                    // 0x01E0(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     EquipmentInventory;                                // 0x0280(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     AssistInventory;                                   // 0x0320(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     StatsInventory;                                    // 0x03C0(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     PassiveInventory;                                  // 0x0460(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     MaterialInventory;                                 // 0x0500(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     KeyInventory;                                      // 0x05A0(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     QuestInventory;                                    // 0x0640(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     TipInventory;                                      // 0x06E0(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     TutorialInventory;                                 // 0x0780(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     CostumeInventory;                                  // 0x0820(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     EnemyInfoInventory;                                // 0x08C0(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     NPCInfoInventory;                                  // 0x0960(0x00A0)(NativeAccessSpecifierPublic)
	struct FInventorySaveData                     GalleryInventory;                                  // 0x0A00(0x00A0)(NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      SkillLevels;                                       // 0x0AA0(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerInventorySaveData) == 0x000008, "Wrong alignment on FPlayerInventorySaveData");
static_assert(sizeof(FPlayerInventorySaveData) == 0x000AF0, "Wrong size on FPlayerInventorySaveData");
static_assert(offsetof(FPlayerInventorySaveData, CurrencyInventory) == 0x000000, "Member 'FPlayerInventorySaveData::CurrencyInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, AptitudeInventory) == 0x0000A0, "Member 'FPlayerInventorySaveData::AptitudeInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, SpiritInventory) == 0x000140, "Member 'FPlayerInventorySaveData::SpiritInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, SkillInventory) == 0x0001E0, "Member 'FPlayerInventorySaveData::SkillInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, EquipmentInventory) == 0x000280, "Member 'FPlayerInventorySaveData::EquipmentInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, AssistInventory) == 0x000320, "Member 'FPlayerInventorySaveData::AssistInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, StatsInventory) == 0x0003C0, "Member 'FPlayerInventorySaveData::StatsInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, PassiveInventory) == 0x000460, "Member 'FPlayerInventorySaveData::PassiveInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, MaterialInventory) == 0x000500, "Member 'FPlayerInventorySaveData::MaterialInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, KeyInventory) == 0x0005A0, "Member 'FPlayerInventorySaveData::KeyInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, QuestInventory) == 0x000640, "Member 'FPlayerInventorySaveData::QuestInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, TipInventory) == 0x0006E0, "Member 'FPlayerInventorySaveData::TipInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, TutorialInventory) == 0x000780, "Member 'FPlayerInventorySaveData::TutorialInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, CostumeInventory) == 0x000820, "Member 'FPlayerInventorySaveData::CostumeInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, EnemyInfoInventory) == 0x0008C0, "Member 'FPlayerInventorySaveData::EnemyInfoInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, NPCInfoInventory) == 0x000960, "Member 'FPlayerInventorySaveData::NPCInfoInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, GalleryInventory) == 0x000A00, "Member 'FPlayerInventorySaveData::GalleryInventory' has a wrong offset!");
static_assert(offsetof(FPlayerInventorySaveData, SkillLevels) == 0x000AA0, "Member 'FPlayerInventorySaveData::SkillLevels' has a wrong offset!");

// ScriptStruct Zion.CompressedRenderTarget
// 0x0028 (0x0028 - 0x0000)
struct FCompressedRenderTarget final
{
public:
	TArray<uint8>                                 Buffer;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         UncompressedSize;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CompressionName;                                   // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeX;                                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompressedRenderTarget) == 0x000008, "Wrong alignment on FCompressedRenderTarget");
static_assert(sizeof(FCompressedRenderTarget) == 0x000028, "Wrong size on FCompressedRenderTarget");
static_assert(offsetof(FCompressedRenderTarget, Buffer) == 0x000000, "Member 'FCompressedRenderTarget::Buffer' has a wrong offset!");
static_assert(offsetof(FCompressedRenderTarget, UncompressedSize) == 0x000010, "Member 'FCompressedRenderTarget::UncompressedSize' has a wrong offset!");
static_assert(offsetof(FCompressedRenderTarget, CompressionName) == 0x000014, "Member 'FCompressedRenderTarget::CompressionName' has a wrong offset!");
static_assert(offsetof(FCompressedRenderTarget, SizeX) == 0x00001C, "Member 'FCompressedRenderTarget::SizeX' has a wrong offset!");
static_assert(offsetof(FCompressedRenderTarget, SizeY) == 0x000020, "Member 'FCompressedRenderTarget::SizeY' has a wrong offset!");

// ScriptStruct Zion.FogOfWarSaveData
// 0x0050 (0x0050 - 0x0000)
struct FFogOfWarSaveData final
{
public:
	TMap<class FName, struct FCompressedRenderTarget> MapFogOfWarBuffers;                            // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FFogOfWarSaveData) == 0x000008, "Wrong alignment on FFogOfWarSaveData");
static_assert(sizeof(FFogOfWarSaveData) == 0x000050, "Wrong size on FFogOfWarSaveData");
static_assert(offsetof(FFogOfWarSaveData, MapFogOfWarBuffers) == 0x000000, "Member 'FFogOfWarSaveData::MapFogOfWarBuffers' has a wrong offset!");

// ScriptStruct Zion.PlayerStatsSaveData
// 0x0008 (0x0008 - 0x0000)
struct FPlayerStatsSaveData final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExperiencePoints;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerStatsSaveData) == 0x000004, "Wrong alignment on FPlayerStatsSaveData");
static_assert(sizeof(FPlayerStatsSaveData) == 0x000008, "Wrong size on FPlayerStatsSaveData");
static_assert(offsetof(FPlayerStatsSaveData, Level) == 0x000000, "Member 'FPlayerStatsSaveData::Level' has a wrong offset!");
static_assert(offsetof(FPlayerStatsSaveData, ExperiencePoints) == 0x000004, "Member 'FPlayerStatsSaveData::ExperiencePoints' has a wrong offset!");

// ScriptStruct Zion.CustomMarkerSaveData
// 0x0050 (0x0050 - 0x0000)
struct FCustomMarkerSaveData final
{
public:
	TSet<struct FMapCustomMarkerIconData>         PlacedCustomMarkers;                               // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomMarkerSaveData) == 0x000008, "Wrong alignment on FCustomMarkerSaveData");
static_assert(sizeof(FCustomMarkerSaveData) == 0x000050, "Wrong size on FCustomMarkerSaveData");
static_assert(offsetof(FCustomMarkerSaveData, PlacedCustomMarkers) == 0x000000, "Member 'FCustomMarkerSaveData::PlacedCustomMarkers' has a wrong offset!");

// ScriptStruct Zion.PlayerSaveData
// 0x1008 (0x1008 - 0x0000)
struct FPlayerSaveData final
{
public:
	struct FPlayerStatsSaveData                   Stats;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlayerSkillSaveData                   Skill;                                             // 0x0008(0x0068)(NativeAccessSpecifierPublic)
	struct FPlayerEquipmentSaveData               Equipment;                                         // 0x0070(0x0068)(NativeAccessSpecifierPublic)
	struct FPlayerAssistSaveData                  Assist;                                            // 0x00D8(0x0020)(NativeAccessSpecifierPublic)
	struct FPlayerPassiveSaveData                 Passive;                                           // 0x00F8(0x0028)(NativeAccessSpecifierPublic)
	struct FShopInfoSaveData                      ShopInfo;                                          // 0x0120(0x00A0)(NativeAccessSpecifierPublic)
	struct FPlayerCostumeSaveData                 Costume;                                           // 0x01C0(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FPlayerInventorySaveData               Inventory;                                         // 0x01C8(0x0AF0)(NativeAccessSpecifierPublic)
	class FName                                   RespawnRestPointID;                                // 0x0CB8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FName>                             ClearedEvents;                                     // 0x0CC0(0x0050)(NativeAccessSpecifierPublic)
	TSet<class FName>                             PreviousRunsClearedEvents;                         // 0x0D10(0x0050)(NativeAccessSpecifierPublic)
	TSet<struct FClearActorData>                  VisitedZones;                                      // 0x0D60(0x0050)(NativeAccessSpecifierPublic)
	TSet<class FName>                             VisitedAreas;                                      // 0x0DB0(0x0050)(NativeAccessSpecifierPublic)
	TSet<class FName>                             DisplayedAreaNames;                                // 0x0E00(0x0050)(NativeAccessSpecifierPublic)
	TSet<struct FMapTransitionSpawnPointData>     UsedMapTransitionSpawnPoints;                      // 0x0E50(0x0050)(NativeAccessSpecifierPublic)
	TArray<class FName>                           AvailableRestPointEvents;                          // 0x0EA0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ClearedRestPointEvents;                            // 0x0EB0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<class FName>                             CheckedRecollectionItems;                          // 0x0EC0(0x0050)(NativeAccessSpecifierPublic)
	TSet<class FName>                             KilledEnemies;                                     // 0x0F10(0x0050)(NativeAccessSpecifierPublic)
	struct FFogOfWarSaveData                      FogOfWarData;                                      // 0x0F60(0x0050)(NativeAccessSpecifierPublic)
	EWidgetMinimapDisplayMode                     MinimapDisplayMode;                                // 0x0FB0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB1[0x7];                                      // 0x0FB1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomMarkerSaveData                  CustomMarkerData;                                  // 0x0FB8(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSaveData) == 0x000008, "Wrong alignment on FPlayerSaveData");
static_assert(sizeof(FPlayerSaveData) == 0x001008, "Wrong size on FPlayerSaveData");
static_assert(offsetof(FPlayerSaveData, Stats) == 0x000000, "Member 'FPlayerSaveData::Stats' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, Skill) == 0x000008, "Member 'FPlayerSaveData::Skill' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, Equipment) == 0x000070, "Member 'FPlayerSaveData::Equipment' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, Assist) == 0x0000D8, "Member 'FPlayerSaveData::Assist' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, Passive) == 0x0000F8, "Member 'FPlayerSaveData::Passive' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, ShopInfo) == 0x000120, "Member 'FPlayerSaveData::ShopInfo' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, Costume) == 0x0001C0, "Member 'FPlayerSaveData::Costume' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, Inventory) == 0x0001C8, "Member 'FPlayerSaveData::Inventory' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, RespawnRestPointID) == 0x000CB8, "Member 'FPlayerSaveData::RespawnRestPointID' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, ClearedEvents) == 0x000CC0, "Member 'FPlayerSaveData::ClearedEvents' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, PreviousRunsClearedEvents) == 0x000D10, "Member 'FPlayerSaveData::PreviousRunsClearedEvents' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, VisitedZones) == 0x000D60, "Member 'FPlayerSaveData::VisitedZones' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, VisitedAreas) == 0x000DB0, "Member 'FPlayerSaveData::VisitedAreas' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, DisplayedAreaNames) == 0x000E00, "Member 'FPlayerSaveData::DisplayedAreaNames' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, UsedMapTransitionSpawnPoints) == 0x000E50, "Member 'FPlayerSaveData::UsedMapTransitionSpawnPoints' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, AvailableRestPointEvents) == 0x000EA0, "Member 'FPlayerSaveData::AvailableRestPointEvents' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, ClearedRestPointEvents) == 0x000EB0, "Member 'FPlayerSaveData::ClearedRestPointEvents' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, CheckedRecollectionItems) == 0x000EC0, "Member 'FPlayerSaveData::CheckedRecollectionItems' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, KilledEnemies) == 0x000F10, "Member 'FPlayerSaveData::KilledEnemies' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, FogOfWarData) == 0x000F60, "Member 'FPlayerSaveData::FogOfWarData' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, MinimapDisplayMode) == 0x000FB0, "Member 'FPlayerSaveData::MinimapDisplayMode' has a wrong offset!");
static_assert(offsetof(FPlayerSaveData, CustomMarkerData) == 0x000FB8, "Member 'FPlayerSaveData::CustomMarkerData' has a wrong offset!");

// ScriptStruct Zion.GameAchievementsData
// 0x0010 (0x0010 - 0x0000)
struct FGameAchievementsData final
{
public:
	TArray<class FName>                           GameAchievements;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameAchievementsData) == 0x000008, "Wrong alignment on FGameAchievementsData");
static_assert(sizeof(FGameAchievementsData) == 0x000010, "Wrong size on FGameAchievementsData");
static_assert(offsetof(FGameAchievementsData, GameAchievements) == 0x000000, "Member 'FGameAchievementsData::GameAchievements' has a wrong offset!");

// ScriptStruct Zion.UIInputSettingsData
// 0x0058 (0x0058 - 0x0000)
struct FUIInputSettingsData final
{
public:
	int32                                         Version;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EUIInputType, struct FUIBinding>         Bindings;                                          // 0x0008(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIInputSettingsData) == 0x000008, "Wrong alignment on FUIInputSettingsData");
static_assert(sizeof(FUIInputSettingsData) == 0x000058, "Wrong size on FUIInputSettingsData");
static_assert(offsetof(FUIInputSettingsData, Version) == 0x000000, "Member 'FUIInputSettingsData::Version' has a wrong offset!");
static_assert(offsetof(FUIInputSettingsData, Bindings) == 0x000008, "Member 'FUIInputSettingsData::Bindings' has a wrong offset!");

// ScriptStruct Zion.InputSettingsData
// 0x0078 (0x0078 - 0x0000)
struct FInputSettingsData final
{
public:
	struct FGameInputSettingsData                 GameInputSettingsData;                             // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	struct FUIInputSettingsData                   UIInputSettingsData;                               // 0x0018(0x0058)(NativeAccessSpecifierPublic)
	EInputStyle                                   InputStyleGamepadOverride;                         // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputSettingsData) == 0x000008, "Wrong alignment on FInputSettingsData");
static_assert(sizeof(FInputSettingsData) == 0x000078, "Wrong size on FInputSettingsData");
static_assert(offsetof(FInputSettingsData, GameInputSettingsData) == 0x000000, "Member 'FInputSettingsData::GameInputSettingsData' has a wrong offset!");
static_assert(offsetof(FInputSettingsData, UIInputSettingsData) == 0x000018, "Member 'FInputSettingsData::UIInputSettingsData' has a wrong offset!");
static_assert(offsetof(FInputSettingsData, InputStyleGamepadOverride) == 0x000070, "Member 'FInputSettingsData::InputStyleGamepadOverride' has a wrong offset!");

// ScriptStruct Zion.SoundSettingsData
// 0x0060 (0x0060 - 0x0000)
struct FSoundSettingsData final
{
public:
	TMap<ESoundFamily, float>                     Volumes;                                           // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	class FString                                 VoiceLanguage;                                     // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundSettingsData) == 0x000008, "Wrong alignment on FSoundSettingsData");
static_assert(sizeof(FSoundSettingsData) == 0x000060, "Wrong size on FSoundSettingsData");
static_assert(offsetof(FSoundSettingsData, Volumes) == 0x000000, "Member 'FSoundSettingsData::Volumes' has a wrong offset!");
static_assert(offsetof(FSoundSettingsData, VoiceLanguage) == 0x000050, "Member 'FSoundSettingsData::VoiceLanguage' has a wrong offset!");

// ScriptStruct Zion.GameSettingsData
// 0x0058 (0x0058 - 0x0000)
struct FGameSettingsData final
{
public:
	bool                                          bInitialSettingsDone;                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoUploadCrashReport;                            // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Gamma;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResolutionScale;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Language;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayDamageValues;                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayHealValues;                                // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayHPAboveGauge;                              // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ControllerVibration;                               // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShake;                                       // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraOscillation;                                // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldDownToDodgeStill;                             // 0x002D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAutoClimbDirectionMode                       AutoClimbDirectionMode;                            // 0x002E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayPlayerUI;                                  // 0x002F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayEnemyGauges;                               // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayTutorials;                                 // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSkipAlreadySeenEvents;                        // 0x0032(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayAchievementNotifications;                  // 0x0033(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConstraintCameraAspectRatio                  ConstraintCameraAspectRatio;                       // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAntiAliasingMethod                           AntiAliasingMethod;                                // 0x0035(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConstraintCameraAspectRatio                  UIAspectRatio;                                     // 0x0036(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConstraintHUDAspectRatio;                         // 0x0037(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftStickDeadZone;                                 // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightStickDeadZone;                                // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EGameEndingType>                       ReachedGameEndings;                                // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EGameEndingType                               TitleScreenType;                                   // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowHPFeedbackOpacity;                              // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameSettingsData) == 0x000008, "Wrong alignment on FGameSettingsData");
static_assert(sizeof(FGameSettingsData) == 0x000058, "Wrong size on FGameSettingsData");
static_assert(offsetof(FGameSettingsData, bInitialSettingsDone) == 0x000000, "Member 'FGameSettingsData::bInitialSettingsDone' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, bAutoUploadCrashReport) == 0x000001, "Member 'FGameSettingsData::bAutoUploadCrashReport' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, Gamma) == 0x000004, "Member 'FGameSettingsData::Gamma' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, ResolutionScale) == 0x000008, "Member 'FGameSettingsData::ResolutionScale' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, Language) == 0x000010, "Member 'FGameSettingsData::Language' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, bDisplayDamageValues) == 0x000020, "Member 'FGameSettingsData::bDisplayDamageValues' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, bDisplayHealValues) == 0x000021, "Member 'FGameSettingsData::bDisplayHealValues' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, bDisplayHPAboveGauge) == 0x000022, "Member 'FGameSettingsData::bDisplayHPAboveGauge' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, ControllerVibration) == 0x000024, "Member 'FGameSettingsData::ControllerVibration' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, CameraShake) == 0x000028, "Member 'FGameSettingsData::CameraShake' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, bCameraOscillation) == 0x00002C, "Member 'FGameSettingsData::bCameraOscillation' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, bHoldDownToDodgeStill) == 0x00002D, "Member 'FGameSettingsData::bHoldDownToDodgeStill' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, AutoClimbDirectionMode) == 0x00002E, "Member 'FGameSettingsData::AutoClimbDirectionMode' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, bDisplayPlayerUI) == 0x00002F, "Member 'FGameSettingsData::bDisplayPlayerUI' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, bDisplayEnemyGauges) == 0x000030, "Member 'FGameSettingsData::bDisplayEnemyGauges' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, bDisplayTutorials) == 0x000031, "Member 'FGameSettingsData::bDisplayTutorials' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, bAutoSkipAlreadySeenEvents) == 0x000032, "Member 'FGameSettingsData::bAutoSkipAlreadySeenEvents' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, bDisplayAchievementNotifications) == 0x000033, "Member 'FGameSettingsData::bDisplayAchievementNotifications' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, ConstraintCameraAspectRatio) == 0x000034, "Member 'FGameSettingsData::ConstraintCameraAspectRatio' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, AntiAliasingMethod) == 0x000035, "Member 'FGameSettingsData::AntiAliasingMethod' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, UIAspectRatio) == 0x000036, "Member 'FGameSettingsData::UIAspectRatio' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, bConstraintHUDAspectRatio) == 0x000037, "Member 'FGameSettingsData::bConstraintHUDAspectRatio' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, LeftStickDeadZone) == 0x000038, "Member 'FGameSettingsData::LeftStickDeadZone' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, RightStickDeadZone) == 0x00003C, "Member 'FGameSettingsData::RightStickDeadZone' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, ReachedGameEndings) == 0x000040, "Member 'FGameSettingsData::ReachedGameEndings' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, TitleScreenType) == 0x000050, "Member 'FGameSettingsData::TitleScreenType' has a wrong offset!");
static_assert(offsetof(FGameSettingsData, LowHPFeedbackOpacity) == 0x000054, "Member 'FGameSettingsData::LowHPFeedbackOpacity' has a wrong offset!");

// ScriptStruct Zion.ShakeData
// 0x0030 (0x0030 - 0x0000)
struct FShakeData final
{
public:
	float                                         OscillationDuration;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OscillationBlendInTime;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OscillationBlendOutTime;                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVOscillator                           LocOscillation;                                    // 0x000C(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShakeData) == 0x000004, "Wrong alignment on FShakeData");
static_assert(sizeof(FShakeData) == 0x000030, "Wrong size on FShakeData");
static_assert(offsetof(FShakeData, OscillationDuration) == 0x000000, "Member 'FShakeData::OscillationDuration' has a wrong offset!");
static_assert(offsetof(FShakeData, OscillationBlendInTime) == 0x000004, "Member 'FShakeData::OscillationBlendInTime' has a wrong offset!");
static_assert(offsetof(FShakeData, OscillationBlendOutTime) == 0x000008, "Member 'FShakeData::OscillationBlendOutTime' has a wrong offset!");
static_assert(offsetof(FShakeData, LocOscillation) == 0x00000C, "Member 'FShakeData::LocOscillation' has a wrong offset!");

// ScriptStruct Zion.ShopItemData
// 0x0020 (0x0020 - 0x0000)
struct FShopItemData final
{
public:
	struct FDataTableRowHandle                    Item;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         StockCount;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewGamePlusOnly;                                  // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNew;                                              // 0x0015(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0xA];                                       // 0x0016(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShopItemData) == 0x000008, "Wrong alignment on FShopItemData");
static_assert(sizeof(FShopItemData) == 0x000020, "Wrong size on FShopItemData");
static_assert(offsetof(FShopItemData, Item) == 0x000000, "Member 'FShopItemData::Item' has a wrong offset!");
static_assert(offsetof(FShopItemData, StockCount) == 0x000010, "Member 'FShopItemData::StockCount' has a wrong offset!");
static_assert(offsetof(FShopItemData, bNewGamePlusOnly) == 0x000014, "Member 'FShopItemData::bNewGamePlusOnly' has a wrong offset!");
static_assert(offsetof(FShopItemData, bNew) == 0x000015, "Member 'FShopItemData::bNew' has a wrong offset!");

// ScriptStruct Zion.LeveledShopData
// 0x0010 (0x0018 - 0x0008)
struct FLeveledShopData final : public FTableRowBase
{
public:
	TArray<struct FShopItemData>                  Items;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeveledShopData) == 0x000008, "Wrong alignment on FLeveledShopData");
static_assert(sizeof(FLeveledShopData) == 0x000018, "Wrong size on FLeveledShopData");
static_assert(offsetof(FLeveledShopData, Items) == 0x000008, "Member 'FLeveledShopData::Items' has a wrong offset!");

// ScriptStruct Zion.InputActions
// 0x0010 (0x0010 - 0x0000)
struct FInputActions final
{
public:
	class UInputAction*                           InputAction;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputAction*                           SpecialInputAction;                                // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputActions) == 0x000008, "Wrong alignment on FInputActions");
static_assert(sizeof(FInputActions) == 0x000010, "Wrong size on FInputActions");
static_assert(offsetof(FInputActions, InputAction) == 0x000000, "Member 'FInputActions::InputAction' has a wrong offset!");
static_assert(offsetof(FInputActions, SpecialInputAction) == 0x000008, "Member 'FInputActions::SpecialInputAction' has a wrong offset!");

// ScriptStruct Zion.EquippedSkillData
// 0x0390 (0x0390 - 0x0000)
struct FEquippedSkillData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommandSet*                            CommandSet;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCommandSet*                            SpecialCommandSet;                                 // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x370];                                     // 0x0020(0x0370)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEquippedSkillData) == 0x000008, "Wrong alignment on FEquippedSkillData");
static_assert(sizeof(FEquippedSkillData) == 0x000390, "Wrong size on FEquippedSkillData");
static_assert(offsetof(FEquippedSkillData, CommandSet) == 0x000010, "Member 'FEquippedSkillData::CommandSet' has a wrong offset!");
static_assert(offsetof(FEquippedSkillData, SpecialCommandSet) == 0x000018, "Member 'FEquippedSkillData::SpecialCommandSet' has a wrong offset!");

// ScriptStruct Zion.SkillData
// 0x0058 (0x0058 - 0x0000)
struct FSkillData final
{
public:
	int32                                         Rank;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RatingPower;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RatingBreak;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RatingSpeed;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RatingRange;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackType                                   Type;                                              // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackElement                                Element;                                           // 0x0015(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCommandSet>             CommandSet;                                        // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommandSetCategory                           Category;                                          // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostSP;                                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlatformMediaSource*                   Video;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillData) == 0x000008, "Wrong alignment on FSkillData");
static_assert(sizeof(FSkillData) == 0x000058, "Wrong size on FSkillData");
static_assert(offsetof(FSkillData, Rank) == 0x000000, "Member 'FSkillData::Rank' has a wrong offset!");
static_assert(offsetof(FSkillData, RatingPower) == 0x000004, "Member 'FSkillData::RatingPower' has a wrong offset!");
static_assert(offsetof(FSkillData, RatingBreak) == 0x000008, "Member 'FSkillData::RatingBreak' has a wrong offset!");
static_assert(offsetof(FSkillData, RatingSpeed) == 0x00000C, "Member 'FSkillData::RatingSpeed' has a wrong offset!");
static_assert(offsetof(FSkillData, RatingRange) == 0x000010, "Member 'FSkillData::RatingRange' has a wrong offset!");
static_assert(offsetof(FSkillData, Type) == 0x000014, "Member 'FSkillData::Type' has a wrong offset!");
static_assert(offsetof(FSkillData, Element) == 0x000015, "Member 'FSkillData::Element' has a wrong offset!");
static_assert(offsetof(FSkillData, CommandSet) == 0x000018, "Member 'FSkillData::CommandSet' has a wrong offset!");
static_assert(offsetof(FSkillData, Category) == 0x000040, "Member 'FSkillData::Category' has a wrong offset!");
static_assert(offsetof(FSkillData, Cooldown) == 0x000044, "Member 'FSkillData::Cooldown' has a wrong offset!");
static_assert(offsetof(FSkillData, CostSP) == 0x000048, "Member 'FSkillData::CostSP' has a wrong offset!");
static_assert(offsetof(FSkillData, Video) == 0x000050, "Member 'FSkillData::Video' has a wrong offset!");

// ScriptStruct Zion.SkillMaterialData
// 0x0018 (0x0018 - 0x0000)
struct FSkillMaterialData final
{
public:
	struct FDataTableRowHandle                    Item;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillMaterialData) == 0x000008, "Wrong alignment on FSkillMaterialData");
static_assert(sizeof(FSkillMaterialData) == 0x000018, "Wrong size on FSkillMaterialData");
static_assert(offsetof(FSkillMaterialData, Item) == 0x000000, "Member 'FSkillMaterialData::Item' has a wrong offset!");
static_assert(offsetof(FSkillMaterialData, Count) == 0x000010, "Member 'FSkillMaterialData::Count' has a wrong offset!");

// ScriptStruct Zion.SkillLevelData
// 0x00E0 (0x00E8 - 0x0008)
struct FSkillLevelData final : public FTableRowBase
{
public:
	struct FSkillData                             SkillData;                                         // 0x0008(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSkillData                             SpecialSkillData;                                  // 0x0060(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSkillMaterialData>             UnlockMaterials;                                   // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FInventoryItemUpgradeInfo>      UnlockInfos;                                       // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FInventoryItemUpgradeInfo>      UnlockSpecialInfos;                                // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillLevelData) == 0x000008, "Wrong alignment on FSkillLevelData");
static_assert(sizeof(FSkillLevelData) == 0x0000E8, "Wrong size on FSkillLevelData");
static_assert(offsetof(FSkillLevelData, SkillData) == 0x000008, "Member 'FSkillLevelData::SkillData' has a wrong offset!");
static_assert(offsetof(FSkillLevelData, SpecialSkillData) == 0x000060, "Member 'FSkillLevelData::SpecialSkillData' has a wrong offset!");
static_assert(offsetof(FSkillLevelData, UnlockMaterials) == 0x0000B8, "Member 'FSkillLevelData::UnlockMaterials' has a wrong offset!");
static_assert(offsetof(FSkillLevelData, UnlockInfos) == 0x0000C8, "Member 'FSkillLevelData::UnlockInfos' has a wrong offset!");
static_assert(offsetof(FSkillLevelData, UnlockSpecialInfos) == 0x0000D8, "Member 'FSkillLevelData::UnlockSpecialInfos' has a wrong offset!");

// ScriptStruct Zion.AudioVolumeSettings
// 0x0028 (0x0028 - 0x0000)
struct FAudioVolumeSettings final
{
public:
	bool                                          bOverrideBGM;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             BGM;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAmbience;                                 // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             Ambience;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideRestPointProximity;                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestPointProximity;                               // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAudioVolumeSettings) == 0x000008, "Wrong alignment on FAudioVolumeSettings");
static_assert(sizeof(FAudioVolumeSettings) == 0x000028, "Wrong size on FAudioVolumeSettings");
static_assert(offsetof(FAudioVolumeSettings, bOverrideBGM) == 0x000000, "Member 'FAudioVolumeSettings::bOverrideBGM' has a wrong offset!");
static_assert(offsetof(FAudioVolumeSettings, BGM) == 0x000008, "Member 'FAudioVolumeSettings::BGM' has a wrong offset!");
static_assert(offsetof(FAudioVolumeSettings, bOverrideAmbience) == 0x000010, "Member 'FAudioVolumeSettings::bOverrideAmbience' has a wrong offset!");
static_assert(offsetof(FAudioVolumeSettings, Ambience) == 0x000018, "Member 'FAudioVolumeSettings::Ambience' has a wrong offset!");
static_assert(offsetof(FAudioVolumeSettings, bOverrideRestPointProximity) == 0x000020, "Member 'FAudioVolumeSettings::bOverrideRestPointProximity' has a wrong offset!");
static_assert(offsetof(FAudioVolumeSettings, bRestPointProximity) == 0x000021, "Member 'FAudioVolumeSettings::bRestPointProximity' has a wrong offset!");

// ScriptStruct Zion.SpawnData
// 0x0090 (0x0090 - 0x0000)
struct FSpawnData final
{
public:
	struct FDataTableRowHandle                    EntityRowHandle;                                   // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	ESpineBone                                    SpawnBone;                                         // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpawnBoneCustomName;                               // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpineBoneRotationMode                        RotationMode;                                      // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalSpaceOffset;                                  // 0x0030(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnData) == 0x000010, "Wrong alignment on FSpawnData");
static_assert(sizeof(FSpawnData) == 0x000090, "Wrong size on FSpawnData");
static_assert(offsetof(FSpawnData, EntityRowHandle) == 0x000000, "Member 'FSpawnData::EntityRowHandle' has a wrong offset!");
static_assert(offsetof(FSpawnData, CommandClasses) == 0x000010, "Member 'FSpawnData::CommandClasses' has a wrong offset!");
static_assert(offsetof(FSpawnData, SpawnBone) == 0x000020, "Member 'FSpawnData::SpawnBone' has a wrong offset!");
static_assert(offsetof(FSpawnData, SpawnBoneCustomName) == 0x000024, "Member 'FSpawnData::SpawnBoneCustomName' has a wrong offset!");
static_assert(offsetof(FSpawnData, RotationMode) == 0x00002C, "Member 'FSpawnData::RotationMode' has a wrong offset!");
static_assert(offsetof(FSpawnData, LocalSpaceOffset) == 0x000030, "Member 'FSpawnData::LocalSpaceOffset' has a wrong offset!");

// ScriptStruct Zion.SpineAdditiveAccessorySettings
// 0x0190 (0x0190 - 0x0000)
struct FSpineAdditiveAccessorySettings final
{
public:
	class FString                                 AdditiveAnimationShowName;                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AdditiveAnimationHideName;                         // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditiveTrackIndex;                                // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayBeforeHide;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FName>                             TriggerAnimations;                                 // 0x0028(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           HideFXData;                                        // 0x0080(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EAptitudeType                                 NecessaryAptitude;                                 // 0x0180(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0xF];                                      // 0x0181(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpineAdditiveAccessorySettings) == 0x000010, "Wrong alignment on FSpineAdditiveAccessorySettings");
static_assert(sizeof(FSpineAdditiveAccessorySettings) == 0x000190, "Wrong size on FSpineAdditiveAccessorySettings");
static_assert(offsetof(FSpineAdditiveAccessorySettings, AdditiveAnimationShowName) == 0x000000, "Member 'FSpineAdditiveAccessorySettings::AdditiveAnimationShowName' has a wrong offset!");
static_assert(offsetof(FSpineAdditiveAccessorySettings, AdditiveAnimationHideName) == 0x000010, "Member 'FSpineAdditiveAccessorySettings::AdditiveAnimationHideName' has a wrong offset!");
static_assert(offsetof(FSpineAdditiveAccessorySettings, AdditiveTrackIndex) == 0x000020, "Member 'FSpineAdditiveAccessorySettings::AdditiveTrackIndex' has a wrong offset!");
static_assert(offsetof(FSpineAdditiveAccessorySettings, DelayBeforeHide) == 0x000024, "Member 'FSpineAdditiveAccessorySettings::DelayBeforeHide' has a wrong offset!");
static_assert(offsetof(FSpineAdditiveAccessorySettings, TriggerAnimations) == 0x000028, "Member 'FSpineAdditiveAccessorySettings::TriggerAnimations' has a wrong offset!");
static_assert(offsetof(FSpineAdditiveAccessorySettings, HideFXData) == 0x000080, "Member 'FSpineAdditiveAccessorySettings::HideFXData' has a wrong offset!");
static_assert(offsetof(FSpineAdditiveAccessorySettings, NecessaryAptitude) == 0x000180, "Member 'FSpineAdditiveAccessorySettings::NecessaryAptitude' has a wrong offset!");

// ScriptStruct Zion.SpineAdditiveSettings
// 0x0068 (0x0068 - 0x0000)
struct FSpineAdditiveSettings final
{
public:
	class FString                                 AdditiveAnimationName;                             // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditiveTrackIndex;                                // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FString>                           AllowedOverrideAnimations;                         // 0x0018(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpineAdditiveSettings) == 0x000008, "Wrong alignment on FSpineAdditiveSettings");
static_assert(sizeof(FSpineAdditiveSettings) == 0x000068, "Wrong size on FSpineAdditiveSettings");
static_assert(offsetof(FSpineAdditiveSettings, AdditiveAnimationName) == 0x000000, "Member 'FSpineAdditiveSettings::AdditiveAnimationName' has a wrong offset!");
static_assert(offsetof(FSpineAdditiveSettings, AdditiveTrackIndex) == 0x000010, "Member 'FSpineAdditiveSettings::AdditiveTrackIndex' has a wrong offset!");
static_assert(offsetof(FSpineAdditiveSettings, AllowedOverrideAnimations) == 0x000018, "Member 'FSpineAdditiveSettings::AllowedOverrideAnimations' has a wrong offset!");

// ScriptStruct Zion.SpineAnimationStaggerDefinitions
// 0x0020 (0x0020 - 0x0000)
struct FSpineAnimationStaggerDefinitions final
{
public:
	TArray<struct FSpineAnimationDefinition>      Stagger;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FSpineAnimationDefinition>      Recovery;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpineAnimationStaggerDefinitions) == 0x000008, "Wrong alignment on FSpineAnimationStaggerDefinitions");
static_assert(sizeof(FSpineAnimationStaggerDefinitions) == 0x000020, "Wrong size on FSpineAnimationStaggerDefinitions");
static_assert(offsetof(FSpineAnimationStaggerDefinitions, Stagger) == 0x000000, "Member 'FSpineAnimationStaggerDefinitions::Stagger' has a wrong offset!");
static_assert(offsetof(FSpineAnimationStaggerDefinitions, Recovery) == 0x000010, "Member 'FSpineAnimationStaggerDefinitions::Recovery' has a wrong offset!");

// ScriptStruct Zion.SpineAnimationTransitionDefinition
// 0x0040 (0x0040 - 0x0000)
struct FSpineAnimationTransitionDefinition final
{
public:
	class FString                                 From;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 To;                                                // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USpineAnimationTransitionCondition*> Conditions;                                    // 0x0020(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FSpineAnimationDefinition>      AnimationDefinitions;                              // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpineAnimationTransitionDefinition) == 0x000008, "Wrong alignment on FSpineAnimationTransitionDefinition");
static_assert(sizeof(FSpineAnimationTransitionDefinition) == 0x000040, "Wrong size on FSpineAnimationTransitionDefinition");
static_assert(offsetof(FSpineAnimationTransitionDefinition, From) == 0x000000, "Member 'FSpineAnimationTransitionDefinition::From' has a wrong offset!");
static_assert(offsetof(FSpineAnimationTransitionDefinition, To) == 0x000010, "Member 'FSpineAnimationTransitionDefinition::To' has a wrong offset!");
static_assert(offsetof(FSpineAnimationTransitionDefinition, Conditions) == 0x000020, "Member 'FSpineAnimationTransitionDefinition::Conditions' has a wrong offset!");
static_assert(offsetof(FSpineAnimationTransitionDefinition, AnimationDefinitions) == 0x000030, "Member 'FSpineAnimationTransitionDefinition::AnimationDefinitions' has a wrong offset!");

// ScriptStruct Zion.SpineAnimatorHistoryData
// 0x0018 (0x0018 - 0x0000)
struct FSpineAnimatorHistoryData final
{
public:
	class FString                                 AnimationName;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayedDuration;                                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpineAnimatorHistoryData) == 0x000008, "Wrong alignment on FSpineAnimatorHistoryData");
static_assert(sizeof(FSpineAnimatorHistoryData) == 0x000018, "Wrong size on FSpineAnimatorHistoryData");
static_assert(offsetof(FSpineAnimatorHistoryData, AnimationName) == 0x000000, "Member 'FSpineAnimatorHistoryData::AnimationName' has a wrong offset!");
static_assert(offsetof(FSpineAnimatorHistoryData, PlayedDuration) == 0x000010, "Member 'FSpineAnimatorHistoryData::PlayedDuration' has a wrong offset!");

// ScriptStruct Zion.SpineFlashColorData
// 0x0018 (0x0018 - 0x0000)
struct FSpineFlashColorData final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartAlpha;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpineFlashColorData) == 0x000004, "Wrong alignment on FSpineFlashColorData");
static_assert(sizeof(FSpineFlashColorData) == 0x000018, "Wrong size on FSpineFlashColorData");
static_assert(offsetof(FSpineFlashColorData, Color) == 0x000000, "Member 'FSpineFlashColorData::Color' has a wrong offset!");
static_assert(offsetof(FSpineFlashColorData, StartAlpha) == 0x000010, "Member 'FSpineFlashColorData::StartAlpha' has a wrong offset!");
static_assert(offsetof(FSpineFlashColorData, Duration) == 0x000014, "Member 'FSpineFlashColorData::Duration' has a wrong offset!");

// ScriptStruct Zion.StepData
// 0x0130 (0x0130 - 0x0000)
struct FStepData final
{
public:
	struct FSpineFXData                           FXData;                                            // 0x0000(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoundData                             SoundData;                                         // 0x0100(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStepData) == 0x000010, "Wrong alignment on FStepData");
static_assert(sizeof(FStepData) == 0x000130, "Wrong size on FStepData");
static_assert(offsetof(FStepData, FXData) == 0x000000, "Member 'FStepData::FXData' has a wrong offset!");
static_assert(offsetof(FStepData, SoundData) == 0x000100, "Member 'FStepData::SoundData' has a wrong offset!");

// ScriptStruct Zion.SurfaceToStepMap
// 0x0050 (0x0050 - 0x0000)
struct FSurfaceToStepMap final
{
public:
	TMap<EPhysicalSurface, struct FStepData>      Surfaces;                                          // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurfaceToStepMap) == 0x000008, "Wrong alignment on FSurfaceToStepMap");
static_assert(sizeof(FSurfaceToStepMap) == 0x000050, "Wrong size on FSurfaceToStepMap");
static_assert(offsetof(FSurfaceToStepMap, Surfaces) == 0x000000, "Member 'FSurfaceToStepMap::Surfaces' has a wrong offset!");

// ScriptStruct Zion.SpeedModeToSurfaceMap
// 0x0050 (0x0050 - 0x0000)
struct FSpeedModeToSurfaceMap final
{
public:
	TMap<EMovementSpeedMode, struct FSurfaceToStepMap> SpeedModes;                                   // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpeedModeToSurfaceMap) == 0x000008, "Wrong alignment on FSpeedModeToSurfaceMap");
static_assert(sizeof(FSpeedModeToSurfaceMap) == 0x000050, "Wrong size on FSpeedModeToSurfaceMap");
static_assert(offsetof(FSpeedModeToSurfaceMap, SpeedModes) == 0x000000, "Member 'FSpeedModeToSurfaceMap::SpeedModes' has a wrong offset!");

// ScriptStruct Zion.AbilityDataList
// 0x0010 (0x0010 - 0x0000)
struct FAbilityDataList final
{
public:
	TArray<struct FAbilityData>                   Abilities;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityDataList) == 0x000008, "Wrong alignment on FAbilityDataList");
static_assert(sizeof(FAbilityDataList) == 0x000010, "Wrong size on FAbilityDataList");
static_assert(offsetof(FAbilityDataList, Abilities) == 0x000000, "Member 'FAbilityDataList::Abilities' has a wrong offset!");

// ScriptStruct Zion.SpiritRepeatSummonParameters
// 0x0088 (0x0088 - 0x0000)
struct FSpiritRepeatSummonParameters final
{
public:
	ESpiritRepeatAbilityUseType                   AbilityUseType;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityDataList                       Abilities;                                         // 0x0008(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EMovementMode, struct FAbilityDataList>  AbilitiesPerMovementMode;                          // 0x0018(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAbilityAdditionalData                 AbilityAdditionalData;                             // 0x0068(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOneShotAbilityMode;                               // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialDelay;                                      // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepeatTrigger;                                    // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopDelay;                                         // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpiritRepeatSummonParameters) == 0x000008, "Wrong alignment on FSpiritRepeatSummonParameters");
static_assert(sizeof(FSpiritRepeatSummonParameters) == 0x000088, "Wrong size on FSpiritRepeatSummonParameters");
static_assert(offsetof(FSpiritRepeatSummonParameters, AbilityUseType) == 0x000000, "Member 'FSpiritRepeatSummonParameters::AbilityUseType' has a wrong offset!");
static_assert(offsetof(FSpiritRepeatSummonParameters, Abilities) == 0x000008, "Member 'FSpiritRepeatSummonParameters::Abilities' has a wrong offset!");
static_assert(offsetof(FSpiritRepeatSummonParameters, AbilitiesPerMovementMode) == 0x000018, "Member 'FSpiritRepeatSummonParameters::AbilitiesPerMovementMode' has a wrong offset!");
static_assert(offsetof(FSpiritRepeatSummonParameters, AbilityAdditionalData) == 0x000068, "Member 'FSpiritRepeatSummonParameters::AbilityAdditionalData' has a wrong offset!");
static_assert(offsetof(FSpiritRepeatSummonParameters, bOneShotAbilityMode) == 0x000078, "Member 'FSpiritRepeatSummonParameters::bOneShotAbilityMode' has a wrong offset!");
static_assert(offsetof(FSpiritRepeatSummonParameters, InitialDelay) == 0x00007C, "Member 'FSpiritRepeatSummonParameters::InitialDelay' has a wrong offset!");
static_assert(offsetof(FSpiritRepeatSummonParameters, bRepeatTrigger) == 0x000080, "Member 'FSpiritRepeatSummonParameters::bRepeatTrigger' has a wrong offset!");
static_assert(offsetof(FSpiritRepeatSummonParameters, LoopDelay) == 0x000084, "Member 'FSpiritRepeatSummonParameters::LoopDelay' has a wrong offset!");

// ScriptStruct Zion.CommandClassList
// 0x0010 (0x0010 - 0x0000)
struct FCommandClassList final
{
public:
	TArray<TSubclassOf<class UCommand>>           List;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommandClassList) == 0x000008, "Wrong alignment on FCommandClassList");
static_assert(sizeof(FCommandClassList) == 0x000010, "Wrong size on FCommandClassList");
static_assert(offsetof(FCommandClassList, List) == 0x000000, "Member 'FCommandClassList::List' has a wrong offset!");

// ScriptStruct Zion.SpiritAutoSummonParameters
// 0x01A0 (0x01A0 - 0x0000)
struct FSpiritAutoSummonParameters final
{
public:
	ESpiritAutoType                               AutoType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIData                                AIData;                                            // 0x0008(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         DodgeMinDelay;                                     // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EMovementMode, struct FCommandClassList> CommandClassesPerMovementModes;                    // 0x00B0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocationFromSummoner;                        // 0x0100(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     MoveCurve;                                         // 0x0118(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpiritAutoSummonParameters) == 0x000008, "Wrong alignment on FSpiritAutoSummonParameters");
static_assert(sizeof(FSpiritAutoSummonParameters) == 0x0001A0, "Wrong size on FSpiritAutoSummonParameters");
static_assert(offsetof(FSpiritAutoSummonParameters, AutoType) == 0x000000, "Member 'FSpiritAutoSummonParameters::AutoType' has a wrong offset!");
static_assert(offsetof(FSpiritAutoSummonParameters, AIData) == 0x000008, "Member 'FSpiritAutoSummonParameters::AIData' has a wrong offset!");
static_assert(offsetof(FSpiritAutoSummonParameters, DodgeMinDelay) == 0x000098, "Member 'FSpiritAutoSummonParameters::DodgeMinDelay' has a wrong offset!");
static_assert(offsetof(FSpiritAutoSummonParameters, CommandClasses) == 0x0000A0, "Member 'FSpiritAutoSummonParameters::CommandClasses' has a wrong offset!");
static_assert(offsetof(FSpiritAutoSummonParameters, CommandClassesPerMovementModes) == 0x0000B0, "Member 'FSpiritAutoSummonParameters::CommandClassesPerMovementModes' has a wrong offset!");
static_assert(offsetof(FSpiritAutoSummonParameters, TargetLocationFromSummoner) == 0x000100, "Member 'FSpiritAutoSummonParameters::TargetLocationFromSummoner' has a wrong offset!");
static_assert(offsetof(FSpiritAutoSummonParameters, MoveCurve) == 0x000118, "Member 'FSpiritAutoSummonParameters::MoveCurve' has a wrong offset!");

// ScriptStruct Zion.SpiritTurretSummonParameters
// 0x0040 (0x0040 - 0x0000)
struct FSpiritTurretSummonParameters final
{
public:
	TArray<TSubclassOf<class UCommand>>           InitialCommandClasses;                             // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCommand>>           AttackCommandClasses;                              // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCommand>>           IdleCommandClasses;                                // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         MaxSummonerDistanceForAttack;                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireSummonerLineOfSight;                       // 0x0034(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceForAutoDismiss;                            // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpiritTurretSummonParameters) == 0x000008, "Wrong alignment on FSpiritTurretSummonParameters");
static_assert(sizeof(FSpiritTurretSummonParameters) == 0x000040, "Wrong size on FSpiritTurretSummonParameters");
static_assert(offsetof(FSpiritTurretSummonParameters, InitialCommandClasses) == 0x000000, "Member 'FSpiritTurretSummonParameters::InitialCommandClasses' has a wrong offset!");
static_assert(offsetof(FSpiritTurretSummonParameters, AttackCommandClasses) == 0x000010, "Member 'FSpiritTurretSummonParameters::AttackCommandClasses' has a wrong offset!");
static_assert(offsetof(FSpiritTurretSummonParameters, IdleCommandClasses) == 0x000020, "Member 'FSpiritTurretSummonParameters::IdleCommandClasses' has a wrong offset!");
static_assert(offsetof(FSpiritTurretSummonParameters, MaxSummonerDistanceForAttack) == 0x000030, "Member 'FSpiritTurretSummonParameters::MaxSummonerDistanceForAttack' has a wrong offset!");
static_assert(offsetof(FSpiritTurretSummonParameters, bRequireSummonerLineOfSight) == 0x000034, "Member 'FSpiritTurretSummonParameters::bRequireSummonerLineOfSight' has a wrong offset!");
static_assert(offsetof(FSpiritTurretSummonParameters, DistanceForAutoDismiss) == 0x000038, "Member 'FSpiritTurretSummonParameters::DistanceForAutoDismiss' has a wrong offset!");

// ScriptStruct Zion.StatBreakableData
// 0x0014 (0x0014 - 0x0000)
struct FStatBreakableData final
{
public:
	int32                                         MaxValue;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayBeforeRecovery;                               // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryPerSecond;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrokenDuration;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostBreakInvincibilityTime;                        // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatBreakableData) == 0x000004, "Wrong alignment on FStatBreakableData");
static_assert(sizeof(FStatBreakableData) == 0x000014, "Wrong size on FStatBreakableData");
static_assert(offsetof(FStatBreakableData, MaxValue) == 0x000000, "Member 'FStatBreakableData::MaxValue' has a wrong offset!");
static_assert(offsetof(FStatBreakableData, DelayBeforeRecovery) == 0x000004, "Member 'FStatBreakableData::DelayBeforeRecovery' has a wrong offset!");
static_assert(offsetof(FStatBreakableData, RecoveryPerSecond) == 0x000008, "Member 'FStatBreakableData::RecoveryPerSecond' has a wrong offset!");
static_assert(offsetof(FStatBreakableData, BrokenDuration) == 0x00000C, "Member 'FStatBreakableData::BrokenDuration' has a wrong offset!");
static_assert(offsetof(FStatBreakableData, PostBreakInvincibilityTime) == 0x000010, "Member 'FStatBreakableData::PostBreakInvincibilityTime' has a wrong offset!");

// ScriptStruct Zion.StatBreakableMultiplicativeData
// 0x0014 (0x0014 - 0x0000)
struct FStatBreakableMultiplicativeData final
{
public:
	float                                         MaxValueFactor;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayBeforeRecoveryFactor;                         // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryPerSecondFactor;                           // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrokenDurationFactor;                              // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostBreakInvincibilityTimeFactor;                  // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatBreakableMultiplicativeData) == 0x000004, "Wrong alignment on FStatBreakableMultiplicativeData");
static_assert(sizeof(FStatBreakableMultiplicativeData) == 0x000014, "Wrong size on FStatBreakableMultiplicativeData");
static_assert(offsetof(FStatBreakableMultiplicativeData, MaxValueFactor) == 0x000000, "Member 'FStatBreakableMultiplicativeData::MaxValueFactor' has a wrong offset!");
static_assert(offsetof(FStatBreakableMultiplicativeData, DelayBeforeRecoveryFactor) == 0x000004, "Member 'FStatBreakableMultiplicativeData::DelayBeforeRecoveryFactor' has a wrong offset!");
static_assert(offsetof(FStatBreakableMultiplicativeData, RecoveryPerSecondFactor) == 0x000008, "Member 'FStatBreakableMultiplicativeData::RecoveryPerSecondFactor' has a wrong offset!");
static_assert(offsetof(FStatBreakableMultiplicativeData, BrokenDurationFactor) == 0x00000C, "Member 'FStatBreakableMultiplicativeData::BrokenDurationFactor' has a wrong offset!");
static_assert(offsetof(FStatBreakableMultiplicativeData, PostBreakInvincibilityTimeFactor) == 0x000010, "Member 'FStatBreakableMultiplicativeData::PostBreakInvincibilityTimeFactor' has a wrong offset!");

// ScriptStruct Zion.TimedStateData
// 0x0010 (0x0010 - 0x0000)
struct FTimedStateData
{
public:
	TArray<TSubclassOf<class UState>>             States;                                            // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTimedStateData) == 0x000008, "Wrong alignment on FTimedStateData");
static_assert(sizeof(FTimedStateData) == 0x000010, "Wrong size on FTimedStateData");
static_assert(offsetof(FTimedStateData, States) == 0x000000, "Member 'FTimedStateData::States' has a wrong offset!");

// ScriptStruct Zion.TimedStateData_Time
// 0x0008 (0x0018 - 0x0010)
struct FTimedStateData_Time final : public FTimedStateData
{
public:
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimedStateData_Time) == 0x000008, "Wrong alignment on FTimedStateData_Time");
static_assert(sizeof(FTimedStateData_Time) == 0x000018, "Wrong size on FTimedStateData_Time");

// ScriptStruct Zion.TimedStateData_Frame
// 0x0008 (0x0018 - 0x0010)
struct FTimedStateData_Frame final : public FTimedStateData
{
public:
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimedStateData_Frame) == 0x000008, "Wrong alignment on FTimedStateData_Frame");
static_assert(sizeof(FTimedStateData_Frame) == 0x000018, "Wrong size on FTimedStateData_Frame");

// ScriptStruct Zion.NiagaraComponentList
// 0x0010 (0x0010 - 0x0000)
struct FNiagaraComponentList final
{
public:
	TArray<class UNiagaraComponent*>              List;                                              // 0x0000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNiagaraComponentList) == 0x000008, "Wrong alignment on FNiagaraComponentList");
static_assert(sizeof(FNiagaraComponentList) == 0x000010, "Wrong size on FNiagaraComponentList");
static_assert(offsetof(FNiagaraComponentList, List) == 0x000000, "Member 'FNiagaraComponentList::List' has a wrong offset!");

// ScriptStruct Zion.EnemyStatsLevelData
// 0x0018 (0x0058 - 0x0040)
struct FEnemyStatsLevelData final : public FStatsLevelData
{
public:
	struct FDataTableRowHandle                    Drop;                                              // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ExperienceDrop;                                    // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyStatsLevelData) == 0x000008, "Wrong alignment on FEnemyStatsLevelData");
static_assert(sizeof(FEnemyStatsLevelData) == 0x000058, "Wrong size on FEnemyStatsLevelData");
static_assert(offsetof(FEnemyStatsLevelData, Drop) == 0x000040, "Member 'FEnemyStatsLevelData::Drop' has a wrong offset!");
static_assert(offsetof(FEnemyStatsLevelData, ExperienceDrop) == 0x000050, "Member 'FEnemyStatsLevelData::ExperienceDrop' has a wrong offset!");

// ScriptStruct Zion.PlayerStatsLevelData
// 0x0008 (0x0048 - 0x0040)
struct FPlayerStatsLevelData final : public FStatsLevelData
{
public:
	int32                                         ExpForLevelUp;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerStatsLevelData) == 0x000008, "Wrong alignment on FPlayerStatsLevelData");
static_assert(sizeof(FPlayerStatsLevelData) == 0x000048, "Wrong size on FPlayerStatsLevelData");
static_assert(offsetof(FPlayerStatsLevelData, ExpForLevelUp) == 0x000040, "Member 'FPlayerStatsLevelData::ExpForLevelUp' has a wrong offset!");

// ScriptStruct Zion.StatusEffectList
// 0x0010 (0x0010 - 0x0000)
struct FStatusEffectList final
{
public:
	TArray<class UStatusEffect*>                  StatusEffects;                                     // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusEffectList) == 0x000008, "Wrong alignment on FStatusEffectList");
static_assert(sizeof(FStatusEffectList) == 0x000010, "Wrong size on FStatusEffectList");
static_assert(offsetof(FStatusEffectList, StatusEffects) == 0x000000, "Member 'FStatusEffectList::StatusEffects' has a wrong offset!");

// ScriptStruct Zion.StoryLevelData
// 0x0048 (0x0050 - 0x0008)
struct FStoryLevelData final : public FTableRowBase
{
public:
	bool                                          bEnabled;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   GoalDescription;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        StoryEventWorldLocations;                          // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UEventAsset>>     NecessaryEvents;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UEventAsset>>     ProgressionEvents;                                 // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoryLevelData) == 0x000008, "Wrong alignment on FStoryLevelData");
static_assert(sizeof(FStoryLevelData) == 0x000050, "Wrong size on FStoryLevelData");
static_assert(offsetof(FStoryLevelData, bEnabled) == 0x000008, "Member 'FStoryLevelData::bEnabled' has a wrong offset!");
static_assert(offsetof(FStoryLevelData, GoalDescription) == 0x000010, "Member 'FStoryLevelData::GoalDescription' has a wrong offset!");
static_assert(offsetof(FStoryLevelData, StoryEventWorldLocations) == 0x000020, "Member 'FStoryLevelData::StoryEventWorldLocations' has a wrong offset!");
static_assert(offsetof(FStoryLevelData, NecessaryEvents) == 0x000030, "Member 'FStoryLevelData::NecessaryEvents' has a wrong offset!");
static_assert(offsetof(FStoryLevelData, ProgressionEvents) == 0x000040, "Member 'FStoryLevelData::ProgressionEvents' has a wrong offset!");

// ScriptStruct Zion.LoadedIdleSpiritClass
// 0x0010 (0x0010 - 0x0000)
struct FLoadedIdleSpiritClass final
{
public:
	TSubclassOf<class ACharacterZionSpirit>       IdleSpiritClass;                                   // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACharacterZionSpirit>       AssociatedSpiritClass;                             // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadedIdleSpiritClass) == 0x000008, "Wrong alignment on FLoadedIdleSpiritClass");
static_assert(sizeof(FLoadedIdleSpiritClass) == 0x000010, "Wrong size on FLoadedIdleSpiritClass");
static_assert(offsetof(FLoadedIdleSpiritClass, IdleSpiritClass) == 0x000000, "Member 'FLoadedIdleSpiritClass::IdleSpiritClass' has a wrong offset!");
static_assert(offsetof(FLoadedIdleSpiritClass, AssociatedSpiritClass) == 0x000008, "Member 'FLoadedIdleSpiritClass::AssociatedSpiritClass' has a wrong offset!");

// ScriptStruct Zion.SummonedIdleSpiritData
// 0x0024 (0x0024 - 0x0000)
struct FSummonedIdleSpiritData final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ACharacterZionSpirit>    Spirit;                                            // 0x001C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSummonedIdleSpiritData) == 0x000004, "Wrong alignment on FSummonedIdleSpiritData");
static_assert(sizeof(FSummonedIdleSpiritData) == 0x000024, "Wrong size on FSummonedIdleSpiritData");
static_assert(offsetof(FSummonedIdleSpiritData, Spirit) == 0x00001C, "Member 'FSummonedIdleSpiritData::Spirit' has a wrong offset!");

// ScriptStruct Zion.AptitudeArray
// 0x0020 (0x0020 - 0x0000)
struct FAptitudeArray final
{
public:
	TArray<EAptitudeType>                         AllowedAptitudes;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EAptitudeType>                         NotAllowedAptitudes;                               // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAptitudeArray) == 0x000008, "Wrong alignment on FAptitudeArray");
static_assert(sizeof(FAptitudeArray) == 0x000020, "Wrong size on FAptitudeArray");
static_assert(offsetof(FAptitudeArray, AllowedAptitudes) == 0x000000, "Member 'FAptitudeArray::AllowedAptitudes' has a wrong offset!");
static_assert(offsetof(FAptitudeArray, NotAllowedAptitudes) == 0x000010, "Member 'FAptitudeArray::NotAllowedAptitudes' has a wrong offset!");

// ScriptStruct Zion.TalkLocationData
// 0x0068 (0x0068 - 0x0000)
struct FTalkLocationData final
{
public:
	struct FVector                                DefaultTalkOffset;                                 // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FVector>           TalkOffsetPerAnimations;                           // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkLocationData) == 0x000008, "Wrong alignment on FTalkLocationData");
static_assert(sizeof(FTalkLocationData) == 0x000068, "Wrong size on FTalkLocationData");
static_assert(offsetof(FTalkLocationData, DefaultTalkOffset) == 0x000000, "Member 'FTalkLocationData::DefaultTalkOffset' has a wrong offset!");
static_assert(offsetof(FTalkLocationData, TalkOffsetPerAnimations) == 0x000018, "Member 'FTalkLocationData::TalkOffsetPerAnimations' has a wrong offset!");

// ScriptStruct Zion.TimelineEntry
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FTimelineEntry
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETimelineEntryActiveType                      ActiveType;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndTime;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimelineEntry) == 0x000008, "Wrong alignment on FTimelineEntry");
static_assert(sizeof(FTimelineEntry) == 0x000018, "Wrong size on FTimelineEntry");
static_assert(offsetof(FTimelineEntry, ActiveType) == 0x000008, "Member 'FTimelineEntry::ActiveType' has a wrong offset!");
static_assert(offsetof(FTimelineEntry, StartTime) == 0x00000C, "Member 'FTimelineEntry::StartTime' has a wrong offset!");
static_assert(offsetof(FTimelineEntry, EndTime) == 0x000010, "Member 'FTimelineEntry::EndTime' has a wrong offset!");

// ScriptStruct Zion.TimelineBase
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FTimelineBase
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimelineBase) == 0x000008, "Wrong alignment on FTimelineBase");
static_assert(sizeof(FTimelineBase) == 0x000018, "Wrong size on FTimelineBase");

// ScriptStruct Zion.TimelineEntry_Ability
// 0x00F8 (0x0110 - 0x0018)
struct FTimelineEntry_Ability final : public FTimelineEntry
{
public:
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityData                           AbilityData;                                       // 0x0020(0x00E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class AAbility*                               AbilityInstance;                                   // 0x0100(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimelineEntry_Ability) == 0x000010, "Wrong alignment on FTimelineEntry_Ability");
static_assert(sizeof(FTimelineEntry_Ability) == 0x000110, "Wrong size on FTimelineEntry_Ability");
static_assert(offsetof(FTimelineEntry_Ability, AbilityData) == 0x000020, "Member 'FTimelineEntry_Ability::AbilityData' has a wrong offset!");
static_assert(offsetof(FTimelineEntry_Ability, AbilityInstance) == 0x000100, "Member 'FTimelineEntry_Ability::AbilityInstance' has a wrong offset!");

// ScriptStruct Zion.AbilityVisualCue
// 0x0120 (0x0120 - 0x0000)
struct FAbilityVisualCue final
{
public:
	bool                                          bUseVisualCue;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideLeadTime;                                 // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeadTimeOverride;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideFX;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           FXOverride;                                        // 0x0010(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityVisualCue) == 0x000010, "Wrong alignment on FAbilityVisualCue");
static_assert(sizeof(FAbilityVisualCue) == 0x000120, "Wrong size on FAbilityVisualCue");
static_assert(offsetof(FAbilityVisualCue, bUseVisualCue) == 0x000000, "Member 'FAbilityVisualCue::bUseVisualCue' has a wrong offset!");
static_assert(offsetof(FAbilityVisualCue, bOverrideLeadTime) == 0x000001, "Member 'FAbilityVisualCue::bOverrideLeadTime' has a wrong offset!");
static_assert(offsetof(FAbilityVisualCue, LeadTimeOverride) == 0x000004, "Member 'FAbilityVisualCue::LeadTimeOverride' has a wrong offset!");
static_assert(offsetof(FAbilityVisualCue, bOverrideFX) == 0x000008, "Member 'FAbilityVisualCue::bOverrideFX' has a wrong offset!");
static_assert(offsetof(FAbilityVisualCue, FXOverride) == 0x000010, "Member 'FAbilityVisualCue::FXOverride' has a wrong offset!");

// ScriptStruct Zion.TimelineAbility
// 0x01B8 (0x01D0 - 0x0018)
struct FTimelineAbility final : public FTimelineBase
{
public:
	uint8                                         Pad_18[0x68];                                      // 0x0018(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTimelineEntry_Ability>         Entries;                                           // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAbilityVisualCue                      VisualCueData;                                     // 0x0090(0x0120)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x20];                                     // 0x01B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimelineAbility) == 0x000010, "Wrong alignment on FTimelineAbility");
static_assert(sizeof(FTimelineAbility) == 0x0001D0, "Wrong size on FTimelineAbility");
static_assert(offsetof(FTimelineAbility, Entries) == 0x000080, "Member 'FTimelineAbility::Entries' has a wrong offset!");
static_assert(offsetof(FTimelineAbility, VisualCueData) == 0x000090, "Member 'FTimelineAbility::VisualCueData' has a wrong offset!");

// ScriptStruct Zion.TimelineEntry_FX
// 0x0118 (0x0130 - 0x0018)
struct FTimelineEntry_FX final : public FTimelineEntry
{
public:
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           FXData;                                            // 0x0020(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimelineEntry_FX) == 0x000010, "Wrong alignment on FTimelineEntry_FX");
static_assert(sizeof(FTimelineEntry_FX) == 0x000130, "Wrong size on FTimelineEntry_FX");
static_assert(offsetof(FTimelineEntry_FX, FXData) == 0x000020, "Member 'FTimelineEntry_FX::FXData' has a wrong offset!");

// ScriptStruct Zion.TimelineFX
// 0x0018 (0x0030 - 0x0018)
struct FTimelineFX final : public FTimelineBase
{
public:
	TArray<struct FTimelineEntry_FX>              Entries;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimelineFX) == 0x000008, "Wrong alignment on FTimelineFX");
static_assert(sizeof(FTimelineFX) == 0x000030, "Wrong size on FTimelineFX");
static_assert(offsetof(FTimelineFX, Entries) == 0x000018, "Member 'FTimelineFX::Entries' has a wrong offset!");

// ScriptStruct Zion.TimelineEntry_Move
// 0x0178 (0x0190 - 0x0018)
struct alignas(0x10) FTimelineEntry_Move final : public FTimelineEntry
{
public:
	ERootMotionAccumulateMode                     AccumulateMode;                                    // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MoveVelocity;                                      // 0x0020(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            MoveFactorCurve;                                   // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRootMotionFinishVelocitySettingsBP    FinishVelocitySettings;                            // 0x0040(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x128];                                     // 0x0068(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimelineEntry_Move) == 0x000010, "Wrong alignment on FTimelineEntry_Move");
static_assert(sizeof(FTimelineEntry_Move) == 0x000190, "Wrong size on FTimelineEntry_Move");
static_assert(offsetof(FTimelineEntry_Move, AccumulateMode) == 0x000018, "Member 'FTimelineEntry_Move::AccumulateMode' has a wrong offset!");
static_assert(offsetof(FTimelineEntry_Move, MoveVelocity) == 0x000020, "Member 'FTimelineEntry_Move::MoveVelocity' has a wrong offset!");
static_assert(offsetof(FTimelineEntry_Move, MoveFactorCurve) == 0x000038, "Member 'FTimelineEntry_Move::MoveFactorCurve' has a wrong offset!");
static_assert(offsetof(FTimelineEntry_Move, FinishVelocitySettings) == 0x000040, "Member 'FTimelineEntry_Move::FinishVelocitySettings' has a wrong offset!");

// ScriptStruct Zion.TimelineMove
// 0x0018 (0x0030 - 0x0018)
struct FTimelineMove final : public FTimelineBase
{
public:
	TArray<struct FTimelineEntry_Move>            Entries;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimelineMove) == 0x000008, "Wrong alignment on FTimelineMove");
static_assert(sizeof(FTimelineMove) == 0x000030, "Wrong size on FTimelineMove");
static_assert(offsetof(FTimelineMove, Entries) == 0x000018, "Member 'FTimelineMove::Entries' has a wrong offset!");

// ScriptStruct Zion.TimelineEntry_SE
// 0x0040 (0x0058 - 0x0018)
struct FTimelineEntry_SE final : public FTimelineEntry
{
public:
	struct FSoundData                             SoundData;                                         // 0x0018(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimelineEntry_SE) == 0x000008, "Wrong alignment on FTimelineEntry_SE");
static_assert(sizeof(FTimelineEntry_SE) == 0x000058, "Wrong size on FTimelineEntry_SE");
static_assert(offsetof(FTimelineEntry_SE, SoundData) == 0x000018, "Member 'FTimelineEntry_SE::SoundData' has a wrong offset!");

// ScriptStruct Zion.TimelineSE
// 0x0010 (0x0028 - 0x0018)
struct FTimelineSE final : public FTimelineBase
{
public:
	TArray<struct FTimelineEntry_SE>              Entries;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTimelineSE) == 0x000008, "Wrong alignment on FTimelineSE");
static_assert(sizeof(FTimelineSE) == 0x000028, "Wrong size on FTimelineSE");
static_assert(offsetof(FTimelineSE, Entries) == 0x000018, "Member 'FTimelineSE::Entries' has a wrong offset!");

// ScriptStruct Zion.TimelineStateEntry
// 0x0008 (0x0020 - 0x0018)
struct FTimelineStateEntry final : public FTimelineEntry
{
public:
	TSubclassOf<class UState>                     State;                                             // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTimelineStateEntry) == 0x000008, "Wrong alignment on FTimelineStateEntry");
static_assert(sizeof(FTimelineStateEntry) == 0x000020, "Wrong size on FTimelineStateEntry");
static_assert(offsetof(FTimelineStateEntry, State) == 0x000018, "Member 'FTimelineStateEntry::State' has a wrong offset!");

// ScriptStruct Zion.TimelineState
// 0x0018 (0x0030 - 0x0018)
struct FTimelineState final : public FTimelineBase
{
public:
	TArray<struct FTimelineStateEntry>            Entries;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimelineState) == 0x000008, "Wrong alignment on FTimelineState");
static_assert(sizeof(FTimelineState) == 0x000030, "Wrong size on FTimelineState");
static_assert(offsetof(FTimelineState, Entries) == 0x000018, "Member 'FTimelineState::Entries' has a wrong offset!");

// ScriptStruct Zion.TimedDilationData
// 0x0010 (0x0010 - 0x0000)
struct FTimedDilationData final
{
public:
	float                                         Dilation;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendIn;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOut;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTimedDilationData) == 0x000004, "Wrong alignment on FTimedDilationData");
static_assert(sizeof(FTimedDilationData) == 0x000010, "Wrong size on FTimedDilationData");
static_assert(offsetof(FTimedDilationData, Dilation) == 0x000000, "Member 'FTimedDilationData::Dilation' has a wrong offset!");
static_assert(offsetof(FTimedDilationData, Duration) == 0x000004, "Member 'FTimedDilationData::Duration' has a wrong offset!");
static_assert(offsetof(FTimedDilationData, BlendIn) == 0x000008, "Member 'FTimedDilationData::BlendIn' has a wrong offset!");
static_assert(offsetof(FTimedDilationData, BlendOut) == 0x00000C, "Member 'FTimedDilationData::BlendOut' has a wrong offset!");

// ScriptStruct Zion.EventData
// 0x0220 (0x0220 - 0x0000)
struct FEventData final
{
public:
	struct FGameplayConditionChecker              Conditions;                                        // 0x0000(0x0018)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UEventAsset>             EventAsset;                                        // 0x0018(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class AActor*>              ActorBindings;                                     // 0x0040(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, class ASpawner*>            SpawnerBindings;                                   // 0x0090(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FEventBlackboardInit                   DefaultEventValues;                                // 0x00E0(0x0140)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventData) == 0x000008, "Wrong alignment on FEventData");
static_assert(sizeof(FEventData) == 0x000220, "Wrong size on FEventData");
static_assert(offsetof(FEventData, Conditions) == 0x000000, "Member 'FEventData::Conditions' has a wrong offset!");
static_assert(offsetof(FEventData, EventAsset) == 0x000018, "Member 'FEventData::EventAsset' has a wrong offset!");
static_assert(offsetof(FEventData, ActorBindings) == 0x000040, "Member 'FEventData::ActorBindings' has a wrong offset!");
static_assert(offsetof(FEventData, SpawnerBindings) == 0x000090, "Member 'FEventData::SpawnerBindings' has a wrong offset!");
static_assert(offsetof(FEventData, DefaultEventValues) == 0x0000E0, "Member 'FEventData::DefaultEventValues' has a wrong offset!");

// ScriptStruct Zion.FieldMessageNPCData
// 0x00C8 (0x00C8 - 0x0000)
struct FFieldMessageNPCData final
{
public:
	struct FGameplayConditionChecker              Conditions;                                        // 0x0000(0x0018)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bOverrideFieldMessageAsset;                        // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFieldMessageAsset>      FieldMessageAsset;                                 // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCooldown;                                 // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAnimations;                               // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      IdleAnimations;                                    // 0x0058(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseAI;                                            // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNPCAIData                             AIData;                                            // 0x0070(0x0058)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFieldMessageNPCData) == 0x000008, "Wrong alignment on FFieldMessageNPCData");
static_assert(sizeof(FFieldMessageNPCData) == 0x0000C8, "Wrong size on FFieldMessageNPCData");
static_assert(offsetof(FFieldMessageNPCData, Conditions) == 0x000000, "Member 'FFieldMessageNPCData::Conditions' has a wrong offset!");
static_assert(offsetof(FFieldMessageNPCData, bOverrideFieldMessageAsset) == 0x000018, "Member 'FFieldMessageNPCData::bOverrideFieldMessageAsset' has a wrong offset!");
static_assert(offsetof(FFieldMessageNPCData, FieldMessageAsset) == 0x000020, "Member 'FFieldMessageNPCData::FieldMessageAsset' has a wrong offset!");
static_assert(offsetof(FFieldMessageNPCData, bOverrideCooldown) == 0x000048, "Member 'FFieldMessageNPCData::bOverrideCooldown' has a wrong offset!");
static_assert(offsetof(FFieldMessageNPCData, Cooldown) == 0x00004C, "Member 'FFieldMessageNPCData::Cooldown' has a wrong offset!");
static_assert(offsetof(FFieldMessageNPCData, bOverrideAnimations) == 0x000050, "Member 'FFieldMessageNPCData::bOverrideAnimations' has a wrong offset!");
static_assert(offsetof(FFieldMessageNPCData, IdleAnimations) == 0x000058, "Member 'FFieldMessageNPCData::IdleAnimations' has a wrong offset!");
static_assert(offsetof(FFieldMessageNPCData, bUseAI) == 0x000068, "Member 'FFieldMessageNPCData::bUseAI' has a wrong offset!");
static_assert(offsetof(FFieldMessageNPCData, AIData) == 0x000070, "Member 'FFieldMessageNPCData::AIData' has a wrong offset!");

// ScriptStruct Zion.PlaySoundTriggerData
// 0x0010 (0x0010 - 0x0000)
struct FPlaySoundTriggerData final
{
public:
	class UFMODEvent*                             Event;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayCount;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDelay;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlaySoundTriggerData) == 0x000008, "Wrong alignment on FPlaySoundTriggerData");
static_assert(sizeof(FPlaySoundTriggerData) == 0x000010, "Wrong size on FPlaySoundTriggerData");
static_assert(offsetof(FPlaySoundTriggerData, Event) == 0x000000, "Member 'FPlaySoundTriggerData::Event' has a wrong offset!");
static_assert(offsetof(FPlaySoundTriggerData, PlayCount) == 0x000008, "Member 'FPlaySoundTriggerData::PlayCount' has a wrong offset!");
static_assert(offsetof(FPlaySoundTriggerData, StartDelay) == 0x00000C, "Member 'FPlaySoundTriggerData::StartDelay' has a wrong offset!");

// ScriptStruct Zion.FooterData
// 0x0058 (0x0058 - 0x0000)
struct FFooterData final
{
public:
	struct FRichTextInputElement                  InputElement;                                      // 0x0000(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Label;                                             // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFooterData) == 0x000008, "Wrong alignment on FFooterData");
static_assert(sizeof(FFooterData) == 0x000058, "Wrong size on FFooterData");
static_assert(offsetof(FFooterData, InputElement) == 0x000000, "Member 'FFooterData::InputElement' has a wrong offset!");
static_assert(offsetof(FFooterData, Label) == 0x000048, "Member 'FFooterData::Label' has a wrong offset!");

// ScriptStruct Zion.GameMenuPageData
// 0x0010 (0x0010 - 0x0000)
struct FGameMenuPageData final
{
public:
	TSubclassOf<class UUserWidgetGameMenu_Page>   PageClass;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidgetGameMenu_Page*               PageInstance;                                      // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameMenuPageData) == 0x000008, "Wrong alignment on FGameMenuPageData");
static_assert(sizeof(FGameMenuPageData) == 0x000010, "Wrong size on FGameMenuPageData");
static_assert(offsetof(FGameMenuPageData, PageClass) == 0x000000, "Member 'FGameMenuPageData::PageClass' has a wrong offset!");
static_assert(offsetof(FGameMenuPageData, PageInstance) == 0x000008, "Member 'FGameMenuPageData::PageInstance' has a wrong offset!");

// ScriptStruct Zion.RestPointListData
// 0x0020 (0x0020 - 0x0000)
struct FRestPointListData final
{
public:
	class FName                                   MapAreaName;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UUserWidgetMapIcon_RestPoint*>   RestPointIcons;                                    // 0x0008(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         CompletionPercentage;                              // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRestPointListData) == 0x000008, "Wrong alignment on FRestPointListData");
static_assert(sizeof(FRestPointListData) == 0x000020, "Wrong size on FRestPointListData");
static_assert(offsetof(FRestPointListData, MapAreaName) == 0x000000, "Member 'FRestPointListData::MapAreaName' has a wrong offset!");
static_assert(offsetof(FRestPointListData, RestPointIcons) == 0x000008, "Member 'FRestPointListData::RestPointIcons' has a wrong offset!");
static_assert(offsetof(FRestPointListData, CompletionPercentage) == 0x000018, "Member 'FRestPointListData::CompletionPercentage' has a wrong offset!");

// ScriptStruct Zion.TalkParameters
// 0x0028 (0x0028 - 0x0000)
struct FTalkParameters final
{
public:
	class FText                                   SpeakerName;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ETalkDesign                                   Design;                                            // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoComplete;                                     // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoCompleteTime;                                  // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkParameters) == 0x000008, "Wrong alignment on FTalkParameters");
static_assert(sizeof(FTalkParameters) == 0x000028, "Wrong size on FTalkParameters");
static_assert(offsetof(FTalkParameters, SpeakerName) == 0x000000, "Member 'FTalkParameters::SpeakerName' has a wrong offset!");
static_assert(offsetof(FTalkParameters, Text) == 0x000010, "Member 'FTalkParameters::Text' has a wrong offset!");
static_assert(offsetof(FTalkParameters, Design) == 0x000020, "Member 'FTalkParameters::Design' has a wrong offset!");
static_assert(offsetof(FTalkParameters, bAutoComplete) == 0x000021, "Member 'FTalkParameters::bAutoComplete' has a wrong offset!");
static_assert(offsetof(FTalkParameters, AutoCompleteTime) == 0x000024, "Member 'FTalkParameters::AutoCompleteTime' has a wrong offset!");

// ScriptStruct Zion.GameplayCameraSettings
// 0x0078 (0x0078 - 0x0000)
struct FGameplayCameraSettings final
{
public:
	float                                         SettingsEaseOutExp;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraSpeed;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinMaxBlendSpeed;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              WorldLocationOffset;                               // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraModuleOverrideType                     ZoomOffsetOverrideType;                            // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomOffset;                                        // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOffsetFactor;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraModuleOverrideType                     FOVOverrideType;                                   // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FOV;                                               // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVFactor;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraLocalOffsetBlendType                   LocalOffsetBlendType;                              // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LocalLocationOffset;                               // 0x0040(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalOffsetSpeed;                                  // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalOffsetEaseExp;                                // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MaxInputLocationOffset;                            // 0x0058(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputLocationOffsetSpeed;                          // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerBoundsFactor;                                // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyBoundsFactor;                                 // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCenterHorizontal;                                 // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCenterVertical;                                   // 0x0075(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCameraSettings) == 0x000008, "Wrong alignment on FGameplayCameraSettings");
static_assert(sizeof(FGameplayCameraSettings) == 0x000078, "Wrong size on FGameplayCameraSettings");
static_assert(offsetof(FGameplayCameraSettings, SettingsEaseOutExp) == 0x000000, "Member 'FGameplayCameraSettings::SettingsEaseOutExp' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, CameraSpeed) == 0x000004, "Member 'FGameplayCameraSettings::CameraSpeed' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, MinMaxBlendSpeed) == 0x000008, "Member 'FGameplayCameraSettings::MinMaxBlendSpeed' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, WorldLocationOffset) == 0x000010, "Member 'FGameplayCameraSettings::WorldLocationOffset' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, ZoomOffsetOverrideType) == 0x000020, "Member 'FGameplayCameraSettings::ZoomOffsetOverrideType' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, ZoomOffset) == 0x000024, "Member 'FGameplayCameraSettings::ZoomOffset' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, ZoomOffsetFactor) == 0x000028, "Member 'FGameplayCameraSettings::ZoomOffsetFactor' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, FOVOverrideType) == 0x00002C, "Member 'FGameplayCameraSettings::FOVOverrideType' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, FOV) == 0x000030, "Member 'FGameplayCameraSettings::FOV' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, FOVFactor) == 0x000034, "Member 'FGameplayCameraSettings::FOVFactor' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, LocalOffsetBlendType) == 0x000038, "Member 'FGameplayCameraSettings::LocalOffsetBlendType' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, LocalLocationOffset) == 0x000040, "Member 'FGameplayCameraSettings::LocalLocationOffset' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, LocalOffsetSpeed) == 0x000050, "Member 'FGameplayCameraSettings::LocalOffsetSpeed' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, LocalOffsetEaseExp) == 0x000054, "Member 'FGameplayCameraSettings::LocalOffsetEaseExp' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, MaxInputLocationOffset) == 0x000058, "Member 'FGameplayCameraSettings::MaxInputLocationOffset' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, InputLocationOffsetSpeed) == 0x000068, "Member 'FGameplayCameraSettings::InputLocationOffsetSpeed' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, PlayerBoundsFactor) == 0x00006C, "Member 'FGameplayCameraSettings::PlayerBoundsFactor' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, EnemyBoundsFactor) == 0x000070, "Member 'FGameplayCameraSettings::EnemyBoundsFactor' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, bCenterHorizontal) == 0x000074, "Member 'FGameplayCameraSettings::bCenterHorizontal' has a wrong offset!");
static_assert(offsetof(FGameplayCameraSettings, bCenterVertical) == 0x000075, "Member 'FGameplayCameraSettings::bCenterVertical' has a wrong offset!");

// ScriptStruct Zion.GameplayCameraOverrideSettings
// 0x0010 (0x0010 - 0x0000)
struct FGameplayCameraOverrideSettings final
{
public:
	TArray<class UCameraOverrideModule*>          OverrideSettings;                                  // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameplayCameraOverrideSettings) == 0x000008, "Wrong alignment on FGameplayCameraOverrideSettings");
static_assert(sizeof(FGameplayCameraOverrideSettings) == 0x000010, "Wrong size on FGameplayCameraOverrideSettings");
static_assert(offsetof(FGameplayCameraOverrideSettings, OverrideSettings) == 0x000000, "Member 'FGameplayCameraOverrideSettings::OverrideSettings' has a wrong offset!");

// ScriptStruct Zion.ZoneBlackBordersSettings
// 0x0038 (0x0038 - 0x0000)
struct FZoneBlackBordersSettings final
{
public:
	bool                                          bHasBlackBorders;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BorderMin;                                         // 0x0008(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BorderMax;                                         // 0x0020(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZoneBlackBordersSettings) == 0x000008, "Wrong alignment on FZoneBlackBordersSettings");
static_assert(sizeof(FZoneBlackBordersSettings) == 0x000038, "Wrong size on FZoneBlackBordersSettings");
static_assert(offsetof(FZoneBlackBordersSettings, bHasBlackBorders) == 0x000000, "Member 'FZoneBlackBordersSettings::bHasBlackBorders' has a wrong offset!");
static_assert(offsetof(FZoneBlackBordersSettings, BorderMin) == 0x000008, "Member 'FZoneBlackBordersSettings::BorderMin' has a wrong offset!");
static_assert(offsetof(FZoneBlackBordersSettings, BorderMax) == 0x000020, "Member 'FZoneBlackBordersSettings::BorderMax' has a wrong offset!");

}

