#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Zion

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Zion_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "EventSystem_structs.hpp"
#include "EventSystem_classes.hpp"
#include "SpineExtension_structs.hpp"
#include "SpineExtension_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_classes.hpp"
#include "RenderLayer_structs.hpp"
#include "Slate_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CableComponent_classes.hpp"
#include "MovieScene_structs.hpp"
#include "ProceduralMeshComponent_classes.hpp"
#include "GameplayCameras_structs.hpp"
#include "EnhancedInput_structs.hpp"
#include "EnhancedInput_classes.hpp"
#include "SlateCore_structs.hpp"
#include "AdvancedWidgets_classes.hpp"
#include "FMODStudio_structs.hpp"


namespace SDK
{

// Class Zion.AbilityEffect
// 0x0028 (0x0050 - 0x0028)
class UAbilityEffect : public UObject
{
public:
	bool                                          bEnabled;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bExecuteWhenDodged;                                // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bExecuteWhenGuarded;                               // 0x002A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bExecuteWhenParried;                               // 0x002B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             TargetInvalidStates;                               // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInitialize_BP();

	struct FVector GetAbilityForward() const;
	struct FVector GetAbilityLocation() const;
	class AActor* GetSource() const;
	struct FVector GetSourceLocation() const;
	class AActor* GetTarget() const;
	struct FVector GetTargetForward() const;
	struct FVector GetTargetLocation() const;
	struct FVector GetToTargetDirection(EDirectionSource DirectionSource, const struct FVector& Axis) const;
	bool IsFrontalAbility() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffect">();
	}
	static class UAbilityEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffect>();
	}
};
static_assert(alignof(UAbilityEffect) == 0x000008, "Wrong alignment on UAbilityEffect");
static_assert(sizeof(UAbilityEffect) == 0x000050, "Wrong size on UAbilityEffect");
static_assert(offsetof(UAbilityEffect, bEnabled) == 0x000028, "Member 'UAbilityEffect::bEnabled' has a wrong offset!");
static_assert(offsetof(UAbilityEffect, bExecuteWhenDodged) == 0x000029, "Member 'UAbilityEffect::bExecuteWhenDodged' has a wrong offset!");
static_assert(offsetof(UAbilityEffect, bExecuteWhenGuarded) == 0x00002A, "Member 'UAbilityEffect::bExecuteWhenGuarded' has a wrong offset!");
static_assert(offsetof(UAbilityEffect, bExecuteWhenParried) == 0x00002B, "Member 'UAbilityEffect::bExecuteWhenParried' has a wrong offset!");
static_assert(offsetof(UAbilityEffect, TargetInvalidStates) == 0x000030, "Member 'UAbilityEffect::TargetInvalidStates' has a wrong offset!");

// Class Zion.AbilityEffectInstant
// 0x0000 (0x0050 - 0x0050)
class UAbilityEffectInstant : public UAbilityEffect
{
public:
	void OnApplyEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant">();
	}
	static class UAbilityEffectInstant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant>();
	}
};
static_assert(alignof(UAbilityEffectInstant) == 0x000008, "Wrong alignment on UAbilityEffectInstant");
static_assert(sizeof(UAbilityEffectInstant) == 0x000050, "Wrong size on UAbilityEffectInstant");

// Class Zion.AbilityEffectInstant_RestoreSP
// 0x0058 (0x00A8 - 0x0050)
class UAbilityEffectInstant_RestoreSP final : public UAbilityEffectInstant
{
public:
	int32                                         AbsoluteValue;                                     // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<EFaction>                                ValidTargetFactions;                               // 0x0058(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_RestoreSP">();
	}
	static class UAbilityEffectInstant_RestoreSP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_RestoreSP>();
	}
};
static_assert(alignof(UAbilityEffectInstant_RestoreSP) == 0x000008, "Wrong alignment on UAbilityEffectInstant_RestoreSP");
static_assert(sizeof(UAbilityEffectInstant_RestoreSP) == 0x0000A8, "Wrong size on UAbilityEffectInstant_RestoreSP");
static_assert(offsetof(UAbilityEffectInstant_RestoreSP, AbsoluteValue) == 0x000050, "Member 'UAbilityEffectInstant_RestoreSP::AbsoluteValue' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_RestoreSP, ValidTargetFactions) == 0x000058, "Member 'UAbilityEffectInstant_RestoreSP::ValidTargetFactions' has a wrong offset!");

// Class Zion.BTDecoratorZion
// 0x0000 (0x0068 - 0x0068)
class UBTDecoratorZion : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecoratorZion">();
	}
	static class UBTDecoratorZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecoratorZion>();
	}
};
static_assert(alignof(UBTDecoratorZion) == 0x000008, "Wrong alignment on UBTDecoratorZion");
static_assert(sizeof(UBTDecoratorZion) == 0x000068, "Wrong size on UBTDecoratorZion");

// Class Zion.BTDecorator_Comparator
// 0x0008 (0x0070 - 0x0068)
class UBTDecorator_Comparator : public UBTDecoratorZion
{
public:
	EConditionType                                ConditionType;                                     // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_Comparator">();
	}
	static class UBTDecorator_Comparator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_Comparator>();
	}
};
static_assert(alignof(UBTDecorator_Comparator) == 0x000008, "Wrong alignment on UBTDecorator_Comparator");
static_assert(sizeof(UBTDecorator_Comparator) == 0x000070, "Wrong size on UBTDecorator_Comparator");
static_assert(offsetof(UBTDecorator_Comparator, ConditionType) == 0x000068, "Member 'UBTDecorator_Comparator::ConditionType' has a wrong offset!");

// Class Zion.BTDecorator_Comparator_PhaseLevel
// 0x0008 (0x0078 - 0x0070)
class UBTDecorator_Comparator_PhaseLevel final : public UBTDecorator_Comparator
{
public:
	int32                                         Level;                                             // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_Comparator_PhaseLevel">();
	}
	static class UBTDecorator_Comparator_PhaseLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_Comparator_PhaseLevel>();
	}
};
static_assert(alignof(UBTDecorator_Comparator_PhaseLevel) == 0x000008, "Wrong alignment on UBTDecorator_Comparator_PhaseLevel");
static_assert(sizeof(UBTDecorator_Comparator_PhaseLevel) == 0x000078, "Wrong size on UBTDecorator_Comparator_PhaseLevel");
static_assert(offsetof(UBTDecorator_Comparator_PhaseLevel, Level) == 0x000070, "Member 'UBTDecorator_Comparator_PhaseLevel::Level' has a wrong offset!");

// Class Zion.State
// 0x0000 (0x0028 - 0x0028)
class UState : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"State">();
	}
	static class UState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UState>();
	}
};
static_assert(alignof(UState) == 0x000008, "Wrong alignment on UState");
static_assert(sizeof(UState) == 0x000028, "Wrong size on UState");

// Class Zion.EventAction_MoveTo_TalkDistance
// 0x00F0 (0x0148 - 0x0058)
class UEventAction_MoveTo_TalkDistance final : public UEventAction_SubjectBinding
{
public:
	struct FActorBindingKey                       TalkTargetBinding;                                 // 0x0058(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMoveToTalkDistanceMovementType               MovementType;                                      // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceToTalkTarget;                              // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUpdateFacingWhileMoving;                          // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSweepOnTeleport;                                  // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A[0x1E];                                      // 0x006A(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPlaySubjectTurnAnimation;                         // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      SubjectTurnAnimationDefinitions;                   // 0x0090(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	EMoveToTalkDistanceTargetFacingType           TalkTargetFacingType;                              // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      TalkTargetTurnAnimationDefinitions;                // 0x00A8(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseEventCamera;                                   // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomDistanceOverride;                              // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                WorldSpaceOffset;                                  // 0x0120(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FViewTargetBlendSettings               BlendSettings;                                     // 0x0138(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_MoveTo_TalkDistance">();
	}
	static class UEventAction_MoveTo_TalkDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_MoveTo_TalkDistance>();
	}
};
static_assert(alignof(UEventAction_MoveTo_TalkDistance) == 0x000008, "Wrong alignment on UEventAction_MoveTo_TalkDistance");
static_assert(sizeof(UEventAction_MoveTo_TalkDistance) == 0x000148, "Wrong size on UEventAction_MoveTo_TalkDistance");
static_assert(offsetof(UEventAction_MoveTo_TalkDistance, TalkTargetBinding) == 0x000058, "Member 'UEventAction_MoveTo_TalkDistance::TalkTargetBinding' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_TalkDistance, MovementType) == 0x000060, "Member 'UEventAction_MoveTo_TalkDistance::MovementType' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_TalkDistance, DistanceToTalkTarget) == 0x000064, "Member 'UEventAction_MoveTo_TalkDistance::DistanceToTalkTarget' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_TalkDistance, bUpdateFacingWhileMoving) == 0x000068, "Member 'UEventAction_MoveTo_TalkDistance::bUpdateFacingWhileMoving' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_TalkDistance, bSweepOnTeleport) == 0x000069, "Member 'UEventAction_MoveTo_TalkDistance::bSweepOnTeleport' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_TalkDistance, bPlaySubjectTurnAnimation) == 0x000088, "Member 'UEventAction_MoveTo_TalkDistance::bPlaySubjectTurnAnimation' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_TalkDistance, SubjectTurnAnimationDefinitions) == 0x000090, "Member 'UEventAction_MoveTo_TalkDistance::SubjectTurnAnimationDefinitions' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_TalkDistance, TalkTargetFacingType) == 0x0000A0, "Member 'UEventAction_MoveTo_TalkDistance::TalkTargetFacingType' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_TalkDistance, TalkTargetTurnAnimationDefinitions) == 0x0000A8, "Member 'UEventAction_MoveTo_TalkDistance::TalkTargetTurnAnimationDefinitions' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_TalkDistance, bUseEventCamera) == 0x000118, "Member 'UEventAction_MoveTo_TalkDistance::bUseEventCamera' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_TalkDistance, ZoomDistanceOverride) == 0x00011C, "Member 'UEventAction_MoveTo_TalkDistance::ZoomDistanceOverride' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_TalkDistance, WorldSpaceOffset) == 0x000120, "Member 'UEventAction_MoveTo_TalkDistance::WorldSpaceOffset' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_TalkDistance, BlendSettings) == 0x000138, "Member 'UEventAction_MoveTo_TalkDistance::BlendSettings' has a wrong offset!");

// Class Zion.AbilityEffectTimed
// 0x0008 (0x0058 - 0x0050)
class UAbilityEffectTimed : public UAbilityEffect
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStart();
	bool OnUpdate(float DeltaTime, float* out_ConsumedDeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectTimed">();
	}
	static class UAbilityEffectTimed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectTimed>();
	}
};
static_assert(alignof(UAbilityEffectTimed) == 0x000008, "Wrong alignment on UAbilityEffectTimed");
static_assert(sizeof(UAbilityEffectTimed) == 0x000058, "Wrong size on UAbilityEffectTimed");

// Class Zion.RecollectionBossBaseComponent
// 0x00B0 (0x0150 - 0x00A0)
class URecollectionBossBaseComponent : public UActorComponent
{
public:
	ERespawnReason                                ExitRespawnReason;                                 // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERespawnReason                                RetryRespawnReason;                                // 0x00A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DialogMessage;                                     // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bAutoActivateBoss;                                 // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoActivationTimer;                               // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DialogYesNoClass;                                  // 0x00C0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFadeDescriptionData                   FadeDescription;                                   // 0x00E8(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x48];                                     // 0x0108(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BossActivation(class AEnemySpawner* EnemySpawner);
	void BossDeathEnd(class AEnemySpawner* EnemySpawner);
	void BossDeathEndPostDelay();
	void BossDeathStart(class AEnemySpawner* EnemySpawner);
	void ExitRecollectionMode();
	void ExitRecollectionMode_PostFadeOut();
	void Finish();
	void GameMapChange();
	bool InstantiateRetryDialog();
	void OnDialogClosed();
	void OnRetryDialogNo();
	void OnRetryDialogYes();
	void RetryRecollectionMode();
	void RetryRecollectionMode_PostFadeOut();
	void SetNewGameGenerationOverride(int32 GenerationOverride);
	void Start();

	bool CanLeaveRecollectionBoss() const;
	class AEnemySpawner* GetCachedEnemySpawner() const;
	int32 GetNewGameGenerationOverride() const;
	bool IsStarted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecollectionBossBaseComponent">();
	}
	static class URecollectionBossBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecollectionBossBaseComponent>();
	}
};
static_assert(alignof(URecollectionBossBaseComponent) == 0x000008, "Wrong alignment on URecollectionBossBaseComponent");
static_assert(sizeof(URecollectionBossBaseComponent) == 0x000150, "Wrong size on URecollectionBossBaseComponent");
static_assert(offsetof(URecollectionBossBaseComponent, ExitRespawnReason) == 0x0000A0, "Member 'URecollectionBossBaseComponent::ExitRespawnReason' has a wrong offset!");
static_assert(offsetof(URecollectionBossBaseComponent, RetryRespawnReason) == 0x0000A1, "Member 'URecollectionBossBaseComponent::RetryRespawnReason' has a wrong offset!");
static_assert(offsetof(URecollectionBossBaseComponent, DialogMessage) == 0x0000A8, "Member 'URecollectionBossBaseComponent::DialogMessage' has a wrong offset!");
static_assert(offsetof(URecollectionBossBaseComponent, bAutoActivateBoss) == 0x0000B8, "Member 'URecollectionBossBaseComponent::bAutoActivateBoss' has a wrong offset!");
static_assert(offsetof(URecollectionBossBaseComponent, AutoActivationTimer) == 0x0000BC, "Member 'URecollectionBossBaseComponent::AutoActivationTimer' has a wrong offset!");
static_assert(offsetof(URecollectionBossBaseComponent, DialogYesNoClass) == 0x0000C0, "Member 'URecollectionBossBaseComponent::DialogYesNoClass' has a wrong offset!");
static_assert(offsetof(URecollectionBossBaseComponent, FadeDescription) == 0x0000E8, "Member 'URecollectionBossBaseComponent::FadeDescription' has a wrong offset!");

// Class Zion.RecollectionBossComponent
// 0x0018 (0x0168 - 0x0150)
class URecollectionBossComponent final : public URecollectionBossBaseComponent
{
public:
	float                                         BossDeathEndDelay;                                 // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_154[0x14];                                     // 0x0154(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecollectionBossComponent">();
	}
	static class URecollectionBossComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecollectionBossComponent>();
	}
};
static_assert(alignof(URecollectionBossComponent) == 0x000008, "Wrong alignment on URecollectionBossComponent");
static_assert(sizeof(URecollectionBossComponent) == 0x000168, "Wrong size on URecollectionBossComponent");
static_assert(offsetof(URecollectionBossComponent, BossDeathEndDelay) == 0x000150, "Member 'URecollectionBossComponent::BossDeathEndDelay' has a wrong offset!");

// Class Zion.StateLockMovement
// 0x0000 (0x0028 - 0x0028)
class UStateLockMovement final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateLockMovement">();
	}
	static class UStateLockMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateLockMovement>();
	}
};
static_assert(alignof(UStateLockMovement) == 0x000008, "Wrong alignment on UStateLockMovement");
static_assert(sizeof(UStateLockMovement) == 0x000028, "Wrong size on UStateLockMovement");

// Class Zion.StateLockMovementAndFacing
// 0x0000 (0x0028 - 0x0028)
class UStateLockMovementAndFacing final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateLockMovementAndFacing">();
	}
	static class UStateLockMovementAndFacing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateLockMovementAndFacing>();
	}
};
static_assert(alignof(UStateLockMovementAndFacing) == 0x000008, "Wrong alignment on UStateLockMovementAndFacing");
static_assert(sizeof(UStateLockMovementAndFacing) == 0x000028, "Wrong size on UStateLockMovementAndFacing");

// Class Zion.AbilityEffectInstant_ForceFeedback
// 0x0008 (0x0058 - 0x0050)
class UAbilityEffectInstant_ForceFeedback final : public UAbilityEffectInstant
{
public:
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_ForceFeedback">();
	}
	static class UAbilityEffectInstant_ForceFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_ForceFeedback>();
	}
};
static_assert(alignof(UAbilityEffectInstant_ForceFeedback) == 0x000008, "Wrong alignment on UAbilityEffectInstant_ForceFeedback");
static_assert(sizeof(UAbilityEffectInstant_ForceFeedback) == 0x000058, "Wrong size on UAbilityEffectInstant_ForceFeedback");
static_assert(offsetof(UAbilityEffectInstant_ForceFeedback, ForceFeedbackEffect) == 0x000050, "Member 'UAbilityEffectInstant_ForceFeedback::ForceFeedbackEffect' has a wrong offset!");

// Class Zion.EventAction_SetRenderLayer
// 0x0008 (0x0060 - 0x0058)
class UEventAction_SetRenderLayer final : public UEventAction_SubjectBinding
{
public:
	ERenderLayerTypes                             RenderLayer;                                       // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_SetRenderLayer">();
	}
	static class UEventAction_SetRenderLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_SetRenderLayer>();
	}
};
static_assert(alignof(UEventAction_SetRenderLayer) == 0x000008, "Wrong alignment on UEventAction_SetRenderLayer");
static_assert(sizeof(UEventAction_SetRenderLayer) == 0x000060, "Wrong size on UEventAction_SetRenderLayer");
static_assert(offsetof(UEventAction_SetRenderLayer, RenderLayer) == 0x000058, "Member 'UEventAction_SetRenderLayer::RenderLayer' has a wrong offset!");

// Class Zion.CommandModule
// 0x0010 (0x0038 - 0x0028)
class UCommandModule : public UObject
{
public:
	bool                                          bEnabled;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWaitForModuleToComplete;                          // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A[0xE];                                       // 0x002A(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinish();
	void OnInitialize();
	void OnReset();
	void OnStart();

	class ACharacter* GetCharacter() const;
	class UCommand* GetCommand() const;
	float GetExecutionTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule">();
	}
	static class UCommandModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule>();
	}
};
static_assert(alignof(UCommandModule) == 0x000008, "Wrong alignment on UCommandModule");
static_assert(sizeof(UCommandModule) == 0x000038, "Wrong size on UCommandModule");
static_assert(offsetof(UCommandModule, bEnabled) == 0x000028, "Member 'UCommandModule::bEnabled' has a wrong offset!");
static_assert(offsetof(UCommandModule, bWaitForModuleToComplete) == 0x000029, "Member 'UCommandModule::bWaitForModuleToComplete' has a wrong offset!");

// Class Zion.CommandModule_GravityScale
// 0x0020 (0x0058 - 0x0038)
class UCommandModule_GravityScale final : public UCommandModule
{
public:
	float                                         GravityScale;                                      // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            GravityScaleFactorCurve;                           // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_GravityScale">();
	}
	static class UCommandModule_GravityScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_GravityScale>();
	}
};
static_assert(alignof(UCommandModule_GravityScale) == 0x000008, "Wrong alignment on UCommandModule_GravityScale");
static_assert(sizeof(UCommandModule_GravityScale) == 0x000058, "Wrong size on UCommandModule_GravityScale");
static_assert(offsetof(UCommandModule_GravityScale, GravityScale) == 0x000038, "Member 'UCommandModule_GravityScale::GravityScale' has a wrong offset!");
static_assert(offsetof(UCommandModule_GravityScale, GravityScaleFactorCurve) == 0x000040, "Member 'UCommandModule_GravityScale::GravityScaleFactorCurve' has a wrong offset!");

// Class Zion.StateIgnoreGroundFriction
// 0x0000 (0x0028 - 0x0028)
class UStateIgnoreGroundFriction final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateIgnoreGroundFriction">();
	}
	static class UStateIgnoreGroundFriction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateIgnoreGroundFriction>();
	}
};
static_assert(alignof(UStateIgnoreGroundFriction) == 0x000008, "Wrong alignment on UStateIgnoreGroundFriction");
static_assert(sizeof(UStateIgnoreGroundFriction) == 0x000028, "Wrong size on UStateIgnoreGroundFriction");

// Class Zion.StateLockFacing
// 0x0000 (0x0028 - 0x0028)
class UStateLockFacing final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateLockFacing">();
	}
	static class UStateLockFacing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateLockFacing>();
	}
};
static_assert(alignof(UStateLockFacing) == 0x000008, "Wrong alignment on UStateLockFacing");
static_assert(sizeof(UStateLockFacing) == 0x000028, "Wrong size on UStateLockFacing");

// Class Zion.CommandModule_Timeline
// 0x0000 (0x0038 - 0x0038)
class UCommandModule_Timeline : public UCommandModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_Timeline">();
	}
	static class UCommandModule_Timeline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_Timeline>();
	}
};
static_assert(alignof(UCommandModule_Timeline) == 0x000008, "Wrong alignment on UCommandModule_Timeline");
static_assert(sizeof(UCommandModule_Timeline) == 0x000038, "Wrong size on UCommandModule_Timeline");

// Class Zion.CommandModule_Timeline_SE
// 0x0028 (0x0060 - 0x0038)
class UCommandModule_Timeline_SE final : public UCommandModule_Timeline
{
public:
	struct FTimelineSE                            TimelineSE;                                        // 0x0038(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_Timeline_SE">();
	}
	static class UCommandModule_Timeline_SE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_Timeline_SE>();
	}
};
static_assert(alignof(UCommandModule_Timeline_SE) == 0x000008, "Wrong alignment on UCommandModule_Timeline_SE");
static_assert(sizeof(UCommandModule_Timeline_SE) == 0x000060, "Wrong size on UCommandModule_Timeline_SE");
static_assert(offsetof(UCommandModule_Timeline_SE, TimelineSE) == 0x000038, "Member 'UCommandModule_Timeline_SE::TimelineSE' has a wrong offset!");

// Class Zion.StateStun
// 0x0000 (0x0028 - 0x0028)
class UStateStun final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateStun">();
	}
	static class UStateStun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateStun>();
	}
};
static_assert(alignof(UStateStun) == 0x000008, "Wrong alignment on UStateStun");
static_assert(sizeof(UStateStun) == 0x000028, "Wrong size on UStateStun");

// Class Zion.Spawner
// 0x0000 (0x0290 - 0x0290)
class ASpawner : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Spawner">();
	}
	static class ASpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawner>();
	}
};
static_assert(alignof(ASpawner) == 0x000008, "Wrong alignment on ASpawner");
static_assert(sizeof(ASpawner) == 0x000290, "Wrong size on ASpawner");

// Class Zion.NPCSpawner
// 0x0058 (0x02E8 - 0x0290)
class ANPCSpawner final : public ASpawner
{
public:
	class USceneComponent*                        RootSceneComponent;                                // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayConditionRefreshComponent*     ConditionRefreshComponent;                         // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   NPCClass;                                          // 0x02A0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSpawnerNPCData>                NPCDataList;                                       // 0x02C8(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SpawnedNPC;                                        // 0x02E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCSpawner">();
	}
	static class ANPCSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANPCSpawner>();
	}
};
static_assert(alignof(ANPCSpawner) == 0x000008, "Wrong alignment on ANPCSpawner");
static_assert(sizeof(ANPCSpawner) == 0x0002E8, "Wrong size on ANPCSpawner");
static_assert(offsetof(ANPCSpawner, RootSceneComponent) == 0x000290, "Member 'ANPCSpawner::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(ANPCSpawner, ConditionRefreshComponent) == 0x000298, "Member 'ANPCSpawner::ConditionRefreshComponent' has a wrong offset!");
static_assert(offsetof(ANPCSpawner, NPCClass) == 0x0002A0, "Member 'ANPCSpawner::NPCClass' has a wrong offset!");
static_assert(offsetof(ANPCSpawner, NPCDataList) == 0x0002C8, "Member 'ANPCSpawner::NPCDataList' has a wrong offset!");
static_assert(offsetof(ANPCSpawner, SpawnedNPC) == 0x0002E0, "Member 'ANPCSpawner::SpawnedNPC' has a wrong offset!");

// Class Zion.Ability
// 0x04F0 (0x0780 - 0x0290)
class AAbility : public AActor
{
public:
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoStopByTime;                                   // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoStopTime;                                      // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoStopByTriggerCount;                           // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AutoStopTriggerCount;                              // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoAbortOnSourceDeath;                           // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoRefreshStatsSnapshot;                         // 0x02B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanBeDodged;                                      // 0x02BA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanBeParried;                                     // 0x02BB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanBeGuarded;                                     // 0x02BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BD[0x3];                                      // 0x02BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAbilityDirectionMode                         DirectionMode;                                     // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4[0xC];                                      // 0x02C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimelineAbility                       TimelineAbility;                                   // 0x02D0(0x01D0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTimelineSE                            TimelineSE;                                        // 0x04A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bExecuteAbilitiesOnStop;                           // 0x04C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C9[0x7];                                      // 0x04C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAbilityData>                   OnStopAbilityDataList;                             // 0x04D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   FXDataList;                                        // 0x04E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   OnStopFXDataList;                                  // 0x04F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EAbilityWeightCategory                        WeightCategory;                                    // 0x0500(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_501[0x7];                                      // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityComponent*                      AbilityComponent;                                  // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UAbilityEffectProcess>      AbilityEffectProcessClass;                         // 0x0510(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UAbilityEffectProcess>, struct FAbilityEffectProcessCollection> AbilityEffectProcessCache; // 0x0518(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              RuntimeFXInstances;                                // 0x0568(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_578[0x208];                                    // 0x0578(0x0208)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInitialize_BP();
	void OnLaunch_BP();
	void OnReset_BP();
	void OnSourceDeath();
	void OnStop_BP();
	void RequestAbort();
	void RequestStop();

	float GetExecutionTime() const;
	class AActor* GetSource() const;
	EAbilityWeightCategory GetWeightCategory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability">();
	}
	static class AAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbility>();
	}
};
static_assert(alignof(AAbility) == 0x000010, "Wrong alignment on AAbility");
static_assert(sizeof(AAbility) == 0x000780, "Wrong size on AAbility");
static_assert(offsetof(AAbility, bAutoStopByTime) == 0x0002A8, "Member 'AAbility::bAutoStopByTime' has a wrong offset!");
static_assert(offsetof(AAbility, AutoStopTime) == 0x0002AC, "Member 'AAbility::AutoStopTime' has a wrong offset!");
static_assert(offsetof(AAbility, bAutoStopByTriggerCount) == 0x0002B0, "Member 'AAbility::bAutoStopByTriggerCount' has a wrong offset!");
static_assert(offsetof(AAbility, AutoStopTriggerCount) == 0x0002B4, "Member 'AAbility::AutoStopTriggerCount' has a wrong offset!");
static_assert(offsetof(AAbility, bAutoAbortOnSourceDeath) == 0x0002B8, "Member 'AAbility::bAutoAbortOnSourceDeath' has a wrong offset!");
static_assert(offsetof(AAbility, bAutoRefreshStatsSnapshot) == 0x0002B9, "Member 'AAbility::bAutoRefreshStatsSnapshot' has a wrong offset!");
static_assert(offsetof(AAbility, bCanBeDodged) == 0x0002BA, "Member 'AAbility::bCanBeDodged' has a wrong offset!");
static_assert(offsetof(AAbility, bCanBeParried) == 0x0002BB, "Member 'AAbility::bCanBeParried' has a wrong offset!");
static_assert(offsetof(AAbility, bCanBeGuarded) == 0x0002BC, "Member 'AAbility::bCanBeGuarded' has a wrong offset!");
static_assert(offsetof(AAbility, DirectionMode) == 0x0002C0, "Member 'AAbility::DirectionMode' has a wrong offset!");
static_assert(offsetof(AAbility, TimelineAbility) == 0x0002D0, "Member 'AAbility::TimelineAbility' has a wrong offset!");
static_assert(offsetof(AAbility, TimelineSE) == 0x0004A0, "Member 'AAbility::TimelineSE' has a wrong offset!");
static_assert(offsetof(AAbility, bExecuteAbilitiesOnStop) == 0x0004C8, "Member 'AAbility::bExecuteAbilitiesOnStop' has a wrong offset!");
static_assert(offsetof(AAbility, OnStopAbilityDataList) == 0x0004D0, "Member 'AAbility::OnStopAbilityDataList' has a wrong offset!");
static_assert(offsetof(AAbility, FXDataList) == 0x0004E0, "Member 'AAbility::FXDataList' has a wrong offset!");
static_assert(offsetof(AAbility, OnStopFXDataList) == 0x0004F0, "Member 'AAbility::OnStopFXDataList' has a wrong offset!");
static_assert(offsetof(AAbility, WeightCategory) == 0x000500, "Member 'AAbility::WeightCategory' has a wrong offset!");
static_assert(offsetof(AAbility, AbilityComponent) == 0x000508, "Member 'AAbility::AbilityComponent' has a wrong offset!");
static_assert(offsetof(AAbility, AbilityEffectProcessClass) == 0x000510, "Member 'AAbility::AbilityEffectProcessClass' has a wrong offset!");
static_assert(offsetof(AAbility, AbilityEffectProcessCache) == 0x000518, "Member 'AAbility::AbilityEffectProcessCache' has a wrong offset!");
static_assert(offsetof(AAbility, RuntimeFXInstances) == 0x000568, "Member 'AAbility::RuntimeFXInstances' has a wrong offset!");

// Class Zion.AbilityHitbox
// 0x0340 (0x0AC0 - 0x0780)
#pragma pack(push, 0x1)
class alignas(0x10) AAbilityHitbox : public AAbility
{
public:
	uint8                                         Pad_780[0x18];                                     // 0x0780(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeCollision;                              // 0x0798(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DelayBeforeProcessing;                             // 0x079C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             IgnoreIfTargetHasAnyState;                         // 0x07A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	EHitBoxTargetType                             TargetType;                                        // 0x07B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionProfile>                     CustomTargetCollisionProfiles;                     // 0x07B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<EFaction>                              CustomTargetFactions;                              // 0x07C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bTriggerOnReEntry;                                 // 0x07D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnableReTrigger;                                  // 0x07D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7DA[0x2];                                      // 0x07DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeReTrigger;                              // 0x07DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBlockOnOneWayPlatforms;                           // 0x07E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7E1[0xF];                                      // 0x07E1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           OnContactFXData;                                   // 0x07F0(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FAbilityData>                   OnContactAbilityDataList;                          // 0x08F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bStopOnBlockerOverlap;                             // 0x0900(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_901[0xF];                                      // 0x0901(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           OnBlockerFXData;                                   // 0x0910(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FAbilityData>                   OnBlockerAbilityDataList;                          // 0x0A10(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class USceneComponent*                        RootSceneComponent;                                // 0x0A20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A28[0x90];                                     // 0x0A28(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityHitbox">();
	}
	static class AAbilityHitbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityHitbox>();
	}
};
#pragma pack(pop)
static_assert(alignof(AAbilityHitbox) == 0x000010, "Wrong alignment on AAbilityHitbox");
static_assert(sizeof(AAbilityHitbox) == 0x000AC0, "Wrong size on AAbilityHitbox");
static_assert(offsetof(AAbilityHitbox, DelayBeforeCollision) == 0x000798, "Member 'AAbilityHitbox::DelayBeforeCollision' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, DelayBeforeProcessing) == 0x00079C, "Member 'AAbilityHitbox::DelayBeforeProcessing' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, IgnoreIfTargetHasAnyState) == 0x0007A0, "Member 'AAbilityHitbox::IgnoreIfTargetHasAnyState' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, TargetType) == 0x0007B0, "Member 'AAbilityHitbox::TargetType' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, CustomTargetCollisionProfiles) == 0x0007B8, "Member 'AAbilityHitbox::CustomTargetCollisionProfiles' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, CustomTargetFactions) == 0x0007C8, "Member 'AAbilityHitbox::CustomTargetFactions' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, bTriggerOnReEntry) == 0x0007D8, "Member 'AAbilityHitbox::bTriggerOnReEntry' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, bEnableReTrigger) == 0x0007D9, "Member 'AAbilityHitbox::bEnableReTrigger' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, DelayBeforeReTrigger) == 0x0007DC, "Member 'AAbilityHitbox::DelayBeforeReTrigger' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, bBlockOnOneWayPlatforms) == 0x0007E0, "Member 'AAbilityHitbox::bBlockOnOneWayPlatforms' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, OnContactFXData) == 0x0007F0, "Member 'AAbilityHitbox::OnContactFXData' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, OnContactAbilityDataList) == 0x0008F0, "Member 'AAbilityHitbox::OnContactAbilityDataList' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, bStopOnBlockerOverlap) == 0x000900, "Member 'AAbilityHitbox::bStopOnBlockerOverlap' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, OnBlockerFXData) == 0x000910, "Member 'AAbilityHitbox::OnBlockerFXData' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, OnBlockerAbilityDataList) == 0x000A10, "Member 'AAbilityHitbox::OnBlockerAbilityDataList' has a wrong offset!");
static_assert(offsetof(AAbilityHitbox, RootSceneComponent) == 0x000A20, "Member 'AAbilityHitbox::RootSceneComponent' has a wrong offset!");

// Class Zion.Command
// 0x0080 (0x00A8 - 0x0028)
class UCommand : public UObject
{
public:
	TArray<class UCommandCondition*>              Conditions;                                        // 0x0028(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UCommandModule*>                 Modules;                                           // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UCommandCondition*>              FinishConditions;                                  // 0x0048(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x50];                                      // 0x0058(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool OnCanBeStarted();
	void OnFinish(ECommandFinishType FinishType);
	void OnInitialize(class APawn* PawnOwner);
	void OnPreStart();
	void OnReset();
	void OnStart();

	class ACharacter* GetCharacter() const;
	ECommandCategory GetCommandCategory() const;
	ECommandLayerType GetCommandLayer() const;
	float GetExecutionTime() const;
	const struct FInputSnapshot GetInputSnapshot() const;
	const class UInputAction* GetInvokedInputAction() const;
	class UCommandModule* GetModule(TSubclassOf<class UCommandModule> CommandModuleClass, bool bEnsureIfMissing) const;
	class UMovementComponent* GetMovementComponent() const;
	class APawn* GetPawn() const;
	const class UCommandSet* GetSourceCommandSet() const;
	bool IsInvokedInputPressed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command">();
	}
	static class UCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand>();
	}
};
static_assert(alignof(UCommand) == 0x000008, "Wrong alignment on UCommand");
static_assert(sizeof(UCommand) == 0x0000A8, "Wrong size on UCommand");
static_assert(offsetof(UCommand, Conditions) == 0x000028, "Member 'UCommand::Conditions' has a wrong offset!");
static_assert(offsetof(UCommand, Modules) == 0x000038, "Member 'UCommand::Modules' has a wrong offset!");
static_assert(offsetof(UCommand, FinishConditions) == 0x000048, "Member 'UCommand::FinishConditions' has a wrong offset!");

// Class Zion.Command_PileAttack
// 0x0080 (0x0128 - 0x00A8)
class UCommand_PileAttack : public UCommand
{
public:
	float                                         ChargePhaseTime;                                   // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             ChargePhaseStates;                                 // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FPileAttackChargeLevel>         DiveChargeLevels;                                  // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         DiveLaunchVelocity;                                // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0xC];                                       // 0x00D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             CurrentDiveChargeLevelStates;                      // 0x00E0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      CurrentDiveLoopFXInstance;                         // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAbility*                               CurrentDiveAbility;                                // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x28];                                     // 0x0100(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command_PileAttack">();
	}
	static class UCommand_PileAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand_PileAttack>();
	}
};
static_assert(alignof(UCommand_PileAttack) == 0x000008, "Wrong alignment on UCommand_PileAttack");
static_assert(sizeof(UCommand_PileAttack) == 0x000128, "Wrong size on UCommand_PileAttack");
static_assert(offsetof(UCommand_PileAttack, ChargePhaseTime) == 0x0000A8, "Member 'UCommand_PileAttack::ChargePhaseTime' has a wrong offset!");
static_assert(offsetof(UCommand_PileAttack, ChargePhaseStates) == 0x0000B0, "Member 'UCommand_PileAttack::ChargePhaseStates' has a wrong offset!");
static_assert(offsetof(UCommand_PileAttack, DiveChargeLevels) == 0x0000C0, "Member 'UCommand_PileAttack::DiveChargeLevels' has a wrong offset!");
static_assert(offsetof(UCommand_PileAttack, DiveLaunchVelocity) == 0x0000D0, "Member 'UCommand_PileAttack::DiveLaunchVelocity' has a wrong offset!");
static_assert(offsetof(UCommand_PileAttack, CurrentDiveChargeLevelStates) == 0x0000E0, "Member 'UCommand_PileAttack::CurrentDiveChargeLevelStates' has a wrong offset!");
static_assert(offsetof(UCommand_PileAttack, CurrentDiveLoopFXInstance) == 0x0000F0, "Member 'UCommand_PileAttack::CurrentDiveLoopFXInstance' has a wrong offset!");
static_assert(offsetof(UCommand_PileAttack, CurrentDiveAbility) == 0x0000F8, "Member 'UCommand_PileAttack::CurrentDiveAbility' has a wrong offset!");

// Class Zion.StatusEffectComponent
// 0x00D8 (0x0178 - 0x00A0)
class UStatusEffectComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class UStatusEffect* StatusEffect)> OnStatusEffectLaunchedDelegate; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UStatusEffect* StatusEffect)> OnStatusEffectStoppedDelegate; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x30];                                      // 0x00C0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              StatusEffectBurn;                                  // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              StatusEffectFreeze;                                // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              StatusEffectShock;                                 // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  StatusEffects;                                     // 0x0108(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UStatusEffect>, struct FStatusEffectList> CachedStatusEffects;            // 0x0118(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LaunchStatusEffect(EStatusEffectType StatusEffectType);
	void LaunchStatusEffectFromClass(const TSubclassOf<class UStatusEffect>& StatusEffectClass);
	void OnDeathProcessStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectComponent">();
	}
	static class UStatusEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectComponent>();
	}
};
static_assert(alignof(UStatusEffectComponent) == 0x000008, "Wrong alignment on UStatusEffectComponent");
static_assert(sizeof(UStatusEffectComponent) == 0x000178, "Wrong size on UStatusEffectComponent");
static_assert(offsetof(UStatusEffectComponent, OnStatusEffectLaunchedDelegate) == 0x0000A0, "Member 'UStatusEffectComponent::OnStatusEffectLaunchedDelegate' has a wrong offset!");
static_assert(offsetof(UStatusEffectComponent, OnStatusEffectStoppedDelegate) == 0x0000B0, "Member 'UStatusEffectComponent::OnStatusEffectStoppedDelegate' has a wrong offset!");
static_assert(offsetof(UStatusEffectComponent, StatusEffectBurn) == 0x0000F0, "Member 'UStatusEffectComponent::StatusEffectBurn' has a wrong offset!");
static_assert(offsetof(UStatusEffectComponent, StatusEffectFreeze) == 0x0000F8, "Member 'UStatusEffectComponent::StatusEffectFreeze' has a wrong offset!");
static_assert(offsetof(UStatusEffectComponent, StatusEffectShock) == 0x000100, "Member 'UStatusEffectComponent::StatusEffectShock' has a wrong offset!");
static_assert(offsetof(UStatusEffectComponent, StatusEffects) == 0x000108, "Member 'UStatusEffectComponent::StatusEffects' has a wrong offset!");
static_assert(offsetof(UStatusEffectComponent, CachedStatusEffects) == 0x000118, "Member 'UStatusEffectComponent::CachedStatusEffects' has a wrong offset!");

// Class Zion.StateLockFreeCommandLayer
// 0x0000 (0x0028 - 0x0028)
class UStateLockFreeCommandLayer final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateLockFreeCommandLayer">();
	}
	static class UStateLockFreeCommandLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateLockFreeCommandLayer>();
	}
};
static_assert(alignof(UStateLockFreeCommandLayer) == 0x000008, "Wrong alignment on UStateLockFreeCommandLayer");
static_assert(sizeof(UStateLockFreeCommandLayer) == 0x000028, "Wrong size on UStateLockFreeCommandLayer");

// Class Zion.Command_Transform
// 0x0040 (0x00E8 - 0x00A8)
class UCommand_Transform : public UCommand
{
public:
	float                                         TransformDelay;                                    // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    EnemyRowHandle;                                    // 0x00B0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	ESpineBone                                    SpawnBone;                                         // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpawnBoneCustomName;                               // 0x00C4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSpawnOffsetByHalfHeight;                          // 0x00CC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command_Transform">();
	}
	static class UCommand_Transform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand_Transform>();
	}
};
static_assert(alignof(UCommand_Transform) == 0x000008, "Wrong alignment on UCommand_Transform");
static_assert(sizeof(UCommand_Transform) == 0x0000E8, "Wrong size on UCommand_Transform");
static_assert(offsetof(UCommand_Transform, TransformDelay) == 0x0000A8, "Member 'UCommand_Transform::TransformDelay' has a wrong offset!");
static_assert(offsetof(UCommand_Transform, EnemyRowHandle) == 0x0000B0, "Member 'UCommand_Transform::EnemyRowHandle' has a wrong offset!");
static_assert(offsetof(UCommand_Transform, SpawnBone) == 0x0000C0, "Member 'UCommand_Transform::SpawnBone' has a wrong offset!");
static_assert(offsetof(UCommand_Transform, SpawnBoneCustomName) == 0x0000C4, "Member 'UCommand_Transform::SpawnBoneCustomName' has a wrong offset!");
static_assert(offsetof(UCommand_Transform, bSpawnOffsetByHalfHeight) == 0x0000CC, "Member 'UCommand_Transform::bSpawnOffsetByHalfHeight' has a wrong offset!");
static_assert(offsetof(UCommand_Transform, CommandClasses) == 0x0000D0, "Member 'UCommand_Transform::CommandClasses' has a wrong offset!");

// Class Zion.StateDebuff
// 0x0000 (0x0028 - 0x0028)
class UStateDebuff final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateDebuff">();
	}
	static class UStateDebuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateDebuff>();
	}
};
static_assert(alignof(UStateDebuff) == 0x000008, "Wrong alignment on UStateDebuff");
static_assert(sizeof(UStateDebuff) == 0x000028, "Wrong size on UStateDebuff");

// Class Zion.AbilityHitboxTarget
// 0x0000 (0x0AC0 - 0x0AC0)
#pragma pack(push, 0x1)
class alignas(0x10) AAbilityHitboxTarget : public AAbilityHitbox
{
public:
	class AActor* GetTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityHitboxTarget">();
	}
	static class AAbilityHitboxTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityHitboxTarget>();
	}
};
#pragma pack(pop)
static_assert(alignof(AAbilityHitboxTarget) == 0x000010, "Wrong alignment on AAbilityHitboxTarget");
static_assert(sizeof(AAbilityHitboxTarget) == 0x000AC0, "Wrong size on AAbilityHitboxTarget");

// Class Zion.AbilityHitboxTarget_Search
// 0x0000 (0x0AC0 - 0x0AC0)
class AAbilityHitboxTarget_Search : public AAbilityHitboxTarget
{
public:
	float                                         MaxDistance;                                       // 0x0AB8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNeedsLineOfSight;                                 // 0x0ABC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFrontCheck;                                       // 0x0ABD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             VisibilityChannel;                                 // 0x0ABE(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_ABF[0x1];                                      // 0x0ABF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityHitboxTarget_Search">();
	}
	static class AAbilityHitboxTarget_Search* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityHitboxTarget_Search>();
	}
};
static_assert(alignof(AAbilityHitboxTarget_Search) == 0x000010, "Wrong alignment on AAbilityHitboxTarget_Search");
static_assert(sizeof(AAbilityHitboxTarget_Search) == 0x000AC0, "Wrong size on AAbilityHitboxTarget_Search");
static_assert(offsetof(AAbilityHitboxTarget_Search, MaxDistance) == 0x000AB8, "Member 'AAbilityHitboxTarget_Search::MaxDistance' has a wrong offset!");
static_assert(offsetof(AAbilityHitboxTarget_Search, bNeedsLineOfSight) == 0x000ABC, "Member 'AAbilityHitboxTarget_Search::bNeedsLineOfSight' has a wrong offset!");
static_assert(offsetof(AAbilityHitboxTarget_Search, bFrontCheck) == 0x000ABD, "Member 'AAbilityHitboxTarget_Search::bFrontCheck' has a wrong offset!");
static_assert(offsetof(AAbilityHitboxTarget_Search, VisibilityChannel) == 0x000ABE, "Member 'AAbilityHitboxTarget_Search::VisibilityChannel' has a wrong offset!");

// Class Zion.AbilityHitboxTarget_Search_Homing
// 0x0010 (0x0AD0 - 0x0AC0)
class AAbilityHitboxTarget_Search_Homing : public AAbilityHitboxTarget_Search
{
public:
	class UHomingComponent*                       HomingComponent;                                   // 0x0AC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC8[0x8];                                      // 0x0AC8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityHitboxTarget_Search_Homing">();
	}
	static class AAbilityHitboxTarget_Search_Homing* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityHitboxTarget_Search_Homing>();
	}
};
static_assert(alignof(AAbilityHitboxTarget_Search_Homing) == 0x000010, "Wrong alignment on AAbilityHitboxTarget_Search_Homing");
static_assert(sizeof(AAbilityHitboxTarget_Search_Homing) == 0x000AD0, "Wrong size on AAbilityHitboxTarget_Search_Homing");
static_assert(offsetof(AAbilityHitboxTarget_Search_Homing, HomingComponent) == 0x000AC0, "Member 'AAbilityHitboxTarget_Search_Homing::HomingComponent' has a wrong offset!");

// Class Zion.GameSettingsSubsystem
// 0x00E8 (0x0118 - 0x0030)
class UGameSettingsSubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void()>              OnAutoUploadCrashReportChanged;                    // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDisplayHPAboveGaugeChanged;                      // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDisplaySPAboveGaugeChanged;                      // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDisplayPlayerUIChanged;                          // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDisplayEnemyGaugesChanged;                       // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDisplayAchievementNotificationsChanged;          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnConstraintHUDAspectRatioChanged;                 // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAutoClimbDirectionModeChanged;                   // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLowHPFeedbackOpacityChanged;                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x58];                                      // 0x00C0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetMaxResolutionScale();
	static float GetMinResolutionScale();

	void ResetAntiAliasingMethod();
	void ResetAspectRatio();
	EAutoClimbDirectionMode ResetAutoClimbDirectionMode();
	bool ResetAutoSkipAlreadySeenEvents();
	bool ResetCameraOscillation();
	float ResetCameraShake();
	float ResetControllerVibration();
	bool ResetDisplayAchievementNotifications();
	bool ResetDisplayDamageValues();
	bool ResetDisplayEnemyGauges();
	bool ResetDisplayHealValues();
	bool ResetDisplayHPAboveGauge();
	bool ResetDisplayPlayerUI();
	bool ResetDisplayTutorials();
	bool ResetHoldDownToDodgeStill();
	float ResetLowHPFeedbackOpacity();
	float ResetResolutionScale();
	void ResetSticksDeadZone();
	void ResetToDefault(EGameSettingsType GameSettingsToReset);
	EAntiAliasingMethod SetAntiAliasingMethod(const EAntiAliasingMethod& NewAntiAliasingMethod);
	EAutoClimbDirectionMode SetAutoClimbDirectionMode(EAutoClimbDirectionMode NewMode);
	bool SetAutoSkipAlreadySeenEvents(bool bAutoSkip);
	void SetAutoUploadCrashReport(bool bNewAutoUploadCrashReport);
	bool SetCameraOscillation(bool bEnable);
	float SetCameraShake(float NewCameraShake);
	EConstraintCameraAspectRatio SetConstraintCameraAspectRatio(const EConstraintCameraAspectRatio& NewConstraintCameraAspectRatio);
	bool SetConstraintHUDAspectRatio(bool bNewConstraintHUDAspectRatio);
	float SetControllerVibration(float NewControllerVibration);
	bool SetDisplayAchievementNotifications(bool bDisplay);
	bool SetDisplayDamageValues(bool bDisplayDamageValues);
	bool SetDisplayEnemyGauges(bool bDisplay);
	bool SetDisplayHealValues(bool bDisplayHealValues);
	bool SetDisplayHPAboveGauge(bool bDisplayHPAboveGauge);
	bool SetDisplayPlayerUI(bool bDisplay);
	bool SetDisplayTutorials(bool bDisplay);
	float SetGamma(float NewGamma);
	float SetGammaPercentage(float NewGammaPercentage);
	bool SetHoldDownToDodgeStill(bool bEnable);
	void SetInitialSettingsDone();
	void SetLanguage(const class FString& Language);
	float SetLowHPFeedbackOpacity(float NewLowHPFeedbackOpacity);
	float SetResolutionScale(float NewResolutionScale);
	float SetStickDeadZone(const EInputStick& InputStick, float NewDeadZone);
	void SetTitleType(EGameEndingType TitleType);
	EConstraintCameraAspectRatio SetUIAspectRatio(const EConstraintCameraAspectRatio& NewUIAspectRatio);

	bool DidReachAnyGameEnding() const;
	bool DidReachGameEnding(EGameEndingType GameEndingType) const;
	EAntiAliasingMethod GetAntiAliasingMethod() const;
	EAutoClimbDirectionMode GetAutoClimbDirectionMode() const;
	bool GetAutoSkipAlreadySeenEvents() const;
	bool GetAutoUploadCrashReport() const;
	bool GetCameraOscillation() const;
	float GetCameraShake() const;
	EConstraintCameraAspectRatio GetConstraintCameraAspectRatio() const;
	bool GetConstraintHUDAspectRatio() const;
	float GetControllerVibration() const;
	bool GetDisplayAchievementNotifications() const;
	bool GetDisplayDamageValues() const;
	bool GetDisplayEnemyGauges() const;
	bool GetDisplayHealValues() const;
	bool GetDisplayHPAboveGauge() const;
	bool GetDisplayPlayerUI() const;
	bool GetDisplayTutorials() const;
	float GetGamma() const;
	float GetGammaDefault() const;
	float GetGammaMax() const;
	float GetGammaMin() const;
	float GetGammaPercentage() const;
	bool GetHoldDownToDodgeStill() const;
	class FString GetLanguage() const;
	float GetLowHPFeedbackOpacity() const;
	float GetResolutionScale() const;
	float GetStickDeadZone(const EInputStick& InputStick) const;
	EGameEndingType GetTitleType() const;
	EConstraintCameraAspectRatio GetUIAspectRatio() const;
	bool IsInitialSettingsDone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSettingsSubsystem">();
	}
	static class UGameSettingsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSettingsSubsystem>();
	}
};
static_assert(alignof(UGameSettingsSubsystem) == 0x000008, "Wrong alignment on UGameSettingsSubsystem");
static_assert(sizeof(UGameSettingsSubsystem) == 0x000118, "Wrong size on UGameSettingsSubsystem");
static_assert(offsetof(UGameSettingsSubsystem, OnAutoUploadCrashReportChanged) == 0x000030, "Member 'UGameSettingsSubsystem::OnAutoUploadCrashReportChanged' has a wrong offset!");
static_assert(offsetof(UGameSettingsSubsystem, OnDisplayHPAboveGaugeChanged) == 0x000040, "Member 'UGameSettingsSubsystem::OnDisplayHPAboveGaugeChanged' has a wrong offset!");
static_assert(offsetof(UGameSettingsSubsystem, OnDisplaySPAboveGaugeChanged) == 0x000050, "Member 'UGameSettingsSubsystem::OnDisplaySPAboveGaugeChanged' has a wrong offset!");
static_assert(offsetof(UGameSettingsSubsystem, OnDisplayPlayerUIChanged) == 0x000060, "Member 'UGameSettingsSubsystem::OnDisplayPlayerUIChanged' has a wrong offset!");
static_assert(offsetof(UGameSettingsSubsystem, OnDisplayEnemyGaugesChanged) == 0x000070, "Member 'UGameSettingsSubsystem::OnDisplayEnemyGaugesChanged' has a wrong offset!");
static_assert(offsetof(UGameSettingsSubsystem, OnDisplayAchievementNotificationsChanged) == 0x000080, "Member 'UGameSettingsSubsystem::OnDisplayAchievementNotificationsChanged' has a wrong offset!");
static_assert(offsetof(UGameSettingsSubsystem, OnConstraintHUDAspectRatioChanged) == 0x000090, "Member 'UGameSettingsSubsystem::OnConstraintHUDAspectRatioChanged' has a wrong offset!");
static_assert(offsetof(UGameSettingsSubsystem, OnAutoClimbDirectionModeChanged) == 0x0000A0, "Member 'UGameSettingsSubsystem::OnAutoClimbDirectionModeChanged' has a wrong offset!");
static_assert(offsetof(UGameSettingsSubsystem, OnLowHPFeedbackOpacityChanged) == 0x0000B0, "Member 'UGameSettingsSubsystem::OnLowHPFeedbackOpacityChanged' has a wrong offset!");

// Class Zion.DeathProcess
// 0x0218 (0x0240 - 0x0028)
class UDeathProcess : public UObject
{
public:
	EDeathFacingMode                              FacingMode;                                        // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BorderDistanceForFallback;                         // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSpineFXData                           FXData;                                            // 0x0030(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSpineFXData                           OnFinishFXData;                                    // 0x0130(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Destroy();
	void FinishProcess();
	void Initialize(class AActor* Actor);
	void Launch(class AActor* Actor);
	void OnFinish();
	void Update(class AActor* Actor, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathProcess">();
	}
	static class UDeathProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathProcess>();
	}
};
static_assert(alignof(UDeathProcess) == 0x000010, "Wrong alignment on UDeathProcess");
static_assert(sizeof(UDeathProcess) == 0x000240, "Wrong size on UDeathProcess");
static_assert(offsetof(UDeathProcess, FacingMode) == 0x000028, "Member 'UDeathProcess::FacingMode' has a wrong offset!");
static_assert(offsetof(UDeathProcess, BorderDistanceForFallback) == 0x00002C, "Member 'UDeathProcess::BorderDistanceForFallback' has a wrong offset!");
static_assert(offsetof(UDeathProcess, FXData) == 0x000030, "Member 'UDeathProcess::FXData' has a wrong offset!");
static_assert(offsetof(UDeathProcess, OnFinishFXData) == 0x000130, "Member 'UDeathProcess::OnFinishFXData' has a wrong offset!");

// Class Zion.DeathProcess_Animation
// 0x0030 (0x0270 - 0x0240)
class UDeathProcess_Animation : public UDeathProcess
{
public:
	TArray<struct FSpineAnimationDefinition>      DeathAnimations;                                   // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bCanUseBackAnimations;                             // 0x0250(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      BackDeathAnimations;                               // 0x0258(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bWaitForAnimations;                                // 0x0268(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeathAnimationFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathProcess_Animation">();
	}
	static class UDeathProcess_Animation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathProcess_Animation>();
	}
};
static_assert(alignof(UDeathProcess_Animation) == 0x000010, "Wrong alignment on UDeathProcess_Animation");
static_assert(sizeof(UDeathProcess_Animation) == 0x000270, "Wrong size on UDeathProcess_Animation");
static_assert(offsetof(UDeathProcess_Animation, DeathAnimations) == 0x000240, "Member 'UDeathProcess_Animation::DeathAnimations' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Animation, bCanUseBackAnimations) == 0x000250, "Member 'UDeathProcess_Animation::bCanUseBackAnimations' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Animation, BackDeathAnimations) == 0x000258, "Member 'UDeathProcess_Animation::BackDeathAnimations' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Animation, bWaitForAnimations) == 0x000268, "Member 'UDeathProcess_Animation::bWaitForAnimations' has a wrong offset!");

// Class Zion.DeathProcess_Boss
// 0x0030 (0x02A0 - 0x0270)
class UDeathProcess_Boss : public UDeathProcess_Animation
{
public:
	bool                                          bLockFastTravel;                                   // 0x0270(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSetInvincible;                                    // 0x0271(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopNegativeStatusEffects;                        // 0x0272(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseTimeDilation;                                  // 0x0273(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSetFallingIfAirborne;                             // 0x0274(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_275[0x3];                                      // 0x0275(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimedDilationData                     TimeDilation;                                      // 0x0278(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x18];                                     // 0x0288(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathProcess_Boss">();
	}
	static class UDeathProcess_Boss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathProcess_Boss>();
	}
};
static_assert(alignof(UDeathProcess_Boss) == 0x000010, "Wrong alignment on UDeathProcess_Boss");
static_assert(sizeof(UDeathProcess_Boss) == 0x0002A0, "Wrong size on UDeathProcess_Boss");
static_assert(offsetof(UDeathProcess_Boss, bLockFastTravel) == 0x000270, "Member 'UDeathProcess_Boss::bLockFastTravel' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Boss, bSetInvincible) == 0x000271, "Member 'UDeathProcess_Boss::bSetInvincible' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Boss, bStopNegativeStatusEffects) == 0x000272, "Member 'UDeathProcess_Boss::bStopNegativeStatusEffects' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Boss, bUseTimeDilation) == 0x000273, "Member 'UDeathProcess_Boss::bUseTimeDilation' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Boss, bSetFallingIfAirborne) == 0x000274, "Member 'UDeathProcess_Boss::bSetFallingIfAirborne' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Boss, TimeDilation) == 0x000278, "Member 'UDeathProcess_Boss::TimeDilation' has a wrong offset!");

// Class Zion.Trigger
// 0x0010 (0x02A0 - 0x0290)
class ATrigger : public AActor
{
public:
	class USceneComponent*                        RootSceneComponent;                                // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBillboardComponent*                    BillboardComponent;                                // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Trigger">();
	}
	static class ATrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrigger>();
	}
};
static_assert(alignof(ATrigger) == 0x000008, "Wrong alignment on ATrigger");
static_assert(sizeof(ATrigger) == 0x0002A0, "Wrong size on ATrigger");
static_assert(offsetof(ATrigger, RootSceneComponent) == 0x000290, "Member 'ATrigger::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(ATrigger, BillboardComponent) == 0x000298, "Member 'ATrigger::BillboardComponent' has a wrong offset!");

// Class Zion.Trigger_FieldMessage
// 0x0028 (0x02C8 - 0x02A0)
class ATrigger_FieldMessage : public ATrigger
{
public:
	class UFieldMessageComponent*                 FieldMessageComponent;                             // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClearComponent*                        ClearComponent;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFieldMessageAsset*                     FieldMessageAsset;                                 // 0x02B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Cooldown;                                          // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAbortOnNewFieldMessage;                           // 0x02BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BD[0xB];                                      // 0x02BD(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LaunchFieldMessage(class UFieldMessageAsset* FieldMessageAssetOverride);
	void OnClearStatusChecked(EClearStatus ClearStatus);
	void OnFieldMessageFinished();

	class AActor* GetTargetActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Trigger_FieldMessage">();
	}
	static class ATrigger_FieldMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrigger_FieldMessage>();
	}
};
static_assert(alignof(ATrigger_FieldMessage) == 0x000008, "Wrong alignment on ATrigger_FieldMessage");
static_assert(sizeof(ATrigger_FieldMessage) == 0x0002C8, "Wrong size on ATrigger_FieldMessage");
static_assert(offsetof(ATrigger_FieldMessage, FieldMessageComponent) == 0x0002A0, "Member 'ATrigger_FieldMessage::FieldMessageComponent' has a wrong offset!");
static_assert(offsetof(ATrigger_FieldMessage, ClearComponent) == 0x0002A8, "Member 'ATrigger_FieldMessage::ClearComponent' has a wrong offset!");
static_assert(offsetof(ATrigger_FieldMessage, FieldMessageAsset) == 0x0002B0, "Member 'ATrigger_FieldMessage::FieldMessageAsset' has a wrong offset!");
static_assert(offsetof(ATrigger_FieldMessage, Cooldown) == 0x0002B8, "Member 'ATrigger_FieldMessage::Cooldown' has a wrong offset!");
static_assert(offsetof(ATrigger_FieldMessage, bAbortOnNewFieldMessage) == 0x0002BC, "Member 'ATrigger_FieldMessage::bAbortOnNewFieldMessage' has a wrong offset!");

// Class Zion.Trigger_FieldMessageNPC
// 0x0128 (0x03F0 - 0x02C8)
class alignas(0x10) ATrigger_FieldMessageNPC : public ATrigger_FieldMessage
{
public:
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UChildActorComponent*                   ChildActorComponent;                               // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayConditionRefreshComponent*     ConditionRefreshComponent;                         // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   NPCClass;                                          // 0x02E0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FFieldMessageNPCData>           NPCDataList;                                       // 0x0308(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFieldMessageAsset*                     OverrideFieldMessageAsset;                         // 0x0320(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0xC8];                                     // 0x0328(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNPCDestroyed(class AActor* DestroyedActor);

	class UShapeComponent* GetCollisionComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Trigger_FieldMessageNPC">();
	}
	static class ATrigger_FieldMessageNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrigger_FieldMessageNPC>();
	}
};
static_assert(alignof(ATrigger_FieldMessageNPC) == 0x000010, "Wrong alignment on ATrigger_FieldMessageNPC");
static_assert(sizeof(ATrigger_FieldMessageNPC) == 0x0003F0, "Wrong size on ATrigger_FieldMessageNPC");
static_assert(offsetof(ATrigger_FieldMessageNPC, ChildActorComponent) == 0x0002D0, "Member 'ATrigger_FieldMessageNPC::ChildActorComponent' has a wrong offset!");
static_assert(offsetof(ATrigger_FieldMessageNPC, ConditionRefreshComponent) == 0x0002D8, "Member 'ATrigger_FieldMessageNPC::ConditionRefreshComponent' has a wrong offset!");
static_assert(offsetof(ATrigger_FieldMessageNPC, NPCClass) == 0x0002E0, "Member 'ATrigger_FieldMessageNPC::NPCClass' has a wrong offset!");
static_assert(offsetof(ATrigger_FieldMessageNPC, NPCDataList) == 0x000308, "Member 'ATrigger_FieldMessageNPC::NPCDataList' has a wrong offset!");
static_assert(offsetof(ATrigger_FieldMessageNPC, OverrideFieldMessageAsset) == 0x000320, "Member 'ATrigger_FieldMessageNPC::OverrideFieldMessageAsset' has a wrong offset!");

// Class Zion.StateBusy
// 0x0000 (0x0028 - 0x0028)
class UStateBusy : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateBusy">();
	}
	static class UStateBusy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateBusy>();
	}
};
static_assert(alignof(UStateBusy) == 0x000008, "Wrong alignment on UStateBusy");
static_assert(sizeof(UStateBusy) == 0x000028, "Wrong size on UStateBusy");

// Class Zion.ActivitySubsystem
// 0x0048 (0x0078 - 0x0030)
class UActivitySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivitySubsystem">();
	}
	static class UActivitySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivitySubsystem>();
	}
};
static_assert(alignof(UActivitySubsystem) == 0x000008, "Wrong alignment on UActivitySubsystem");
static_assert(sizeof(UActivitySubsystem) == 0x000078, "Wrong size on UActivitySubsystem");

// Class Zion.CommandCondition
// 0x0010 (0x0038 - 0x0028)
class UCommandCondition : public UObject
{
public:
	bool                                          bInvertCondition;                                  // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0xF];                                       // 0x0029(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInitialize();

	class ACharacter* GetCharacter() const;
	class UCommand* GetCommand() const;
	bool OnCheckCondition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition">();
	}
	static class UCommandCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition>();
	}
};
static_assert(alignof(UCommandCondition) == 0x000008, "Wrong alignment on UCommandCondition");
static_assert(sizeof(UCommandCondition) == 0x000038, "Wrong size on UCommandCondition");
static_assert(offsetof(UCommandCondition, bInvertCondition) == 0x000028, "Member 'UCommandCondition::bInvertCondition' has a wrong offset!");

// Class Zion.CommandCondition_IsSpecialModifierPressed
// 0x0010 (0x0048 - 0x0038)
class UCommandCondition_IsSpecialModifierPressed final : public UCommandCondition
{
public:
	class UInputAction*                           SpecialInputAction;                                // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_IsSpecialModifierPressed">();
	}
	static class UCommandCondition_IsSpecialModifierPressed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_IsSpecialModifierPressed>();
	}
};
static_assert(alignof(UCommandCondition_IsSpecialModifierPressed) == 0x000008, "Wrong alignment on UCommandCondition_IsSpecialModifierPressed");
static_assert(sizeof(UCommandCondition_IsSpecialModifierPressed) == 0x000048, "Wrong size on UCommandCondition_IsSpecialModifierPressed");
static_assert(offsetof(UCommandCondition_IsSpecialModifierPressed, SpecialInputAction) == 0x000038, "Member 'UCommandCondition_IsSpecialModifierPressed::SpecialInputAction' has a wrong offset!");

// Class Zion.EventAction_Choice
// 0x0040 (0x0090 - 0x0050)
class UEventAction_Choice final : public UEventAction
{
public:
	class FText                                   Speaker;                                           // 0x0050(0x0010)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   ChoiceLine;                                        // 0x0060(0x0010)(Edit, NativeAccessSpecifierPrivate)
	class FName                                   ChoiceSaveKey;                                     // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FChoiceEntryData>               ChoicesData;                                       // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_Choice">();
	}
	static class UEventAction_Choice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_Choice>();
	}
};
static_assert(alignof(UEventAction_Choice) == 0x000008, "Wrong alignment on UEventAction_Choice");
static_assert(sizeof(UEventAction_Choice) == 0x000090, "Wrong size on UEventAction_Choice");
static_assert(offsetof(UEventAction_Choice, Speaker) == 0x000050, "Member 'UEventAction_Choice::Speaker' has a wrong offset!");
static_assert(offsetof(UEventAction_Choice, ChoiceLine) == 0x000060, "Member 'UEventAction_Choice::ChoiceLine' has a wrong offset!");
static_assert(offsetof(UEventAction_Choice, ChoiceSaveKey) == 0x000070, "Member 'UEventAction_Choice::ChoiceSaveKey' has a wrong offset!");
static_assert(offsetof(UEventAction_Choice, ChoicesData) == 0x000078, "Member 'UEventAction_Choice::ChoicesData' has a wrong offset!");

// Class Zion.StateFreezeCritical
// 0x0000 (0x0028 - 0x0028)
class UStateFreezeCritical final : public UStateBusy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateFreezeCritical">();
	}
	static class UStateFreezeCritical* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateFreezeCritical>();
	}
};
static_assert(alignof(UStateFreezeCritical) == 0x000008, "Wrong alignment on UStateFreezeCritical");
static_assert(sizeof(UStateFreezeCritical) == 0x000028, "Wrong size on UStateFreezeCritical");

// Class Zion.CommandModule_PhaseLevel_Set
// 0x0010 (0x0048 - 0x0038)
class UCommandModule_PhaseLevel_Set final : public UCommandModule
{
public:
	int32                                         PhaseLevel;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0xC];                                       // 0x003C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_PhaseLevel_Set">();
	}
	static class UCommandModule_PhaseLevel_Set* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_PhaseLevel_Set>();
	}
};
static_assert(alignof(UCommandModule_PhaseLevel_Set) == 0x000008, "Wrong alignment on UCommandModule_PhaseLevel_Set");
static_assert(sizeof(UCommandModule_PhaseLevel_Set) == 0x000048, "Wrong size on UCommandModule_PhaseLevel_Set");
static_assert(offsetof(UCommandModule_PhaseLevel_Set, PhaseLevel) == 0x000038, "Member 'UCommandModule_PhaseLevel_Set::PhaseLevel' has a wrong offset!");

// Class Zion.UserWidgetZionBase
// 0x0008 (0x02E8 - 0x02E0)
class UUserWidgetZionBase : public UUserWidget
{
public:
	bool                                          bTickWhenPaused;                                   // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetZionBase">();
	}
	static class UUserWidgetZionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetZionBase>();
	}
};
static_assert(alignof(UUserWidgetZionBase) == 0x000008, "Wrong alignment on UUserWidgetZionBase");
static_assert(sizeof(UUserWidgetZionBase) == 0x0002E8, "Wrong size on UUserWidgetZionBase");
static_assert(offsetof(UUserWidgetZionBase, bTickWhenPaused) == 0x0002E0, "Member 'UUserWidgetZionBase::bTickWhenPaused' has a wrong offset!");

// Class Zion.UserWidgetZion
// 0x0178 (0x0460 - 0x02E8)
class UUserWidgetZion : public UUserWidgetZionBase
{
public:
	TMulticastInlineDelegate<void()>              OnDestruct;                                        // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bMouseHoverFocus;                                  // 0x02F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTriggerOnChildFocus;                              // 0x02F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAcceptRepeatKeys;                                 // 0x02FA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FB[0x15];                                     // 0x02FB(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	class UNativeWidgetHost*                      WidgetHost;                                        // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             OnConfirmFMODEvent;                                // 0x0318(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             OnCancelFMODEvent;                                 // 0x0320(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             OnNavigationFMODEvent;                             // 0x0328(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FFooterData>                    FooterEntries;                                     // 0x0330(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FText                                   ExplanationText;                                   // 0x0340(0x0010)(Edit, NativeAccessSpecifierPrivate)
	TMap<EBuildPlatformType, class FText>         ExplanationTextPerPlatforms;                       // 0x0350(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TArray<struct FRichTextInputElement>          ExplanationInputElements;                          // 0x03A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         ExplanationStringElements;                         // 0x03B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0xA0];                                     // 0x03C0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeExplanationText(const class FText& InExplanationText);
	void OnChildFocused(class UNativeWidgetHost* FocusedWidgetHost, const struct FFocusEvent& FocusEvent);
	struct FEventReply OnDownLeft(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnDownNext(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnDownNextAlt(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnDownPrevious(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnDownPreviousAlt(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnDownRight(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnPressCancel(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnPressConfirm(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnPressContext(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnPressContextAlt(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnPressDown(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnPressLeft(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnPressNext(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnPressNextAlt(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnPressPrevious(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnPressPreviousAlt(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnPressRight(const struct FKeyEvent& KeyEvent);
	struct FEventReply OnPressUp(const struct FKeyEvent& KeyEvent);
	void OnSetIsEnabled(bool bInIsEnabled);
	void ResetLastFocusedChild();
	void SetFocusToLastFocusedChild(class UWidget* FallbackWidget);

	bool IsFocusedFromMouse() const;
	bool IsOnFocusPath() const;
	void PlaySoundEvent(class UFMODEvent* SoundEffect) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetZion">();
	}
	static class UUserWidgetZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetZion>();
	}
};
static_assert(alignof(UUserWidgetZion) == 0x000008, "Wrong alignment on UUserWidgetZion");
static_assert(sizeof(UUserWidgetZion) == 0x000460, "Wrong size on UUserWidgetZion");
static_assert(offsetof(UUserWidgetZion, OnDestruct) == 0x0002E8, "Member 'UUserWidgetZion::OnDestruct' has a wrong offset!");
static_assert(offsetof(UUserWidgetZion, bMouseHoverFocus) == 0x0002F8, "Member 'UUserWidgetZion::bMouseHoverFocus' has a wrong offset!");
static_assert(offsetof(UUserWidgetZion, bTriggerOnChildFocus) == 0x0002F9, "Member 'UUserWidgetZion::bTriggerOnChildFocus' has a wrong offset!");
static_assert(offsetof(UUserWidgetZion, bAcceptRepeatKeys) == 0x0002FA, "Member 'UUserWidgetZion::bAcceptRepeatKeys' has a wrong offset!");
static_assert(offsetof(UUserWidgetZion, WidgetHost) == 0x000310, "Member 'UUserWidgetZion::WidgetHost' has a wrong offset!");
static_assert(offsetof(UUserWidgetZion, OnConfirmFMODEvent) == 0x000318, "Member 'UUserWidgetZion::OnConfirmFMODEvent' has a wrong offset!");
static_assert(offsetof(UUserWidgetZion, OnCancelFMODEvent) == 0x000320, "Member 'UUserWidgetZion::OnCancelFMODEvent' has a wrong offset!");
static_assert(offsetof(UUserWidgetZion, OnNavigationFMODEvent) == 0x000328, "Member 'UUserWidgetZion::OnNavigationFMODEvent' has a wrong offset!");
static_assert(offsetof(UUserWidgetZion, FooterEntries) == 0x000330, "Member 'UUserWidgetZion::FooterEntries' has a wrong offset!");
static_assert(offsetof(UUserWidgetZion, ExplanationText) == 0x000340, "Member 'UUserWidgetZion::ExplanationText' has a wrong offset!");
static_assert(offsetof(UUserWidgetZion, ExplanationTextPerPlatforms) == 0x000350, "Member 'UUserWidgetZion::ExplanationTextPerPlatforms' has a wrong offset!");
static_assert(offsetof(UUserWidgetZion, ExplanationInputElements) == 0x0003A0, "Member 'UUserWidgetZion::ExplanationInputElements' has a wrong offset!");
static_assert(offsetof(UUserWidgetZion, ExplanationStringElements) == 0x0003B0, "Member 'UUserWidgetZion::ExplanationStringElements' has a wrong offset!");

// Class Zion.UserWidgetEvent
// 0x0050 (0x04B0 - 0x0460)
class UUserWidgetEvent : public UUserWidgetZion
{
public:
	uint8                                         Pad_460[0x50];                                     // 0x0460(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CompleteChoices(int32 SelectedChoiceIndex);
	void CompleteTalk();
	void OnNotifyEventStartPlaying();
	void OnPlayChoices(const class FText& SpeakerName, const class FText& Text, const TArray<class FText>& Choices);
	void OnRequestRemoveFromParent();
	void OnTalk(const class FText& SpeakerName, const class FText& Text, float Duration);

	bool CanAutoSkipEvent() const;
	bool CanSkipEvent() const;
	class UEventPlayer* GetEventPlayer() const;
	bool IsEventAlreadySeen() const;
	bool ShouldUsePostSkipFadeIn() const;
	bool ShouldUsePreSkipFadeOut() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetEvent">();
	}
	static class UUserWidgetEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetEvent>();
	}
};
static_assert(alignof(UUserWidgetEvent) == 0x000008, "Wrong alignment on UUserWidgetEvent");
static_assert(sizeof(UUserWidgetEvent) == 0x0004B0, "Wrong size on UUserWidgetEvent");

// Class Zion.StateInvincible
// 0x0000 (0x0028 - 0x0028)
class UStateInvincible final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateInvincible">();
	}
	static class UStateInvincible* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateInvincible>();
	}
};
static_assert(alignof(UStateInvincible) == 0x000008, "Wrong alignment on UStateInvincible");
static_assert(sizeof(UStateInvincible) == 0x000028, "Wrong size on UStateInvincible");

// Class Zion.AbilityEffectInstant_HealHP
// 0x0010 (0x0060 - 0x0050)
class UAbilityEffectInstant_HealHP final : public UAbilityEffectInstant
{
public:
	EHealEffectType                               HealEffectType;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AbsoluteHeal;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TargetPercentageHeal;                              // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_HealHP">();
	}
	static class UAbilityEffectInstant_HealHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_HealHP>();
	}
};
static_assert(alignof(UAbilityEffectInstant_HealHP) == 0x000008, "Wrong alignment on UAbilityEffectInstant_HealHP");
static_assert(sizeof(UAbilityEffectInstant_HealHP) == 0x000060, "Wrong size on UAbilityEffectInstant_HealHP");
static_assert(offsetof(UAbilityEffectInstant_HealHP, HealEffectType) == 0x000050, "Member 'UAbilityEffectInstant_HealHP::HealEffectType' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_HealHP, AbsoluteHeal) == 0x000054, "Member 'UAbilityEffectInstant_HealHP::AbsoluteHeal' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_HealHP, TargetPercentageHeal) == 0x000058, "Member 'UAbilityEffectInstant_HealHP::TargetPercentageHeal' has a wrong offset!");

// Class Zion.CommandModule_PlayAnimation
// 0x00C0 (0x00F8 - 0x0038)
class UCommandModule_PlayAnimation : public UCommandModule
{
public:
	TArray<struct FSpineAnimationDefinition>      AnimationDefinitions;                              // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<struct FMovementModeData, struct FAnimationDefinitionList> OverrideForMovementModes;        // 0x0048(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<EMovementSpeedMode, struct FAnimationDefinitionList> OverrideForMovementSpeedModes;         // 0x0098(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_PlayAnimation">();
	}
	static class UCommandModule_PlayAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_PlayAnimation>();
	}
};
static_assert(alignof(UCommandModule_PlayAnimation) == 0x000008, "Wrong alignment on UCommandModule_PlayAnimation");
static_assert(sizeof(UCommandModule_PlayAnimation) == 0x0000F8, "Wrong size on UCommandModule_PlayAnimation");
static_assert(offsetof(UCommandModule_PlayAnimation, AnimationDefinitions) == 0x000038, "Member 'UCommandModule_PlayAnimation::AnimationDefinitions' has a wrong offset!");
static_assert(offsetof(UCommandModule_PlayAnimation, OverrideForMovementModes) == 0x000048, "Member 'UCommandModule_PlayAnimation::OverrideForMovementModes' has a wrong offset!");
static_assert(offsetof(UCommandModule_PlayAnimation, OverrideForMovementSpeedModes) == 0x000098, "Member 'UCommandModule_PlayAnimation::OverrideForMovementSpeedModes' has a wrong offset!");

// Class Zion.StateKnockbackLaunch
// 0x0000 (0x0028 - 0x0028)
class UStateKnockbackLaunch final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateKnockbackLaunch">();
	}
	static class UStateKnockbackLaunch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateKnockbackLaunch>();
	}
};
static_assert(alignof(UStateKnockbackLaunch) == 0x000008, "Wrong alignment on UStateKnockbackLaunch");
static_assert(sizeof(UStateKnockbackLaunch) == 0x000028, "Wrong size on UStateKnockbackLaunch");

// Class Zion.Collectable
// 0x0070 (0x0300 - 0x0290)
class ACollectable : public AActor
{
public:
	class UNiagaraSystem*                         FXSystem;                                          // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActivateOnBeginPlay;                              // 0x0298(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableCollisionOnActivate;                        // 0x0299(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDetectionMatchReachedRange;                       // 0x029A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29B[0x1];                                      // 0x029B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetDetectionRange;                              // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeBeforeTargetReachActivation;                // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             OnCollectFMODEvent;                                // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        RootSceneComponent;                                // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       TargetDetectionComponent;                          // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       TargetReachedComponent;                            // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHomingComponent*                       HomingComponent;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      FXInstance;                                        // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Collect(class AActor* CollectActor);
	void OnPostSwitchZone(const class AStaticVolume_Zone* ActiveZone);
	void OnTargetOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void SetActive(bool bSetActive);

	class AActor* GetCollectingActor() const;
	float GetTargetDetectionRange() const;
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Collectable">();
	}
	static class ACollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectable>();
	}
};
static_assert(alignof(ACollectable) == 0x000008, "Wrong alignment on ACollectable");
static_assert(sizeof(ACollectable) == 0x000300, "Wrong size on ACollectable");
static_assert(offsetof(ACollectable, FXSystem) == 0x000290, "Member 'ACollectable::FXSystem' has a wrong offset!");
static_assert(offsetof(ACollectable, bActivateOnBeginPlay) == 0x000298, "Member 'ACollectable::bActivateOnBeginPlay' has a wrong offset!");
static_assert(offsetof(ACollectable, bEnableCollisionOnActivate) == 0x000299, "Member 'ACollectable::bEnableCollisionOnActivate' has a wrong offset!");
static_assert(offsetof(ACollectable, bDetectionMatchReachedRange) == 0x00029A, "Member 'ACollectable::bDetectionMatchReachedRange' has a wrong offset!");
static_assert(offsetof(ACollectable, TargetDetectionRange) == 0x00029C, "Member 'ACollectable::TargetDetectionRange' has a wrong offset!");
static_assert(offsetof(ACollectable, MinTimeBeforeTargetReachActivation) == 0x0002A0, "Member 'ACollectable::MinTimeBeforeTargetReachActivation' has a wrong offset!");
static_assert(offsetof(ACollectable, OnCollectFMODEvent) == 0x0002A8, "Member 'ACollectable::OnCollectFMODEvent' has a wrong offset!");
static_assert(offsetof(ACollectable, RootSceneComponent) == 0x0002C0, "Member 'ACollectable::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(ACollectable, TargetDetectionComponent) == 0x0002C8, "Member 'ACollectable::TargetDetectionComponent' has a wrong offset!");
static_assert(offsetof(ACollectable, TargetReachedComponent) == 0x0002D0, "Member 'ACollectable::TargetReachedComponent' has a wrong offset!");
static_assert(offsetof(ACollectable, HomingComponent) == 0x0002D8, "Member 'ACollectable::HomingComponent' has a wrong offset!");
static_assert(offsetof(ACollectable, FXInstance) == 0x0002E0, "Member 'ACollectable::FXInstance' has a wrong offset!");

// Class Zion.Collectable_GameplayEffect
// 0x0010 (0x0310 - 0x0300)
class ACollectable_GameplayEffect final : public ACollectable
{
public:
	TArray<class UGameplayEffect*>                Effects;                                           // 0x0300(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Collectable_GameplayEffect">();
	}
	static class ACollectable_GameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectable_GameplayEffect>();
	}
};
static_assert(alignof(ACollectable_GameplayEffect) == 0x000008, "Wrong alignment on ACollectable_GameplayEffect");
static_assert(sizeof(ACollectable_GameplayEffect) == 0x000310, "Wrong size on ACollectable_GameplayEffect");
static_assert(offsetof(ACollectable_GameplayEffect, Effects) == 0x000300, "Member 'ACollectable_GameplayEffect::Effects' has a wrong offset!");

// Class Zion.AbilityEffectInstant_BreakPart
// 0x0008 (0x0058 - 0x0050)
class UAbilityEffectInstant_BreakPart final : public UAbilityEffectInstant
{
public:
	EBreakType                                    BreakType;                                         // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_BreakPart">();
	}
	static class UAbilityEffectInstant_BreakPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_BreakPart>();
	}
};
static_assert(alignof(UAbilityEffectInstant_BreakPart) == 0x000008, "Wrong alignment on UAbilityEffectInstant_BreakPart");
static_assert(sizeof(UAbilityEffectInstant_BreakPart) == 0x000058, "Wrong size on UAbilityEffectInstant_BreakPart");
static_assert(offsetof(UAbilityEffectInstant_BreakPart, BreakType) == 0x000050, "Member 'UAbilityEffectInstant_BreakPart::BreakType' has a wrong offset!");

// Class Zion.GameplayEffect
// 0x0000 (0x0028 - 0x0028)
class UGameplayEffect : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEffect">();
	}
	static class UGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffect>();
	}
};
static_assert(alignof(UGameplayEffect) == 0x000008, "Wrong alignment on UGameplayEffect");
static_assert(sizeof(UGameplayEffect) == 0x000028, "Wrong size on UGameplayEffect");

// Class Zion.RefreshableRichTextBlock
// 0x0060 (0x0910 - 0x08B0)
class URefreshableRichTextBlock final : public URichTextBlock
{
public:
	ERichTextDecoratorMode                        DecoratorMode;                                     // 0x08B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8B1[0x7];                                      // 0x08B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Format;                                            // 0x08B8(0x0010)(Edit, NativeAccessSpecifierPrivate)
	TArray<struct FRichTextInputElement>          FormatElements;                                    // 0x08C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         FormatStrings;                                     // 0x08D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E8[0x28];                                     // 0x08E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Refresh();
	void SetDecoratorMode(ERichTextDecoratorMode NewDecoratorMode);
	void SetFormat(const class FText& NewFormat);
	void SetFormatElements(const TArray<struct FRichTextInputElement>& NewFormatElements, const TArray<class FString>& NewStringElements);
	void SetupAndRefresh(const class FText& NewFormat, const TArray<struct FRichTextInputElement>& NewFormatElements, const TArray<class FString>& NewStringElements);

	ERichTextDecoratorMode GetDecoratorMode() const;
	const TArray<struct FRichTextInputElement> GetFormatElements() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RefreshableRichTextBlock">();
	}
	static class URefreshableRichTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<URefreshableRichTextBlock>();
	}
};
static_assert(alignof(URefreshableRichTextBlock) == 0x000010, "Wrong alignment on URefreshableRichTextBlock");
static_assert(sizeof(URefreshableRichTextBlock) == 0x000910, "Wrong size on URefreshableRichTextBlock");
static_assert(offsetof(URefreshableRichTextBlock, DecoratorMode) == 0x0008B0, "Member 'URefreshableRichTextBlock::DecoratorMode' has a wrong offset!");
static_assert(offsetof(URefreshableRichTextBlock, Format) == 0x0008B8, "Member 'URefreshableRichTextBlock::Format' has a wrong offset!");
static_assert(offsetof(URefreshableRichTextBlock, FormatElements) == 0x0008C8, "Member 'URefreshableRichTextBlock::FormatElements' has a wrong offset!");
static_assert(offsetof(URefreshableRichTextBlock, FormatStrings) == 0x0008D8, "Member 'URefreshableRichTextBlock::FormatStrings' has a wrong offset!");

// Class Zion.StateKnockback
// 0x0000 (0x0028 - 0x0028)
class UStateKnockback final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateKnockback">();
	}
	static class UStateKnockback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateKnockback>();
	}
};
static_assert(alignof(UStateKnockback) == 0x000008, "Wrong alignment on UStateKnockback");
static_assert(sizeof(UStateKnockback) == 0x000028, "Wrong size on UStateKnockback");

// Class Zion.AbilityHitboxMoving
// 0x0000 (0x0AC0 - 0x0AC0)
class AAbilityHitboxMoving : public AAbilityHitbox
{
public:
	class UZionProjectileMovementComponent*       ZionProjectileMovementComponent;                   // 0x0AB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityHitboxMoving">();
	}
	static class AAbilityHitboxMoving* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityHitboxMoving>();
	}
};
static_assert(alignof(AAbilityHitboxMoving) == 0x000010, "Wrong alignment on AAbilityHitboxMoving");
static_assert(sizeof(AAbilityHitboxMoving) == 0x000AC0, "Wrong size on AAbilityHitboxMoving");
static_assert(offsetof(AAbilityHitboxMoving, ZionProjectileMovementComponent) == 0x000AB8, "Member 'AAbilityHitboxMoving::ZionProjectileMovementComponent' has a wrong offset!");

// Class Zion.CommandCondition_HasAptitude
// 0x0018 (0x0050 - 0x0038)
class UCommandCondition_HasAptitude final : public UCommandCondition
{
public:
	TArray<EAptitudeType>                         Aptitudes;                                         // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_HasAptitude">();
	}
	static class UCommandCondition_HasAptitude* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_HasAptitude>();
	}
};
static_assert(alignof(UCommandCondition_HasAptitude) == 0x000008, "Wrong alignment on UCommandCondition_HasAptitude");
static_assert(sizeof(UCommandCondition_HasAptitude) == 0x000050, "Wrong size on UCommandCondition_HasAptitude");
static_assert(offsetof(UCommandCondition_HasAptitude, Aptitudes) == 0x000038, "Member 'UCommandCondition_HasAptitude::Aptitudes' has a wrong offset!");

// Class Zion.PlayerControllerZionBase
// 0x0000 (0x0858 - 0x0858)
class APlayerControllerZionBase : public APlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerZionBase">();
	}
	static class APlayerControllerZionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerControllerZionBase>();
	}
};
static_assert(alignof(APlayerControllerZionBase) == 0x000008, "Wrong alignment on APlayerControllerZionBase");
static_assert(sizeof(APlayerControllerZionBase) == 0x000858, "Wrong size on APlayerControllerZionBase");

// Class Zion.StateGuard_Back
// 0x0000 (0x0028 - 0x0028)
class UStateGuard_Back final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateGuard_Back">();
	}
	static class UStateGuard_Back* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateGuard_Back>();
	}
};
static_assert(alignof(UStateGuard_Back) == 0x000008, "Wrong alignment on UStateGuard_Back");
static_assert(sizeof(UStateGuard_Back) == 0x000028, "Wrong size on UStateGuard_Back");

// Class Zion.DebugDisplayComponent
// 0x00D8 (0x0178 - 0x00A0)
class UDebugDisplayComponent final : public UActorComponent
{
public:
	TSubclassOf<class UUserWidgetWorldSpaceDebug> WidgetClass;                                       // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                WorldSpaceLocationOffset;                          // 0x00A8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AWorldSpaceWidgetHolder*                WidgetHolder;                                      // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidgetWorldSpaceDebug*             Widget;                                            // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0xA8];                                      // 0x00D0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationEnd(class UTrackEntry* Entry);
	void OnAnimationStart(class UTrackEntry* Entry);
	void OnCommandFinished(const class UCommand* Command, ECommandFinishType FinishType);
	void OnCommandLevelChanged();
	void OnCommandStart(const class UCommand* Command);
	void OnHPValueChanged();
	void OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void OnTickLevel();
	void OnTickSpineTextureInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugDisplayComponent">();
	}
	static class UDebugDisplayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugDisplayComponent>();
	}
};
static_assert(alignof(UDebugDisplayComponent) == 0x000008, "Wrong alignment on UDebugDisplayComponent");
static_assert(sizeof(UDebugDisplayComponent) == 0x000178, "Wrong size on UDebugDisplayComponent");
static_assert(offsetof(UDebugDisplayComponent, WidgetClass) == 0x0000A0, "Member 'UDebugDisplayComponent::WidgetClass' has a wrong offset!");
static_assert(offsetof(UDebugDisplayComponent, WorldSpaceLocationOffset) == 0x0000A8, "Member 'UDebugDisplayComponent::WorldSpaceLocationOffset' has a wrong offset!");
static_assert(offsetof(UDebugDisplayComponent, WidgetHolder) == 0x0000C0, "Member 'UDebugDisplayComponent::WidgetHolder' has a wrong offset!");
static_assert(offsetof(UDebugDisplayComponent, Widget) == 0x0000C8, "Member 'UDebugDisplayComponent::Widget' has a wrong offset!");

// Class Zion.Trigger_Event
// 0x0030 (0x02D0 - 0x02A0)
class ATrigger_Event final : public ATrigger
{
public:
	TArray<struct FEventData>                     EventDataList;                                     // 0x02A0(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UGameplayConditionRefreshComponent*     ConditionRefreshComponent;                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEventAsset*                            LoadedEventAsset;                                  // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEventPlayer*                           EventPlayer;                                       // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEventFinish();
	void OnEventFinished(class UEventPlayer* InEventPlayer, bool bCompletedEvent, EEventPlayerResult EventResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Trigger_Event">();
	}
	static class ATrigger_Event* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrigger_Event>();
	}
};
static_assert(alignof(ATrigger_Event) == 0x000008, "Wrong alignment on ATrigger_Event");
static_assert(sizeof(ATrigger_Event) == 0x0002D0, "Wrong size on ATrigger_Event");
static_assert(offsetof(ATrigger_Event, EventDataList) == 0x0002A0, "Member 'ATrigger_Event::EventDataList' has a wrong offset!");
static_assert(offsetof(ATrigger_Event, ConditionRefreshComponent) == 0x0002B0, "Member 'ATrigger_Event::ConditionRefreshComponent' has a wrong offset!");
static_assert(offsetof(ATrigger_Event, LoadedEventAsset) == 0x0002B8, "Member 'ATrigger_Event::LoadedEventAsset' has a wrong offset!");
static_assert(offsetof(ATrigger_Event, EventPlayer) == 0x0002C0, "Member 'ATrigger_Event::EventPlayer' has a wrong offset!");

// Class Zion.StateGuard_Front
// 0x0000 (0x0028 - 0x0028)
class UStateGuard_Front final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateGuard_Front">();
	}
	static class UStateGuard_Front* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateGuard_Front>();
	}
};
static_assert(alignof(UStateGuard_Front) == 0x000008, "Wrong alignment on UStateGuard_Front");
static_assert(sizeof(UStateGuard_Front) == 0x000028, "Wrong size on UStateGuard_Front");

// Class Zion.AbilityEffectInstant_SetTargetInvincible
// 0x0008 (0x0058 - 0x0050)
class UAbilityEffectInstant_SetTargetInvincible final : public UAbilityEffectInstant
{
public:
	float                                         Duration;                                          // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_SetTargetInvincible">();
	}
	static class UAbilityEffectInstant_SetTargetInvincible* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_SetTargetInvincible>();
	}
};
static_assert(alignof(UAbilityEffectInstant_SetTargetInvincible) == 0x000008, "Wrong alignment on UAbilityEffectInstant_SetTargetInvincible");
static_assert(sizeof(UAbilityEffectInstant_SetTargetInvincible) == 0x000058, "Wrong size on UAbilityEffectInstant_SetTargetInvincible");
static_assert(offsetof(UAbilityEffectInstant_SetTargetInvincible, Duration) == 0x000050, "Member 'UAbilityEffectInstant_SetTargetInvincible::Duration' has a wrong offset!");

// Class Zion.DelayFrameAsyncAction
// 0x0028 (0x0058 - 0x0030)
class UDelayFrameAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDelayFrameAsyncAction* DelayFrame(const class UObject* WorldContextObject, int32 DelayInFrames);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelayFrameAsyncAction">();
	}
	static class UDelayFrameAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelayFrameAsyncAction>();
	}
};
static_assert(alignof(UDelayFrameAsyncAction) == 0x000008, "Wrong alignment on UDelayFrameAsyncAction");
static_assert(sizeof(UDelayFrameAsyncAction) == 0x000058, "Wrong size on UDelayFrameAsyncAction");
static_assert(offsetof(UDelayFrameAsyncAction, OnFinish) == 0x000030, "Member 'UDelayFrameAsyncAction::OnFinish' has a wrong offset!");

// Class Zion.StateInEvent
// 0x0000 (0x0028 - 0x0028)
class UStateInEvent final : public UStateBusy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateInEvent">();
	}
	static class UStateInEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateInEvent>();
	}
};
static_assert(alignof(UStateInEvent) == 0x000008, "Wrong alignment on UStateInEvent");
static_assert(sizeof(UStateInEvent) == 0x000028, "Wrong size on UStateInEvent");

// Class Zion.CommandCharge
// 0x0028 (0x00D0 - 0x00A8)
class UCommandCharge : public UCommand
{
public:
	TArray<struct FChargeReleaseData>             ReleaseDataArray;                                  // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bAutoRelease;                                      // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECommandMinimumChargeType                     MinimumChargeType;                                 // 0x00B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumChargeTime;                                 // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChargeLevelUp(int32 NewChargeLevel);
	void OnRelease();

	int32 GetChargeLevel() const;
	bool IsReleased() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCharge">();
	}
	static class UCommandCharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCharge>();
	}
};
static_assert(alignof(UCommandCharge) == 0x000008, "Wrong alignment on UCommandCharge");
static_assert(sizeof(UCommandCharge) == 0x0000D0, "Wrong size on UCommandCharge");
static_assert(offsetof(UCommandCharge, ReleaseDataArray) == 0x0000A8, "Member 'UCommandCharge::ReleaseDataArray' has a wrong offset!");
static_assert(offsetof(UCommandCharge, bAutoRelease) == 0x0000B8, "Member 'UCommandCharge::bAutoRelease' has a wrong offset!");
static_assert(offsetof(UCommandCharge, MinimumChargeType) == 0x0000B9, "Member 'UCommandCharge::MinimumChargeType' has a wrong offset!");
static_assert(offsetof(UCommandCharge, MinimumChargeTime) == 0x0000BC, "Member 'UCommandCharge::MinimumChargeTime' has a wrong offset!");

// Class Zion.AbilityEffectTimed_ShakeTarget
// 0x0068 (0x00C0 - 0x0058)
class UAbilityEffectTimed_ShakeTarget final : public UAbilityEffectTimed
{
public:
	struct FShakeData                             GroundShakeData;                                   // 0x0058(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FShakeData                             AirShakeData;                                      // 0x0088(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectTimed_ShakeTarget">();
	}
	static class UAbilityEffectTimed_ShakeTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectTimed_ShakeTarget>();
	}
};
static_assert(alignof(UAbilityEffectTimed_ShakeTarget) == 0x000008, "Wrong alignment on UAbilityEffectTimed_ShakeTarget");
static_assert(sizeof(UAbilityEffectTimed_ShakeTarget) == 0x0000C0, "Wrong size on UAbilityEffectTimed_ShakeTarget");
static_assert(offsetof(UAbilityEffectTimed_ShakeTarget, GroundShakeData) == 0x000058, "Member 'UAbilityEffectTimed_ShakeTarget::GroundShakeData' has a wrong offset!");
static_assert(offsetof(UAbilityEffectTimed_ShakeTarget, AirShakeData) == 0x000088, "Member 'UAbilityEffectTimed_ShakeTarget::AirShakeData' has a wrong offset!");

// Class Zion.GameplayCondition
// 0x0008 (0x0030 - 0x0028)
class UGameplayCondition : public UObject
{
public:
	bool                                          bInvertCondition;                                  // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CheckGameplayCondition(const TSubclassOf<class UGameplayCondition>& GameplayConditionClass, class APlayerController* PlayerController);

	bool OnCheckCondition(class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCondition">();
	}
	static class UGameplayCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCondition>();
	}
};
static_assert(alignof(UGameplayCondition) == 0x000008, "Wrong alignment on UGameplayCondition");
static_assert(sizeof(UGameplayCondition) == 0x000030, "Wrong size on UGameplayCondition");
static_assert(offsetof(UGameplayCondition, bInvertCondition) == 0x000028, "Member 'UGameplayCondition::bInvertCondition' has a wrong offset!");

// Class Zion.GameplayCondition_HasItem
// 0x0010 (0x0040 - 0x0030)
class UGameplayCondition_HasItem final : public UGameplayCondition
{
public:
	struct FDataTableRowHandle                    Item;                                              // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCondition_HasItem">();
	}
	static class UGameplayCondition_HasItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCondition_HasItem>();
	}
};
static_assert(alignof(UGameplayCondition_HasItem) == 0x000008, "Wrong alignment on UGameplayCondition_HasItem");
static_assert(sizeof(UGameplayCondition_HasItem) == 0x000040, "Wrong size on UGameplayCondition_HasItem");
static_assert(offsetof(UGameplayCondition_HasItem, Item) == 0x000030, "Member 'UGameplayCondition_HasItem::Item' has a wrong offset!");

// Class Zion.CommandModule_AbilityShockwave
// 0x01D8 (0x0210 - 0x0038)
class UCommandModule_AbilityShockwave final : public UCommandModule
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityData                           AbilityData;                                       // 0x0050(0x00E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAbilityAdditionalData                 AbilityAdditionalData;                             // 0x0130(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         DelayBeforeFirstLaunch;                            // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DelayBetweenLaunch;                                // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxCount;                                          // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OffsetBetweenLaunch;                               // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAcceptableAngle;                                // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GroundCheckStartDistance;                          // 0x0154(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GroundMaxDistance;                                 // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseAdditionalGroundCheck;                         // 0x015C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15D[0x3];                                      // 0x015D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalGroundCheckDistanceStep;                 // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_164[0xAC];                                     // 0x0164(0x00AC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_AbilityShockwave">();
	}
	static class UCommandModule_AbilityShockwave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_AbilityShockwave>();
	}
};
static_assert(alignof(UCommandModule_AbilityShockwave) == 0x000010, "Wrong alignment on UCommandModule_AbilityShockwave");
static_assert(sizeof(UCommandModule_AbilityShockwave) == 0x000210, "Wrong size on UCommandModule_AbilityShockwave");
static_assert(offsetof(UCommandModule_AbilityShockwave, AbilityData) == 0x000050, "Member 'UCommandModule_AbilityShockwave::AbilityData' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityShockwave, AbilityAdditionalData) == 0x000130, "Member 'UCommandModule_AbilityShockwave::AbilityAdditionalData' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityShockwave, DelayBeforeFirstLaunch) == 0x000140, "Member 'UCommandModule_AbilityShockwave::DelayBeforeFirstLaunch' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityShockwave, DelayBetweenLaunch) == 0x000144, "Member 'UCommandModule_AbilityShockwave::DelayBetweenLaunch' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityShockwave, MaxCount) == 0x000148, "Member 'UCommandModule_AbilityShockwave::MaxCount' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityShockwave, OffsetBetweenLaunch) == 0x00014C, "Member 'UCommandModule_AbilityShockwave::OffsetBetweenLaunch' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityShockwave, MaxAcceptableAngle) == 0x000150, "Member 'UCommandModule_AbilityShockwave::MaxAcceptableAngle' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityShockwave, GroundCheckStartDistance) == 0x000154, "Member 'UCommandModule_AbilityShockwave::GroundCheckStartDistance' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityShockwave, GroundMaxDistance) == 0x000158, "Member 'UCommandModule_AbilityShockwave::GroundMaxDistance' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityShockwave, bUseAdditionalGroundCheck) == 0x00015C, "Member 'UCommandModule_AbilityShockwave::bUseAdditionalGroundCheck' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityShockwave, AdditionalGroundCheckDistanceStep) == 0x000160, "Member 'UCommandModule_AbilityShockwave::AdditionalGroundCheckDistanceStep' has a wrong offset!");

// Class Zion.StateLockInteract
// 0x0000 (0x0028 - 0x0028)
class UStateLockInteract final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateLockInteract">();
	}
	static class UStateLockInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateLockInteract>();
	}
};
static_assert(alignof(UStateLockInteract) == 0x000008, "Wrong alignment on UStateLockInteract");
static_assert(sizeof(UStateLockInteract) == 0x000028, "Wrong size on UStateLockInteract");

// Class Zion.StateBurn
// 0x0000 (0x0028 - 0x0028)
class UStateBurn final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateBurn">();
	}
	static class UStateBurn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateBurn>();
	}
};
static_assert(alignof(UStateBurn) == 0x000008, "Wrong alignment on UStateBurn");
static_assert(sizeof(UStateBurn) == 0x000028, "Wrong size on UStateBurn");

// Class Zion.BTDecorator_RandomChooseOne_ChildChance
// 0x0008 (0x0070 - 0x0068)
class UBTDecorator_RandomChooseOne_ChildChance final : public UBTDecoratorZion
{
public:
	float                                         ChildChance;                                       // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RandomChooseOne_ChildChance">();
	}
	static class UBTDecorator_RandomChooseOne_ChildChance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RandomChooseOne_ChildChance>();
	}
};
static_assert(alignof(UBTDecorator_RandomChooseOne_ChildChance) == 0x000008, "Wrong alignment on UBTDecorator_RandomChooseOne_ChildChance");
static_assert(sizeof(UBTDecorator_RandomChooseOne_ChildChance) == 0x000070, "Wrong size on UBTDecorator_RandomChooseOne_ChildChance");
static_assert(offsetof(UBTDecorator_RandomChooseOne_ChildChance, ChildChance) == 0x000068, "Member 'UBTDecorator_RandomChooseOne_ChildChance::ChildChance' has a wrong offset!");

// Class Zion.StateFreeze
// 0x0000 (0x0028 - 0x0028)
class UStateFreeze final : public UStateBusy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateFreeze">();
	}
	static class UStateFreeze* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateFreeze>();
	}
};
static_assert(alignof(UStateFreeze) == 0x000008, "Wrong alignment on UStateFreeze");
static_assert(sizeof(UStateFreeze) == 0x000028, "Wrong size on UStateFreeze");

// Class Zion.EventAction_SetFacing
// 0x0020 (0x0078 - 0x0058)
class UEventAction_SetFacing : public UEventAction_SubjectBinding
{
public:
	bool                                          bPlayAnimation;                                    // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFacingAnimationType                          AnimationType;                                     // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      TurnAnimationDefinitions;                          // 0x0060(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_SetFacing">();
	}
	static class UEventAction_SetFacing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_SetFacing>();
	}
};
static_assert(alignof(UEventAction_SetFacing) == 0x000008, "Wrong alignment on UEventAction_SetFacing");
static_assert(sizeof(UEventAction_SetFacing) == 0x000078, "Wrong size on UEventAction_SetFacing");
static_assert(offsetof(UEventAction_SetFacing, bPlayAnimation) == 0x000058, "Member 'UEventAction_SetFacing::bPlayAnimation' has a wrong offset!");
static_assert(offsetof(UEventAction_SetFacing, AnimationType) == 0x00005C, "Member 'UEventAction_SetFacing::AnimationType' has a wrong offset!");
static_assert(offsetof(UEventAction_SetFacing, TurnAnimationDefinitions) == 0x000060, "Member 'UEventAction_SetFacing::TurnAnimationDefinitions' has a wrong offset!");

// Class Zion.EventAction_SetFacing_FacingType
// 0x0008 (0x0080 - 0x0078)
class UEventAction_SetFacing_FacingType final : public UEventAction_SetFacing
{
public:
	EFacingType                                   FacingType;                                        // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_SetFacing_FacingType">();
	}
	static class UEventAction_SetFacing_FacingType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_SetFacing_FacingType>();
	}
};
static_assert(alignof(UEventAction_SetFacing_FacingType) == 0x000008, "Wrong alignment on UEventAction_SetFacing_FacingType");
static_assert(sizeof(UEventAction_SetFacing_FacingType) == 0x000080, "Wrong size on UEventAction_SetFacing_FacingType");
static_assert(offsetof(UEventAction_SetFacing_FacingType, FacingType) == 0x000078, "Member 'UEventAction_SetFacing_FacingType::FacingType' has a wrong offset!");

// Class Zion.AchievementsSubsystem
// 0x0070 (0x00A0 - 0x0030)
class UAchievementsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeForMainUser();

	bool IsAchievementUnlocked(EZionAchievement Achievement) const;
	bool IsUsingInternalAchievements() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementsSubsystem">();
	}
	static class UAchievementsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementsSubsystem>();
	}
};
static_assert(alignof(UAchievementsSubsystem) == 0x000008, "Wrong alignment on UAchievementsSubsystem");
static_assert(sizeof(UAchievementsSubsystem) == 0x0000A0, "Wrong size on UAchievementsSubsystem");

// Class Zion.SkillComponent
// 0x0160 (0x0200 - 0x00A0)
class USkillComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(ESkillSlot SkillSlot)> OnEquipSkillDelegate;                       // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ESkillSlot SkillSlot)> OnLoadEquippedSkillDelegate;                // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ESkillSlot SkillSlot)> OnUnequipSkillDelegate;                     // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESkillSlot, struct FInputActions>        InputActionsForSkillSlots;                         // 0x00D8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<ESkillSlot, class FName>                 DefaultSkills;                                     // 0x0128(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<ESkillSlot, struct FEquippedSkillData>   EquippedSkillDataForSkillSlots;                    // 0x0178(0x0050)(Transient, NativeAccessSpecifierPrivate)
	int32                                         CurrentLoadoutIndex;                               // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerSkillLoadoutData>        SkillLoadouts;                                     // 0x01D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E0[0x20];                                     // 0x01E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Equip(ESkillSlot SkillSlot, const class FName& SkillID, bool bAddToCurrentLoadout, bool bAutoLoad);
	void EquipSkillLoadout(int32 LoadoutIndex, bool bAutoLoad);
	void LoadEquippedSkills();
	void UnEquip(ESkillSlot SkillSlot, bool bRemoveFromCurrentLoadout);
	void UnEquipAll(bool bRemoveFromCurrentLoadout);

	int32 GetCurrentSkillLoadoutIndex() const;
	class UCommandSet* GetEquippedCommandSet(ESkillSlot SkillSlot) const;
	const struct FInventoryItemSkillData GetEquippedItemSkillData(ESkillSlot SkillSlot) const;
	class FName GetEquippedSkillID(ESkillSlot SkillSlot) const;
	const class UInputAction* GetEquippedSkillInputActionFromSpirit(const struct FInventoryItemSpiritData& SpiritData) const;
	const struct FSkillLevelData GetEquippedSkillLevelData(ESkillSlot SkillSlot) const;
	ESkillSlot GetEquippedSkillSlotFromID(const class FName& SkillID) const;
	int32 GetMinimumEquippedSPCost() const;
	bool HasAnyEquippedSkill() const;
	bool HasEquippedSkill(ESkillSlot SkillSlot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillComponent">();
	}
	static class USkillComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillComponent>();
	}
};
static_assert(alignof(USkillComponent) == 0x000008, "Wrong alignment on USkillComponent");
static_assert(sizeof(USkillComponent) == 0x000200, "Wrong size on USkillComponent");
static_assert(offsetof(USkillComponent, OnEquipSkillDelegate) == 0x0000A0, "Member 'USkillComponent::OnEquipSkillDelegate' has a wrong offset!");
static_assert(offsetof(USkillComponent, OnLoadEquippedSkillDelegate) == 0x0000B0, "Member 'USkillComponent::OnLoadEquippedSkillDelegate' has a wrong offset!");
static_assert(offsetof(USkillComponent, OnUnequipSkillDelegate) == 0x0000C0, "Member 'USkillComponent::OnUnequipSkillDelegate' has a wrong offset!");
static_assert(offsetof(USkillComponent, InputActionsForSkillSlots) == 0x0000D8, "Member 'USkillComponent::InputActionsForSkillSlots' has a wrong offset!");
static_assert(offsetof(USkillComponent, DefaultSkills) == 0x000128, "Member 'USkillComponent::DefaultSkills' has a wrong offset!");
static_assert(offsetof(USkillComponent, EquippedSkillDataForSkillSlots) == 0x000178, "Member 'USkillComponent::EquippedSkillDataForSkillSlots' has a wrong offset!");
static_assert(offsetof(USkillComponent, CurrentLoadoutIndex) == 0x0001C8, "Member 'USkillComponent::CurrentLoadoutIndex' has a wrong offset!");
static_assert(offsetof(USkillComponent, SkillLoadouts) == 0x0001D0, "Member 'USkillComponent::SkillLoadouts' has a wrong offset!");

// Class Zion.StateShock
// 0x0000 (0x0028 - 0x0028)
class UStateShock final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateShock">();
	}
	static class UStateShock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateShock>();
	}
};
static_assert(alignof(UStateShock) == 0x000008, "Wrong alignment on UStateShock");
static_assert(sizeof(UStateShock) == 0x000028, "Wrong size on UStateShock");

// Class Zion.CameraOverrideModule
// 0x0000 (0x0028 - 0x0028)
class UCameraOverrideModule : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule">();
	}
	static class UCameraOverrideModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule>();
	}
};
static_assert(alignof(UCameraOverrideModule) == 0x000008, "Wrong alignment on UCameraOverrideModule");
static_assert(sizeof(UCameraOverrideModule) == 0x000028, "Wrong size on UCameraOverrideModule");

// Class Zion.CameraOverrideModule_LocalOffsetSpeed
// 0x0008 (0x0030 - 0x0028)
class UCameraOverrideModule_LocalOffsetSpeed final : public UCameraOverrideModule
{
public:
	float                                         LocalLocationOffsetSpeed;                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_LocalOffsetSpeed">();
	}
	static class UCameraOverrideModule_LocalOffsetSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_LocalOffsetSpeed>();
	}
};
static_assert(alignof(UCameraOverrideModule_LocalOffsetSpeed) == 0x000008, "Wrong alignment on UCameraOverrideModule_LocalOffsetSpeed");
static_assert(sizeof(UCameraOverrideModule_LocalOffsetSpeed) == 0x000030, "Wrong size on UCameraOverrideModule_LocalOffsetSpeed");
static_assert(offsetof(UCameraOverrideModule_LocalOffsetSpeed, LocalLocationOffsetSpeed) == 0x000028, "Member 'UCameraOverrideModule_LocalOffsetSpeed::LocalLocationOffsetSpeed' has a wrong offset!");

// Class Zion.AbilityComponent
// 0x01F0 (0x0290 - 0x00A0)
class UAbilityComponent final : public UActorComponent
{
public:
	TMap<TSubclassOf<class AAbility>, struct FAbilityArray> InstancesForClasses;                     // 0x00A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class AAbility*>                       RunningAbilities;                                  // 0x00F0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x190];                                    // 0x0100(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AAbility* LaunchAbility(const struct FAbilityData& AbilityData, const struct FAbilityAdditionalData& AdditionalData, const struct FTransform& GlobalOffset);
	class AAbilityInstant* LaunchAbilityInstant(const struct FAbilityData& AbilityData, const TArray<class AActor*>& Targets, const struct FAbilityAdditionalData& AdditionalData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityComponent">();
	}
	static class UAbilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityComponent>();
	}
};
static_assert(alignof(UAbilityComponent) == 0x000008, "Wrong alignment on UAbilityComponent");
static_assert(sizeof(UAbilityComponent) == 0x000290, "Wrong size on UAbilityComponent");
static_assert(offsetof(UAbilityComponent, InstancesForClasses) == 0x0000A0, "Member 'UAbilityComponent::InstancesForClasses' has a wrong offset!");
static_assert(offsetof(UAbilityComponent, RunningAbilities) == 0x0000F0, "Member 'UAbilityComponent::RunningAbilities' has a wrong offset!");

// Class Zion.CommandModule_AbilityLoop
// 0x0128 (0x0160 - 0x0038)
class UCommandModule_AbilityLoop final : public UCommandModule
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityData                           AbilityData;                                       // 0x0040(0x00E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAbilityAdditionalData                 AbilityAdditionalData;                             // 0x0120(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         DelayBeforeLaunch;                                 // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LoopMaxCount;                                      // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LoopTimer;                                         // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x24];                                     // 0x013C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_AbilityLoop">();
	}
	static class UCommandModule_AbilityLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_AbilityLoop>();
	}
};
static_assert(alignof(UCommandModule_AbilityLoop) == 0x000010, "Wrong alignment on UCommandModule_AbilityLoop");
static_assert(sizeof(UCommandModule_AbilityLoop) == 0x000160, "Wrong size on UCommandModule_AbilityLoop");
static_assert(offsetof(UCommandModule_AbilityLoop, AbilityData) == 0x000040, "Member 'UCommandModule_AbilityLoop::AbilityData' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityLoop, AbilityAdditionalData) == 0x000120, "Member 'UCommandModule_AbilityLoop::AbilityAdditionalData' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityLoop, DelayBeforeLaunch) == 0x000130, "Member 'UCommandModule_AbilityLoop::DelayBeforeLaunch' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityLoop, LoopMaxCount) == 0x000134, "Member 'UCommandModule_AbilityLoop::LoopMaxCount' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityLoop, LoopTimer) == 0x000138, "Member 'UCommandModule_AbilityLoop::LoopTimer' has a wrong offset!");

// Class Zion.AbilityEffectProcess
// 0x0348 (0x0370 - 0x0028)
class alignas(0x10) UAbilityEffectProcess : public UObject
{
public:
	uint8                                         Pad_28[0x310];                                     // 0x0028(0x0310)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAbilityEffect*>                 Effects;                                           // 0x0338(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_348[0x28];                                     // 0x0348(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectProcess">();
	}
	static class UAbilityEffectProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectProcess>();
	}
};
static_assert(alignof(UAbilityEffectProcess) == 0x000010, "Wrong alignment on UAbilityEffectProcess");
static_assert(sizeof(UAbilityEffectProcess) == 0x000370, "Wrong size on UAbilityEffectProcess");
static_assert(offsetof(UAbilityEffectProcess, Effects) == 0x000338, "Member 'UAbilityEffectProcess::Effects' has a wrong offset!");

// Class Zion.ZionInputComponent
// 0x02B8 (0x0358 - 0x00A0)
class UZionInputComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x48];                                      // 0x00A0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UInputMappingContext*, EInputMappingPriority> InputContexts;                          // 0x00E8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_Movement;                              // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_SpecialModifier;                       // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UInputAction*>                     InputActions_Attack;                               // 0x0148(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0xF0];                                     // 0x0198(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  OwnerPawn;                                         // 0x0288(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnhancedInputComponent*                CachedEnhancedInput;                               // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatSPComponent*                       SPComponent;                                       // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0xB8];                                     // 0x02A0(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddInputMappingContext(const class UInputMappingContext* InputMappingContext, EInputMappingPriority Priority);
	void RemoveInputMappingContext(const class UInputMappingContext* InputMappingContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZionInputComponent">();
	}
	static class UZionInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZionInputComponent>();
	}
};
static_assert(alignof(UZionInputComponent) == 0x000008, "Wrong alignment on UZionInputComponent");
static_assert(sizeof(UZionInputComponent) == 0x000358, "Wrong size on UZionInputComponent");
static_assert(offsetof(UZionInputComponent, InputContexts) == 0x0000E8, "Member 'UZionInputComponent::InputContexts' has a wrong offset!");
static_assert(offsetof(UZionInputComponent, InputAction_Movement) == 0x000138, "Member 'UZionInputComponent::InputAction_Movement' has a wrong offset!");
static_assert(offsetof(UZionInputComponent, InputAction_SpecialModifier) == 0x000140, "Member 'UZionInputComponent::InputAction_SpecialModifier' has a wrong offset!");
static_assert(offsetof(UZionInputComponent, InputActions_Attack) == 0x000148, "Member 'UZionInputComponent::InputActions_Attack' has a wrong offset!");
static_assert(offsetof(UZionInputComponent, OwnerPawn) == 0x000288, "Member 'UZionInputComponent::OwnerPawn' has a wrong offset!");
static_assert(offsetof(UZionInputComponent, CachedEnhancedInput) == 0x000290, "Member 'UZionInputComponent::CachedEnhancedInput' has a wrong offset!");
static_assert(offsetof(UZionInputComponent, SPComponent) == 0x000298, "Member 'UZionInputComponent::SPComponent' has a wrong offset!");

// Class Zion.AbilityEffectInstant_CameraShake
// 0x0018 (0x0068 - 0x0050)
class UAbilityEffectInstant_CameraShake final : public UAbilityEffectInstant
{
public:
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InnerRadius;                                       // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OuterRadius;                                       // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Falloff;                                           // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOrientShakeTowardsEpicenter;                      // 0x0064(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_CameraShake">();
	}
	static class UAbilityEffectInstant_CameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_CameraShake>();
	}
};
static_assert(alignof(UAbilityEffectInstant_CameraShake) == 0x000008, "Wrong alignment on UAbilityEffectInstant_CameraShake");
static_assert(sizeof(UAbilityEffectInstant_CameraShake) == 0x000068, "Wrong size on UAbilityEffectInstant_CameraShake");
static_assert(offsetof(UAbilityEffectInstant_CameraShake, CameraShake) == 0x000050, "Member 'UAbilityEffectInstant_CameraShake::CameraShake' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_CameraShake, InnerRadius) == 0x000058, "Member 'UAbilityEffectInstant_CameraShake::InnerRadius' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_CameraShake, OuterRadius) == 0x00005C, "Member 'UAbilityEffectInstant_CameraShake::OuterRadius' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_CameraShake, Falloff) == 0x000060, "Member 'UAbilityEffectInstant_CameraShake::Falloff' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_CameraShake, bOrientShakeTowardsEpicenter) == 0x000064, "Member 'UAbilityEffectInstant_CameraShake::bOrientShakeTowardsEpicenter' has a wrong offset!");

// Class Zion.LocomotionComponent
// 0x0080 (0x0120 - 0x00A0)
class alignas(0x10) ULocomotionComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnFacingChange;                                    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UInputAction*                           DashInputAction;                                   // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowFacing;                                      // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUpdateFacing;                                     // 0x00B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseVelocityForFacing;                             // 0x00BA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BB[0x1];                                       // 0x00BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImmersionDepthForLateralOnly;                      // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x60];                                      // 0x00C0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFacing(EFacingType FacingType);
	void SetFacingFromVector(const struct FVector& Vector);
	void SetUpdateFacing(bool bNewUpdateFacing);
	void SetUpVector(const struct FVector& NewUpVector);
	void ToggleFacing();

	EFacingType GetFacing() const;
	bool GetUpdateFacing() const;
	const struct FVector GetUpVector() const;
	struct FQuat GetWorldUpToUpRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionComponent">();
	}
	static class ULocomotionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionComponent>();
	}
};
static_assert(alignof(ULocomotionComponent) == 0x000010, "Wrong alignment on ULocomotionComponent");
static_assert(sizeof(ULocomotionComponent) == 0x000120, "Wrong size on ULocomotionComponent");
static_assert(offsetof(ULocomotionComponent, OnFacingChange) == 0x0000A0, "Member 'ULocomotionComponent::OnFacingChange' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, DashInputAction) == 0x0000B0, "Member 'ULocomotionComponent::DashInputAction' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, bAllowFacing) == 0x0000B8, "Member 'ULocomotionComponent::bAllowFacing' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, bUpdateFacing) == 0x0000B9, "Member 'ULocomotionComponent::bUpdateFacing' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, bUseVelocityForFacing) == 0x0000BA, "Member 'ULocomotionComponent::bUseVelocityForFacing' has a wrong offset!");
static_assert(offsetof(ULocomotionComponent, ImmersionDepthForLateralOnly) == 0x0000BC, "Member 'ULocomotionComponent::ImmersionDepthForLateralOnly' has a wrong offset!");

// Class Zion.AbilityEffectInstant_DamageElemental
// 0x0008 (0x0058 - 0x0050)
class UAbilityEffectInstant_DamageElemental : public UAbilityEffectInstant
{
public:
	int32                                         AbsoluteDamage;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_DamageElemental">();
	}
	static class UAbilityEffectInstant_DamageElemental* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_DamageElemental>();
	}
};
static_assert(alignof(UAbilityEffectInstant_DamageElemental) == 0x000008, "Wrong alignment on UAbilityEffectInstant_DamageElemental");
static_assert(sizeof(UAbilityEffectInstant_DamageElemental) == 0x000058, "Wrong size on UAbilityEffectInstant_DamageElemental");
static_assert(offsetof(UAbilityEffectInstant_DamageElemental, AbsoluteDamage) == 0x000050, "Member 'UAbilityEffectInstant_DamageElemental::AbsoluteDamage' has a wrong offset!");

// Class Zion.AbilityEffectInstant_DamageElemental_Freeze
// 0x0000 (0x0058 - 0x0058)
class UAbilityEffectInstant_DamageElemental_Freeze final : public UAbilityEffectInstant_DamageElemental
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_DamageElemental_Freeze">();
	}
	static class UAbilityEffectInstant_DamageElemental_Freeze* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_DamageElemental_Freeze>();
	}
};
static_assert(alignof(UAbilityEffectInstant_DamageElemental_Freeze) == 0x000008, "Wrong alignment on UAbilityEffectInstant_DamageElemental_Freeze");
static_assert(sizeof(UAbilityEffectInstant_DamageElemental_Freeze) == 0x000058, "Wrong size on UAbilityEffectInstant_DamageElemental_Freeze");

// Class Zion.CameraOverrideModule_CenterVerticalFlag
// 0x0008 (0x0030 - 0x0028)
class UCameraOverrideModule_CenterVerticalFlag final : public UCameraOverrideModule
{
public:
	bool                                          bCenterVertical;                                   // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_CenterVerticalFlag">();
	}
	static class UCameraOverrideModule_CenterVerticalFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_CenterVerticalFlag>();
	}
};
static_assert(alignof(UCameraOverrideModule_CenterVerticalFlag) == 0x000008, "Wrong alignment on UCameraOverrideModule_CenterVerticalFlag");
static_assert(sizeof(UCameraOverrideModule_CenterVerticalFlag) == 0x000030, "Wrong size on UCameraOverrideModule_CenterVerticalFlag");
static_assert(offsetof(UCameraOverrideModule_CenterVerticalFlag, bCenterVertical) == 0x000028, "Member 'UCameraOverrideModule_CenterVerticalFlag::bCenterVertical' has a wrong offset!");

// Class Zion.AbilityEffectInstant_DamageElemental_Burn
// 0x0000 (0x0058 - 0x0058)
class UAbilityEffectInstant_DamageElemental_Burn final : public UAbilityEffectInstant_DamageElemental
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_DamageElemental_Burn">();
	}
	static class UAbilityEffectInstant_DamageElemental_Burn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_DamageElemental_Burn>();
	}
};
static_assert(alignof(UAbilityEffectInstant_DamageElemental_Burn) == 0x000008, "Wrong alignment on UAbilityEffectInstant_DamageElemental_Burn");
static_assert(sizeof(UAbilityEffectInstant_DamageElemental_Burn) == 0x000058, "Wrong size on UAbilityEffectInstant_DamageElemental_Burn");

// Class Zion.AbilityEffectInstant_DamageElemental_Shock
// 0x0000 (0x0058 - 0x0058)
class UAbilityEffectInstant_DamageElemental_Shock final : public UAbilityEffectInstant_DamageElemental
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_DamageElemental_Shock">();
	}
	static class UAbilityEffectInstant_DamageElemental_Shock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_DamageElemental_Shock>();
	}
};
static_assert(alignof(UAbilityEffectInstant_DamageElemental_Shock) == 0x000008, "Wrong alignment on UAbilityEffectInstant_DamageElemental_Shock");
static_assert(sizeof(UAbilityEffectInstant_DamageElemental_Shock) == 0x000058, "Wrong size on UAbilityEffectInstant_DamageElemental_Shock");

// Class Zion.ItemStatsWatcherComponent
// 0x00A0 (0x0140 - 0x00A0)
class UItemStatsWatcherComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0xA0];                                      // 0x00A0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemStatsWatcherComponent">();
	}
	static class UItemStatsWatcherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemStatsWatcherComponent>();
	}
};
static_assert(alignof(UItemStatsWatcherComponent) == 0x000008, "Wrong alignment on UItemStatsWatcherComponent");
static_assert(sizeof(UItemStatsWatcherComponent) == 0x000140, "Wrong size on UItemStatsWatcherComponent");

// Class Zion.AbilityEffectInstant_DamageHP
// 0x0018 (0x0068 - 0x0050)
class UAbilityEffectInstant_DamageHP final : public UAbilityEffectInstant
{
public:
	EAttackElement                                Element;                                           // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EDamageEffectType                             DamageEffectType;                                  // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DamageFactor;                                      // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AbsoluteDamage;                                    // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TargetPercentageDamage;                            // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreInstantKillSetting;                         // 0x0064(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_DamageHP">();
	}
	static class UAbilityEffectInstant_DamageHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_DamageHP>();
	}
};
static_assert(alignof(UAbilityEffectInstant_DamageHP) == 0x000008, "Wrong alignment on UAbilityEffectInstant_DamageHP");
static_assert(sizeof(UAbilityEffectInstant_DamageHP) == 0x000068, "Wrong size on UAbilityEffectInstant_DamageHP");
static_assert(offsetof(UAbilityEffectInstant_DamageHP, Element) == 0x000050, "Member 'UAbilityEffectInstant_DamageHP::Element' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_DamageHP, DamageEffectType) == 0x000054, "Member 'UAbilityEffectInstant_DamageHP::DamageEffectType' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_DamageHP, DamageFactor) == 0x000058, "Member 'UAbilityEffectInstant_DamageHP::DamageFactor' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_DamageHP, AbsoluteDamage) == 0x00005C, "Member 'UAbilityEffectInstant_DamageHP::AbsoluteDamage' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_DamageHP, TargetPercentageDamage) == 0x000060, "Member 'UAbilityEffectInstant_DamageHP::TargetPercentageDamage' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_DamageHP, bIgnoreInstantKillSetting) == 0x000064, "Member 'UAbilityEffectInstant_DamageHP::bIgnoreInstantKillSetting' has a wrong offset!");

// Class Zion.AbilityEffectInstant_DamageStamina
// 0x0008 (0x0058 - 0x0050)
class UAbilityEffectInstant_DamageStamina final : public UAbilityEffectInstant
{
public:
	int32                                         AbsoluteDamage;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInjectFacingOnStun;                               // 0x0054(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_DamageStamina">();
	}
	static class UAbilityEffectInstant_DamageStamina* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_DamageStamina>();
	}
};
static_assert(alignof(UAbilityEffectInstant_DamageStamina) == 0x000008, "Wrong alignment on UAbilityEffectInstant_DamageStamina");
static_assert(sizeof(UAbilityEffectInstant_DamageStamina) == 0x000058, "Wrong size on UAbilityEffectInstant_DamageStamina");
static_assert(offsetof(UAbilityEffectInstant_DamageStamina, AbsoluteDamage) == 0x000050, "Member 'UAbilityEffectInstant_DamageStamina::AbsoluteDamage' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_DamageStamina, bInjectFacingOnStun) == 0x000054, "Member 'UAbilityEffectInstant_DamageStamina::bInjectFacingOnStun' has a wrong offset!");

// Class Zion.FXComponent
// 0x0688 (0x0750 - 0x00C8)
class UFXComponent final : public USpineFXComponent
{
public:
	bool                                          bTriggerStepOnLanding;                             // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EStepHeavinessCategory                        LandingStepHeaviness;                              // 0x00C9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAuraFXData>                    AuraFXDataList;                                    // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FAuraFXDataList>     AuraFXDataListForTags;                             // 0x00E0(0x0050)(Edit, NativeAccessSpecifierPrivate)
	struct FSpineFXData                           FindTargetFXData;                                  // 0x0130(0x0100)(Edit, NativeAccessSpecifierPrivate)
	struct FSpineFXData                           LeadAbilityFXData;                                 // 0x0230(0x0100)(Edit, NativeAccessSpecifierPrivate)
	struct FSpineFXData                           OnGuardFXData;                                     // 0x0330(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSpineFXData                           OnParryFXData;                                     // 0x0430(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   SPChargedFXDataList;                               // 0x0530(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   SPChargedLoopFXDataList;                           // 0x0540(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   BurnFXDataList;                                    // 0x0550(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   StopBurnFXDataList;                                // 0x0560(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   FreezeFXDataList;                                  // 0x0570(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   StopFreezeFXDataList;                              // 0x0580(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   ShockFXDataList;                                   // 0x0590(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   StopShockFXDataList;                               // 0x05A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   StunFXDataList;                                    // 0x05B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   StopStunFXDataList;                                // 0x05C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   AttackUpFXDataList;                                // 0x05D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   StopAttackUpFXDataList;                            // 0x05E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   DefenseUpFXDataList;                               // 0x05F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   StopDefenseUpFXDataList;                           // 0x0600(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAuraFXRuntimeData>             AuraFXInstances;                                   // 0x0610(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              SPChargedLoopFXInstances;                          // 0x0620(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              BurnFXInstances;                                   // 0x0630(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              FreezeFXInstances;                                 // 0x0640(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              ShockFXInstances;                                  // 0x0650(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              StunFXInstances;                                   // 0x0660(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              AttackUpFXInstances;                               // 0x0670(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              DefenseUpFXInstances;                              // 0x0680(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_690[0xC0];                                     // 0x0690(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateAuraFXs(const class FName& AuraFXTag);
	void DeactivateAuraFXs(const class FName& AuraFXTag);
	void OnDeathProcessStart();
	void OnFinishCommand(const class UCommand* Command, ECommandFinishType FinishType);
	void OnGuarded(class AAbility* Ability, class AActor* Source);
	void OnLanded(const struct FHitResult& Hit);
	void OnParried(class AAbility* Ability, class AActor* Source);
	void OnSPValueChanged();
	void OnStatusEffectLaunched(class UStatusEffect* StatusEffect);
	void OnStatusEffectStopped(class UStatusEffect* StatusEffect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FXComponent">();
	}
	static class UFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFXComponent>();
	}
};
static_assert(alignof(UFXComponent) == 0x000010, "Wrong alignment on UFXComponent");
static_assert(sizeof(UFXComponent) == 0x000750, "Wrong size on UFXComponent");
static_assert(offsetof(UFXComponent, bTriggerStepOnLanding) == 0x0000C8, "Member 'UFXComponent::bTriggerStepOnLanding' has a wrong offset!");
static_assert(offsetof(UFXComponent, LandingStepHeaviness) == 0x0000C9, "Member 'UFXComponent::LandingStepHeaviness' has a wrong offset!");
static_assert(offsetof(UFXComponent, AuraFXDataList) == 0x0000D0, "Member 'UFXComponent::AuraFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, AuraFXDataListForTags) == 0x0000E0, "Member 'UFXComponent::AuraFXDataListForTags' has a wrong offset!");
static_assert(offsetof(UFXComponent, FindTargetFXData) == 0x000130, "Member 'UFXComponent::FindTargetFXData' has a wrong offset!");
static_assert(offsetof(UFXComponent, LeadAbilityFXData) == 0x000230, "Member 'UFXComponent::LeadAbilityFXData' has a wrong offset!");
static_assert(offsetof(UFXComponent, OnGuardFXData) == 0x000330, "Member 'UFXComponent::OnGuardFXData' has a wrong offset!");
static_assert(offsetof(UFXComponent, OnParryFXData) == 0x000430, "Member 'UFXComponent::OnParryFXData' has a wrong offset!");
static_assert(offsetof(UFXComponent, SPChargedFXDataList) == 0x000530, "Member 'UFXComponent::SPChargedFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, SPChargedLoopFXDataList) == 0x000540, "Member 'UFXComponent::SPChargedLoopFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, BurnFXDataList) == 0x000550, "Member 'UFXComponent::BurnFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, StopBurnFXDataList) == 0x000560, "Member 'UFXComponent::StopBurnFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, FreezeFXDataList) == 0x000570, "Member 'UFXComponent::FreezeFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, StopFreezeFXDataList) == 0x000580, "Member 'UFXComponent::StopFreezeFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, ShockFXDataList) == 0x000590, "Member 'UFXComponent::ShockFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, StopShockFXDataList) == 0x0005A0, "Member 'UFXComponent::StopShockFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, StunFXDataList) == 0x0005B0, "Member 'UFXComponent::StunFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, StopStunFXDataList) == 0x0005C0, "Member 'UFXComponent::StopStunFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, AttackUpFXDataList) == 0x0005D0, "Member 'UFXComponent::AttackUpFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, StopAttackUpFXDataList) == 0x0005E0, "Member 'UFXComponent::StopAttackUpFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, DefenseUpFXDataList) == 0x0005F0, "Member 'UFXComponent::DefenseUpFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, StopDefenseUpFXDataList) == 0x000600, "Member 'UFXComponent::StopDefenseUpFXDataList' has a wrong offset!");
static_assert(offsetof(UFXComponent, AuraFXInstances) == 0x000610, "Member 'UFXComponent::AuraFXInstances' has a wrong offset!");
static_assert(offsetof(UFXComponent, SPChargedLoopFXInstances) == 0x000620, "Member 'UFXComponent::SPChargedLoopFXInstances' has a wrong offset!");
static_assert(offsetof(UFXComponent, BurnFXInstances) == 0x000630, "Member 'UFXComponent::BurnFXInstances' has a wrong offset!");
static_assert(offsetof(UFXComponent, FreezeFXInstances) == 0x000640, "Member 'UFXComponent::FreezeFXInstances' has a wrong offset!");
static_assert(offsetof(UFXComponent, ShockFXInstances) == 0x000650, "Member 'UFXComponent::ShockFXInstances' has a wrong offset!");
static_assert(offsetof(UFXComponent, StunFXInstances) == 0x000660, "Member 'UFXComponent::StunFXInstances' has a wrong offset!");
static_assert(offsetof(UFXComponent, AttackUpFXInstances) == 0x000670, "Member 'UFXComponent::AttackUpFXInstances' has a wrong offset!");
static_assert(offsetof(UFXComponent, DefenseUpFXInstances) == 0x000680, "Member 'UFXComponent::DefenseUpFXInstances' has a wrong offset!");

// Class Zion.AbilityEffectInstant_Knockback
// 0x0078 (0x00C8 - 0x0050)
class UAbilityEffectInstant_Knockback final : public UAbilityEffectInstant
{
public:
	EKnockbackTriggerCondition                    Condition;                                         // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EKnockbackDirectionMode                       DirectionMode;                                     // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                AbsoluteDirection;                                 // 0x0058(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FKnockbackData                         KnockbackData;                                     // 0x0070(0x0058)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_Knockback">();
	}
	static class UAbilityEffectInstant_Knockback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_Knockback>();
	}
};
static_assert(alignof(UAbilityEffectInstant_Knockback) == 0x000008, "Wrong alignment on UAbilityEffectInstant_Knockback");
static_assert(sizeof(UAbilityEffectInstant_Knockback) == 0x0000C8, "Wrong size on UAbilityEffectInstant_Knockback");
static_assert(offsetof(UAbilityEffectInstant_Knockback, Condition) == 0x000050, "Member 'UAbilityEffectInstant_Knockback::Condition' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_Knockback, DirectionMode) == 0x000054, "Member 'UAbilityEffectInstant_Knockback::DirectionMode' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_Knockback, AbsoluteDirection) == 0x000058, "Member 'UAbilityEffectInstant_Knockback::AbsoluteDirection' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_Knockback, KnockbackData) == 0x000070, "Member 'UAbilityEffectInstant_Knockback::KnockbackData' has a wrong offset!");

// Class Zion.AbilityEffectInstant_SetFacing
// 0x0008 (0x0058 - 0x0050)
class UAbilityEffectInstant_SetFacing final : public UAbilityEffectInstant
{
public:
	ESetFacingMode                                SetFacingMode;                                     // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInvertFacing;                                     // 0x0051(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_SetFacing">();
	}
	static class UAbilityEffectInstant_SetFacing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_SetFacing>();
	}
};
static_assert(alignof(UAbilityEffectInstant_SetFacing) == 0x000008, "Wrong alignment on UAbilityEffectInstant_SetFacing");
static_assert(sizeof(UAbilityEffectInstant_SetFacing) == 0x000058, "Wrong size on UAbilityEffectInstant_SetFacing");
static_assert(offsetof(UAbilityEffectInstant_SetFacing, SetFacingMode) == 0x000050, "Member 'UAbilityEffectInstant_SetFacing::SetFacingMode' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_SetFacing, bInvertFacing) == 0x000051, "Member 'UAbilityEffectInstant_SetFacing::bInvertFacing' has a wrong offset!");

// Class Zion.OrientFromInputComponent
// 0x0018 (0x00B8 - 0x00A0)
class UOrientFromInputComponent final : public UActorComponent
{
public:
	bool                                          bBlendRotation;                                    // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationBlendSpeed;                                // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrientFromInputComponent">();
	}
	static class UOrientFromInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrientFromInputComponent>();
	}
};
static_assert(alignof(UOrientFromInputComponent) == 0x000008, "Wrong alignment on UOrientFromInputComponent");
static_assert(sizeof(UOrientFromInputComponent) == 0x0000B8, "Wrong size on UOrientFromInputComponent");
static_assert(offsetof(UOrientFromInputComponent, bBlendRotation) == 0x0000A0, "Member 'UOrientFromInputComponent::bBlendRotation' has a wrong offset!");
static_assert(offsetof(UOrientFromInputComponent, RotationBlendSpeed) == 0x0000A4, "Member 'UOrientFromInputComponent::RotationBlendSpeed' has a wrong offset!");

// Class Zion.MoveComponent
// 0x0048 (0x0150 - 0x0108)
class UMoveComponent final : public UMovementComponent
{
public:
	bool                                          bSweep;                                            // 0x0108(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InitialLocalSpaceVelocity;                         // 0x0110(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LocalSpaceAcceleration;                            // 0x0128(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bClampMaxSpeed;                                    // 0x0140(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeed;                                          // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRotationFollowsVelocity;                          // 0x0148(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityFactor;                                     // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Reset();
	void SetVelocity(const struct FVector& NewVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveComponent">();
	}
	static class UMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveComponent>();
	}
};
static_assert(alignof(UMoveComponent) == 0x000008, "Wrong alignment on UMoveComponent");
static_assert(sizeof(UMoveComponent) == 0x000150, "Wrong size on UMoveComponent");
static_assert(offsetof(UMoveComponent, bSweep) == 0x000108, "Member 'UMoveComponent::bSweep' has a wrong offset!");
static_assert(offsetof(UMoveComponent, InitialLocalSpaceVelocity) == 0x000110, "Member 'UMoveComponent::InitialLocalSpaceVelocity' has a wrong offset!");
static_assert(offsetof(UMoveComponent, LocalSpaceAcceleration) == 0x000128, "Member 'UMoveComponent::LocalSpaceAcceleration' has a wrong offset!");
static_assert(offsetof(UMoveComponent, bClampMaxSpeed) == 0x000140, "Member 'UMoveComponent::bClampMaxSpeed' has a wrong offset!");
static_assert(offsetof(UMoveComponent, MaxSpeed) == 0x000144, "Member 'UMoveComponent::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UMoveComponent, bRotationFollowsVelocity) == 0x000148, "Member 'UMoveComponent::bRotationFollowsVelocity' has a wrong offset!");
static_assert(offsetof(UMoveComponent, GravityFactor) == 0x00014C, "Member 'UMoveComponent::GravityFactor' has a wrong offset!");

// Class Zion.AbilityEffectInstant_ShakeTarget
// 0x0060 (0x00B0 - 0x0050)
class UAbilityEffectInstant_ShakeTarget final : public UAbilityEffectInstant
{
public:
	struct FShakeData                             GroundShakeData;                                   // 0x0050(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FShakeData                             AirShakeData;                                      // 0x0080(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_ShakeTarget">();
	}
	static class UAbilityEffectInstant_ShakeTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_ShakeTarget>();
	}
};
static_assert(alignof(UAbilityEffectInstant_ShakeTarget) == 0x000008, "Wrong alignment on UAbilityEffectInstant_ShakeTarget");
static_assert(sizeof(UAbilityEffectInstant_ShakeTarget) == 0x0000B0, "Wrong size on UAbilityEffectInstant_ShakeTarget");
static_assert(offsetof(UAbilityEffectInstant_ShakeTarget, GroundShakeData) == 0x000050, "Member 'UAbilityEffectInstant_ShakeTarget::GroundShakeData' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_ShakeTarget, AirShakeData) == 0x000080, "Member 'UAbilityEffectInstant_ShakeTarget::AirShakeData' has a wrong offset!");

// Class Zion.AbilityEffectInstant_SpawnFX
// 0x0110 (0x0160 - 0x0050)
class UAbilityEffectInstant_SpawnFX final : public UAbilityEffectInstant
{
public:
	struct FSpineFXData                           FXData;                                            // 0x0050(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bOrientFromAttacker;                               // 0x0150(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_151[0xF];                                      // 0x0151(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_SpawnFX">();
	}
	static class UAbilityEffectInstant_SpawnFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_SpawnFX>();
	}
};
static_assert(alignof(UAbilityEffectInstant_SpawnFX) == 0x000010, "Wrong alignment on UAbilityEffectInstant_SpawnFX");
static_assert(sizeof(UAbilityEffectInstant_SpawnFX) == 0x000160, "Wrong size on UAbilityEffectInstant_SpawnFX");
static_assert(offsetof(UAbilityEffectInstant_SpawnFX, FXData) == 0x000050, "Member 'UAbilityEffectInstant_SpawnFX::FXData' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_SpawnFX, bOrientFromAttacker) == 0x000150, "Member 'UAbilityEffectInstant_SpawnFX::bOrientFromAttacker' has a wrong offset!");

// Class Zion.AbilityEffectInstant_SpawnFXCategory
// 0x0008 (0x0058 - 0x0050)
class UAbilityEffectInstant_SpawnFXCategory final : public UAbilityEffectInstant
{
public:
	EEffectAttackType                             AttackType;                                        // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEffectActionType                             Action;                                            // 0x0051(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_SpawnFXCategory">();
	}
	static class UAbilityEffectInstant_SpawnFXCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_SpawnFXCategory>();
	}
};
static_assert(alignof(UAbilityEffectInstant_SpawnFXCategory) == 0x000008, "Wrong alignment on UAbilityEffectInstant_SpawnFXCategory");
static_assert(sizeof(UAbilityEffectInstant_SpawnFXCategory) == 0x000058, "Wrong size on UAbilityEffectInstant_SpawnFXCategory");
static_assert(offsetof(UAbilityEffectInstant_SpawnFXCategory, AttackType) == 0x000050, "Member 'UAbilityEffectInstant_SpawnFXCategory::AttackType' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_SpawnFXCategory, Action) == 0x000051, "Member 'UAbilityEffectInstant_SpawnFXCategory::Action' has a wrong offset!");

// Class Zion.EventAction_StopBGM
// 0x0008 (0x0058 - 0x0050)
class UEventAction_StopBGM final : public UEventAction
{
public:
	float                                         FadeOutTime;                                       // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_StopBGM">();
	}
	static class UEventAction_StopBGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_StopBGM>();
	}
};
static_assert(alignof(UEventAction_StopBGM) == 0x000008, "Wrong alignment on UEventAction_StopBGM");
static_assert(sizeof(UEventAction_StopBGM) == 0x000058, "Wrong size on UEventAction_StopBGM");
static_assert(offsetof(UEventAction_StopBGM, FadeOutTime) == 0x000050, "Member 'UEventAction_StopBGM::FadeOutTime' has a wrong offset!");

// Class Zion.AbilityEffectInstant_SpawnSECategory
// 0x0008 (0x0058 - 0x0050)
class UAbilityEffectInstant_SpawnSECategory final : public UAbilityEffectInstant
{
public:
	EEffectAttackType                             AttackType;                                        // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEffectActionType                             Action;                                            // 0x0051(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectInstant_SpawnSECategory">();
	}
	static class UAbilityEffectInstant_SpawnSECategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectInstant_SpawnSECategory>();
	}
};
static_assert(alignof(UAbilityEffectInstant_SpawnSECategory) == 0x000008, "Wrong alignment on UAbilityEffectInstant_SpawnSECategory");
static_assert(sizeof(UAbilityEffectInstant_SpawnSECategory) == 0x000058, "Wrong size on UAbilityEffectInstant_SpawnSECategory");
static_assert(offsetof(UAbilityEffectInstant_SpawnSECategory, AttackType) == 0x000050, "Member 'UAbilityEffectInstant_SpawnSECategory::AttackType' has a wrong offset!");
static_assert(offsetof(UAbilityEffectInstant_SpawnSECategory, Action) == 0x000051, "Member 'UAbilityEffectInstant_SpawnSECategory::Action' has a wrong offset!");

// Class Zion.AbilityEffectTimed_HitStop
// 0x0010 (0x0068 - 0x0058)
class UAbilityEffectTimed_HitStop final : public UAbilityEffectTimed
{
public:
	bool                                          bTriggerOnSource;                                  // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTriggerOnTarget;                                  // 0x0059(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTriggerOnSourceSummoner;                          // 0x005A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B[0x1];                                       // 0x005B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectTimed_HitStop">();
	}
	static class UAbilityEffectTimed_HitStop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectTimed_HitStop>();
	}
};
static_assert(alignof(UAbilityEffectTimed_HitStop) == 0x000008, "Wrong alignment on UAbilityEffectTimed_HitStop");
static_assert(sizeof(UAbilityEffectTimed_HitStop) == 0x000068, "Wrong size on UAbilityEffectTimed_HitStop");
static_assert(offsetof(UAbilityEffectTimed_HitStop, bTriggerOnSource) == 0x000058, "Member 'UAbilityEffectTimed_HitStop::bTriggerOnSource' has a wrong offset!");
static_assert(offsetof(UAbilityEffectTimed_HitStop, bTriggerOnTarget) == 0x000059, "Member 'UAbilityEffectTimed_HitStop::bTriggerOnTarget' has a wrong offset!");
static_assert(offsetof(UAbilityEffectTimed_HitStop, bTriggerOnSourceSummoner) == 0x00005A, "Member 'UAbilityEffectTimed_HitStop::bTriggerOnSourceSummoner' has a wrong offset!");
static_assert(offsetof(UAbilityEffectTimed_HitStop, Duration) == 0x00005C, "Member 'UAbilityEffectTimed_HitStop::Duration' has a wrong offset!");

// Class Zion.AbilityEffectTimed_TimeDilation
// 0x0020 (0x0078 - 0x0058)
class UAbilityEffectTimed_TimeDilation final : public UAbilityEffectTimed
{
public:
	struct FTimedDilationData                     Settings;                                          // 0x0058(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEffectTimed_TimeDilation">();
	}
	static class UAbilityEffectTimed_TimeDilation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEffectTimed_TimeDilation>();
	}
};
static_assert(alignof(UAbilityEffectTimed_TimeDilation) == 0x000008, "Wrong alignment on UAbilityEffectTimed_TimeDilation");
static_assert(sizeof(UAbilityEffectTimed_TimeDilation) == 0x000078, "Wrong size on UAbilityEffectTimed_TimeDilation");
static_assert(offsetof(UAbilityEffectTimed_TimeDilation, Settings) == 0x000058, "Member 'UAbilityEffectTimed_TimeDilation::Settings' has a wrong offset!");

// Class Zion.AbilityHitboxBounce
// 0x0020 (0x0AE0 - 0x0AC0)
class AAbilityHitboxBounce : public AAbilityHitboxMoving
{
public:
	class USphereComponent*                       SphereCollision;                                   // 0x0AC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLimitBounceCount;                                 // 0x0AC8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC9[0x3];                                      // 0x0AC9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxBounceCount;                                    // 0x0ACC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AD0[0x10];                                     // 0x0AD0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityHitboxBounce">();
	}
	static class AAbilityHitboxBounce* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityHitboxBounce>();
	}
};
static_assert(alignof(AAbilityHitboxBounce) == 0x000010, "Wrong alignment on AAbilityHitboxBounce");
static_assert(sizeof(AAbilityHitboxBounce) == 0x000AE0, "Wrong size on AAbilityHitboxBounce");
static_assert(offsetof(AAbilityHitboxBounce, SphereCollision) == 0x000AC0, "Member 'AAbilityHitboxBounce::SphereCollision' has a wrong offset!");
static_assert(offsetof(AAbilityHitboxBounce, bLimitBounceCount) == 0x000AC8, "Member 'AAbilityHitboxBounce::bLimitBounceCount' has a wrong offset!");
static_assert(offsetof(AAbilityHitboxBounce, MaxBounceCount) == 0x000ACC, "Member 'AAbilityHitboxBounce::MaxBounceCount' has a wrong offset!");

// Class Zion.InputSettingsSubsystem
// 0x0028 (0x0058 - 0x0030)
class UInputSettingsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInputMappingContext*>           InputContexts;                                     // 0x0048(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	bool RemapKey(const EActionInputType& ActionInputType, const struct FKey& NewKey, const TSet<EActionInputType>& InvalidInputTypes, bool bIsGamepadKey);
	void ResetAllInputMappingContextsToDefault(bool bIsGamepad);
	void ResetInputMappingContextToDefault(class UInputMappingContext* InputMappingContext, bool bIsGamepad);

	struct FKey GetMappedKey(const class FName& MappingName) const;
	class FName GetMappingNameFromInputAction(const class UInputAction* InputAction, bool bIsGamepad) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputSettingsSubsystem">();
	}
	static class UInputSettingsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputSettingsSubsystem>();
	}
};
static_assert(alignof(UInputSettingsSubsystem) == 0x000008, "Wrong alignment on UInputSettingsSubsystem");
static_assert(sizeof(UInputSettingsSubsystem) == 0x000058, "Wrong size on UInputSettingsSubsystem");
static_assert(offsetof(UInputSettingsSubsystem, InputContexts) == 0x000048, "Member 'UInputSettingsSubsystem::InputContexts' has a wrong offset!");

// Class Zion.AbilityHitboxFollowGeometry
// 0x0010 (0x0AD0 - 0x0AC0)
class AAbilityHitboxFollowGeometry final : public AAbilityHitbox
{
public:
	class USphereComponent*                       SphereCollision;                                   // 0x0AB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFollowGeometryMovementComponent*       FollowGeometryMovementComponent;                   // 0x0AC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC8[0x8];                                      // 0x0AC8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityHitboxFollowGeometry">();
	}
	static class AAbilityHitboxFollowGeometry* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityHitboxFollowGeometry>();
	}
};
static_assert(alignof(AAbilityHitboxFollowGeometry) == 0x000010, "Wrong alignment on AAbilityHitboxFollowGeometry");
static_assert(sizeof(AAbilityHitboxFollowGeometry) == 0x000AD0, "Wrong size on AAbilityHitboxFollowGeometry");
static_assert(offsetof(AAbilityHitboxFollowGeometry, SphereCollision) == 0x000AB8, "Member 'AAbilityHitboxFollowGeometry::SphereCollision' has a wrong offset!");
static_assert(offsetof(AAbilityHitboxFollowGeometry, FollowGeometryMovementComponent) == 0x000AC0, "Member 'AAbilityHitboxFollowGeometry::FollowGeometryMovementComponent' has a wrong offset!");

// Class Zion.EventAction_PlayRandomAnimations
// 0x0038 (0x0090 - 0x0058)
class UEventAction_PlayRandomAnimations final : public UEventAction_SubjectBinding
{
public:
	TArray<struct FSpineAnimationDefinition>      StartAnimationDefinitions;                         // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      RandomAnimationDefinitions;                        // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class FName                                   FinishActionKey;                                   // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_PlayRandomAnimations">();
	}
	static class UEventAction_PlayRandomAnimations* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_PlayRandomAnimations>();
	}
};
static_assert(alignof(UEventAction_PlayRandomAnimations) == 0x000008, "Wrong alignment on UEventAction_PlayRandomAnimations");
static_assert(sizeof(UEventAction_PlayRandomAnimations) == 0x000090, "Wrong size on UEventAction_PlayRandomAnimations");
static_assert(offsetof(UEventAction_PlayRandomAnimations, StartAnimationDefinitions) == 0x000058, "Member 'UEventAction_PlayRandomAnimations::StartAnimationDefinitions' has a wrong offset!");
static_assert(offsetof(UEventAction_PlayRandomAnimations, RandomAnimationDefinitions) == 0x000068, "Member 'UEventAction_PlayRandomAnimations::RandomAnimationDefinitions' has a wrong offset!");
static_assert(offsetof(UEventAction_PlayRandomAnimations, FinishActionKey) == 0x000078, "Member 'UEventAction_PlayRandomAnimations::FinishActionKey' has a wrong offset!");

// Class Zion.CommandModule_Summon
// 0x0068 (0x00A0 - 0x0038)
class UCommandModule_Summon : public UCommandModule
{
public:
	TSubclassOf<class ACharacterZionSpirit>       SpiritClass;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FSpiritSummonParameters                SummonParameters;                                  // 0x0050(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	EDismissType                                  OnFinishDismissType;                               // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DismissDelay;                                      // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class ACharacterZionSpirit* GetSpirit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_Summon">();
	}
	static class UCommandModule_Summon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_Summon>();
	}
};
static_assert(alignof(UCommandModule_Summon) == 0x000008, "Wrong alignment on UCommandModule_Summon");
static_assert(sizeof(UCommandModule_Summon) == 0x0000A0, "Wrong size on UCommandModule_Summon");
static_assert(offsetof(UCommandModule_Summon, SpiritClass) == 0x000038, "Member 'UCommandModule_Summon::SpiritClass' has a wrong offset!");
static_assert(offsetof(UCommandModule_Summon, CommandClasses) == 0x000040, "Member 'UCommandModule_Summon::CommandClasses' has a wrong offset!");
static_assert(offsetof(UCommandModule_Summon, SummonParameters) == 0x000050, "Member 'UCommandModule_Summon::SummonParameters' has a wrong offset!");
static_assert(offsetof(UCommandModule_Summon, OnFinishDismissType) == 0x000088, "Member 'UCommandModule_Summon::OnFinishDismissType' has a wrong offset!");
static_assert(offsetof(UCommandModule_Summon, DismissDelay) == 0x00008C, "Member 'UCommandModule_Summon::DismissDelay' has a wrong offset!");

// Class Zion.CommandModule_SummonTurret
// 0x0048 (0x00E8 - 0x00A0)
class UCommandModule_SummonTurret final : public UCommandModule_Summon
{
public:
	struct FSpiritTurretSummonParameters          TurretParameters;                                  // 0x00A0(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_SummonTurret">();
	}
	static class UCommandModule_SummonTurret* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_SummonTurret>();
	}
};
static_assert(alignof(UCommandModule_SummonTurret) == 0x000008, "Wrong alignment on UCommandModule_SummonTurret");
static_assert(sizeof(UCommandModule_SummonTurret) == 0x0000E8, "Wrong size on UCommandModule_SummonTurret");
static_assert(offsetof(UCommandModule_SummonTurret, TurretParameters) == 0x0000A0, "Member 'UCommandModule_SummonTurret::TurretParameters' has a wrong offset!");

// Class Zion.AbilityHitboxTarget_AI
// 0x0000 (0x0AC0 - 0x0AC0)
#pragma pack(push, 0x1)
class alignas(0x10) AAbilityHitboxTarget_AI : public AAbilityHitboxTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityHitboxTarget_AI">();
	}
	static class AAbilityHitboxTarget_AI* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityHitboxTarget_AI>();
	}
};
#pragma pack(pop)
static_assert(alignof(AAbilityHitboxTarget_AI) == 0x000010, "Wrong alignment on AAbilityHitboxTarget_AI");
static_assert(sizeof(AAbilityHitboxTarget_AI) == 0x000AC0, "Wrong size on AAbilityHitboxTarget_AI");

// Class Zion.GameplayCondition_HasAptitude
// 0x0008 (0x0038 - 0x0030)
class UGameplayCondition_HasAptitude final : public UGameplayCondition
{
public:
	EAptitudeType                                 Aptitude;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCondition_HasAptitude">();
	}
	static class UGameplayCondition_HasAptitude* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCondition_HasAptitude>();
	}
};
static_assert(alignof(UGameplayCondition_HasAptitude) == 0x000008, "Wrong alignment on UGameplayCondition_HasAptitude");
static_assert(sizeof(UGameplayCondition_HasAptitude) == 0x000038, "Wrong size on UGameplayCondition_HasAptitude");
static_assert(offsetof(UGameplayCondition_HasAptitude, Aptitude) == 0x000030, "Member 'UGameplayCondition_HasAptitude::Aptitude' has a wrong offset!");

// Class Zion.AbilityHitboxTarget_AI_Homing
// 0x0000 (0x0AC0 - 0x0AC0)
class AAbilityHitboxTarget_AI_Homing : public AAbilityHitboxTarget_AI
{
public:
	class UHomingComponent*                       HomingComponent;                                   // 0x0AB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityHitboxTarget_AI_Homing">();
	}
	static class AAbilityHitboxTarget_AI_Homing* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityHitboxTarget_AI_Homing>();
	}
};
static_assert(alignof(AAbilityHitboxTarget_AI_Homing) == 0x000010, "Wrong alignment on AAbilityHitboxTarget_AI_Homing");
static_assert(sizeof(AAbilityHitboxTarget_AI_Homing) == 0x000AC0, "Wrong size on AAbilityHitboxTarget_AI_Homing");
static_assert(offsetof(AAbilityHitboxTarget_AI_Homing, HomingComponent) == 0x000AB8, "Member 'AAbilityHitboxTarget_AI_Homing::HomingComponent' has a wrong offset!");

// Class Zion.AbilityHitboxScaling
// 0x0030 (0x0AF0 - 0x0AC0)
class AAbilityHitboxScaling : public AAbilityHitbox
{
public:
	class USceneComponent*                        ScaleContainer;                                    // 0x0AB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             CollisionChannel;                                  // 0x0AC0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC1[0x7];                                      // 0x0AC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         BeamFX;                                            // 0x0AC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         BeamCollisionFX;                                   // 0x0AD0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxRange;                                          // 0x0AD8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERenderLayerTypes                             BeamRenderLayer;                                   // 0x0ADC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_ADD[0x13];                                     // 0x0ADD(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityHitboxScaling">();
	}
	static class AAbilityHitboxScaling* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityHitboxScaling>();
	}
};
static_assert(alignof(AAbilityHitboxScaling) == 0x000010, "Wrong alignment on AAbilityHitboxScaling");
static_assert(sizeof(AAbilityHitboxScaling) == 0x000AF0, "Wrong size on AAbilityHitboxScaling");
static_assert(offsetof(AAbilityHitboxScaling, ScaleContainer) == 0x000AB8, "Member 'AAbilityHitboxScaling::ScaleContainer' has a wrong offset!");
static_assert(offsetof(AAbilityHitboxScaling, CollisionChannel) == 0x000AC0, "Member 'AAbilityHitboxScaling::CollisionChannel' has a wrong offset!");
static_assert(offsetof(AAbilityHitboxScaling, BeamFX) == 0x000AC8, "Member 'AAbilityHitboxScaling::BeamFX' has a wrong offset!");
static_assert(offsetof(AAbilityHitboxScaling, BeamCollisionFX) == 0x000AD0, "Member 'AAbilityHitboxScaling::BeamCollisionFX' has a wrong offset!");
static_assert(offsetof(AAbilityHitboxScaling, MaxRange) == 0x000AD8, "Member 'AAbilityHitboxScaling::MaxRange' has a wrong offset!");
static_assert(offsetof(AAbilityHitboxScaling, BeamRenderLayer) == 0x000ADC, "Member 'AAbilityHitboxScaling::BeamRenderLayer' has a wrong offset!");

// Class Zion.AbilityHitboxScaling_OrientToTargetAI
// 0x0010 (0x0B00 - 0x0AF0)
class AAbilityHitboxScaling_OrientToTargetAI final : public AAbilityHitboxScaling
{
public:
	class UOrientToTargetComponent*               OrientToTargetComponent;                           // 0x0AF0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AF8[0x8];                                      // 0x0AF8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityHitboxScaling_OrientToTargetAI">();
	}
	static class AAbilityHitboxScaling_OrientToTargetAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityHitboxScaling_OrientToTargetAI>();
	}
};
static_assert(alignof(AAbilityHitboxScaling_OrientToTargetAI) == 0x000010, "Wrong alignment on AAbilityHitboxScaling_OrientToTargetAI");
static_assert(sizeof(AAbilityHitboxScaling_OrientToTargetAI) == 0x000B00, "Wrong size on AAbilityHitboxScaling_OrientToTargetAI");
static_assert(offsetof(AAbilityHitboxScaling_OrientToTargetAI, OrientToTargetComponent) == 0x000AF0, "Member 'AAbilityHitboxScaling_OrientToTargetAI::OrientToTargetComponent' has a wrong offset!");

// Class Zion.InventoryComponent
// 0x01A8 (0x0248 - 0x00A0)
class UInventoryComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const class UInventory* Inventory, const class FName& ItemId, int32 AddedCount)> OnItemAdded; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const ECurrencyType& CurrencyType, const int32 AddedCount, const int32 PreviousCount)> OnCurrencyAdded; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x60];                                      // 0x00C0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<ECurrencyType>                           DropFactoredCurrencies;                            // 0x0120(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemCurrencyInventory;                             // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryAptitude*                     ItemAptitudeInventory;                             // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemSpiritInventory;                               // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventorySkill*                        ItemSkillInventory;                                // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemEquipmentInventory;                            // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemAssistInventory;                               // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemStatsInventory;                                // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemPassiveInventory;                              // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemMaterialInventory;                             // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemTipInventory;                                  // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemTutorialInventory;                             // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemKeyInventory;                                  // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemQuestInventory;                                // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemCostumeInventory;                              // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemEnemyInfoInventory;                            // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemNPCInfoInventory;                              // 0x01E8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventory*                             ItemGalleryInventory;                              // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x50];                                     // 0x01F8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddCurrency(ECurrencyType CurrencyType, int32 CurrencyToAdd);
	bool AddDrop(const struct FDrop& Drop, float DropFactor);
	bool AddItem(const struct FDataTableRowHandle& ItemHandle, int32 Count);
	bool HasItem(const struct FDataTableRowHandle& ItemHandle, int32 Count);
	void MarkItemAsChecked(const struct FDataTableRowHandle& ItemHandle);
	bool RemoveItem(const struct FDataTableRowHandle& ItemHandle, int32 Count);
	int32 SpendCurrency(const struct FCurrencyValue& CurrencyValue);

	bool CanSpendCurrency(const struct FCurrencyValue& CurrencyValue) const;
	class UInventoryAptitude* GetAptitudeInventory() const;
	class UInventory* GetAssistInventory() const;
	class UInventory* GetCostumeInventory() const;
	int32 GetCountOfItem(const struct FDataTableRowHandle& ItemHandle) const;
	int32 GetCurrency(ECurrencyType CurrencyType) const;
	class UInventory* GetCurrencyInventory() const;
	class UInventory* GetEnemyInfoInventory() const;
	class UInventory* GetEquipmentInventory() const;
	class UInventory* GetGalleryInventory() const;
	class UInventory* GetInventoryFromItemType(EInventoryItemType ItemType) const;
	class UInventory* GetNPCInfoInventory() const;
	class UInventory* GetPassiveInventory() const;
	class UInventorySkill* GetSkillInventory() const;
	class UInventory* GetSpiritInventory() const;
	class UInventory* GetStatsInventory() const;
	class UInventory* GetTipInventory() const;
	class UInventory* GetTutorialInventory() const;
	bool HasAptitude(const EAptitudeType& AptitudeType) const;
	bool HasNonCheckedItem(EInventoryItemType ItemType) const;
	bool IsItemChecked(const struct FDataTableRowHandle& ItemHandle) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryComponent">();
	}
	static class UInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryComponent>();
	}
};
static_assert(alignof(UInventoryComponent) == 0x000008, "Wrong alignment on UInventoryComponent");
static_assert(sizeof(UInventoryComponent) == 0x000248, "Wrong size on UInventoryComponent");
static_assert(offsetof(UInventoryComponent, OnItemAdded) == 0x0000A0, "Member 'UInventoryComponent::OnItemAdded' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnCurrencyAdded) == 0x0000B0, "Member 'UInventoryComponent::OnCurrencyAdded' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, DropFactoredCurrencies) == 0x000120, "Member 'UInventoryComponent::DropFactoredCurrencies' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemCurrencyInventory) == 0x000170, "Member 'UInventoryComponent::ItemCurrencyInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemAptitudeInventory) == 0x000178, "Member 'UInventoryComponent::ItemAptitudeInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemSpiritInventory) == 0x000180, "Member 'UInventoryComponent::ItemSpiritInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemSkillInventory) == 0x000188, "Member 'UInventoryComponent::ItemSkillInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemEquipmentInventory) == 0x000190, "Member 'UInventoryComponent::ItemEquipmentInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemAssistInventory) == 0x000198, "Member 'UInventoryComponent::ItemAssistInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemStatsInventory) == 0x0001A0, "Member 'UInventoryComponent::ItemStatsInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemPassiveInventory) == 0x0001A8, "Member 'UInventoryComponent::ItemPassiveInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemMaterialInventory) == 0x0001B0, "Member 'UInventoryComponent::ItemMaterialInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemTipInventory) == 0x0001B8, "Member 'UInventoryComponent::ItemTipInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemTutorialInventory) == 0x0001C0, "Member 'UInventoryComponent::ItemTutorialInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemKeyInventory) == 0x0001C8, "Member 'UInventoryComponent::ItemKeyInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemQuestInventory) == 0x0001D0, "Member 'UInventoryComponent::ItemQuestInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemCostumeInventory) == 0x0001D8, "Member 'UInventoryComponent::ItemCostumeInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemEnemyInfoInventory) == 0x0001E0, "Member 'UInventoryComponent::ItemEnemyInfoInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemNPCInfoInventory) == 0x0001E8, "Member 'UInventoryComponent::ItemNPCInfoInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemGalleryInventory) == 0x0001F0, "Member 'UInventoryComponent::ItemGalleryInventory' has a wrong offset!");

// Class Zion.AbilityInstant
// 0x0010 (0x0790 - 0x0780)
class AAbilityInstant : public AAbility
{
public:
	uint8                                         Pad_780[0x10];                                     // 0x0780(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTargets(const TArray<class AActor*>& InTargets);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityInstant">();
	}
	static class AAbilityInstant* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityInstant>();
	}
};
static_assert(alignof(AAbilityInstant) == 0x000010, "Wrong alignment on AAbilityInstant");
static_assert(sizeof(AAbilityInstant) == 0x000790, "Wrong size on AAbilityInstant");

// Class Zion.ActorBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class UActorBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearMovementBase(class ACharacter* Character);
	static void FlushAnimations(const class AActor* Actor, bool bResetAnimator);
	static class FName GenerateClearIDForActor(const class AActor* Actor);
	static class FName GetActorID(const class AActor* Actor);
	static struct FVector GetBottomLocation(const class AActor* Actor);
	static float GetHalfHeight(const class AActor* Actor);
	static const class USceneComponent* GetTargetPivotComponent(const class AActor* Actor);
	static struct FVector GetTargetPivotLocation(const class AActor* Actor);
	static struct FVector GetTopLocation(const class AActor* Actor);
	static class FName GetWorldIDForActor(const class AActor* Actor);
	static bool IsPlayer(const class AActor* Actor);
	static void ResetVelocity(class AActor* Actor, bool bResetX, bool bResetY, bool bResetZ);
	static void ToggleActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorBPFLibrary">();
	}
	static class UActorBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorBPFLibrary>();
	}
};
static_assert(alignof(UActorBPFLibrary) == 0x000008, "Wrong alignment on UActorBPFLibrary");
static_assert(sizeof(UActorBPFLibrary) == 0x000028, "Wrong size on UActorBPFLibrary");

// Class Zion.HookComponent
// 0x00E8 (0x0188 - 0x00A0)
class UHookComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SphereComponent;                                   // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SphereRadius;                                      // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxTimeSinceLastRender;                            // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinHookDistance;                                   // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinAngle;                                          // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAngle;                                          // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttachPointZLocationOffset;                        // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HookPointBelowActorDistanceWeightMultiplier;       // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             InvalidStates;                                     // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FMovementModeData>              ValidMovementModes;                                // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidgetWorldSpace>      WorldSpaceHookTargetClass_Point;                   // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x80];                                     // 0x0108(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LockCurrentHook();
	void OnAptitudesChanged();
	void OnComponentOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentOverlapEnd(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnLockHook(class AHookPoint* HookPoint);
	void OnUnlockHook(class AHookPoint* HookPoint);
	void ResetOverrideHookPoint();
	void ResetOverrideHookWorldLocation();
	void SetOverrideHookPoint(class AHookPoint* NewHookPoint);
	void SetOverrideHookWorldLocation(const struct FVector& NewHookWorldLocation);
	void UnlockHook();

	bool CanTargetHook(EHookType HookType) const;
	struct FVector GetHookWorldLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookComponent">();
	}
	static class UHookComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHookComponent>();
	}
};
static_assert(alignof(UHookComponent) == 0x000008, "Wrong alignment on UHookComponent");
static_assert(sizeof(UHookComponent) == 0x000188, "Wrong size on UHookComponent");
static_assert(offsetof(UHookComponent, SphereComponent) == 0x0000B8, "Member 'UHookComponent::SphereComponent' has a wrong offset!");
static_assert(offsetof(UHookComponent, SphereRadius) == 0x0000C0, "Member 'UHookComponent::SphereRadius' has a wrong offset!");
static_assert(offsetof(UHookComponent, MaxTimeSinceLastRender) == 0x0000C4, "Member 'UHookComponent::MaxTimeSinceLastRender' has a wrong offset!");
static_assert(offsetof(UHookComponent, MinHookDistance) == 0x0000C8, "Member 'UHookComponent::MinHookDistance' has a wrong offset!");
static_assert(offsetof(UHookComponent, MinAngle) == 0x0000CC, "Member 'UHookComponent::MinAngle' has a wrong offset!");
static_assert(offsetof(UHookComponent, MaxAngle) == 0x0000D0, "Member 'UHookComponent::MaxAngle' has a wrong offset!");
static_assert(offsetof(UHookComponent, AttachPointZLocationOffset) == 0x0000D4, "Member 'UHookComponent::AttachPointZLocationOffset' has a wrong offset!");
static_assert(offsetof(UHookComponent, HookPointBelowActorDistanceWeightMultiplier) == 0x0000D8, "Member 'UHookComponent::HookPointBelowActorDistanceWeightMultiplier' has a wrong offset!");
static_assert(offsetof(UHookComponent, InvalidStates) == 0x0000E0, "Member 'UHookComponent::InvalidStates' has a wrong offset!");
static_assert(offsetof(UHookComponent, ValidMovementModes) == 0x0000F0, "Member 'UHookComponent::ValidMovementModes' has a wrong offset!");
static_assert(offsetof(UHookComponent, WorldSpaceHookTargetClass_Point) == 0x000100, "Member 'UHookComponent::WorldSpaceHookTargetClass_Point' has a wrong offset!");

// Class Zion.EventAction_Convert
// 0x0030 (0x0088 - 0x0058)
class UEventAction_Convert : public UEventAction_SubjectBinding
{
public:
	struct FActorBindingKey                       TargetBinding;                                     // 0x0058(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      SpawnAnimations;                                   // 0x0060(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	EActorHideMode                                HideMode;                                          // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HideAnimation;                                     // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_Convert">();
	}
	static class UEventAction_Convert* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_Convert>();
	}
};
static_assert(alignof(UEventAction_Convert) == 0x000008, "Wrong alignment on UEventAction_Convert");
static_assert(sizeof(UEventAction_Convert) == 0x000088, "Wrong size on UEventAction_Convert");
static_assert(offsetof(UEventAction_Convert, TargetBinding) == 0x000058, "Member 'UEventAction_Convert::TargetBinding' has a wrong offset!");
static_assert(offsetof(UEventAction_Convert, SpawnAnimations) == 0x000060, "Member 'UEventAction_Convert::SpawnAnimations' has a wrong offset!");
static_assert(offsetof(UEventAction_Convert, HideMode) == 0x000070, "Member 'UEventAction_Convert::HideMode' has a wrong offset!");
static_assert(offsetof(UEventAction_Convert, HideAnimation) == 0x000078, "Member 'UEventAction_Convert::HideAnimation' has a wrong offset!");

// Class Zion.EventAction_ConvertToInteractableNPC
// 0x0070 (0x00F8 - 0x0088)
class UEventAction_ConvertToInteractableNPC final : public UEventAction_Convert
{
public:
	TSoftClassPtr<class UClass>                   InteractableNPCClass;                              // 0x0088(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   NPCClass;                                          // 0x00B0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FInteractableNPCData>           NPCDataList;                                       // 0x00D8(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class AInteractable_EventNPC>     LoadedInteractableNPCClass;                        // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACharacterZionNPC>          LoadedNPCClass;                                    // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_ConvertToInteractableNPC">();
	}
	static class UEventAction_ConvertToInteractableNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_ConvertToInteractableNPC>();
	}
};
static_assert(alignof(UEventAction_ConvertToInteractableNPC) == 0x000008, "Wrong alignment on UEventAction_ConvertToInteractableNPC");
static_assert(sizeof(UEventAction_ConvertToInteractableNPC) == 0x0000F8, "Wrong size on UEventAction_ConvertToInteractableNPC");
static_assert(offsetof(UEventAction_ConvertToInteractableNPC, InteractableNPCClass) == 0x000088, "Member 'UEventAction_ConvertToInteractableNPC::InteractableNPCClass' has a wrong offset!");
static_assert(offsetof(UEventAction_ConvertToInteractableNPC, NPCClass) == 0x0000B0, "Member 'UEventAction_ConvertToInteractableNPC::NPCClass' has a wrong offset!");
static_assert(offsetof(UEventAction_ConvertToInteractableNPC, NPCDataList) == 0x0000D8, "Member 'UEventAction_ConvertToInteractableNPC::NPCDataList' has a wrong offset!");
static_assert(offsetof(UEventAction_ConvertToInteractableNPC, LoadedInteractableNPCClass) == 0x0000E8, "Member 'UEventAction_ConvertToInteractableNPC::LoadedInteractableNPCClass' has a wrong offset!");
static_assert(offsetof(UEventAction_ConvertToInteractableNPC, LoadedNPCClass) == 0x0000F0, "Member 'UEventAction_ConvertToInteractableNPC::LoadedNPCClass' has a wrong offset!");

// Class Zion.VisualPivotProviderInterface
// 0x0000 (0x0000 - 0x0000)
class IVisualPivotProviderInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualPivotProviderInterface">();
	}
	static class IVisualPivotProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVisualPivotProviderInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IVisualPivotProviderInterface) == 0x000001, "Wrong alignment on IVisualPivotProviderInterface");
static_assert(sizeof(IVisualPivotProviderInterface) == 0x000001, "Wrong size on IVisualPivotProviderInterface");

// Class Zion.ActorSpawner
// 0x0058 (0x02E8 - 0x0290)
class AActorSpawner final : public ASpawner
{
public:
	class UGameplayConditionRefreshComponent*     ConditionRefreshComponent;                         // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   ActorToSpawn;                                      // 0x0298(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOffsetByHalfHeight;                               // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayConditionChecker              ConditionChecker;                                  // 0x02C8(0x0018)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPostSpawnActor(class AActor* Actor, bool bPreview);
	void OnPreSpawnActor(class AActor* Actor);
	void SetActorToSpawn(const TSoftClassPtr<class UClass>& InActorClassToSpawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorSpawner">();
	}
	static class AActorSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActorSpawner>();
	}
};
static_assert(alignof(AActorSpawner) == 0x000008, "Wrong alignment on AActorSpawner");
static_assert(sizeof(AActorSpawner) == 0x0002E8, "Wrong size on AActorSpawner");
static_assert(offsetof(AActorSpawner, ConditionRefreshComponent) == 0x000290, "Member 'AActorSpawner::ConditionRefreshComponent' has a wrong offset!");
static_assert(offsetof(AActorSpawner, ActorToSpawn) == 0x000298, "Member 'AActorSpawner::ActorToSpawn' has a wrong offset!");
static_assert(offsetof(AActorSpawner, bOffsetByHalfHeight) == 0x0002C0, "Member 'AActorSpawner::bOffsetByHalfHeight' has a wrong offset!");
static_assert(offsetof(AActorSpawner, ConditionChecker) == 0x0002C8, "Member 'AActorSpawner::ConditionChecker' has a wrong offset!");

// Class Zion.AfterImageRenderer
// 0x0000 (0x0290 - 0x0290)
class AAfterImageRenderer final : public AActor
{
public:
	void OnSetup(const struct FTransform& Transform, class UTextureRenderTarget2D* Texture);
	void Release();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AfterImageRenderer">();
	}
	static class AAfterImageRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAfterImageRenderer>();
	}
};
static_assert(alignof(AAfterImageRenderer) == 0x000008, "Wrong alignment on AAfterImageRenderer");
static_assert(sizeof(AAfterImageRenderer) == 0x000290, "Wrong size on AAfterImageRenderer");

// Class Zion.CommandModule_IKBoneTarget
// 0x0048 (0x0080 - 0x0038)
class UCommandModule_IKBoneTarget final : public UCommandModule
{
public:
	EIKBoneDriver                                 IKBoneDriver;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bResetIKBoneOnFinish;                              // 0x0039(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseEndTime;                                       // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndTime;                                           // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EIKBoneBlendMode                              BlendMode;                                         // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInjectionSpeed;                               // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationSpeed;                                     // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinIKTargetDistance;                               // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EIKBoneReferenceVectorMode                    ClampReferenceVectorMode;                          // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampAngleMin;                                     // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ClampAngleMax;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideAbilityGlobalOffset;                      // 0x0064(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_65[0x1B];                                      // 0x0065(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_IKBoneTarget">();
	}
	static class UCommandModule_IKBoneTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_IKBoneTarget>();
	}
};
static_assert(alignof(UCommandModule_IKBoneTarget) == 0x000008, "Wrong alignment on UCommandModule_IKBoneTarget");
static_assert(sizeof(UCommandModule_IKBoneTarget) == 0x000080, "Wrong size on UCommandModule_IKBoneTarget");
static_assert(offsetof(UCommandModule_IKBoneTarget, IKBoneDriver) == 0x000038, "Member 'UCommandModule_IKBoneTarget::IKBoneDriver' has a wrong offset!");
static_assert(offsetof(UCommandModule_IKBoneTarget, bResetIKBoneOnFinish) == 0x000039, "Member 'UCommandModule_IKBoneTarget::bResetIKBoneOnFinish' has a wrong offset!");
static_assert(offsetof(UCommandModule_IKBoneTarget, StartTime) == 0x00003C, "Member 'UCommandModule_IKBoneTarget::StartTime' has a wrong offset!");
static_assert(offsetof(UCommandModule_IKBoneTarget, bUseEndTime) == 0x000040, "Member 'UCommandModule_IKBoneTarget::bUseEndTime' has a wrong offset!");
static_assert(offsetof(UCommandModule_IKBoneTarget, EndTime) == 0x000044, "Member 'UCommandModule_IKBoneTarget::EndTime' has a wrong offset!");
static_assert(offsetof(UCommandModule_IKBoneTarget, BlendMode) == 0x000048, "Member 'UCommandModule_IKBoneTarget::BlendMode' has a wrong offset!");
static_assert(offsetof(UCommandModule_IKBoneTarget, BlendInjectionSpeed) == 0x00004C, "Member 'UCommandModule_IKBoneTarget::BlendInjectionSpeed' has a wrong offset!");
static_assert(offsetof(UCommandModule_IKBoneTarget, RotationSpeed) == 0x000050, "Member 'UCommandModule_IKBoneTarget::RotationSpeed' has a wrong offset!");
static_assert(offsetof(UCommandModule_IKBoneTarget, MinIKTargetDistance) == 0x000054, "Member 'UCommandModule_IKBoneTarget::MinIKTargetDistance' has a wrong offset!");
static_assert(offsetof(UCommandModule_IKBoneTarget, ClampReferenceVectorMode) == 0x000058, "Member 'UCommandModule_IKBoneTarget::ClampReferenceVectorMode' has a wrong offset!");
static_assert(offsetof(UCommandModule_IKBoneTarget, ClampAngleMin) == 0x00005C, "Member 'UCommandModule_IKBoneTarget::ClampAngleMin' has a wrong offset!");
static_assert(offsetof(UCommandModule_IKBoneTarget, ClampAngleMax) == 0x000060, "Member 'UCommandModule_IKBoneTarget::ClampAngleMax' has a wrong offset!");
static_assert(offsetof(UCommandModule_IKBoneTarget, bOverrideAbilityGlobalOffset) == 0x000064, "Member 'UCommandModule_IKBoneTarget::bOverrideAbilityGlobalOffset' has a wrong offset!");

// Class Zion.CameraOverrideModule_SettingsEaseOutExp
// 0x0008 (0x0030 - 0x0028)
class UCameraOverrideModule_SettingsEaseOutExp final : public UCameraOverrideModule
{
public:
	float                                         SettingsEaseOutExp;                                // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_SettingsEaseOutExp">();
	}
	static class UCameraOverrideModule_SettingsEaseOutExp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_SettingsEaseOutExp>();
	}
};
static_assert(alignof(UCameraOverrideModule_SettingsEaseOutExp) == 0x000008, "Wrong alignment on UCameraOverrideModule_SettingsEaseOutExp");
static_assert(sizeof(UCameraOverrideModule_SettingsEaseOutExp) == 0x000030, "Wrong size on UCameraOverrideModule_SettingsEaseOutExp");
static_assert(offsetof(UCameraOverrideModule_SettingsEaseOutExp, SettingsEaseOutExp) == 0x000028, "Member 'UCameraOverrideModule_SettingsEaseOutExp::SettingsEaseOutExp' has a wrong offset!");

// Class Zion.AfterImageComponent
// 0x0140 (0x0C30 - 0x0AF0)
class UAfterImageComponent final : public USceneCaptureComponent2D
{
public:
	int32                                         RenderTargetSize;                                  // 0x0AF0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AfterImageCount;                                   // 0x0AF4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpdatePeriod;                                      // 0x0AF8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAlwaysEnabled;                                    // 0x0AFC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAfterImageType                               AfterImageType;                                    // 0x0AFD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AFE[0x2];                                      // 0x0AFE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           FXData;                                            // 0x0B00(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class AAfterImageRenderer>        AfterImageRendererClass;                           // 0x0C00(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTextureRenderTarget2D*>         RenderTargets;                                     // 0x0C08(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C18[0x18];                                     // 0x0C18(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAfterImageType(EAfterImageType NewAfterImageType);

	EAfterImageType GetAfterImageType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AfterImageComponent">();
	}
	static class UAfterImageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAfterImageComponent>();
	}
};
static_assert(alignof(UAfterImageComponent) == 0x000010, "Wrong alignment on UAfterImageComponent");
static_assert(sizeof(UAfterImageComponent) == 0x000C30, "Wrong size on UAfterImageComponent");
static_assert(offsetof(UAfterImageComponent, RenderTargetSize) == 0x000AF0, "Member 'UAfterImageComponent::RenderTargetSize' has a wrong offset!");
static_assert(offsetof(UAfterImageComponent, AfterImageCount) == 0x000AF4, "Member 'UAfterImageComponent::AfterImageCount' has a wrong offset!");
static_assert(offsetof(UAfterImageComponent, UpdatePeriod) == 0x000AF8, "Member 'UAfterImageComponent::UpdatePeriod' has a wrong offset!");
static_assert(offsetof(UAfterImageComponent, bAlwaysEnabled) == 0x000AFC, "Member 'UAfterImageComponent::bAlwaysEnabled' has a wrong offset!");
static_assert(offsetof(UAfterImageComponent, AfterImageType) == 0x000AFD, "Member 'UAfterImageComponent::AfterImageType' has a wrong offset!");
static_assert(offsetof(UAfterImageComponent, FXData) == 0x000B00, "Member 'UAfterImageComponent::FXData' has a wrong offset!");
static_assert(offsetof(UAfterImageComponent, AfterImageRendererClass) == 0x000C00, "Member 'UAfterImageComponent::AfterImageRendererClass' has a wrong offset!");
static_assert(offsetof(UAfterImageComponent, RenderTargets) == 0x000C08, "Member 'UAfterImageComponent::RenderTargets' has a wrong offset!");

// Class Zion.Command_HoldGuard
// 0x0148 (0x01F0 - 0x00A8)
class UCommand_HoldGuard final : public UCommand
{
public:
	float                                         MaxEnergy;                                         // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EnergyCostPerSecond;                               // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EnergyRegenPerSecond;                              // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DamageCutPercentageBonus;                          // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityData                           OnGuardedAbilityData;                              // 0x00C0(0x00E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bUseAbilityCooldown;                               // 0x01A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AbilityCooldown;                                   // 0x01A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidgetWorldSpaceGauge> GaugeClass;                                        // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AWorldSpaceWidgetHolder*                GaugeWidgetHolder;                                 // 0x01B0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x38];                                     // 0x01B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGuarded(class AAbility* Ability, class AActor* Source);
	void OnReceivedDamage(class AActor* Source, int32 Value);
	void OnRelease();

	bool IsReleased() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command_HoldGuard">();
	}
	static class UCommand_HoldGuard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand_HoldGuard>();
	}
};
static_assert(alignof(UCommand_HoldGuard) == 0x000010, "Wrong alignment on UCommand_HoldGuard");
static_assert(sizeof(UCommand_HoldGuard) == 0x0001F0, "Wrong size on UCommand_HoldGuard");
static_assert(offsetof(UCommand_HoldGuard, MaxEnergy) == 0x0000A8, "Member 'UCommand_HoldGuard::MaxEnergy' has a wrong offset!");
static_assert(offsetof(UCommand_HoldGuard, EnergyCostPerSecond) == 0x0000AC, "Member 'UCommand_HoldGuard::EnergyCostPerSecond' has a wrong offset!");
static_assert(offsetof(UCommand_HoldGuard, EnergyRegenPerSecond) == 0x0000B0, "Member 'UCommand_HoldGuard::EnergyRegenPerSecond' has a wrong offset!");
static_assert(offsetof(UCommand_HoldGuard, DamageCutPercentageBonus) == 0x0000B4, "Member 'UCommand_HoldGuard::DamageCutPercentageBonus' has a wrong offset!");
static_assert(offsetof(UCommand_HoldGuard, OnGuardedAbilityData) == 0x0000C0, "Member 'UCommand_HoldGuard::OnGuardedAbilityData' has a wrong offset!");
static_assert(offsetof(UCommand_HoldGuard, bUseAbilityCooldown) == 0x0001A0, "Member 'UCommand_HoldGuard::bUseAbilityCooldown' has a wrong offset!");
static_assert(offsetof(UCommand_HoldGuard, AbilityCooldown) == 0x0001A4, "Member 'UCommand_HoldGuard::AbilityCooldown' has a wrong offset!");
static_assert(offsetof(UCommand_HoldGuard, GaugeClass) == 0x0001A8, "Member 'UCommand_HoldGuard::GaugeClass' has a wrong offset!");
static_assert(offsetof(UCommand_HoldGuard, GaugeWidgetHolder) == 0x0001B0, "Member 'UCommand_HoldGuard::GaugeWidgetHolder' has a wrong offset!");

// Class Zion.AICommandClassProviderInterface
// 0x0000 (0x0000 - 0x0000)
class IAICommandClassProviderInterface final
{
public:
	void GetFindEnemyCommandClass(TSubclassOf<class UCommand>* out_CommandClass);
	void GetIdlePeaceCommandClass(TSubclassOf<class UCommand>* out_CommandClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICommandClassProviderInterface">();
	}
	static class IAICommandClassProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAICommandClassProviderInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAICommandClassProviderInterface) == 0x000001, "Wrong alignment on IAICommandClassProviderInterface");
static_assert(sizeof(IAICommandClassProviderInterface) == 0x000001, "Wrong size on IAICommandClassProviderInterface");

// Class Zion.HookPoint
// 0x0038 (0x02C8 - 0x0290)
class AHookPoint : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EHookType                                     HookType;                                          // 0x0298(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        RootSceneComponent;                                // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       SphereComponent;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         AvailableFXSystem;                                 // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      FXInstance;                                        // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class USceneComponent* GetHookAttachComponent() const;
	struct FVector GetHookLocation() const;
	struct FTransform GetHookTransform() const;
	EHookType GetHookType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookPoint">();
	}
	static class AHookPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHookPoint>();
	}
};
static_assert(alignof(AHookPoint) == 0x000008, "Wrong alignment on AHookPoint");
static_assert(sizeof(AHookPoint) == 0x0002C8, "Wrong size on AHookPoint");
static_assert(offsetof(AHookPoint, HookType) == 0x000298, "Member 'AHookPoint::HookType' has a wrong offset!");
static_assert(offsetof(AHookPoint, RootSceneComponent) == 0x0002A0, "Member 'AHookPoint::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AHookPoint, SphereComponent) == 0x0002A8, "Member 'AHookPoint::SphereComponent' has a wrong offset!");
static_assert(offsetof(AHookPoint, AvailableFXSystem) == 0x0002B0, "Member 'AHookPoint::AvailableFXSystem' has a wrong offset!");
static_assert(offsetof(AHookPoint, FXInstance) == 0x0002C0, "Member 'AHookPoint::FXInstance' has a wrong offset!");

// Class Zion.HookPoint_Moving
// 0x0088 (0x0350 - 0x02C8)
class AHookPoint_Moving final : public AHookPoint
{
public:
	class UFollowSplineComponent*                 FollowSplineComponent;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       SplineComponent;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          CallToStartTrigger;                                // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          CallToEndTrigger;                                  // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             StartMovementFMODEvent;                            // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             LoopMovementFMODEvent;                             // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             StopMovementFMODEvent;                             // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldStopWhenCharacterLeaves;                    // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanBeUsedAtSplineEnd;                             // 0x0301(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanBeCalledAtSplineStart;                         // 0x0302(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanBeCalledAtSplineEnd;                           // 0x0303(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x0308(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InnerRadius;                                       // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OuterRadius;                                       // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Falloff;                                           // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOrientShakeTowardsEpicenter;                      // 0x031C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0320(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x28];                                     // 0x0328(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookPoint_Moving">();
	}
	static class AHookPoint_Moving* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHookPoint_Moving>();
	}
};
static_assert(alignof(AHookPoint_Moving) == 0x000008, "Wrong alignment on AHookPoint_Moving");
static_assert(sizeof(AHookPoint_Moving) == 0x000350, "Wrong size on AHookPoint_Moving");
static_assert(offsetof(AHookPoint_Moving, FollowSplineComponent) == 0x0002C8, "Member 'AHookPoint_Moving::FollowSplineComponent' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, SplineComponent) == 0x0002D0, "Member 'AHookPoint_Moving::SplineComponent' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, CallToStartTrigger) == 0x0002D8, "Member 'AHookPoint_Moving::CallToStartTrigger' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, CallToEndTrigger) == 0x0002E0, "Member 'AHookPoint_Moving::CallToEndTrigger' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, StartMovementFMODEvent) == 0x0002E8, "Member 'AHookPoint_Moving::StartMovementFMODEvent' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, LoopMovementFMODEvent) == 0x0002F0, "Member 'AHookPoint_Moving::LoopMovementFMODEvent' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, StopMovementFMODEvent) == 0x0002F8, "Member 'AHookPoint_Moving::StopMovementFMODEvent' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, bShouldStopWhenCharacterLeaves) == 0x000300, "Member 'AHookPoint_Moving::bShouldStopWhenCharacterLeaves' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, bCanBeUsedAtSplineEnd) == 0x000301, "Member 'AHookPoint_Moving::bCanBeUsedAtSplineEnd' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, bCanBeCalledAtSplineStart) == 0x000302, "Member 'AHookPoint_Moving::bCanBeCalledAtSplineStart' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, bCanBeCalledAtSplineEnd) == 0x000303, "Member 'AHookPoint_Moving::bCanBeCalledAtSplineEnd' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, CameraShake) == 0x000308, "Member 'AHookPoint_Moving::CameraShake' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, InnerRadius) == 0x000310, "Member 'AHookPoint_Moving::InnerRadius' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, OuterRadius) == 0x000314, "Member 'AHookPoint_Moving::OuterRadius' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, Falloff) == 0x000318, "Member 'AHookPoint_Moving::Falloff' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, bOrientShakeTowardsEpicenter) == 0x00031C, "Member 'AHookPoint_Moving::bOrientShakeTowardsEpicenter' has a wrong offset!");
static_assert(offsetof(AHookPoint_Moving, ForceFeedbackEffect) == 0x000320, "Member 'AHookPoint_Moving::ForceFeedbackEffect' has a wrong offset!");

// Class Zion.CameraOverrideModule_MinMaxBlendSpeed
// 0x0008 (0x0030 - 0x0028)
class UCameraOverrideModule_MinMaxBlendSpeed final : public UCameraOverrideModule
{
public:
	float                                         MinMaxBlendSpeed;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_MinMaxBlendSpeed">();
	}
	static class UCameraOverrideModule_MinMaxBlendSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_MinMaxBlendSpeed>();
	}
};
static_assert(alignof(UCameraOverrideModule_MinMaxBlendSpeed) == 0x000008, "Wrong alignment on UCameraOverrideModule_MinMaxBlendSpeed");
static_assert(sizeof(UCameraOverrideModule_MinMaxBlendSpeed) == 0x000030, "Wrong size on UCameraOverrideModule_MinMaxBlendSpeed");
static_assert(offsetof(UCameraOverrideModule_MinMaxBlendSpeed, MinMaxBlendSpeed) == 0x000028, "Member 'UCameraOverrideModule_MinMaxBlendSpeed::MinMaxBlendSpeed' has a wrong offset!");

// Class Zion.AIControllerZion
// 0x00E8 (0x04A0 - 0x03B8)
class AAIControllerZion : public AAIController
{
public:
	EFaction                                      Faction;                                           // 0x03B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionProfile                             CollisionProfile;                                  // 0x03B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3BA[0x6];                                      // 0x03BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlackboardData*                        BlackboardData;                                    // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTree*                          BehaviorTree_Main;                                 // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTree*                          BehaviorTree_Aggression;                           // 0x03D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           BehaviorTree_Aggression_Tag;                       // 0x03D8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTree*                          BehaviorTree_Idle;                                 // 0x03E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           BehaviorTree_Idle_Tag;                             // 0x03E8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIData                                AIData;                                            // 0x03F0(0x0090)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x20];                                     // 0x0480(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeTarget(const class AActor* NewTarget);
	void OnPawnDeathProcessEnd();
	void OnPawnDeathProcessStart();
	void PauseLogic();
	void RestartLogic();
	void ResumeLogic();
	void StartLogic();
	void StopLogic();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIControllerZion">();
	}
	static class AAIControllerZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIControllerZion>();
	}
};
static_assert(alignof(AAIControllerZion) == 0x000008, "Wrong alignment on AAIControllerZion");
static_assert(sizeof(AAIControllerZion) == 0x0004A0, "Wrong size on AAIControllerZion");
static_assert(offsetof(AAIControllerZion, Faction) == 0x0003B8, "Member 'AAIControllerZion::Faction' has a wrong offset!");
static_assert(offsetof(AAIControllerZion, CollisionProfile) == 0x0003B9, "Member 'AAIControllerZion::CollisionProfile' has a wrong offset!");
static_assert(offsetof(AAIControllerZion, BlackboardData) == 0x0003C0, "Member 'AAIControllerZion::BlackboardData' has a wrong offset!");
static_assert(offsetof(AAIControllerZion, BehaviorTree_Main) == 0x0003C8, "Member 'AAIControllerZion::BehaviorTree_Main' has a wrong offset!");
static_assert(offsetof(AAIControllerZion, BehaviorTree_Aggression) == 0x0003D0, "Member 'AAIControllerZion::BehaviorTree_Aggression' has a wrong offset!");
static_assert(offsetof(AAIControllerZion, BehaviorTree_Aggression_Tag) == 0x0003D8, "Member 'AAIControllerZion::BehaviorTree_Aggression_Tag' has a wrong offset!");
static_assert(offsetof(AAIControllerZion, BehaviorTree_Idle) == 0x0003E0, "Member 'AAIControllerZion::BehaviorTree_Idle' has a wrong offset!");
static_assert(offsetof(AAIControllerZion, BehaviorTree_Idle_Tag) == 0x0003E8, "Member 'AAIControllerZion::BehaviorTree_Idle_Tag' has a wrong offset!");
static_assert(offsetof(AAIControllerZion, AIData) == 0x0003F0, "Member 'AAIControllerZion::AIData' has a wrong offset!");

// Class Zion.AIControllerZion_Enemy
// 0x0168 (0x0608 - 0x04A0)
class AAIControllerZion_Enemy : public AAIControllerZion
{
public:
	class UStatsControllerAIComponent*            StatsControllerAIComponent;                        // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidgetEnemyUI>         EnemyUIClass;                                      // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInAmbush;                                         // 0x04B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B1[0x7];                                      // 0x04B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidgetEnemyUI*                     EnemyUI;                                           // 0x04B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    EnemyDataRowHandle;                                // 0x04C0(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x138];                                    // 0x04D0(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIControllerZion_Enemy">();
	}
	static class AAIControllerZion_Enemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIControllerZion_Enemy>();
	}
};
static_assert(alignof(AAIControllerZion_Enemy) == 0x000008, "Wrong alignment on AAIControllerZion_Enemy");
static_assert(sizeof(AAIControllerZion_Enemy) == 0x000608, "Wrong size on AAIControllerZion_Enemy");
static_assert(offsetof(AAIControllerZion_Enemy, StatsControllerAIComponent) == 0x0004A0, "Member 'AAIControllerZion_Enemy::StatsControllerAIComponent' has a wrong offset!");
static_assert(offsetof(AAIControllerZion_Enemy, EnemyUIClass) == 0x0004A8, "Member 'AAIControllerZion_Enemy::EnemyUIClass' has a wrong offset!");
static_assert(offsetof(AAIControllerZion_Enemy, bInAmbush) == 0x0004B0, "Member 'AAIControllerZion_Enemy::bInAmbush' has a wrong offset!");
static_assert(offsetof(AAIControllerZion_Enemy, EnemyUI) == 0x0004B8, "Member 'AAIControllerZion_Enemy::EnemyUI' has a wrong offset!");
static_assert(offsetof(AAIControllerZion_Enemy, EnemyDataRowHandle) == 0x0004C0, "Member 'AAIControllerZion_Enemy::EnemyDataRowHandle' has a wrong offset!");

// Class Zion.CommandSet
// 0x0018 (0x0048 - 0x0030)
class UCommandSet final : public UDataAsset
{
public:
	ECommandSetCategory                           Category;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowAutoReSummon;                                // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UCommandSettingsData*>           CommandSettingsList;                               // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandSet">();
	}
	static class UCommandSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandSet>();
	}
};
static_assert(alignof(UCommandSet) == 0x000008, "Wrong alignment on UCommandSet");
static_assert(sizeof(UCommandSet) == 0x000048, "Wrong size on UCommandSet");
static_assert(offsetof(UCommandSet, Category) == 0x000030, "Member 'UCommandSet::Category' has a wrong offset!");
static_assert(offsetof(UCommandSet, bAllowAutoReSummon) == 0x000031, "Member 'UCommandSet::bAllowAutoReSummon' has a wrong offset!");
static_assert(offsetof(UCommandSet, Cooldown) == 0x000034, "Member 'UCommandSet::Cooldown' has a wrong offset!");
static_assert(offsetof(UCommandSet, CommandSettingsList) == 0x000038, "Member 'UCommandSet::CommandSettingsList' has a wrong offset!");

// Class Zion.UserWidgetWrapBox
// 0x0020 (0x0480 - 0x0460)
class UUserWidgetWrapBox final : public UUserWidgetZion
{
public:
	class UWrapBox*                               WrapBox;                                           // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              InnerSlotPadding;                                  // 0x0468(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WrapSize;                                          // 0x0478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bExplicitWrapSize;                                 // 0x047C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x047D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrientation                                  Orientation;                                       // 0x047E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47F[0x1];                                      // 0x047F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddChild(class UWidget* Content);
	void ClearChildren();
	bool RemoveChild(class UWidget* Content);
	bool RemoveChildAt(int32 Index_0);

	TArray<class UWidget*> GetAllChildren() const;
	class UWidget* GetChildAt(int32 Index_0) const;
	int32 GetChildIndex(const class UWidget* Content) const;
	int32 GetChildrenCount() const;
	class UWidget* GetWrapNavigationWidget(bool bWrapToTop) const;
	bool HasAnyChildren() const;
	bool HasChild(class UWidget* Content) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetWrapBox">();
	}
	static class UUserWidgetWrapBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetWrapBox>();
	}
};
static_assert(alignof(UUserWidgetWrapBox) == 0x000008, "Wrong alignment on UUserWidgetWrapBox");
static_assert(sizeof(UUserWidgetWrapBox) == 0x000480, "Wrong size on UUserWidgetWrapBox");
static_assert(offsetof(UUserWidgetWrapBox, WrapBox) == 0x000460, "Member 'UUserWidgetWrapBox::WrapBox' has a wrong offset!");
static_assert(offsetof(UUserWidgetWrapBox, InnerSlotPadding) == 0x000468, "Member 'UUserWidgetWrapBox::InnerSlotPadding' has a wrong offset!");
static_assert(offsetof(UUserWidgetWrapBox, WrapSize) == 0x000478, "Member 'UUserWidgetWrapBox::WrapSize' has a wrong offset!");
static_assert(offsetof(UUserWidgetWrapBox, bExplicitWrapSize) == 0x00047C, "Member 'UUserWidgetWrapBox::bExplicitWrapSize' has a wrong offset!");
static_assert(offsetof(UUserWidgetWrapBox, HorizontalAlignment) == 0x00047D, "Member 'UUserWidgetWrapBox::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UUserWidgetWrapBox, Orientation) == 0x00047E, "Member 'UUserWidgetWrapBox::Orientation' has a wrong offset!");

// Class Zion.AIControllerZion_Spirit
// 0x0000 (0x04A0 - 0x04A0)
class AAIControllerZion_Spirit : public AAIControllerZion
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIControllerZion_Spirit">();
	}
	static class AAIControllerZion_Spirit* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIControllerZion_Spirit>();
	}
};
static_assert(alignof(AAIControllerZion_Spirit) == 0x000008, "Wrong alignment on AAIControllerZion_Spirit");
static_assert(sizeof(AAIControllerZion_Spirit) == 0x0004A0, "Wrong size on AAIControllerZion_Spirit");

// Class Zion.EventAction_ForceFeedback
// 0x0008 (0x0058 - 0x0050)
class UEventAction_ForceFeedback final : public UEventAction
{
public:
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_ForceFeedback">();
	}
	static class UEventAction_ForceFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_ForceFeedback>();
	}
};
static_assert(alignof(UEventAction_ForceFeedback) == 0x000008, "Wrong alignment on UEventAction_ForceFeedback");
static_assert(sizeof(UEventAction_ForceFeedback) == 0x000058, "Wrong size on UEventAction_ForceFeedback");
static_assert(offsetof(UEventAction_ForceFeedback, ForceFeedbackEffect) == 0x000050, "Member 'UEventAction_ForceFeedback::ForceFeedbackEffect' has a wrong offset!");

// Class Zion.AnimationFromVelocityComponent
// 0x0060 (0x0100 - 0x00A0)
class UAnimationFromVelocityComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnimationNeutral;                                  // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AnimationUp;                                       // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AnimationDown;                                     // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AnimationForward;                                  // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSyncTrackTime;                                    // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VelocityZForUp;                                    // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VelocityZForDown;                                  // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VelocityYForForward;                               // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ResetAnimationCycle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationFromVelocityComponent">();
	}
	static class UAnimationFromVelocityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationFromVelocityComponent>();
	}
};
static_assert(alignof(UAnimationFromVelocityComponent) == 0x000008, "Wrong alignment on UAnimationFromVelocityComponent");
static_assert(sizeof(UAnimationFromVelocityComponent) == 0x000100, "Wrong size on UAnimationFromVelocityComponent");
static_assert(offsetof(UAnimationFromVelocityComponent, AnimationNeutral) == 0x0000B0, "Member 'UAnimationFromVelocityComponent::AnimationNeutral' has a wrong offset!");
static_assert(offsetof(UAnimationFromVelocityComponent, AnimationUp) == 0x0000C0, "Member 'UAnimationFromVelocityComponent::AnimationUp' has a wrong offset!");
static_assert(offsetof(UAnimationFromVelocityComponent, AnimationDown) == 0x0000D0, "Member 'UAnimationFromVelocityComponent::AnimationDown' has a wrong offset!");
static_assert(offsetof(UAnimationFromVelocityComponent, AnimationForward) == 0x0000E0, "Member 'UAnimationFromVelocityComponent::AnimationForward' has a wrong offset!");
static_assert(offsetof(UAnimationFromVelocityComponent, bSyncTrackTime) == 0x0000F0, "Member 'UAnimationFromVelocityComponent::bSyncTrackTime' has a wrong offset!");
static_assert(offsetof(UAnimationFromVelocityComponent, VelocityZForUp) == 0x0000F4, "Member 'UAnimationFromVelocityComponent::VelocityZForUp' has a wrong offset!");
static_assert(offsetof(UAnimationFromVelocityComponent, VelocityZForDown) == 0x0000F8, "Member 'UAnimationFromVelocityComponent::VelocityZForDown' has a wrong offset!");
static_assert(offsetof(UAnimationFromVelocityComponent, VelocityYForForward) == 0x0000FC, "Member 'UAnimationFromVelocityComponent::VelocityYForForward' has a wrong offset!");

// Class Zion.CameraOverrideModule_FOV
// 0x0010 (0x0038 - 0x0028)
class UCameraOverrideModule_FOV final : public UCameraOverrideModule
{
public:
	ECameraModuleOverrideType                     OverrideType;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FOV;                                               // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FOVFactor;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_FOV">();
	}
	static class UCameraOverrideModule_FOV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_FOV>();
	}
};
static_assert(alignof(UCameraOverrideModule_FOV) == 0x000008, "Wrong alignment on UCameraOverrideModule_FOV");
static_assert(sizeof(UCameraOverrideModule_FOV) == 0x000038, "Wrong size on UCameraOverrideModule_FOV");
static_assert(offsetof(UCameraOverrideModule_FOV, OverrideType) == 0x000028, "Member 'UCameraOverrideModule_FOV::OverrideType' has a wrong offset!");
static_assert(offsetof(UCameraOverrideModule_FOV, FOV) == 0x00002C, "Member 'UCameraOverrideModule_FOV::FOV' has a wrong offset!");
static_assert(offsetof(UCameraOverrideModule_FOV, FOVFactor) == 0x000030, "Member 'UCameraOverrideModule_FOV::FOVFactor' has a wrong offset!");

// Class Zion.ArrayBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class UArrayBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FName> SortNames(TArray<class FName>& Array);
	static TArray<struct FTextIntStruct> SortTextIntStructs(TArray<struct FTextIntStruct>& Array);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrayBPFLibrary">();
	}
	static class UArrayBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArrayBPFLibrary>();
	}
};
static_assert(alignof(UArrayBPFLibrary) == 0x000008, "Wrong alignment on UArrayBPFLibrary");
static_assert(sizeof(UArrayBPFLibrary) == 0x000028, "Wrong size on UArrayBPFLibrary");

// Class Zion.Assist
// 0x0058 (0x0080 - 0x0028)
class UAssist final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAssistTrigger*>                 Triggers;                                          // 0x0070(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Assist">();
	}
	static class UAssist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssist>();
	}
};
static_assert(alignof(UAssist) == 0x000008, "Wrong alignment on UAssist");
static_assert(sizeof(UAssist) == 0x000080, "Wrong size on UAssist");
static_assert(offsetof(UAssist, Triggers) == 0x000070, "Member 'UAssist::Triggers' has a wrong offset!");

// Class Zion.CommandModule_ResetJumpCount
// 0x0008 (0x0040 - 0x0038)
class UCommandModule_ResetJumpCount final : public UCommandModule
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_ResetJumpCount">();
	}
	static class UCommandModule_ResetJumpCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_ResetJumpCount>();
	}
};
static_assert(alignof(UCommandModule_ResetJumpCount) == 0x000008, "Wrong alignment on UCommandModule_ResetJumpCount");
static_assert(sizeof(UCommandModule_ResetJumpCount) == 0x000040, "Wrong size on UCommandModule_ResetJumpCount");

// Class Zion.ZionPathFollowingComponent
// 0x0010 (0x02F0 - 0x02E0)
class UZionPathFollowingComponent final : public UPathFollowingComponent
{
public:
	EPathFollowingMode                            PathFollowingMode;                                 // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverridePathAcceptanceRadius;                     // 0x02E4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathPointAcceptanceRadius;                         // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZionPathFollowingComponent">();
	}
	static class UZionPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZionPathFollowingComponent>();
	}
};
static_assert(alignof(UZionPathFollowingComponent) == 0x000008, "Wrong alignment on UZionPathFollowingComponent");
static_assert(sizeof(UZionPathFollowingComponent) == 0x0002F0, "Wrong size on UZionPathFollowingComponent");
static_assert(offsetof(UZionPathFollowingComponent, PathFollowingMode) == 0x0002E0, "Member 'UZionPathFollowingComponent::PathFollowingMode' has a wrong offset!");
static_assert(offsetof(UZionPathFollowingComponent, bOverridePathAcceptanceRadius) == 0x0002E4, "Member 'UZionPathFollowingComponent::bOverridePathAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(UZionPathFollowingComponent, PathPointAcceptanceRadius) == 0x0002E8, "Member 'UZionPathFollowingComponent::PathPointAcceptanceRadius' has a wrong offset!");

// Class Zion.AssistAction
// 0x0000 (0x0028 - 0x0028)
class UAssistAction : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistAction">();
	}
	static class UAssistAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistAction>();
	}
};
static_assert(alignof(UAssistAction) == 0x000008, "Wrong alignment on UAssistAction");
static_assert(sizeof(UAssistAction) == 0x000028, "Wrong size on UAssistAction");

// Class Zion.CommandCondition_MovementSpeedMode
// 0x0018 (0x0050 - 0x0038)
class UCommandCondition_MovementSpeedMode final : public UCommandCondition
{
public:
	TArray<EMovementSpeedMode>                    ValidMovementSpeedModes;                           // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_MovementSpeedMode">();
	}
	static class UCommandCondition_MovementSpeedMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_MovementSpeedMode>();
	}
};
static_assert(alignof(UCommandCondition_MovementSpeedMode) == 0x000008, "Wrong alignment on UCommandCondition_MovementSpeedMode");
static_assert(sizeof(UCommandCondition_MovementSpeedMode) == 0x000050, "Wrong size on UCommandCondition_MovementSpeedMode");
static_assert(offsetof(UCommandCondition_MovementSpeedMode, ValidMovementSpeedModes) == 0x000038, "Member 'UCommandCondition_MovementSpeedMode::ValidMovementSpeedModes' has a wrong offset!");

// Class Zion.AssistAction_DebuffReset
// 0x0000 (0x0028 - 0x0028)
class UAssistAction_DebuffReset final : public UAssistAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistAction_DebuffReset">();
	}
	static class UAssistAction_DebuffReset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistAction_DebuffReset>();
	}
};
static_assert(alignof(UAssistAction_DebuffReset) == 0x000008, "Wrong alignment on UAssistAction_DebuffReset");
static_assert(sizeof(UAssistAction_DebuffReset) == 0x000028, "Wrong size on UAssistAction_DebuffReset");

// Class Zion.CameraOverrideModule_EnemyBoundsFactor
// 0x0008 (0x0030 - 0x0028)
class UCameraOverrideModule_EnemyBoundsFactor final : public UCameraOverrideModule
{
public:
	float                                         EnemyBoundsFactor;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_EnemyBoundsFactor">();
	}
	static class UCameraOverrideModule_EnemyBoundsFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_EnemyBoundsFactor>();
	}
};
static_assert(alignof(UCameraOverrideModule_EnemyBoundsFactor) == 0x000008, "Wrong alignment on UCameraOverrideModule_EnemyBoundsFactor");
static_assert(sizeof(UCameraOverrideModule_EnemyBoundsFactor) == 0x000030, "Wrong size on UCameraOverrideModule_EnemyBoundsFactor");
static_assert(offsetof(UCameraOverrideModule_EnemyBoundsFactor, EnemyBoundsFactor) == 0x000028, "Member 'UCameraOverrideModule_EnemyBoundsFactor::EnemyBoundsFactor' has a wrong offset!");

// Class Zion.AssistAction_RestoreHP
// 0x0008 (0x0030 - 0x0028)
class UAssistAction_RestoreHP final : public UAssistAction
{
public:
	float                                         HPPercentage;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistAction_RestoreHP">();
	}
	static class UAssistAction_RestoreHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistAction_RestoreHP>();
	}
};
static_assert(alignof(UAssistAction_RestoreHP) == 0x000008, "Wrong alignment on UAssistAction_RestoreHP");
static_assert(sizeof(UAssistAction_RestoreHP) == 0x000030, "Wrong size on UAssistAction_RestoreHP");
static_assert(offsetof(UAssistAction_RestoreHP, HPPercentage) == 0x000028, "Member 'UAssistAction_RestoreHP::HPPercentage' has a wrong offset!");

// Class Zion.AssistAction_RestoreSP
// 0x0008 (0x0030 - 0x0028)
class UAssistAction_RestoreSP final : public UAssistAction
{
public:
	float                                         SPPercentage;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistAction_RestoreSP">();
	}
	static class UAssistAction_RestoreSP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistAction_RestoreSP>();
	}
};
static_assert(alignof(UAssistAction_RestoreSP) == 0x000008, "Wrong alignment on UAssistAction_RestoreSP");
static_assert(sizeof(UAssistAction_RestoreSP) == 0x000030, "Wrong size on UAssistAction_RestoreSP");
static_assert(offsetof(UAssistAction_RestoreSP, SPPercentage) == 0x000028, "Member 'UAssistAction_RestoreSP::SPPercentage' has a wrong offset!");

// Class Zion.Command_Heal
// 0x0128 (0x01D0 - 0x00A8)
class UCommand_Heal : public UCommand
{
public:
	float                                         TimeBeforeHeal;                                    // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           OnHealFXData;                                      // 0x00B0(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x20];                                     // 0x01B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command_Heal">();
	}
	static class UCommand_Heal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand_Heal>();
	}
};
static_assert(alignof(UCommand_Heal) == 0x000010, "Wrong alignment on UCommand_Heal");
static_assert(sizeof(UCommand_Heal) == 0x0001D0, "Wrong size on UCommand_Heal");
static_assert(offsetof(UCommand_Heal, TimeBeforeHeal) == 0x0000A8, "Member 'UCommand_Heal::TimeBeforeHeal' has a wrong offset!");
static_assert(offsetof(UCommand_Heal, OnHealFXData) == 0x0000B0, "Member 'UCommand_Heal::OnHealFXData' has a wrong offset!");

// Class Zion.WorldSpaceWidgetHolder
// 0x0038 (0x02C8 - 0x0290)
class AWorldSpaceWidgetHolder final : public AActor
{
public:
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetComponent*                       WidgetComponent;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x18];                                     // 0x02B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AWorldSpaceWidgetHolder* CreateWorldSpaceWidgetHolder(const class UObject* WorldObjectContext, const TSubclassOf<class UUserWidgetWorldSpace>& UserWidgetWorldSpaceClass, EWidgetReleaseMode ReleaseMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldSpaceWidgetHolder">();
	}
	static class AWorldSpaceWidgetHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldSpaceWidgetHolder>();
	}
};
static_assert(alignof(AWorldSpaceWidgetHolder) == 0x000008, "Wrong alignment on AWorldSpaceWidgetHolder");
static_assert(sizeof(AWorldSpaceWidgetHolder) == 0x0002C8, "Wrong size on AWorldSpaceWidgetHolder");
static_assert(offsetof(AWorldSpaceWidgetHolder, WidgetComponent) == 0x0002A8, "Member 'AWorldSpaceWidgetHolder::WidgetComponent' has a wrong offset!");

// Class Zion.AssistAction_StatusEffect
// 0x0008 (0x0030 - 0x0028)
class UAssistAction_StatusEffect final : public UAssistAction
{
public:
	TSubclassOf<class UStatusEffect>              StatusEffectClass;                                 // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistAction_StatusEffect">();
	}
	static class UAssistAction_StatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistAction_StatusEffect>();
	}
};
static_assert(alignof(UAssistAction_StatusEffect) == 0x000008, "Wrong alignment on UAssistAction_StatusEffect");
static_assert(sizeof(UAssistAction_StatusEffect) == 0x000030, "Wrong size on UAssistAction_StatusEffect");
static_assert(offsetof(UAssistAction_StatusEffect, StatusEffectClass) == 0x000028, "Member 'UAssistAction_StatusEffect::StatusEffectClass' has a wrong offset!");

// Class Zion.EventAction_MoveTo
// 0x0070 (0x00C8 - 0x0058)
class UEventAction_MoveTo : public UEventAction_SubjectBinding
{
public:
	float                                         AcceptanceRadius;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopOnOverlap;                                    // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTeleportToTargetOnComplete;                       // 0x005D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMovementSpeedMode                            MovementSpeedModeOverride;                         // 0x005E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F[0x69];                                      // 0x005F(0x0069)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_MoveTo">();
	}
	static class UEventAction_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_MoveTo>();
	}
};
static_assert(alignof(UEventAction_MoveTo) == 0x000008, "Wrong alignment on UEventAction_MoveTo");
static_assert(sizeof(UEventAction_MoveTo) == 0x0000C8, "Wrong size on UEventAction_MoveTo");
static_assert(offsetof(UEventAction_MoveTo, AcceptanceRadius) == 0x000058, "Member 'UEventAction_MoveTo::AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo, bStopOnOverlap) == 0x00005C, "Member 'UEventAction_MoveTo::bStopOnOverlap' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo, bTeleportToTargetOnComplete) == 0x00005D, "Member 'UEventAction_MoveTo::bTeleportToTargetOnComplete' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo, MovementSpeedModeOverride) == 0x00005E, "Member 'UEventAction_MoveTo::MovementSpeedModeOverride' has a wrong offset!");

// Class Zion.AssistComponent
// 0x0270 (0x0310 - 0x00A0)
class UAssistComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x38];                                      // 0x00A0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEquippedAssist                        EquippedAssist;                                    // 0x00D8(0x0220)(Transient, NativeAccessSpecifierPrivate)
	int32                                         CurrentLoadoutIndex;                               // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerAssistLoadoutData>       AssistLoadouts;                                    // 0x0300(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void EquipAssist(const class FName& AssistID, bool bAddToCurrentLoadout);
	void EquipAssistLoadout(int32 LoadoutIndex);
	void OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn);
	void UnEquipAssist(bool bRemoveFromCurrentLoadout);

	const struct FInventoryItemAssistData GetAssistDataFromID(const class FName& AssistID) const;
	class FName GetAssistID() const;
	int32 GetCurrentAssistLoadoutIndex() const;
	const struct FInventoryItemAssistData GetEquippedAssistData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistComponent">();
	}
	static class UAssistComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistComponent>();
	}
};
static_assert(alignof(UAssistComponent) == 0x000008, "Wrong alignment on UAssistComponent");
static_assert(sizeof(UAssistComponent) == 0x000310, "Wrong size on UAssistComponent");
static_assert(offsetof(UAssistComponent, EquippedAssist) == 0x0000D8, "Member 'UAssistComponent::EquippedAssist' has a wrong offset!");
static_assert(offsetof(UAssistComponent, CurrentLoadoutIndex) == 0x0002F8, "Member 'UAssistComponent::CurrentLoadoutIndex' has a wrong offset!");
static_assert(offsetof(UAssistComponent, AssistLoadouts) == 0x000300, "Member 'UAssistComponent::AssistLoadouts' has a wrong offset!");

// Class Zion.AssistTrigger
// 0x0080 (0x00A8 - 0x0028)
class UAssistTrigger : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseTriggerLimitCount;                             // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TriggerLimitCount;                                 // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Cooldown;                                          // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             InvalidStates;                                     // 0x0068(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UAssistAction*>                  Actions;                                           // 0x0078(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x20];                                      // 0x0088(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistTrigger">();
	}
	static class UAssistTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistTrigger>();
	}
};
static_assert(alignof(UAssistTrigger) == 0x000008, "Wrong alignment on UAssistTrigger");
static_assert(sizeof(UAssistTrigger) == 0x0000A8, "Wrong size on UAssistTrigger");
static_assert(offsetof(UAssistTrigger, bUseTriggerLimitCount) == 0x000058, "Member 'UAssistTrigger::bUseTriggerLimitCount' has a wrong offset!");
static_assert(offsetof(UAssistTrigger, TriggerLimitCount) == 0x00005C, "Member 'UAssistTrigger::TriggerLimitCount' has a wrong offset!");
static_assert(offsetof(UAssistTrigger, Cooldown) == 0x000060, "Member 'UAssistTrigger::Cooldown' has a wrong offset!");
static_assert(offsetof(UAssistTrigger, InvalidStates) == 0x000068, "Member 'UAssistTrigger::InvalidStates' has a wrong offset!");
static_assert(offsetof(UAssistTrigger, Actions) == 0x000078, "Member 'UAssistTrigger::Actions' has a wrong offset!");

// Class Zion.AssistTrigger_EnemyKilled
// 0x0008 (0x00B0 - 0x00A8)
class UAssistTrigger_EnemyKilled final : public UAssistTrigger
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistTrigger_EnemyKilled">();
	}
	static class UAssistTrigger_EnemyKilled* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistTrigger_EnemyKilled>();
	}
};
static_assert(alignof(UAssistTrigger_EnemyKilled) == 0x000008, "Wrong alignment on UAssistTrigger_EnemyKilled");
static_assert(sizeof(UAssistTrigger_EnemyKilled) == 0x0000B0, "Wrong size on UAssistTrigger_EnemyKilled");

// Class Zion.EnemySpawner
// 0x0248 (0x04D8 - 0x0290)
class AEnemySpawner : public ASpawner
{
public:
	TMulticastInlineDelegate<void(class AEnemySpawner* EnemySpawner)> OnEnemySpawnerDeathStart;      // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AEnemySpawner* EnemySpawner)> OnEnemySpawnerDeathEnd;        // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AEnemySpawner* EnemySpawner)> OnEnemySpawnerActivation;      // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UClearComponent*                        ClearComponent;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseConditionChecker;                              // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayConditionChecker              ConditionChecker;                                  // 0x02D0(0x0018)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bMarkAsClearedOnConditionFailed;                   // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    EnemyRowHandle;                                    // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPrivate)
	bool                                          bAutoActivateEnemy;                                // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEnemySpawnerClearTiming                      ClearTiming;                                       // 0x0301(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSpawnEvenWhenCleared;                             // 0x0302(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLockEnvironmentLevel;                             // 0x0303(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDataTableRowHandle>            AdditionalGameMapsToLock;                          // 0x0308(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bIncrementEnvironmentLevel;                        // 0x0318(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideBehaviorIdle;                             // 0x0319(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31A[0x6];                                      // 0x031A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBehaviorTree>           BehaviorTreeOverride_Idle;                         // 0x0320(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideBehaviorAggression;                       // 0x0348(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBehaviorTree>           BehaviorTreeOverride_Aggression;                   // 0x0350(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverridePatrolRange;                              // 0x0378(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PatrolRangeOverride;                               // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, bool>                       BlackboardOverride_Bool;                           // 0x0380(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      BlackboardOverride_Float;                          // 0x03D0(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FVector>             BlackboardOverride_Vector;                         // 0x0420(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<class FName, class AActor*>              BlackboardOverride_Actor;                          // 0x0470(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bCacheBreakPartState;                              // 0x04C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBreakType                                    EnemyPartBrokenType;                               // 0x04C1(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C2[0x16];                                     // 0x04C2(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateEnemy();
	void OnApplyBlackboardOverride();
	void OnClearStatusChecked(EClearStatus ClearStatus);
	void OnEnemyActivation();
	void OnEnemyBreakPart(const EBreakType& BreakType);
	void OnEnemyDeathEnd();
	void OnEnemyDeathProcessEnd();
	void OnEnemyDeathProcessStart();
	void OnEnemyDeathStart();
	void OnEnemyPreActivation();
	void OnRegisterEnemy(class ACharacterZion* Enemy);
	void OnUnregisterEnemy(class ACharacterZion* Enemy);
	void ReplaceEnemy(const struct FDataTableRowHandle& NewEnemyRowHandle, const struct FTransform& SpawnTransform);

	class ACharacterZion* GetEnemy() const;
	class AAIControllerZion* GetEnemyAIController() const;
	bool IsEnemyActivated() const;
	bool ShouldSpawnEvenWhenCleared() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySpawner">();
	}
	static class AEnemySpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemySpawner>();
	}
};
static_assert(alignof(AEnemySpawner) == 0x000008, "Wrong alignment on AEnemySpawner");
static_assert(sizeof(AEnemySpawner) == 0x0004D8, "Wrong size on AEnemySpawner");
static_assert(offsetof(AEnemySpawner, OnEnemySpawnerDeathStart) == 0x000290, "Member 'AEnemySpawner::OnEnemySpawnerDeathStart' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, OnEnemySpawnerDeathEnd) == 0x0002A0, "Member 'AEnemySpawner::OnEnemySpawnerDeathEnd' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, OnEnemySpawnerActivation) == 0x0002B0, "Member 'AEnemySpawner::OnEnemySpawnerActivation' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, ClearComponent) == 0x0002C0, "Member 'AEnemySpawner::ClearComponent' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, bUseConditionChecker) == 0x0002C8, "Member 'AEnemySpawner::bUseConditionChecker' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, ConditionChecker) == 0x0002D0, "Member 'AEnemySpawner::ConditionChecker' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, bMarkAsClearedOnConditionFailed) == 0x0002E8, "Member 'AEnemySpawner::bMarkAsClearedOnConditionFailed' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, EnemyRowHandle) == 0x0002F0, "Member 'AEnemySpawner::EnemyRowHandle' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, bAutoActivateEnemy) == 0x000300, "Member 'AEnemySpawner::bAutoActivateEnemy' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, ClearTiming) == 0x000301, "Member 'AEnemySpawner::ClearTiming' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, bSpawnEvenWhenCleared) == 0x000302, "Member 'AEnemySpawner::bSpawnEvenWhenCleared' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, bLockEnvironmentLevel) == 0x000303, "Member 'AEnemySpawner::bLockEnvironmentLevel' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, AdditionalGameMapsToLock) == 0x000308, "Member 'AEnemySpawner::AdditionalGameMapsToLock' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, bIncrementEnvironmentLevel) == 0x000318, "Member 'AEnemySpawner::bIncrementEnvironmentLevel' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, bOverrideBehaviorIdle) == 0x000319, "Member 'AEnemySpawner::bOverrideBehaviorIdle' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, BehaviorTreeOverride_Idle) == 0x000320, "Member 'AEnemySpawner::BehaviorTreeOverride_Idle' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, bOverrideBehaviorAggression) == 0x000348, "Member 'AEnemySpawner::bOverrideBehaviorAggression' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, BehaviorTreeOverride_Aggression) == 0x000350, "Member 'AEnemySpawner::BehaviorTreeOverride_Aggression' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, bOverridePatrolRange) == 0x000378, "Member 'AEnemySpawner::bOverridePatrolRange' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, PatrolRangeOverride) == 0x00037C, "Member 'AEnemySpawner::PatrolRangeOverride' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, BlackboardOverride_Bool) == 0x000380, "Member 'AEnemySpawner::BlackboardOverride_Bool' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, BlackboardOverride_Float) == 0x0003D0, "Member 'AEnemySpawner::BlackboardOverride_Float' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, BlackboardOverride_Vector) == 0x000420, "Member 'AEnemySpawner::BlackboardOverride_Vector' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, BlackboardOverride_Actor) == 0x000470, "Member 'AEnemySpawner::BlackboardOverride_Actor' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, bCacheBreakPartState) == 0x0004C0, "Member 'AEnemySpawner::bCacheBreakPartState' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, EnemyPartBrokenType) == 0x0004C1, "Member 'AEnemySpawner::EnemyPartBrokenType' has a wrong offset!");

// Class Zion.AssistTrigger_HealSuccess
// 0x0008 (0x00B0 - 0x00A8)
class UAssistTrigger_HealSuccess final : public UAssistTrigger
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHealSucceeded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistTrigger_HealSuccess">();
	}
	static class UAssistTrigger_HealSuccess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistTrigger_HealSuccess>();
	}
};
static_assert(alignof(UAssistTrigger_HealSuccess) == 0x000008, "Wrong alignment on UAssistTrigger_HealSuccess");
static_assert(sizeof(UAssistTrigger_HealSuccess) == 0x0000B0, "Wrong size on UAssistTrigger_HealSuccess");

// Class Zion.CommandModule_CommandLevel_Increment
// 0x0008 (0x0040 - 0x0038)
class UCommandModule_CommandLevel_Increment final : public UCommandModule
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_CommandLevel_Increment">();
	}
	static class UCommandModule_CommandLevel_Increment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_CommandLevel_Increment>();
	}
};
static_assert(alignof(UCommandModule_CommandLevel_Increment) == 0x000008, "Wrong alignment on UCommandModule_CommandLevel_Increment");
static_assert(sizeof(UCommandModule_CommandLevel_Increment) == 0x000040, "Wrong size on UCommandModule_CommandLevel_Increment");

// Class Zion.AssistTrigger_HPPercentage
// 0x0018 (0x00C0 - 0x00A8)
class UAssistTrigger_HPPercentage final : public UAssistTrigger
{
public:
	float                                         HPPercentage;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x14];                                      // 0x00AC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistTrigger_HPPercentage">();
	}
	static class UAssistTrigger_HPPercentage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistTrigger_HPPercentage>();
	}
};
static_assert(alignof(UAssistTrigger_HPPercentage) == 0x000008, "Wrong alignment on UAssistTrigger_HPPercentage");
static_assert(sizeof(UAssistTrigger_HPPercentage) == 0x0000C0, "Wrong size on UAssistTrigger_HPPercentage");
static_assert(offsetof(UAssistTrigger_HPPercentage, HPPercentage) == 0x0000A8, "Member 'UAssistTrigger_HPPercentage::HPPercentage' has a wrong offset!");

// Class Zion.ZoneSystemComponent
// 0x00A0 (0x0140 - 0x00A0)
class UZoneSystemComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFadeDescriptionData                   FadeDescription;                                   // 0x00B8(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x20];                                      // 0x00D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelStreamingDynamic*                 ActiveZoneLevelStreaming;                          // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x40];                                     // 0x0100(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UZoneSystemComponent* Get(const class UObject* WorldContextObject);

	void BindActorToZone(class AActor* Actor);
	void OnFadeOutFinished();

	class FString GetActiveZoneLevelName() const;
	class FString GetActiveZoneName() const;
	bool IsInAnyZone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZoneSystemComponent">();
	}
	static class UZoneSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZoneSystemComponent>();
	}
};
static_assert(alignof(UZoneSystemComponent) == 0x000008, "Wrong alignment on UZoneSystemComponent");
static_assert(sizeof(UZoneSystemComponent) == 0x000140, "Wrong size on UZoneSystemComponent");
static_assert(offsetof(UZoneSystemComponent, FadeDescription) == 0x0000B8, "Member 'UZoneSystemComponent::FadeDescription' has a wrong offset!");
static_assert(offsetof(UZoneSystemComponent, ActiveZoneLevelStreaming) == 0x0000F8, "Member 'UZoneSystemComponent::ActiveZoneLevelStreaming' has a wrong offset!");

// Class Zion.AssistTrigger_ParrySuccess
// 0x0000 (0x00A8 - 0x00A8)
class UAssistTrigger_ParrySuccess final : public UAssistTrigger
{
public:
	void OnParried(class AAbility* Ability, class AActor* Source);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistTrigger_ParrySuccess">();
	}
	static class UAssistTrigger_ParrySuccess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistTrigger_ParrySuccess>();
	}
};
static_assert(alignof(UAssistTrigger_ParrySuccess) == 0x000008, "Wrong alignment on UAssistTrigger_ParrySuccess");
static_assert(sizeof(UAssistTrigger_ParrySuccess) == 0x0000A8, "Wrong size on UAssistTrigger_ParrySuccess");

// Class Zion.AssistTrigger_PartsBreak
// 0x0008 (0x00B0 - 0x00A8)
class UAssistTrigger_PartsBreak final : public UAssistTrigger
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistTrigger_PartsBreak">();
	}
	static class UAssistTrigger_PartsBreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistTrigger_PartsBreak>();
	}
};
static_assert(alignof(UAssistTrigger_PartsBreak) == 0x000008, "Wrong alignment on UAssistTrigger_PartsBreak");
static_assert(sizeof(UAssistTrigger_PartsBreak) == 0x0000B0, "Wrong size on UAssistTrigger_PartsBreak");

// Class Zion.ConditionalDestroyComponent
// 0x0030 (0x00D0 - 0x00A0)
class UConditionalDestroyComponent final : public UActorComponent
{
public:
	EConditionDestroyMode                         Mode;                                              // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayConditionChecker              Conditions;                                        // 0x00A8(0x0018)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         AdditionalActors;                                  // 0x00C0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionalDestroyComponent">();
	}
	static class UConditionalDestroyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionalDestroyComponent>();
	}
};
static_assert(alignof(UConditionalDestroyComponent) == 0x000008, "Wrong alignment on UConditionalDestroyComponent");
static_assert(sizeof(UConditionalDestroyComponent) == 0x0000D0, "Wrong size on UConditionalDestroyComponent");
static_assert(offsetof(UConditionalDestroyComponent, Mode) == 0x0000A0, "Member 'UConditionalDestroyComponent::Mode' has a wrong offset!");
static_assert(offsetof(UConditionalDestroyComponent, Conditions) == 0x0000A8, "Member 'UConditionalDestroyComponent::Conditions' has a wrong offset!");
static_assert(offsetof(UConditionalDestroyComponent, AdditionalActors) == 0x0000C0, "Member 'UConditionalDestroyComponent::AdditionalActors' has a wrong offset!");

// Class Zion.AssistTrigger_ReceiveDamage
// 0x0010 (0x00B8 - 0x00A8)
class UAssistTrigger_ReceiveDamage final : public UAssistTrigger
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistTrigger_ReceiveDamage">();
	}
	static class UAssistTrigger_ReceiveDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistTrigger_ReceiveDamage>();
	}
};
static_assert(alignof(UAssistTrigger_ReceiveDamage) == 0x000008, "Wrong alignment on UAssistTrigger_ReceiveDamage");
static_assert(sizeof(UAssistTrigger_ReceiveDamage) == 0x0000B8, "Wrong size on UAssistTrigger_ReceiveDamage");

// Class Zion.CustomMarkerComponent
// 0x0088 (0x0128 - 0x00A0)
class UCustomMarkerComponent final : public UActorComponent
{
public:
	TSoftClassPtr<class UClass>                   WidgetCustomMarkerIconClass;                       // 0x00A0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CustomMarkerMaxCount;                              // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FMapCustomMarkerIconData>         PlacedCustomMarkers;                               // 0x00D0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetCustomMarkerMaxCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomMarkerComponent">();
	}
	static class UCustomMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomMarkerComponent>();
	}
};
static_assert(alignof(UCustomMarkerComponent) == 0x000008, "Wrong alignment on UCustomMarkerComponent");
static_assert(sizeof(UCustomMarkerComponent) == 0x000128, "Wrong size on UCustomMarkerComponent");
static_assert(offsetof(UCustomMarkerComponent, WidgetCustomMarkerIconClass) == 0x0000A0, "Member 'UCustomMarkerComponent::WidgetCustomMarkerIconClass' has a wrong offset!");
static_assert(offsetof(UCustomMarkerComponent, CustomMarkerMaxCount) == 0x0000C8, "Member 'UCustomMarkerComponent::CustomMarkerMaxCount' has a wrong offset!");
static_assert(offsetof(UCustomMarkerComponent, PlacedCustomMarkers) == 0x0000D0, "Member 'UCustomMarkerComponent::PlacedCustomMarkers' has a wrong offset!");

// Class Zion.AssistTrigger_ReceiveStatusEffect
// 0x0018 (0x00C0 - 0x00A8)
class UAssistTrigger_ReceiveStatusEffect final : public UAssistTrigger
{
public:
	TArray<EStatusEffectType>                     ValidStatusEffects;                                // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStatusEffectLaunched(class UStatusEffect* StatusEffect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistTrigger_ReceiveStatusEffect">();
	}
	static class UAssistTrigger_ReceiveStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistTrigger_ReceiveStatusEffect>();
	}
};
static_assert(alignof(UAssistTrigger_ReceiveStatusEffect) == 0x000008, "Wrong alignment on UAssistTrigger_ReceiveStatusEffect");
static_assert(sizeof(UAssistTrigger_ReceiveStatusEffect) == 0x0000C0, "Wrong size on UAssistTrigger_ReceiveStatusEffect");
static_assert(offsetof(UAssistTrigger_ReceiveStatusEffect, ValidStatusEffects) == 0x0000A8, "Member 'UAssistTrigger_ReceiveStatusEffect::ValidStatusEffects' has a wrong offset!");

// Class Zion.AssistTrigger_TimeInterval
// 0x0010 (0x00B8 - 0x00A8)
class UAssistTrigger_TimeInterval final : public UAssistTrigger
{
public:
	float                                         TimeInterval;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0xC];                                       // 0x00AC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTimeElapsed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistTrigger_TimeInterval">();
	}
	static class UAssistTrigger_TimeInterval* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssistTrigger_TimeInterval>();
	}
};
static_assert(alignof(UAssistTrigger_TimeInterval) == 0x000008, "Wrong alignment on UAssistTrigger_TimeInterval");
static_assert(sizeof(UAssistTrigger_TimeInterval) == 0x0000B8, "Wrong size on UAssistTrigger_TimeInterval");
static_assert(offsetof(UAssistTrigger_TimeInterval, TimeInterval) == 0x0000A8, "Member 'UAssistTrigger_TimeInterval::TimeInterval' has a wrong offset!");

// Class Zion.AssistVisual
// 0x0250 (0x04E0 - 0x0290)
class AAssistVisual final : public AActor
{
public:
	class USceneComponent*                        RootSceneComponent;                                // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   VisualComponent;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFollowTargetComponent*                 FollowTarget;                                      // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpineBone                                    AttachBone;                                        // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           OnTriggerFXData;                                   // 0x02B0(0x0100)(Edit, NativeAccessSpecifierPrivate)
	struct FSpineFXData                           OnCooldownElapsedFXData;                           // 0x03B0(0x0100)(Edit, NativeAccessSpecifierPrivate)
	class FName                                   LightAlphaParameterName;                           // 0x04B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x28];                                     // 0x04B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameMapChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistVisual">();
	}
	static class AAssistVisual* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAssistVisual>();
	}
};
static_assert(alignof(AAssistVisual) == 0x000010, "Wrong alignment on AAssistVisual");
static_assert(sizeof(AAssistVisual) == 0x0004E0, "Wrong size on AAssistVisual");
static_assert(offsetof(AAssistVisual, RootSceneComponent) == 0x000290, "Member 'AAssistVisual::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AAssistVisual, VisualComponent) == 0x000298, "Member 'AAssistVisual::VisualComponent' has a wrong offset!");
static_assert(offsetof(AAssistVisual, FollowTarget) == 0x0002A0, "Member 'AAssistVisual::FollowTarget' has a wrong offset!");
static_assert(offsetof(AAssistVisual, AttachBone) == 0x0002A8, "Member 'AAssistVisual::AttachBone' has a wrong offset!");
static_assert(offsetof(AAssistVisual, OnTriggerFXData) == 0x0002B0, "Member 'AAssistVisual::OnTriggerFXData' has a wrong offset!");
static_assert(offsetof(AAssistVisual, OnCooldownElapsedFXData) == 0x0003B0, "Member 'AAssistVisual::OnCooldownElapsedFXData' has a wrong offset!");
static_assert(offsetof(AAssistVisual, LightAlphaParameterName) == 0x0004B0, "Member 'AAssistVisual::LightAlphaParameterName' has a wrong offset!");

// Class Zion.EventAction_ConvertToActorBinding
// 0x0000 (0x0088 - 0x0088)
class UEventAction_ConvertToActorBinding final : public UEventAction_Convert
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_ConvertToActorBinding">();
	}
	static class UEventAction_ConvertToActorBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_ConvertToActorBinding>();
	}
};
static_assert(alignof(UEventAction_ConvertToActorBinding) == 0x000008, "Wrong alignment on UEventAction_ConvertToActorBinding");
static_assert(sizeof(UEventAction_ConvertToActorBinding) == 0x000088, "Wrong size on UEventAction_ConvertToActorBinding");

// Class Zion.UserWidgetZionShowHide
// 0x0000 (0x0460 - 0x0460)
class UUserWidgetZionShowHide : public UUserWidgetZion
{
public:
	void Hide(bool bInstant);
	void HideAndRemoveFromParent(bool bInstant);
	void Show(bool bInstant);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetZionShowHide">();
	}
	static class UUserWidgetZionShowHide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetZionShowHide>();
	}
};
static_assert(alignof(UUserWidgetZionShowHide) == 0x000008, "Wrong alignment on UUserWidgetZionShowHide");
static_assert(sizeof(UUserWidgetZionShowHide) == 0x000460, "Wrong size on UUserWidgetZionShowHide");

// Class Zion.AutoClimbComponent
// 0x0118 (0x01B8 - 0x00A0)
class UAutoClimbComponent final : public UActorComponent
{
public:
	float                                         AllowedMaxZVelocity;                               // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAngleForClimb;                                  // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForwardOffset;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinHeightForAutoClimbHigh;                         // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxHeightForAutoClimbHigh;                         // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinHeightForAutoClimbMiddle;                       // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxHeightForAutoClimbMiddle;                       // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinHeightForAutoClimbLow;                          // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxHeightForAutoClimbLow;                          // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinHeightForAutoClimbDashCharge;                   // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxHeightForAutoClimbDashCharge;                   // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DistanceAboveHeadToCheck;                          // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckTargetLocation;                              // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommandSettingsData*                   AutoClimbHigh_CommandSettings;                     // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandSettingsData*                   AutoClimbMiddle_CommandSettings;                   // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandSettingsData*                   AutoClimbLow_CommandSettings;                      // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandSettingsData*                   AutoClimbDash_CommandSettings;                     // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandSettingsData*                   AutoClimbDashCharge_CommandSettings;               // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandSettingsData*                   AutoClimbFallthroughHigh_CommandSettings;          // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandSettingsData*                   AutoClimbFallthroughMiddle_CommandSettings;        // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandSettingsData*                   AutoClimbFallthroughLow_CommandSettings;           // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandSettingsData*                   AutoClimbFallthroughDash_CommandSettings;          // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandSettingsData*                   AutoClimbFallthroughDashCharge_CommandSettings;    // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             IgnoreAutoClimbStates;                             // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             PreAutoClimbStates;                                // 0x0138(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          BoxComponent;                                      // 0x0148(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x68];                                     // 0x0150(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MarkActorAsIgnored(class AActor* Actor);
	void OnComponentOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentOverlapEnd(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnMoveBlocked(const struct FHitResult& Impact);
	void UnmarkActorAsIgnored(class AActor* Actor);

	struct FVector GetLastTargetLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoClimbComponent">();
	}
	static class UAutoClimbComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoClimbComponent>();
	}
};
static_assert(alignof(UAutoClimbComponent) == 0x000008, "Wrong alignment on UAutoClimbComponent");
static_assert(sizeof(UAutoClimbComponent) == 0x0001B8, "Wrong size on UAutoClimbComponent");
static_assert(offsetof(UAutoClimbComponent, AllowedMaxZVelocity) == 0x0000A0, "Member 'UAutoClimbComponent::AllowedMaxZVelocity' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, MaxAngleForClimb) == 0x0000A4, "Member 'UAutoClimbComponent::MaxAngleForClimb' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, ForwardOffset) == 0x0000A8, "Member 'UAutoClimbComponent::ForwardOffset' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, MinHeightForAutoClimbHigh) == 0x0000AC, "Member 'UAutoClimbComponent::MinHeightForAutoClimbHigh' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, MaxHeightForAutoClimbHigh) == 0x0000B0, "Member 'UAutoClimbComponent::MaxHeightForAutoClimbHigh' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, MinHeightForAutoClimbMiddle) == 0x0000B4, "Member 'UAutoClimbComponent::MinHeightForAutoClimbMiddle' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, MaxHeightForAutoClimbMiddle) == 0x0000B8, "Member 'UAutoClimbComponent::MaxHeightForAutoClimbMiddle' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, MinHeightForAutoClimbLow) == 0x0000BC, "Member 'UAutoClimbComponent::MinHeightForAutoClimbLow' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, MaxHeightForAutoClimbLow) == 0x0000C0, "Member 'UAutoClimbComponent::MaxHeightForAutoClimbLow' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, MinHeightForAutoClimbDashCharge) == 0x0000C4, "Member 'UAutoClimbComponent::MinHeightForAutoClimbDashCharge' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, MaxHeightForAutoClimbDashCharge) == 0x0000C8, "Member 'UAutoClimbComponent::MaxHeightForAutoClimbDashCharge' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, DistanceAboveHeadToCheck) == 0x0000CC, "Member 'UAutoClimbComponent::DistanceAboveHeadToCheck' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, bCheckTargetLocation) == 0x0000D0, "Member 'UAutoClimbComponent::bCheckTargetLocation' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, AutoClimbHigh_CommandSettings) == 0x0000D8, "Member 'UAutoClimbComponent::AutoClimbHigh_CommandSettings' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, AutoClimbMiddle_CommandSettings) == 0x0000E0, "Member 'UAutoClimbComponent::AutoClimbMiddle_CommandSettings' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, AutoClimbLow_CommandSettings) == 0x0000E8, "Member 'UAutoClimbComponent::AutoClimbLow_CommandSettings' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, AutoClimbDash_CommandSettings) == 0x0000F0, "Member 'UAutoClimbComponent::AutoClimbDash_CommandSettings' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, AutoClimbDashCharge_CommandSettings) == 0x0000F8, "Member 'UAutoClimbComponent::AutoClimbDashCharge_CommandSettings' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, AutoClimbFallthroughHigh_CommandSettings) == 0x000100, "Member 'UAutoClimbComponent::AutoClimbFallthroughHigh_CommandSettings' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, AutoClimbFallthroughMiddle_CommandSettings) == 0x000108, "Member 'UAutoClimbComponent::AutoClimbFallthroughMiddle_CommandSettings' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, AutoClimbFallthroughLow_CommandSettings) == 0x000110, "Member 'UAutoClimbComponent::AutoClimbFallthroughLow_CommandSettings' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, AutoClimbFallthroughDash_CommandSettings) == 0x000118, "Member 'UAutoClimbComponent::AutoClimbFallthroughDash_CommandSettings' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, AutoClimbFallthroughDashCharge_CommandSettings) == 0x000120, "Member 'UAutoClimbComponent::AutoClimbFallthroughDashCharge_CommandSettings' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, IgnoreAutoClimbStates) == 0x000128, "Member 'UAutoClimbComponent::IgnoreAutoClimbStates' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, PreAutoClimbStates) == 0x000138, "Member 'UAutoClimbComponent::PreAutoClimbStates' has a wrong offset!");
static_assert(offsetof(UAutoClimbComponent, BoxComponent) == 0x000148, "Member 'UAutoClimbComponent::BoxComponent' has a wrong offset!");

// Class Zion.CommandModule_FallingExecutionCounts_Reset
// 0x0020 (0x0058 - 0x0038)
class UCommandModule_FallingExecutionCounts_Reset final : public UCommandModule
{
public:
	bool                                          bResetSpecificCategories;                          // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECommandCategory>                      SpecificCategories;                                // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_FallingExecutionCounts_Reset">();
	}
	static class UCommandModule_FallingExecutionCounts_Reset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_FallingExecutionCounts_Reset>();
	}
};
static_assert(alignof(UCommandModule_FallingExecutionCounts_Reset) == 0x000008, "Wrong alignment on UCommandModule_FallingExecutionCounts_Reset");
static_assert(sizeof(UCommandModule_FallingExecutionCounts_Reset) == 0x000058, "Wrong size on UCommandModule_FallingExecutionCounts_Reset");
static_assert(offsetof(UCommandModule_FallingExecutionCounts_Reset, bResetSpecificCategories) == 0x000038, "Member 'UCommandModule_FallingExecutionCounts_Reset::bResetSpecificCategories' has a wrong offset!");
static_assert(offsetof(UCommandModule_FallingExecutionCounts_Reset, SpecificCategories) == 0x000040, "Member 'UCommandModule_FallingExecutionCounts_Reset::SpecificCategories' has a wrong offset!");

// Class Zion.BattleColorComponent
// 0x0030 (0x00D0 - 0x00A0)
class UBattleColorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FadeInCurve;                                       // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            FadeOutCurve;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MaterialParameterName;                             // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnableBattleColorOnStart;                         // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0xF];                                       // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAlpha(float NewAlpha);
	void SetBattleColorEnabled(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleColorComponent">();
	}
	static class UBattleColorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleColorComponent>();
	}
};
static_assert(alignof(UBattleColorComponent) == 0x000008, "Wrong alignment on UBattleColorComponent");
static_assert(sizeof(UBattleColorComponent) == 0x0000D0, "Wrong size on UBattleColorComponent");
static_assert(offsetof(UBattleColorComponent, FadeInCurve) == 0x0000A8, "Member 'UBattleColorComponent::FadeInCurve' has a wrong offset!");
static_assert(offsetof(UBattleColorComponent, FadeOutCurve) == 0x0000B0, "Member 'UBattleColorComponent::FadeOutCurve' has a wrong offset!");
static_assert(offsetof(UBattleColorComponent, MaterialParameterName) == 0x0000B8, "Member 'UBattleColorComponent::MaterialParameterName' has a wrong offset!");
static_assert(offsetof(UBattleColorComponent, bEnableBattleColorOnStart) == 0x0000C0, "Member 'UBattleColorComponent::bEnableBattleColorOnStart' has a wrong offset!");

// Class Zion.BoxBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class UBoxBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector GetCenter(const struct FBox& Box);
	static bool IsValid(const struct FBox& Box);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoxBPFLibrary">();
	}
	static class UBoxBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoxBPFLibrary>();
	}
};
static_assert(alignof(UBoxBPFLibrary) == 0x000008, "Wrong alignment on UBoxBPFLibrary");
static_assert(sizeof(UBoxBPFLibrary) == 0x000028, "Wrong size on UBoxBPFLibrary");

// Class Zion.Breakable
// 0x0180 (0x0410 - 0x0290)
class ABreakable : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        RootSceneComponent;                                // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatHPComponent*                       StatHPComponent;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDeathComponent*                        DeathComponent;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFactionComponent*                      FactionComponent;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClearComponent*                        ClearComponent;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineFXComponent*                      SpineFXComponent;                                  // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineBoneComponent*                    SpineBoneComponent;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMarkAsClearOnDeath;                               // 0x02D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D1[0xF];                                      // 0x02D1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           OnBreakFXData;                                     // 0x02E0(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bRotateBreakFXFromLastAttacker;                    // 0x03E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             OnBreakFMODEvent;                                  // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x20];                                     // 0x03F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBreakableDeathProcessStart();
	void OnBreakableReceivedDamage(class AActor* Source, int32 Value);
	void OnClearStatusChecked(EClearStatus ClearStatus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Breakable">();
	}
	static class ABreakable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABreakable>();
	}
};
static_assert(alignof(ABreakable) == 0x000010, "Wrong alignment on ABreakable");
static_assert(sizeof(ABreakable) == 0x000410, "Wrong size on ABreakable");
static_assert(offsetof(ABreakable, RootSceneComponent) == 0x000298, "Member 'ABreakable::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(ABreakable, StatHPComponent) == 0x0002A0, "Member 'ABreakable::StatHPComponent' has a wrong offset!");
static_assert(offsetof(ABreakable, DeathComponent) == 0x0002A8, "Member 'ABreakable::DeathComponent' has a wrong offset!");
static_assert(offsetof(ABreakable, FactionComponent) == 0x0002B0, "Member 'ABreakable::FactionComponent' has a wrong offset!");
static_assert(offsetof(ABreakable, ClearComponent) == 0x0002B8, "Member 'ABreakable::ClearComponent' has a wrong offset!");
static_assert(offsetof(ABreakable, SpineFXComponent) == 0x0002C0, "Member 'ABreakable::SpineFXComponent' has a wrong offset!");
static_assert(offsetof(ABreakable, SpineBoneComponent) == 0x0002C8, "Member 'ABreakable::SpineBoneComponent' has a wrong offset!");
static_assert(offsetof(ABreakable, bMarkAsClearOnDeath) == 0x0002D0, "Member 'ABreakable::bMarkAsClearOnDeath' has a wrong offset!");
static_assert(offsetof(ABreakable, OnBreakFXData) == 0x0002E0, "Member 'ABreakable::OnBreakFXData' has a wrong offset!");
static_assert(offsetof(ABreakable, bRotateBreakFXFromLastAttacker) == 0x0003E0, "Member 'ABreakable::bRotateBreakFXFromLastAttacker' has a wrong offset!");
static_assert(offsetof(ABreakable, OnBreakFMODEvent) == 0x0003E8, "Member 'ABreakable::OnBreakFMODEvent' has a wrong offset!");

// Class Zion.CommandModule_ActivateAuraFXs
// 0x0020 (0x0058 - 0x0038)
class UCommandModule_ActivateAuraFXs final : public UCommandModule
{
public:
	class FName                                   AuraFXTag;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActivationTime;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnsureActivation;                                 // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45[0x13];                                      // 0x0045(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_ActivateAuraFXs">();
	}
	static class UCommandModule_ActivateAuraFXs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_ActivateAuraFXs>();
	}
};
static_assert(alignof(UCommandModule_ActivateAuraFXs) == 0x000008, "Wrong alignment on UCommandModule_ActivateAuraFXs");
static_assert(sizeof(UCommandModule_ActivateAuraFXs) == 0x000058, "Wrong size on UCommandModule_ActivateAuraFXs");
static_assert(offsetof(UCommandModule_ActivateAuraFXs, AuraFXTag) == 0x000038, "Member 'UCommandModule_ActivateAuraFXs::AuraFXTag' has a wrong offset!");
static_assert(offsetof(UCommandModule_ActivateAuraFXs, ActivationTime) == 0x000040, "Member 'UCommandModule_ActivateAuraFXs::ActivationTime' has a wrong offset!");
static_assert(offsetof(UCommandModule_ActivateAuraFXs, bEnsureActivation) == 0x000044, "Member 'UCommandModule_ActivateAuraFXs::bEnsureActivation' has a wrong offset!");

// Class Zion.BreakPartComponent
// 0x00A8 (0x0148 - 0x00A0)
class UBreakPartComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const EBreakType& BreakType)> OnBreakPartDelegate;                 // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     BreakMaterial;                                     // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BreakDuration;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    BreakDropDataHandle;                               // 0x00C8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   OneShotFXDataList;                                 // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   LoopFXDataList;                                    // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class FString>                         BreakSkins;                                        // 0x00F8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x30];                                     // 0x0108(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNiagaraComponent*>              LoopFXInstances;                                   // 0x0138(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreakPartComponent">();
	}
	static class UBreakPartComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBreakPartComponent>();
	}
};
static_assert(alignof(UBreakPartComponent) == 0x000008, "Wrong alignment on UBreakPartComponent");
static_assert(sizeof(UBreakPartComponent) == 0x000148, "Wrong size on UBreakPartComponent");
static_assert(offsetof(UBreakPartComponent, OnBreakPartDelegate) == 0x0000A0, "Member 'UBreakPartComponent::OnBreakPartDelegate' has a wrong offset!");
static_assert(offsetof(UBreakPartComponent, bEnabled) == 0x0000B0, "Member 'UBreakPartComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UBreakPartComponent, BreakMaterial) == 0x0000B8, "Member 'UBreakPartComponent::BreakMaterial' has a wrong offset!");
static_assert(offsetof(UBreakPartComponent, BreakDuration) == 0x0000C0, "Member 'UBreakPartComponent::BreakDuration' has a wrong offset!");
static_assert(offsetof(UBreakPartComponent, BreakDropDataHandle) == 0x0000C8, "Member 'UBreakPartComponent::BreakDropDataHandle' has a wrong offset!");
static_assert(offsetof(UBreakPartComponent, OneShotFXDataList) == 0x0000D8, "Member 'UBreakPartComponent::OneShotFXDataList' has a wrong offset!");
static_assert(offsetof(UBreakPartComponent, LoopFXDataList) == 0x0000E8, "Member 'UBreakPartComponent::LoopFXDataList' has a wrong offset!");
static_assert(offsetof(UBreakPartComponent, BreakSkins) == 0x0000F8, "Member 'UBreakPartComponent::BreakSkins' has a wrong offset!");
static_assert(offsetof(UBreakPartComponent, LoopFXInstances) == 0x000138, "Member 'UBreakPartComponent::LoopFXInstances' has a wrong offset!");

// Class Zion.CommandModule_ConvertToFlying
// 0x0000 (0x0038 - 0x0038)
class UCommandModule_ConvertToFlying final : public UCommandModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_ConvertToFlying">();
	}
	static class UCommandModule_ConvertToFlying* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_ConvertToFlying>();
	}
};
static_assert(alignof(UCommandModule_ConvertToFlying) == 0x000008, "Wrong alignment on UCommandModule_ConvertToFlying");
static_assert(sizeof(UCommandModule_ConvertToFlying) == 0x000038, "Wrong size on UCommandModule_ConvertToFlying");

// Class Zion.BreakPartStateManagerComponent
// 0x0050 (0x00F0 - 0x00A0)
class UBreakPartStateManagerComponent final : public UActorComponent
{
public:
	TMap<struct FClearActorData, EBreakType>      BreakPartStates;                                   // 0x00A0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UBreakPartStateManagerComponent* Get(const class UObject* WorldContextObject);

	void ClearBreakPartStates();
	EBreakType RegisterBreakPartState(const class AEnemySpawner* EnemySpawner);

	EBreakType GetBreakPartState(const class AEnemySpawner* EnemySpawner) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreakPartStateManagerComponent">();
	}
	static class UBreakPartStateManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBreakPartStateManagerComponent>();
	}
};
static_assert(alignof(UBreakPartStateManagerComponent) == 0x000008, "Wrong alignment on UBreakPartStateManagerComponent");
static_assert(sizeof(UBreakPartStateManagerComponent) == 0x0000F0, "Wrong size on UBreakPartStateManagerComponent");
static_assert(offsetof(UBreakPartStateManagerComponent, BreakPartStates) == 0x0000A0, "Member 'UBreakPartStateManagerComponent::BreakPartStates' has a wrong offset!");

// Class Zion.BTComposite_RandomChooseOne
// 0x0000 (0x0080 - 0x0080)
class UBTComposite_RandomChooseOne final : public UBTCompositeNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTComposite_RandomChooseOne">();
	}
	static class UBTComposite_RandomChooseOne* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTComposite_RandomChooseOne>();
	}
};
static_assert(alignof(UBTComposite_RandomChooseOne) == 0x000008, "Wrong alignment on UBTComposite_RandomChooseOne");
static_assert(sizeof(UBTComposite_RandomChooseOne) == 0x000080, "Wrong size on UBTComposite_RandomChooseOne");

// Class Zion.Command_AutoClimb
// 0x0040 (0x00E8 - 0x00A8)
class UCommand_AutoClimb : public UCommand
{
public:
	class UCurveVector*                           LocationBlendCurve;                                // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x38];                                      // 0x00B0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command_AutoClimb">();
	}
	static class UCommand_AutoClimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand_AutoClimb>();
	}
};
static_assert(alignof(UCommand_AutoClimb) == 0x000008, "Wrong alignment on UCommand_AutoClimb");
static_assert(sizeof(UCommand_AutoClimb) == 0x0000E8, "Wrong size on UCommand_AutoClimb");
static_assert(offsetof(UCommand_AutoClimb, LocationBlendCurve) == 0x0000A8, "Member 'UCommand_AutoClimb::LocationBlendCurve' has a wrong offset!");

// Class Zion.BTDecoratorZionCondition
// 0x0000 (0x0068 - 0x0068)
class UBTDecoratorZionCondition : public UBTDecoratorZion
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecoratorZionCondition">();
	}
	static class UBTDecoratorZionCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecoratorZionCondition>();
	}
};
static_assert(alignof(UBTDecoratorZionCondition) == 0x000008, "Wrong alignment on UBTDecoratorZionCondition");
static_assert(sizeof(UBTDecoratorZionCondition) == 0x000068, "Wrong size on UBTDecoratorZionCondition");

// Class Zion.GunmanIKBoneTargetComponent
// 0x00D0 (0x0170 - 0x00A0)
class UGunmanIKBoneTargetComponent final : public UActorComponent
{
public:
	EIKBoneDriver                                 IKBoneDriver;                                      // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EIKBoneBlendMode                              BlendMode;                                         // 0x00A1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInjectionSpeed;                               // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationSpeed;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinIKTargetDistance;                               // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EIKBoneReferenceVectorMode                    ClampReferenceVectorMode;                          // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampAngleMin;                                     // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ClampAngleMax;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideAbilityGlobalOffset;                      // 0x00BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BD[0xB3];                                      // 0x00BD(0x00B3)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSpiritActivationChanged(bool bNewActive);

	const struct FTransform GetAbilityGlobalOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunmanIKBoneTargetComponent">();
	}
	static class UGunmanIKBoneTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGunmanIKBoneTargetComponent>();
	}
};
static_assert(alignof(UGunmanIKBoneTargetComponent) == 0x000008, "Wrong alignment on UGunmanIKBoneTargetComponent");
static_assert(sizeof(UGunmanIKBoneTargetComponent) == 0x000170, "Wrong size on UGunmanIKBoneTargetComponent");
static_assert(offsetof(UGunmanIKBoneTargetComponent, IKBoneDriver) == 0x0000A0, "Member 'UGunmanIKBoneTargetComponent::IKBoneDriver' has a wrong offset!");
static_assert(offsetof(UGunmanIKBoneTargetComponent, BlendMode) == 0x0000A1, "Member 'UGunmanIKBoneTargetComponent::BlendMode' has a wrong offset!");
static_assert(offsetof(UGunmanIKBoneTargetComponent, BlendInjectionSpeed) == 0x0000A4, "Member 'UGunmanIKBoneTargetComponent::BlendInjectionSpeed' has a wrong offset!");
static_assert(offsetof(UGunmanIKBoneTargetComponent, RotationSpeed) == 0x0000A8, "Member 'UGunmanIKBoneTargetComponent::RotationSpeed' has a wrong offset!");
static_assert(offsetof(UGunmanIKBoneTargetComponent, MinIKTargetDistance) == 0x0000AC, "Member 'UGunmanIKBoneTargetComponent::MinIKTargetDistance' has a wrong offset!");
static_assert(offsetof(UGunmanIKBoneTargetComponent, ClampReferenceVectorMode) == 0x0000B0, "Member 'UGunmanIKBoneTargetComponent::ClampReferenceVectorMode' has a wrong offset!");
static_assert(offsetof(UGunmanIKBoneTargetComponent, ClampAngleMin) == 0x0000B4, "Member 'UGunmanIKBoneTargetComponent::ClampAngleMin' has a wrong offset!");
static_assert(offsetof(UGunmanIKBoneTargetComponent, ClampAngleMax) == 0x0000B8, "Member 'UGunmanIKBoneTargetComponent::ClampAngleMax' has a wrong offset!");
static_assert(offsetof(UGunmanIKBoneTargetComponent, bOverrideAbilityGlobalOffset) == 0x0000BC, "Member 'UGunmanIKBoneTargetComponent::bOverrideAbilityGlobalOffset' has a wrong offset!");

// Class Zion.OneWayPlatform
// 0x00D0 (0x0360 - 0x0290)
class AOneWayPlatform : public AActor
{
public:
	class USceneComponent*                        SceneRootComponent;                                // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        PlatformComponent;                                 // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   BlockerComponent;                                  // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          CollisionEnablerComponent;                         // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          CollisionDisablerComponent;                        // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFallThrough;                                    // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckCharacterBelowPlatform;                      // 0x02B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BA[0x6];                                      // 0x02BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           InsideUnderBoxActors;                              // 0x02C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           FallThroughIgnoredActors;                          // 0x0310(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnComponentOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentOverlapEnd(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	bool IsFallThrough() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OneWayPlatform">();
	}
	static class AOneWayPlatform* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOneWayPlatform>();
	}
};
static_assert(alignof(AOneWayPlatform) == 0x000008, "Wrong alignment on AOneWayPlatform");
static_assert(sizeof(AOneWayPlatform) == 0x000360, "Wrong size on AOneWayPlatform");
static_assert(offsetof(AOneWayPlatform, SceneRootComponent) == 0x000290, "Member 'AOneWayPlatform::SceneRootComponent' has a wrong offset!");
static_assert(offsetof(AOneWayPlatform, PlatformComponent) == 0x000298, "Member 'AOneWayPlatform::PlatformComponent' has a wrong offset!");
static_assert(offsetof(AOneWayPlatform, BlockerComponent) == 0x0002A0, "Member 'AOneWayPlatform::BlockerComponent' has a wrong offset!");
static_assert(offsetof(AOneWayPlatform, CollisionEnablerComponent) == 0x0002A8, "Member 'AOneWayPlatform::CollisionEnablerComponent' has a wrong offset!");
static_assert(offsetof(AOneWayPlatform, CollisionDisablerComponent) == 0x0002B0, "Member 'AOneWayPlatform::CollisionDisablerComponent' has a wrong offset!");
static_assert(offsetof(AOneWayPlatform, bIsFallThrough) == 0x0002B8, "Member 'AOneWayPlatform::bIsFallThrough' has a wrong offset!");
static_assert(offsetof(AOneWayPlatform, bCheckCharacterBelowPlatform) == 0x0002B9, "Member 'AOneWayPlatform::bCheckCharacterBelowPlatform' has a wrong offset!");
static_assert(offsetof(AOneWayPlatform, InsideUnderBoxActors) == 0x0002C0, "Member 'AOneWayPlatform::InsideUnderBoxActors' has a wrong offset!");
static_assert(offsetof(AOneWayPlatform, FallThroughIgnoredActors) == 0x000310, "Member 'AOneWayPlatform::FallThroughIgnoredActors' has a wrong offset!");

// Class Zion.MovingPlatform_Spline
// 0x0018 (0x0378 - 0x0360)
class AMovingPlatform_Spline final : public AOneWayPlatform
{
public:
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFollowSplineComponent*                 FollowSplineComponent;                             // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       SplineComponent;                                   // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovingPlatform_Spline">();
	}
	static class AMovingPlatform_Spline* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMovingPlatform_Spline>();
	}
};
static_assert(alignof(AMovingPlatform_Spline) == 0x000008, "Wrong alignment on AMovingPlatform_Spline");
static_assert(sizeof(AMovingPlatform_Spline) == 0x000378, "Wrong size on AMovingPlatform_Spline");
static_assert(offsetof(AMovingPlatform_Spline, FollowSplineComponent) == 0x000368, "Member 'AMovingPlatform_Spline::FollowSplineComponent' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Spline, SplineComponent) == 0x000370, "Member 'AMovingPlatform_Spline::SplineComponent' has a wrong offset!");

// Class Zion.BTDecorator_Comparator_HP
// 0x0008 (0x0078 - 0x0070)
class UBTDecorator_Comparator_HP final : public UBTDecorator_Comparator
{
public:
	float                                         Percentage;                                        // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_Comparator_HP">();
	}
	static class UBTDecorator_Comparator_HP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_Comparator_HP>();
	}
};
static_assert(alignof(UBTDecorator_Comparator_HP) == 0x000008, "Wrong alignment on UBTDecorator_Comparator_HP");
static_assert(sizeof(UBTDecorator_Comparator_HP) == 0x000078, "Wrong size on UBTDecorator_Comparator_HP");
static_assert(offsetof(UBTDecorator_Comparator_HP, Percentage) == 0x000070, "Member 'UBTDecorator_Comparator_HP::Percentage' has a wrong offset!");

// Class Zion.BTDecorator_IsFacing
// 0x0038 (0x00A0 - 0x0068)
class UBTDecorator_IsFacing final : public UBTDecoratorZionCondition
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0068(0x0028)(Edit, NativeAccessSpecifierPrivate)
	TArray<EFacingType>                           ValidFacings;                                      // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsFacing">();
	}
	static class UBTDecorator_IsFacing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsFacing>();
	}
};
static_assert(alignof(UBTDecorator_IsFacing) == 0x000008, "Wrong alignment on UBTDecorator_IsFacing");
static_assert(sizeof(UBTDecorator_IsFacing) == 0x0000A0, "Wrong size on UBTDecorator_IsFacing");
static_assert(offsetof(UBTDecorator_IsFacing, Target) == 0x000068, "Member 'UBTDecorator_IsFacing::Target' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsFacing, ValidFacings) == 0x000090, "Member 'UBTDecorator_IsFacing::ValidFacings' has a wrong offset!");

// Class Zion.CommandModule_MovementMode
// 0x0010 (0x0048 - 0x0038)
class UCommandModule_MovementMode final : public UCommandModule
{
public:
	struct FMovementModeData                      MovementMode;                                      // 0x0038(0x0002)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A[0xE];                                       // 0x003A(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_MovementMode">();
	}
	static class UCommandModule_MovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_MovementMode>();
	}
};
static_assert(alignof(UCommandModule_MovementMode) == 0x000008, "Wrong alignment on UCommandModule_MovementMode");
static_assert(sizeof(UCommandModule_MovementMode) == 0x000048, "Wrong size on UCommandModule_MovementMode");
static_assert(offsetof(UCommandModule_MovementMode, MovementMode) == 0x000038, "Member 'UCommandModule_MovementMode::MovementMode' has a wrong offset!");

// Class Zion.BTDecorator_IsInBorderRange
// 0x0030 (0x0098 - 0x0068)
class UBTDecorator_IsInBorderRange final : public UBTDecoratorZionCondition
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0068(0x0028)(Edit, NativeAccessSpecifierPrivate)
	EBorderType                                   BorderType;                                        // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AcceptableRange;                                   // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsInBorderRange">();
	}
	static class UBTDecorator_IsInBorderRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsInBorderRange>();
	}
};
static_assert(alignof(UBTDecorator_IsInBorderRange) == 0x000008, "Wrong alignment on UBTDecorator_IsInBorderRange");
static_assert(sizeof(UBTDecorator_IsInBorderRange) == 0x000098, "Wrong size on UBTDecorator_IsInBorderRange");
static_assert(offsetof(UBTDecorator_IsInBorderRange, Target) == 0x000068, "Member 'UBTDecorator_IsInBorderRange::Target' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInBorderRange, BorderType) == 0x000090, "Member 'UBTDecorator_IsInBorderRange::BorderType' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInBorderRange, AcceptableRange) == 0x000094, "Member 'UBTDecorator_IsInBorderRange::AcceptableRange' has a wrong offset!");

// Class Zion.BTDecorator_IsInDirection
// 0x0038 (0x00A0 - 0x0068)
class UBTDecorator_IsInDirection final : public UBTDecoratorZionCondition
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0068(0x0028)(Edit, NativeAccessSpecifierPrivate)
	TArray<ELocalDirection>                       ValidDirections;                                   // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsInDirection">();
	}
	static class UBTDecorator_IsInDirection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsInDirection>();
	}
};
static_assert(alignof(UBTDecorator_IsInDirection) == 0x000008, "Wrong alignment on UBTDecorator_IsInDirection");
static_assert(sizeof(UBTDecorator_IsInDirection) == 0x0000A0, "Wrong size on UBTDecorator_IsInDirection");
static_assert(offsetof(UBTDecorator_IsInDirection, Target) == 0x000068, "Member 'UBTDecorator_IsInDirection::Target' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInDirection, ValidDirections) == 0x000090, "Member 'UBTDecorator_IsInDirection::ValidDirections' has a wrong offset!");

// Class Zion.BTDecorator_IsInFront
// 0x0028 (0x0090 - 0x0068)
class UBTDecorator_IsInFront final : public UBTDecoratorZionCondition
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0068(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsInFront">();
	}
	static class UBTDecorator_IsInFront* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsInFront>();
	}
};
static_assert(alignof(UBTDecorator_IsInFront) == 0x000008, "Wrong alignment on UBTDecorator_IsInFront");
static_assert(sizeof(UBTDecorator_IsInFront) == 0x000090, "Wrong size on UBTDecorator_IsInFront");
static_assert(offsetof(UBTDecorator_IsInFront, Target) == 0x000068, "Member 'UBTDecorator_IsInFront::Target' has a wrong offset!");

// Class Zion.Command_Jump
// 0x0028 (0x00D0 - 0x00A8)
class UCommand_Jump : public UCommand
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinJumpHoldTime;                                   // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0xC];                                       // 0x00C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command_Jump">();
	}
	static class UCommand_Jump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand_Jump>();
	}
};
static_assert(alignof(UCommand_Jump) == 0x000008, "Wrong alignment on UCommand_Jump");
static_assert(sizeof(UCommand_Jump) == 0x0000D0, "Wrong size on UCommand_Jump");
static_assert(offsetof(UCommand_Jump, MinJumpHoldTime) == 0x0000C0, "Member 'UCommand_Jump::MinJumpHoldTime' has a wrong offset!");

// Class Zion.BTDecorator_IsInRange
// 0x0030 (0x0098 - 0x0068)
class UBTDecorator_IsInRange final : public UBTDecoratorZionCondition
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0068(0x0028)(Edit, NativeAccessSpecifierPrivate)
	float                                         AcceptableRange;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDistanceComparisonType                       DistanceType;                                      // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsInRange">();
	}
	static class UBTDecorator_IsInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsInRange>();
	}
};
static_assert(alignof(UBTDecorator_IsInRange) == 0x000008, "Wrong alignment on UBTDecorator_IsInRange");
static_assert(sizeof(UBTDecorator_IsInRange) == 0x000098, "Wrong size on UBTDecorator_IsInRange");
static_assert(offsetof(UBTDecorator_IsInRange, Target) == 0x000068, "Member 'UBTDecorator_IsInRange::Target' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInRange, AcceptableRange) == 0x000090, "Member 'UBTDecorator_IsInRange::AcceptableRange' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInRange, DistanceType) == 0x000094, "Member 'UBTDecorator_IsInRange::DistanceType' has a wrong offset!");

// Class Zion.HookTargetEnemyComponent
// 0x0010 (0x00B0 - 0x00A0)
class UHookTargetEnemyComponent final : public UActorComponent
{
public:
	TArray<class UEnemyHookPointSceneComponent*>  EnemyHookPoints;                                   // 0x00A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookTargetEnemyComponent">();
	}
	static class UHookTargetEnemyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHookTargetEnemyComponent>();
	}
};
static_assert(alignof(UHookTargetEnemyComponent) == 0x000008, "Wrong alignment on UHookTargetEnemyComponent");
static_assert(sizeof(UHookTargetEnemyComponent) == 0x0000B0, "Wrong size on UHookTargetEnemyComponent");
static_assert(offsetof(UHookTargetEnemyComponent, EnemyHookPoints) == 0x0000A0, "Member 'UHookTargetEnemyComponent::EnemyHookPoints' has a wrong offset!");

// Class Zion.CommandModule_SpineSkins
// 0x0028 (0x0060 - 0x0038)
class UCommandModule_SpineSkins final : public UCommandModule
{
public:
	float                                         Delay;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Skins;                                             // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_SpineSkins">();
	}
	static class UCommandModule_SpineSkins* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_SpineSkins>();
	}
};
static_assert(alignof(UCommandModule_SpineSkins) == 0x000008, "Wrong alignment on UCommandModule_SpineSkins");
static_assert(sizeof(UCommandModule_SpineSkins) == 0x000060, "Wrong size on UCommandModule_SpineSkins");
static_assert(offsetof(UCommandModule_SpineSkins, Delay) == 0x000038, "Member 'UCommandModule_SpineSkins::Delay' has a wrong offset!");
static_assert(offsetof(UCommandModule_SpineSkins, Skins) == 0x000040, "Member 'UCommandModule_SpineSkins::Skins' has a wrong offset!");

// Class Zion.BTDecorator_IsNearGround
// 0x0080 (0x00E8 - 0x0068)
class UBTDecorator_IsNearGround final : public UBTDecoratorZionCondition
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0068(0x0028)(Edit, NativeAccessSpecifierPrivate)
	EConditionOperator                            CheckOperator;                                     // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDecoratorNearGroundUpVectorMode              UpVectorMode;                                      // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDecoratorNearGroundDirection, struct FDecoratorNearGroundDirectionData> GroundDirections;  // 0x0098(0x0050)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsNearGround">();
	}
	static class UBTDecorator_IsNearGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsNearGround>();
	}
};
static_assert(alignof(UBTDecorator_IsNearGround) == 0x000008, "Wrong alignment on UBTDecorator_IsNearGround");
static_assert(sizeof(UBTDecorator_IsNearGround) == 0x0000E8, "Wrong size on UBTDecorator_IsNearGround");
static_assert(offsetof(UBTDecorator_IsNearGround, Target) == 0x000068, "Member 'UBTDecorator_IsNearGround::Target' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsNearGround, CheckOperator) == 0x000090, "Member 'UBTDecorator_IsNearGround::CheckOperator' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsNearGround, UpVectorMode) == 0x000091, "Member 'UBTDecorator_IsNearGround::UpVectorMode' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsNearGround, GroundDirections) == 0x000098, "Member 'UBTDecorator_IsNearGround::GroundDirections' has a wrong offset!");

// Class Zion.GameplayCamera
// 0x0520 (0x0ED0 - 0x09B0)
class AGameplayCamera : public ACameraActor
{
public:
	uint8                                         Pad_9B0[0x10];                                     // 0x09B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CurrTargetTransform;                               // 0x09C0(0x0060)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A20[0x18];                                     // 0x0A20(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class APawn>>           EnemyPawnTargets;                                  // 0x0A38(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FVector                                CurrentTargetLocation;                             // 0x0A48(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A60[0x80];                                     // 0x0A60(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CurrentLocalLocationOffset;                        // 0x0AE0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AF0[0x30];                                     // 0x0AF0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           InputAction_CameraOffset;                          // 0x0B20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              LastInputLocationOffset;                           // 0x0B28(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              CurrentInputLocationOffset;                        // 0x0B38(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayCameraSettings                DefaultSettings;                                   // 0x0B48(0x0078)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC0[0x268];                                    // 0x0BC0(0x0268)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseOscillation;                                   // 0x0E28(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E29[0x3];                                      // 0x0E29(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OscillationScale;                                  // 0x0E2C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVOscillator                           LocOscillation;                                    // 0x0E30(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E54[0x34];                                     // 0x0E54(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           DebugAction_Zoom;                                  // 0x0E88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DebugZoomOffset_Speed;                             // 0x0E90(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DebugMinZoomOffset;                                // 0x0E94(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DebugMaxZoomOffset;                                // 0x0E98(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E9C[0x4];                                      // 0x0E9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           DebugAction_FOV;                                   // 0x0EA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DebugFOV_Speed;                                    // 0x0EA8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DebugMinFOV;                                       // 0x0EAC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DebugMaxFOV;                                       // 0x0EB0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EB4[0x4];                                      // 0x0EB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           DebugAction_LocalOffset;                           // 0x0EB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DebugLocalOffset_Speed;                            // 0x0EC0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC4[0xC];                                      // 0x0EC4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearSettings();
	void FlushCamera();
	void RegisterEnemyPawn(class APawn* EnemyPawnToAdd);
	void RegisterEnemyPawns(const TArray<class APawn*>& EnemyPawnsToAdd);
	void ResetCameraToDefault();
	void SetSettings(const struct FGameplayCameraSettings& NewSettings);
	void UnregisterEnemyPawn(class APawn* EnemyPawnToRemove);
	void UnregisterEnemyPawns(const TArray<class APawn*>& EnemyPawnsToRemove);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCamera">();
	}
	static class AGameplayCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayCamera>();
	}
};
static_assert(alignof(AGameplayCamera) == 0x000010, "Wrong alignment on AGameplayCamera");
static_assert(sizeof(AGameplayCamera) == 0x000ED0, "Wrong size on AGameplayCamera");
static_assert(offsetof(AGameplayCamera, CurrTargetTransform) == 0x0009C0, "Member 'AGameplayCamera::CurrTargetTransform' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, EnemyPawnTargets) == 0x000A38, "Member 'AGameplayCamera::EnemyPawnTargets' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, CurrentTargetLocation) == 0x000A48, "Member 'AGameplayCamera::CurrentTargetLocation' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, CurrentLocalLocationOffset) == 0x000AE0, "Member 'AGameplayCamera::CurrentLocalLocationOffset' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, InputAction_CameraOffset) == 0x000B20, "Member 'AGameplayCamera::InputAction_CameraOffset' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, LastInputLocationOffset) == 0x000B28, "Member 'AGameplayCamera::LastInputLocationOffset' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, CurrentInputLocationOffset) == 0x000B38, "Member 'AGameplayCamera::CurrentInputLocationOffset' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, DefaultSettings) == 0x000B48, "Member 'AGameplayCamera::DefaultSettings' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, bUseOscillation) == 0x000E28, "Member 'AGameplayCamera::bUseOscillation' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, OscillationScale) == 0x000E2C, "Member 'AGameplayCamera::OscillationScale' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, LocOscillation) == 0x000E30, "Member 'AGameplayCamera::LocOscillation' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, DebugAction_Zoom) == 0x000E88, "Member 'AGameplayCamera::DebugAction_Zoom' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, DebugZoomOffset_Speed) == 0x000E90, "Member 'AGameplayCamera::DebugZoomOffset_Speed' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, DebugMinZoomOffset) == 0x000E94, "Member 'AGameplayCamera::DebugMinZoomOffset' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, DebugMaxZoomOffset) == 0x000E98, "Member 'AGameplayCamera::DebugMaxZoomOffset' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, DebugAction_FOV) == 0x000EA0, "Member 'AGameplayCamera::DebugAction_FOV' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, DebugFOV_Speed) == 0x000EA8, "Member 'AGameplayCamera::DebugFOV_Speed' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, DebugMinFOV) == 0x000EAC, "Member 'AGameplayCamera::DebugMinFOV' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, DebugMaxFOV) == 0x000EB0, "Member 'AGameplayCamera::DebugMaxFOV' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, DebugAction_LocalOffset) == 0x000EB8, "Member 'AGameplayCamera::DebugAction_LocalOffset' has a wrong offset!");
static_assert(offsetof(AGameplayCamera, DebugLocalOffset_Speed) == 0x000EC0, "Member 'AGameplayCamera::DebugLocalOffset_Speed' has a wrong offset!");

// Class Zion.BTDecorator_IsNearWall
// 0x0080 (0x00E8 - 0x0068)
class UBTDecorator_IsNearWall final : public UBTDecoratorZionCondition
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0068(0x0028)(Edit, NativeAccessSpecifierPrivate)
	EConditionOperator                            CheckOperator;                                     // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDecoratorNearWallDirection, float>      WallDirections;                                    // 0x0098(0x0050)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsNearWall">();
	}
	static class UBTDecorator_IsNearWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsNearWall>();
	}
};
static_assert(alignof(UBTDecorator_IsNearWall) == 0x000008, "Wrong alignment on UBTDecorator_IsNearWall");
static_assert(sizeof(UBTDecorator_IsNearWall) == 0x0000E8, "Wrong size on UBTDecorator_IsNearWall");
static_assert(offsetof(UBTDecorator_IsNearWall, Target) == 0x000068, "Member 'UBTDecorator_IsNearWall::Target' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsNearWall, CheckOperator) == 0x000090, "Member 'UBTDecorator_IsNearWall::CheckOperator' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsNearWall, WallDirections) == 0x000098, "Member 'UBTDecorator_IsNearWall::WallDirections' has a wrong offset!");

// Class Zion.BTDecorator_IsNearWaterSurface
// 0x0008 (0x0070 - 0x0068)
class UBTDecorator_IsNearWaterSurface final : public UBTDecoratorZionCondition
{
public:
	float                                         Distance;                                          // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsNearWaterSurface">();
	}
	static class UBTDecorator_IsNearWaterSurface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsNearWaterSurface>();
	}
};
static_assert(alignof(UBTDecorator_IsNearWaterSurface) == 0x000008, "Wrong alignment on UBTDecorator_IsNearWaterSurface");
static_assert(sizeof(UBTDecorator_IsNearWaterSurface) == 0x000070, "Wrong size on UBTDecorator_IsNearWaterSurface");
static_assert(offsetof(UBTDecorator_IsNearWaterSurface, Distance) == 0x000068, "Member 'UBTDecorator_IsNearWaterSurface::Distance' has a wrong offset!");

// Class Zion.BTDecorator_IsNewGamePlus
// 0x0000 (0x0068 - 0x0068)
class UBTDecorator_IsNewGamePlus final : public UBTDecoratorZion
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsNewGamePlus">();
	}
	static class UBTDecorator_IsNewGamePlus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsNewGamePlus>();
	}
};
static_assert(alignof(UBTDecorator_IsNewGamePlus) == 0x000008, "Wrong alignment on UBTDecorator_IsNewGamePlus");
static_assert(sizeof(UBTDecorator_IsNewGamePlus) == 0x000068, "Wrong size on UBTDecorator_IsNewGamePlus");

// Class Zion.CommandModule_SetFacingFromInput
// 0x0018 (0x0050 - 0x0038)
class UCommandModule_SetFacingFromInput final : public UCommandModule
{
public:
	bool                                          bCheckLockFacing;                                  // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x17];                                      // 0x0039(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_SetFacingFromInput">();
	}
	static class UCommandModule_SetFacingFromInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_SetFacingFromInput>();
	}
};
static_assert(alignof(UCommandModule_SetFacingFromInput) == 0x000008, "Wrong alignment on UCommandModule_SetFacingFromInput");
static_assert(sizeof(UCommandModule_SetFacingFromInput) == 0x000050, "Wrong size on UCommandModule_SetFacingFromInput");
static_assert(offsetof(UCommandModule_SetFacingFromInput, bCheckLockFacing) == 0x000038, "Member 'UCommandModule_SetFacingFromInput::bCheckLockFacing' has a wrong offset!");

// Class Zion.BTDecorator_IsOnScreen
// 0x0008 (0x0070 - 0x0068)
class UBTDecorator_IsOnScreen final : public UBTDecoratorZionCondition
{
public:
	float                                         TimeTolerance;                                     // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsOnScreen">();
	}
	static class UBTDecorator_IsOnScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsOnScreen>();
	}
};
static_assert(alignof(UBTDecorator_IsOnScreen) == 0x000008, "Wrong alignment on UBTDecorator_IsOnScreen");
static_assert(sizeof(UBTDecorator_IsOnScreen) == 0x000070, "Wrong size on UBTDecorator_IsOnScreen");
static_assert(offsetof(UBTDecorator_IsOnScreen, TimeTolerance) == 0x000068, "Member 'UBTDecorator_IsOnScreen::TimeTolerance' has a wrong offset!");

// Class Zion.UserWidgetPlayerUI
// 0x0030 (0x0490 - 0x0460)
class UUserWidgetPlayerUI : public UUserWidgetZion
{
public:
	class UUserWidgetFieldTalkHolder*             WBP_FieldTalkHolder;                               // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidgetMinimap*                     WBP_Minimap;                                       // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x20];                                     // 0x0470(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideUI(bool bInstant);
	void OnDisplayPlayerUIChanged();
	void OnLowHPFeedbackOpacityChanged();
	void OnPlayerInputLocked();
	void OnPlayerInputUnlocked();
	void OnRefreshLowHPFeedbackOpacity(float Opacity);
	void OnRefreshPlayerUIVisibility(bool bVisible);
	void RefreshHealVisibility();
	void RefreshSPVisibility();
	void ShowUI();
	void TriggerAnimation_HealFailure_FullHP();
	void TriggerAnimation_HealFailure_NoHeal();

	bool CanShowHeal() const;
	bool CanShowSP() const;
	class APlayerController* GetController() const;
	class UUserWidgetFieldTalkHolder* GetFieldTalkHolder() const;
	class UUserWidgetMinimap* GetMinimapWidget() const;
	class APawn* GetPawn() const;
	void RefreshCustomMarkers() const;
	void RefreshMinimap() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetPlayerUI">();
	}
	static class UUserWidgetPlayerUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetPlayerUI>();
	}
};
static_assert(alignof(UUserWidgetPlayerUI) == 0x000008, "Wrong alignment on UUserWidgetPlayerUI");
static_assert(sizeof(UUserWidgetPlayerUI) == 0x000490, "Wrong size on UUserWidgetPlayerUI");
static_assert(offsetof(UUserWidgetPlayerUI, WBP_FieldTalkHolder) == 0x000460, "Member 'UUserWidgetPlayerUI::WBP_FieldTalkHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetPlayerUI, WBP_Minimap) == 0x000468, "Member 'UUserWidgetPlayerUI::WBP_Minimap' has a wrong offset!");

// Class Zion.BTDecorator_IsOnSide
// 0x0058 (0x00C0 - 0x0068)
class UBTDecorator_IsOnSide final : public UBTDecoratorZionCondition
{
public:
	struct FBlackboardKeySelector                 Source;                                            // 0x0068(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 Target;                                            // 0x0090(0x0028)(Edit, NativeAccessSpecifierPrivate)
	EConditionOperator                            CheckOperator;                                     // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckRight;                                       // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckLeft;                                        // 0x00BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckUp;                                          // 0x00BB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckDown;                                        // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsOnSide">();
	}
	static class UBTDecorator_IsOnSide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsOnSide>();
	}
};
static_assert(alignof(UBTDecorator_IsOnSide) == 0x000008, "Wrong alignment on UBTDecorator_IsOnSide");
static_assert(sizeof(UBTDecorator_IsOnSide) == 0x0000C0, "Wrong size on UBTDecorator_IsOnSide");
static_assert(offsetof(UBTDecorator_IsOnSide, Source) == 0x000068, "Member 'UBTDecorator_IsOnSide::Source' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsOnSide, Target) == 0x000090, "Member 'UBTDecorator_IsOnSide::Target' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsOnSide, CheckOperator) == 0x0000B8, "Member 'UBTDecorator_IsOnSide::CheckOperator' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsOnSide, bCheckRight) == 0x0000B9, "Member 'UBTDecorator_IsOnSide::bCheckRight' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsOnSide, bCheckLeft) == 0x0000BA, "Member 'UBTDecorator_IsOnSide::bCheckLeft' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsOnSide, bCheckUp) == 0x0000BB, "Member 'UBTDecorator_IsOnSide::bCheckUp' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsOnSide, bCheckDown) == 0x0000BC, "Member 'UBTDecorator_IsOnSide::bCheckDown' has a wrong offset!");

// Class Zion.BTDecorator_MovementModeBase
// 0x0000 (0x0068 - 0x0068)
class UBTDecorator_MovementModeBase : public UBTDecoratorZion
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_MovementModeBase">();
	}
	static class UBTDecorator_MovementModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_MovementModeBase>();
	}
};
static_assert(alignof(UBTDecorator_MovementModeBase) == 0x000008, "Wrong alignment on UBTDecorator_MovementModeBase");
static_assert(sizeof(UBTDecorator_MovementModeBase) == 0x000068, "Wrong size on UBTDecorator_MovementModeBase");

// Class Zion.BTDecorator_MovementMode
// 0x0010 (0x0078 - 0x0068)
class UBTDecorator_MovementMode final : public UBTDecorator_MovementModeBase
{
public:
	TArray<struct FMovementModeData>              ValidMovementModes;                                // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_MovementMode">();
	}
	static class UBTDecorator_MovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_MovementMode>();
	}
};
static_assert(alignof(UBTDecorator_MovementMode) == 0x000008, "Wrong alignment on UBTDecorator_MovementMode");
static_assert(sizeof(UBTDecorator_MovementMode) == 0x000078, "Wrong size on UBTDecorator_MovementMode");
static_assert(offsetof(UBTDecorator_MovementMode, ValidMovementModes) == 0x000068, "Member 'UBTDecorator_MovementMode::ValidMovementModes' has a wrong offset!");

// Class Zion.CommandModule_Timeline_FX
// 0x0030 (0x0068 - 0x0038)
class UCommandModule_Timeline_FX final : public UCommandModule_Timeline
{
public:
	struct FTimelineFX                            TimelineFX;                                        // 0x0038(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_Timeline_FX">();
	}
	static class UCommandModule_Timeline_FX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_Timeline_FX>();
	}
};
static_assert(alignof(UCommandModule_Timeline_FX) == 0x000008, "Wrong alignment on UCommandModule_Timeline_FX");
static_assert(sizeof(UCommandModule_Timeline_FX) == 0x000068, "Wrong size on UCommandModule_Timeline_FX");
static_assert(offsetof(UCommandModule_Timeline_FX, TimelineFX) == 0x000038, "Member 'UCommandModule_Timeline_FX::TimelineFX' has a wrong offset!");

// Class Zion.BTDecorator_MovementModeGrounded
// 0x0010 (0x0078 - 0x0068)
class UBTDecorator_MovementModeGrounded final : public UBTDecorator_MovementModeBase
{
public:
	TArray<struct FMovementModeData>              ValidMovementModes;                                // 0x0068(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_MovementModeGrounded">();
	}
	static class UBTDecorator_MovementModeGrounded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_MovementModeGrounded>();
	}
};
static_assert(alignof(UBTDecorator_MovementModeGrounded) == 0x000008, "Wrong alignment on UBTDecorator_MovementModeGrounded");
static_assert(sizeof(UBTDecorator_MovementModeGrounded) == 0x000078, "Wrong size on UBTDecorator_MovementModeGrounded");
static_assert(offsetof(UBTDecorator_MovementModeGrounded, ValidMovementModes) == 0x000068, "Member 'UBTDecorator_MovementModeGrounded::ValidMovementModes' has a wrong offset!");

// Class Zion.GameplayCondition_IsActorCleared
// 0x0008 (0x0038 - 0x0030)
class UGameplayCondition_IsActorCleared final : public UGameplayCondition
{
public:
	class AActor*                                 Actor;                                             // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCondition_IsActorCleared">();
	}
	static class UGameplayCondition_IsActorCleared* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCondition_IsActorCleared>();
	}
};
static_assert(alignof(UGameplayCondition_IsActorCleared) == 0x000008, "Wrong alignment on UGameplayCondition_IsActorCleared");
static_assert(sizeof(UGameplayCondition_IsActorCleared) == 0x000038, "Wrong size on UGameplayCondition_IsActorCleared");
static_assert(offsetof(UGameplayCondition_IsActorCleared, Actor) == 0x000030, "Member 'UGameplayCondition_IsActorCleared::Actor' has a wrong offset!");

// Class Zion.BTDecorator_Random
// 0x0008 (0x0070 - 0x0068)
class UBTDecorator_Random final : public UBTDecoratorZion
{
public:
	float                                         SuccessPercentage;                                 // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_Random">();
	}
	static class UBTDecorator_Random* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_Random>();
	}
};
static_assert(alignof(UBTDecorator_Random) == 0x000008, "Wrong alignment on UBTDecorator_Random");
static_assert(sizeof(UBTDecorator_Random) == 0x000070, "Wrong size on UBTDecorator_Random");
static_assert(offsetof(UBTDecorator_Random, SuccessPercentage) == 0x000068, "Member 'UBTDecorator_Random::SuccessPercentage' has a wrong offset!");

// Class Zion.UserWidgetNotificationHolder
// 0x0018 (0x0478 - 0x0460)
class UUserWidgetNotificationHolder final : public UUserWidgetZion
{
public:
	class UPanelWidget*                           ScrollContainer;                                   // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0xC];                                      // 0x0468(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScrollDuration;                                    // 0x0474(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnDisplayHolder();
	void OnHide();
	void OnLaunchNotification(const struct FNotificationData& NotificationData);

	bool IsUIReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetNotificationHolder">();
	}
	static class UUserWidgetNotificationHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetNotificationHolder>();
	}
};
static_assert(alignof(UUserWidgetNotificationHolder) == 0x000008, "Wrong alignment on UUserWidgetNotificationHolder");
static_assert(sizeof(UUserWidgetNotificationHolder) == 0x000478, "Wrong size on UUserWidgetNotificationHolder");
static_assert(offsetof(UUserWidgetNotificationHolder, ScrollContainer) == 0x000460, "Member 'UUserWidgetNotificationHolder::ScrollContainer' has a wrong offset!");
static_assert(offsetof(UUserWidgetNotificationHolder, ScrollDuration) == 0x000474, "Member 'UUserWidgetNotificationHolder::ScrollDuration' has a wrong offset!");

// Class Zion.BTDecorator_RandomRuntimeLinear
// 0x0018 (0x0080 - 0x0068)
class UBTDecorator_RandomRuntimeLinear final : public UBTDecoratorZion
{
public:
	float                                         MinSuccessPercentage;                              // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxSuccessPercentage;                              // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeToReachMaxSuccessPercentage;                   // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERandomRuntimeLinearBlendType                 BlendType;                                         // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EaseExp;                                           // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RandomRuntimeLinear">();
	}
	static class UBTDecorator_RandomRuntimeLinear* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RandomRuntimeLinear>();
	}
};
static_assert(alignof(UBTDecorator_RandomRuntimeLinear) == 0x000008, "Wrong alignment on UBTDecorator_RandomRuntimeLinear");
static_assert(sizeof(UBTDecorator_RandomRuntimeLinear) == 0x000080, "Wrong size on UBTDecorator_RandomRuntimeLinear");
static_assert(offsetof(UBTDecorator_RandomRuntimeLinear, MinSuccessPercentage) == 0x000068, "Member 'UBTDecorator_RandomRuntimeLinear::MinSuccessPercentage' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomRuntimeLinear, MaxSuccessPercentage) == 0x00006C, "Member 'UBTDecorator_RandomRuntimeLinear::MaxSuccessPercentage' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomRuntimeLinear, TimeToReachMaxSuccessPercentage) == 0x000070, "Member 'UBTDecorator_RandomRuntimeLinear::TimeToReachMaxSuccessPercentage' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomRuntimeLinear, BlendType) == 0x000074, "Member 'UBTDecorator_RandomRuntimeLinear::BlendType' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomRuntimeLinear, EaseExp) == 0x000078, "Member 'UBTDecorator_RandomRuntimeLinear::EaseExp' has a wrong offset!");

// Class Zion.EventAction_AddRestPointEvent
// 0x0010 (0x0060 - 0x0050)
class UEventAction_AddRestPointEvent final : public UEventAction
{
public:
	struct FDataTableRowHandle                    RestPointEventDataHandle;                          // 0x0050(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_AddRestPointEvent">();
	}
	static class UEventAction_AddRestPointEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_AddRestPointEvent>();
	}
};
static_assert(alignof(UEventAction_AddRestPointEvent) == 0x000008, "Wrong alignment on UEventAction_AddRestPointEvent");
static_assert(sizeof(UEventAction_AddRestPointEvent) == 0x000060, "Wrong size on UEventAction_AddRestPointEvent");
static_assert(offsetof(UEventAction_AddRestPointEvent, RestPointEventDataHandle) == 0x000050, "Member 'UEventAction_AddRestPointEvent::RestPointEventDataHandle' has a wrong offset!");

// Class Zion.BTDecorator_SetStates
// 0x0010 (0x0078 - 0x0068)
class UBTDecorator_SetStates final : public UBTDecoratorZion
{
public:
	TArray<TSubclassOf<class UState>>             States;                                            // 0x0068(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_SetStates">();
	}
	static class UBTDecorator_SetStates* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_SetStates>();
	}
};
static_assert(alignof(UBTDecorator_SetStates) == 0x000008, "Wrong alignment on UBTDecorator_SetStates");
static_assert(sizeof(UBTDecorator_SetStates) == 0x000078, "Wrong size on UBTDecorator_SetStates");
static_assert(offsetof(UBTDecorator_SetStates, States) == 0x000068, "Member 'UBTDecorator_SetStates::States' has a wrong offset!");

// Class Zion.UserWidgetWorldSpace
// 0x0030 (0x0318 - 0x02E8)
class UUserWidgetWorldSpace : public UUserWidgetZionBase
{
public:
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              WorldSpacePivot;                                   // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScaleBox*                              DPIScaler;                                         // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Hide();
	void OnHide();
	void OnShow();
	void Show();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetWorldSpace">();
	}
	static class UUserWidgetWorldSpace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetWorldSpace>();
	}
};
static_assert(alignof(UUserWidgetWorldSpace) == 0x000008, "Wrong alignment on UUserWidgetWorldSpace");
static_assert(sizeof(UUserWidgetWorldSpace) == 0x000318, "Wrong size on UUserWidgetWorldSpace");
static_assert(offsetof(UUserWidgetWorldSpace, WorldSpacePivot) == 0x000300, "Member 'UUserWidgetWorldSpace::WorldSpacePivot' has a wrong offset!");
static_assert(offsetof(UUserWidgetWorldSpace, DPIScaler) == 0x000310, "Member 'UUserWidgetWorldSpace::DPIScaler' has a wrong offset!");

// Class Zion.UserWidgetWorldSpace_InputEvent
// 0x0000 (0x0318 - 0x0318)
class UUserWidgetWorldSpace_InputEvent final : public UUserWidgetWorldSpace
{
public:
	void OnPressConfirm();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetWorldSpace_InputEvent">();
	}
	static class UUserWidgetWorldSpace_InputEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetWorldSpace_InputEvent>();
	}
};
static_assert(alignof(UUserWidgetWorldSpace_InputEvent) == 0x000008, "Wrong alignment on UUserWidgetWorldSpace_InputEvent");
static_assert(sizeof(UUserWidgetWorldSpace_InputEvent) == 0x000318, "Wrong size on UUserWidgetWorldSpace_InputEvent");

// Class Zion.BTService_FindClosestEnemy
// 0x0030 (0x00A0 - 0x0070)
class UBTService_FindClosestEnemy : public UBTService
{
public:
	struct FBlackboardKeySelector                 KeyResult;                                         // 0x0070(0x0028)(Edit, NativeAccessSpecifierPrivate)
	ECollisionChannel                             VisibilityCollisionChannel;                        // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindClosestEnemy">();
	}
	static class UBTService_FindClosestEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindClosestEnemy>();
	}
};
static_assert(alignof(UBTService_FindClosestEnemy) == 0x000008, "Wrong alignment on UBTService_FindClosestEnemy");
static_assert(sizeof(UBTService_FindClosestEnemy) == 0x0000A0, "Wrong size on UBTService_FindClosestEnemy");
static_assert(offsetof(UBTService_FindClosestEnemy, KeyResult) == 0x000070, "Member 'UBTService_FindClosestEnemy::KeyResult' has a wrong offset!");
static_assert(offsetof(UBTService_FindClosestEnemy, VisibilityCollisionChannel) == 0x000098, "Member 'UBTService_FindClosestEnemy::VisibilityCollisionChannel' has a wrong offset!");

// Class Zion.BTService_FindClosestEnemy_Blackboard
// 0x00C8 (0x0168 - 0x00A0)
class UBTService_FindClosestEnemy_Blackboard final : public UBTService_FindClosestEnemy
{
public:
	struct FBlackboardKeySelector                 KeyDetectionType;                                  // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 KeyMinDistance;                                    // 0x00C8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 KeyMaxDistance;                                    // 0x00F0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 KeyCheckFront;                                     // 0x0118(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 KeyCheckLineOfSight;                               // 0x0140(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindClosestEnemy_Blackboard">();
	}
	static class UBTService_FindClosestEnemy_Blackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindClosestEnemy_Blackboard>();
	}
};
static_assert(alignof(UBTService_FindClosestEnemy_Blackboard) == 0x000008, "Wrong alignment on UBTService_FindClosestEnemy_Blackboard");
static_assert(sizeof(UBTService_FindClosestEnemy_Blackboard) == 0x000168, "Wrong size on UBTService_FindClosestEnemy_Blackboard");
static_assert(offsetof(UBTService_FindClosestEnemy_Blackboard, KeyDetectionType) == 0x0000A0, "Member 'UBTService_FindClosestEnemy_Blackboard::KeyDetectionType' has a wrong offset!");
static_assert(offsetof(UBTService_FindClosestEnemy_Blackboard, KeyMinDistance) == 0x0000C8, "Member 'UBTService_FindClosestEnemy_Blackboard::KeyMinDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindClosestEnemy_Blackboard, KeyMaxDistance) == 0x0000F0, "Member 'UBTService_FindClosestEnemy_Blackboard::KeyMaxDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindClosestEnemy_Blackboard, KeyCheckFront) == 0x000118, "Member 'UBTService_FindClosestEnemy_Blackboard::KeyCheckFront' has a wrong offset!");
static_assert(offsetof(UBTService_FindClosestEnemy_Blackboard, KeyCheckLineOfSight) == 0x000140, "Member 'UBTService_FindClosestEnemy_Blackboard::KeyCheckLineOfSight' has a wrong offset!");

// Class Zion.CommandModule_CommandLevel_Set
// 0x0010 (0x0048 - 0x0038)
class UCommandModule_CommandLevel_Set final : public UCommandModule
{
public:
	int32                                         CommandLevel;                                      // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0xC];                                       // 0x003C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_CommandLevel_Set">();
	}
	static class UCommandModule_CommandLevel_Set* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_CommandLevel_Set>();
	}
};
static_assert(alignof(UCommandModule_CommandLevel_Set) == 0x000008, "Wrong alignment on UCommandModule_CommandLevel_Set");
static_assert(sizeof(UCommandModule_CommandLevel_Set) == 0x000048, "Wrong size on UCommandModule_CommandLevel_Set");
static_assert(offsetof(UCommandModule_CommandLevel_Set, CommandLevel) == 0x000038, "Member 'UCommandModule_CommandLevel_Set::CommandLevel' has a wrong offset!");

// Class Zion.CameraOverrideModule_WorldLocationOffset
// 0x0010 (0x0038 - 0x0028)
class UCameraOverrideModule_WorldLocationOffset final : public UCameraOverrideModule
{
public:
	struct FVector2D                              WorldLocationOffset;                               // 0x0028(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_WorldLocationOffset">();
	}
	static class UCameraOverrideModule_WorldLocationOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_WorldLocationOffset>();
	}
};
static_assert(alignof(UCameraOverrideModule_WorldLocationOffset) == 0x000008, "Wrong alignment on UCameraOverrideModule_WorldLocationOffset");
static_assert(sizeof(UCameraOverrideModule_WorldLocationOffset) == 0x000038, "Wrong size on UCameraOverrideModule_WorldLocationOffset");
static_assert(offsetof(UCameraOverrideModule_WorldLocationOffset, WorldLocationOffset) == 0x000028, "Member 'UCameraOverrideModule_WorldLocationOffset::WorldLocationOffset' has a wrong offset!");

// Class Zion.BTService_FindClosestEnemy_Settings
// 0x0010 (0x00B0 - 0x00A0)
class UBTService_FindClosestEnemy_Settings final : public UBTService_FindClosestEnemy
{
public:
	struct FFindClosestEnemySettings              Settings;                                          // 0x00A0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindClosestEnemy_Settings">();
	}
	static class UBTService_FindClosestEnemy_Settings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindClosestEnemy_Settings>();
	}
};
static_assert(alignof(UBTService_FindClosestEnemy_Settings) == 0x000008, "Wrong alignment on UBTService_FindClosestEnemy_Settings");
static_assert(sizeof(UBTService_FindClosestEnemy_Settings) == 0x0000B0, "Wrong size on UBTService_FindClosestEnemy_Settings");
static_assert(offsetof(UBTService_FindClosestEnemy_Settings, Settings) == 0x0000A0, "Member 'UBTService_FindClosestEnemy_Settings::Settings' has a wrong offset!");

// Class Zion.Command_AI_DashTo
// 0x03E8 (0x0490 - 0x00A8)
class UCommand_AI_DashTo : public UCommand
{
public:
	struct FDashToData                            DashForward;                                       // 0x00A8(0x0078)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FDashToData                            DashBackward;                                      // 0x0120(0x0078)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   DashLoopFXs;                                       // 0x0198(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSoundData                             DashLoopSoundData;                                 // 0x01A8(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAbilityData                           AbilityData;                                       // 0x01D0(0x00E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAbilityData                           DashStopAbilityData;                               // 0x02B0(0x00E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bCheckDistanceFromBlocker;                         // 0x0390(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoStopAtDistanceFromBlocker;                     // 0x0394(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0xD8];                                     // 0x0398(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNiagaraComponent*>              LoopFXInstances;                                   // 0x0470(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UFMODAudioComponent*                    LoopSEInstance;                                    // 0x0480(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAbility*                               Ability;                                           // 0x0488(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnMoveBlocked(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command_AI_DashTo">();
	}
	static class UCommand_AI_DashTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand_AI_DashTo>();
	}
};
static_assert(alignof(UCommand_AI_DashTo) == 0x000010, "Wrong alignment on UCommand_AI_DashTo");
static_assert(sizeof(UCommand_AI_DashTo) == 0x000490, "Wrong size on UCommand_AI_DashTo");
static_assert(offsetof(UCommand_AI_DashTo, DashForward) == 0x0000A8, "Member 'UCommand_AI_DashTo::DashForward' has a wrong offset!");
static_assert(offsetof(UCommand_AI_DashTo, DashBackward) == 0x000120, "Member 'UCommand_AI_DashTo::DashBackward' has a wrong offset!");
static_assert(offsetof(UCommand_AI_DashTo, DashLoopFXs) == 0x000198, "Member 'UCommand_AI_DashTo::DashLoopFXs' has a wrong offset!");
static_assert(offsetof(UCommand_AI_DashTo, DashLoopSoundData) == 0x0001A8, "Member 'UCommand_AI_DashTo::DashLoopSoundData' has a wrong offset!");
static_assert(offsetof(UCommand_AI_DashTo, AbilityData) == 0x0001D0, "Member 'UCommand_AI_DashTo::AbilityData' has a wrong offset!");
static_assert(offsetof(UCommand_AI_DashTo, DashStopAbilityData) == 0x0002B0, "Member 'UCommand_AI_DashTo::DashStopAbilityData' has a wrong offset!");
static_assert(offsetof(UCommand_AI_DashTo, bCheckDistanceFromBlocker) == 0x000390, "Member 'UCommand_AI_DashTo::bCheckDistanceFromBlocker' has a wrong offset!");
static_assert(offsetof(UCommand_AI_DashTo, AutoStopAtDistanceFromBlocker) == 0x000394, "Member 'UCommand_AI_DashTo::AutoStopAtDistanceFromBlocker' has a wrong offset!");
static_assert(offsetof(UCommand_AI_DashTo, LoopFXInstances) == 0x000470, "Member 'UCommand_AI_DashTo::LoopFXInstances' has a wrong offset!");
static_assert(offsetof(UCommand_AI_DashTo, LoopSEInstance) == 0x000480, "Member 'UCommand_AI_DashTo::LoopSEInstance' has a wrong offset!");
static_assert(offsetof(UCommand_AI_DashTo, Ability) == 0x000488, "Member 'UCommand_AI_DashTo::Ability' has a wrong offset!");

// Class Zion.BTTaskZion
// 0x0000 (0x0070 - 0x0070)
class UBTTaskZion : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTaskZion">();
	}
	static class UBTTaskZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTaskZion>();
	}
};
static_assert(alignof(UBTTaskZion) == 0x000008, "Wrong alignment on UBTTaskZion");
static_assert(sizeof(UBTTaskZion) == 0x000070, "Wrong size on UBTTaskZion");

// Class Zion.GameViewportZion
// 0x0070 (0x0420 - 0x03B0)
class UGameViewportZion : public UGameViewportClient
{
public:
	TMulticastInlineDelegate<void()>              OnResolutionChangedDelegate;                       // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x60];                                     // 0x03C0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameViewportZion* Get();

	void SetViewportOverlayRenderOpacity(float Opacity);
	void SetViewportOverlayWidgetVisible(bool bVisible);
	void SetWorldRenderingEnable(bool bEnableWorldRendering);

	class UUserWidget* GetUserWidgetInStack(TSubclassOf<class UUserWidget> ClassToFind) const;
	bool IsShowingCollision() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameViewportZion">();
	}
	static class UGameViewportZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameViewportZion>();
	}
};
static_assert(alignof(UGameViewportZion) == 0x000008, "Wrong alignment on UGameViewportZion");
static_assert(sizeof(UGameViewportZion) == 0x000420, "Wrong size on UGameViewportZion");
static_assert(offsetof(UGameViewportZion, OnResolutionChangedDelegate) == 0x0003B0, "Member 'UGameViewportZion::OnResolutionChangedDelegate' has a wrong offset!");

// Class Zion.BTTask_CustomMoveTo
// 0x0010 (0x00C0 - 0x00B0)
class UBTTask_CustomMoveTo final : public UBTTask_MoveTo
{
public:
	EMovementSpeedMode                            MovementSpeedModeOverride;                         // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECustomMoveToAcceptableRadiusType             AcceptableRadiusType;                              // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAcceptableRadius;                               // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAcceptableRadius;                               // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CustomMoveTo">();
	}
	static class UBTTask_CustomMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CustomMoveTo>();
	}
};
static_assert(alignof(UBTTask_CustomMoveTo) == 0x000008, "Wrong alignment on UBTTask_CustomMoveTo");
static_assert(sizeof(UBTTask_CustomMoveTo) == 0x0000C0, "Wrong size on UBTTask_CustomMoveTo");
static_assert(offsetof(UBTTask_CustomMoveTo, MovementSpeedModeOverride) == 0x0000B0, "Member 'UBTTask_CustomMoveTo::MovementSpeedModeOverride' has a wrong offset!");
static_assert(offsetof(UBTTask_CustomMoveTo, AcceptableRadiusType) == 0x0000B1, "Member 'UBTTask_CustomMoveTo::AcceptableRadiusType' has a wrong offset!");
static_assert(offsetof(UBTTask_CustomMoveTo, MinAcceptableRadius) == 0x0000B4, "Member 'UBTTask_CustomMoveTo::MinAcceptableRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_CustomMoveTo, MaxAcceptableRadius) == 0x0000B8, "Member 'UBTTask_CustomMoveTo::MaxAcceptableRadius' has a wrong offset!");

// Class Zion.BTTask_CustomWait
// 0x0010 (0x0088 - 0x0078)
class UBTTask_CustomWait final : public UBTTask_Wait
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseDifficultySettings;                            // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CustomWait">();
	}
	static class UBTTask_CustomWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CustomWait>();
	}
};
static_assert(alignof(UBTTask_CustomWait) == 0x000008, "Wrong alignment on UBTTask_CustomWait");
static_assert(sizeof(UBTTask_CustomWait) == 0x000088, "Wrong size on UBTTask_CustomWait");
static_assert(offsetof(UBTTask_CustomWait, bUseDifficultySettings) == 0x000080, "Member 'UBTTask_CustomWait::bUseDifficultySettings' has a wrong offset!");

// Class Zion.UserWidgetTutorial
// 0x0020 (0x0480 - 0x0460)
class UUserWidgetTutorial : public UUserWidgetZion
{
public:
	TMulticastInlineDelegate<void()>              OnClosed;                                          // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    TutorialDataHandle;                                // 0x0470(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetTutorial">();
	}
	static class UUserWidgetTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetTutorial>();
	}
};
static_assert(alignof(UUserWidgetTutorial) == 0x000008, "Wrong alignment on UUserWidgetTutorial");
static_assert(sizeof(UUserWidgetTutorial) == 0x000480, "Wrong size on UUserWidgetTutorial");
static_assert(offsetof(UUserWidgetTutorial, OnClosed) == 0x000460, "Member 'UUserWidgetTutorial::OnClosed' has a wrong offset!");
static_assert(offsetof(UUserWidgetTutorial, TutorialDataHandle) == 0x000470, "Member 'UUserWidgetTutorial::TutorialDataHandle' has a wrong offset!");

// Class Zion.BTTask_Execute
// 0x0008 (0x0078 - 0x0070)
class UBTTask_Execute : public UBTTaskZion
{
public:
	bool                                          bRequireInstantUpdate;                             // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bClearOnAbort;                                     // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishCommand(const class UCommand* Command, ECommandFinishType FinishType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_Execute">();
	}
	static class UBTTask_Execute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_Execute>();
	}
};
static_assert(alignof(UBTTask_Execute) == 0x000008, "Wrong alignment on UBTTask_Execute");
static_assert(sizeof(UBTTask_Execute) == 0x000078, "Wrong size on UBTTask_Execute");
static_assert(offsetof(UBTTask_Execute, bRequireInstantUpdate) == 0x000070, "Member 'UBTTask_Execute::bRequireInstantUpdate' has a wrong offset!");
static_assert(offsetof(UBTTask_Execute, bClearOnAbort) == 0x000071, "Member 'UBTTask_Execute::bClearOnAbort' has a wrong offset!");

// Class Zion.BTTask_ExecuteCommands
// 0x0010 (0x0088 - 0x0078)
class UBTTask_ExecuteCommands final : public UBTTask_Execute
{
public:
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x0078(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ExecuteCommands">();
	}
	static class UBTTask_ExecuteCommands* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ExecuteCommands>();
	}
};
static_assert(alignof(UBTTask_ExecuteCommands) == 0x000008, "Wrong alignment on UBTTask_ExecuteCommands");
static_assert(sizeof(UBTTask_ExecuteCommands) == 0x000088, "Wrong size on UBTTask_ExecuteCommands");
static_assert(offsetof(UBTTask_ExecuteCommands, CommandClasses) == 0x000078, "Member 'UBTTask_ExecuteCommands::CommandClasses' has a wrong offset!");

// Class Zion.Passive
// 0x0008 (0x0030 - 0x0028)
class UPassive : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive">();
	}
	static class UPassive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive>();
	}
};
static_assert(alignof(UPassive) == 0x000008, "Wrong alignment on UPassive");
static_assert(sizeof(UPassive) == 0x000030, "Wrong size on UPassive");

// Class Zion.Passive_ExplorationAptitudesChargeShort
// 0x0008 (0x0038 - 0x0030)
class UPassive_ExplorationAptitudesChargeShort final : public UPassive
{
public:
	class UCommandSet*                            CommandSet;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_ExplorationAptitudesChargeShort">();
	}
	static class UPassive_ExplorationAptitudesChargeShort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_ExplorationAptitudesChargeShort>();
	}
};
static_assert(alignof(UPassive_ExplorationAptitudesChargeShort) == 0x000008, "Wrong alignment on UPassive_ExplorationAptitudesChargeShort");
static_assert(sizeof(UPassive_ExplorationAptitudesChargeShort) == 0x000038, "Wrong size on UPassive_ExplorationAptitudesChargeShort");
static_assert(offsetof(UPassive_ExplorationAptitudesChargeShort, CommandSet) == 0x000030, "Member 'UPassive_ExplorationAptitudesChargeShort::CommandSet' has a wrong offset!");

// Class Zion.FieldTalkAsset
// 0x0018 (0x0048 - 0x0030)
class UFieldTalkAsset final : public UDataAsset
{
public:
	struct FFieldTalkData                         FieldTalk;                                         // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldTalkAsset">();
	}
	static class UFieldTalkAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldTalkAsset>();
	}
};
static_assert(alignof(UFieldTalkAsset) == 0x000008, "Wrong alignment on UFieldTalkAsset");
static_assert(sizeof(UFieldTalkAsset) == 0x000048, "Wrong size on UFieldTalkAsset");
static_assert(offsetof(UFieldTalkAsset, FieldTalk) == 0x000030, "Member 'UFieldTalkAsset::FieldTalk' has a wrong offset!");

// Class Zion.BTTask_ExecuteCommandLoop
// 0x0038 (0x00B0 - 0x0078)
class UBTTask_ExecuteCommandLoop final : public UBTTask_Execute
{
public:
	TArray<TSubclassOf<class UCommand>>           StartCommandClasses;                               // 0x0078(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UCommand>>           LoopCommandClasses;                                // 0x0088(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         LoopCount;                                         // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x00A0(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ExecuteCommandLoop">();
	}
	static class UBTTask_ExecuteCommandLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ExecuteCommandLoop>();
	}
};
static_assert(alignof(UBTTask_ExecuteCommandLoop) == 0x000008, "Wrong alignment on UBTTask_ExecuteCommandLoop");
static_assert(sizeof(UBTTask_ExecuteCommandLoop) == 0x0000B0, "Wrong size on UBTTask_ExecuteCommandLoop");
static_assert(offsetof(UBTTask_ExecuteCommandLoop, StartCommandClasses) == 0x000078, "Member 'UBTTask_ExecuteCommandLoop::StartCommandClasses' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteCommandLoop, LoopCommandClasses) == 0x000088, "Member 'UBTTask_ExecuteCommandLoop::LoopCommandClasses' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteCommandLoop, LoopCount) == 0x000098, "Member 'UBTTask_ExecuteCommandLoop::LoopCount' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteCommandLoop, CommandClasses) == 0x0000A0, "Member 'UBTTask_ExecuteCommandLoop::CommandClasses' has a wrong offset!");

// Class Zion.BTTask_ExecuteDash
// 0x0078 (0x00F0 - 0x0078)
class UBTTask_ExecuteDash final : public UBTTask_Execute
{
public:
	struct FBlackboardKeySelector                 DashTarget;                                        // 0x0078(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FVector                                WorldSpaceOffset;                                  // 0x00A0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TargetLocalSpaceOffset;                            // 0x00B8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTrackTargetLocation;                              // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AcceptableRadius;                                  // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCommand_AI_DashTo>         DashCommandClass;                                  // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x00E0(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ExecuteDash">();
	}
	static class UBTTask_ExecuteDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ExecuteDash>();
	}
};
static_assert(alignof(UBTTask_ExecuteDash) == 0x000008, "Wrong alignment on UBTTask_ExecuteDash");
static_assert(sizeof(UBTTask_ExecuteDash) == 0x0000F0, "Wrong size on UBTTask_ExecuteDash");
static_assert(offsetof(UBTTask_ExecuteDash, DashTarget) == 0x000078, "Member 'UBTTask_ExecuteDash::DashTarget' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteDash, WorldSpaceOffset) == 0x0000A0, "Member 'UBTTask_ExecuteDash::WorldSpaceOffset' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteDash, TargetLocalSpaceOffset) == 0x0000B8, "Member 'UBTTask_ExecuteDash::TargetLocalSpaceOffset' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteDash, bTrackTargetLocation) == 0x0000D0, "Member 'UBTTask_ExecuteDash::bTrackTargetLocation' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteDash, AcceptableRadius) == 0x0000D4, "Member 'UBTTask_ExecuteDash::AcceptableRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteDash, DashCommandClass) == 0x0000D8, "Member 'UBTTask_ExecuteDash::DashCommandClass' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteDash, CommandClasses) == 0x0000E0, "Member 'UBTTask_ExecuteDash::CommandClasses' has a wrong offset!");

// Class Zion.DeathProcess_Transform
// 0x00B0 (0x02F0 - 0x0240)
class UDeathProcess_Transform final : public UDeathProcess
{
public:
	bool                                          bWaitForGrounded;                                  // 0x0240(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      FallAnimations;                                    // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      DeathAnimations;                                   // 0x0258(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class ULevelSequence*                         LevelSequence;                                     // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMovieSceneSequencePlaybackSettings    SequenceSettings;                                  // 0x0270(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    EnemyRowHandle;                                    // 0x0298(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	ESpineBone                                    SpawnBone;                                         // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpawnBoneCustomName;                               // 0x02AC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSpawnOffsetByHalfHeight;                          // 0x02B4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         ActivationDelay;                                   // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC[0x24];                                     // 0x02CC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeathAnimationFinished();
	void OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathProcess_Transform">();
	}
	static class UDeathProcess_Transform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathProcess_Transform>();
	}
};
static_assert(alignof(UDeathProcess_Transform) == 0x000010, "Wrong alignment on UDeathProcess_Transform");
static_assert(sizeof(UDeathProcess_Transform) == 0x0002F0, "Wrong size on UDeathProcess_Transform");
static_assert(offsetof(UDeathProcess_Transform, bWaitForGrounded) == 0x000240, "Member 'UDeathProcess_Transform::bWaitForGrounded' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Transform, FallAnimations) == 0x000248, "Member 'UDeathProcess_Transform::FallAnimations' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Transform, DeathAnimations) == 0x000258, "Member 'UDeathProcess_Transform::DeathAnimations' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Transform, LevelSequence) == 0x000268, "Member 'UDeathProcess_Transform::LevelSequence' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Transform, SequenceSettings) == 0x000270, "Member 'UDeathProcess_Transform::SequenceSettings' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Transform, EnemyRowHandle) == 0x000298, "Member 'UDeathProcess_Transform::EnemyRowHandle' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Transform, SpawnBone) == 0x0002A8, "Member 'UDeathProcess_Transform::SpawnBone' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Transform, SpawnBoneCustomName) == 0x0002AC, "Member 'UDeathProcess_Transform::SpawnBoneCustomName' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Transform, bSpawnOffsetByHalfHeight) == 0x0002B4, "Member 'UDeathProcess_Transform::bSpawnOffsetByHalfHeight' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Transform, CommandClasses) == 0x0002B8, "Member 'UDeathProcess_Transform::CommandClasses' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Transform, ActivationDelay) == 0x0002C8, "Member 'UDeathProcess_Transform::ActivationDelay' has a wrong offset!");

// Class Zion.BTTask_ExecuteFindEnemy
// 0x0010 (0x0088 - 0x0078)
class UBTTask_ExecuteFindEnemy final : public UBTTask_Execute
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ExecuteFindEnemy">();
	}
	static class UBTTask_ExecuteFindEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ExecuteFindEnemy>();
	}
};
static_assert(alignof(UBTTask_ExecuteFindEnemy) == 0x000008, "Wrong alignment on UBTTask_ExecuteFindEnemy");
static_assert(sizeof(UBTTask_ExecuteFindEnemy) == 0x000088, "Wrong size on UBTTask_ExecuteFindEnemy");

// Class Zion.EventAction_IncrementEnvironmentLevel
// 0x0008 (0x0058 - 0x0050)
class UEventAction_IncrementEnvironmentLevel final : public UEventAction
{
public:
	bool                                          bLockEnvironmentLevel;                             // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_IncrementEnvironmentLevel">();
	}
	static class UEventAction_IncrementEnvironmentLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_IncrementEnvironmentLevel>();
	}
};
static_assert(alignof(UEventAction_IncrementEnvironmentLevel) == 0x000008, "Wrong alignment on UEventAction_IncrementEnvironmentLevel");
static_assert(sizeof(UEventAction_IncrementEnvironmentLevel) == 0x000058, "Wrong size on UEventAction_IncrementEnvironmentLevel");
static_assert(offsetof(UEventAction_IncrementEnvironmentLevel, bLockEnvironmentLevel) == 0x000050, "Member 'UEventAction_IncrementEnvironmentLevel::bLockEnvironmentLevel' has a wrong offset!");

// Class Zion.BTTask_ExecuteIdlePeace
// 0x0010 (0x0088 - 0x0078)
class UBTTask_ExecuteIdlePeace final : public UBTTask_Execute
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ExecuteIdlePeace">();
	}
	static class UBTTask_ExecuteIdlePeace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ExecuteIdlePeace>();
	}
};
static_assert(alignof(UBTTask_ExecuteIdlePeace) == 0x000008, "Wrong alignment on UBTTask_ExecuteIdlePeace");
static_assert(sizeof(UBTTask_ExecuteIdlePeace) == 0x000088, "Wrong size on UBTTask_ExecuteIdlePeace");

// Class Zion.BTTask_ExecuteWarp
// 0x00E8 (0x0160 - 0x0078)
class UBTTask_ExecuteWarp final : public UBTTask_Execute
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0078(0x0028)(Edit, NativeAccessSpecifierPrivate)
	EWarpOffsetMode                               TargetLocalSpaceOffsetMode;                        // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocalSpaceOffset;                            // 0x00A8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TargetLocalSpaceOffsetMin;                         // 0x00C0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TargetLocalSpaceOffsetMax;                         // 0x00D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EWarpOffsetMode                               WorldSpaceOffsetMode;                              // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldSpaceOffset;                                  // 0x00F8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                WorldSpaceOffsetMin;                               // 0x0110(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                WorldSpaceOffsetMax;                               // 0x0128(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseNavMesh;                                       // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSnapToGround;                                     // 0x0141(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_142[0x2];                                      // 0x0142(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightOffsetFromGround;                            // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCommand_AI_WarpTo>         WarpCommandClass;                                  // 0x0148(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x0150(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ExecuteWarp">();
	}
	static class UBTTask_ExecuteWarp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ExecuteWarp>();
	}
};
static_assert(alignof(UBTTask_ExecuteWarp) == 0x000008, "Wrong alignment on UBTTask_ExecuteWarp");
static_assert(sizeof(UBTTask_ExecuteWarp) == 0x000160, "Wrong size on UBTTask_ExecuteWarp");
static_assert(offsetof(UBTTask_ExecuteWarp, Target) == 0x000078, "Member 'UBTTask_ExecuteWarp::Target' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteWarp, TargetLocalSpaceOffsetMode) == 0x0000A0, "Member 'UBTTask_ExecuteWarp::TargetLocalSpaceOffsetMode' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteWarp, TargetLocalSpaceOffset) == 0x0000A8, "Member 'UBTTask_ExecuteWarp::TargetLocalSpaceOffset' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteWarp, TargetLocalSpaceOffsetMin) == 0x0000C0, "Member 'UBTTask_ExecuteWarp::TargetLocalSpaceOffsetMin' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteWarp, TargetLocalSpaceOffsetMax) == 0x0000D8, "Member 'UBTTask_ExecuteWarp::TargetLocalSpaceOffsetMax' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteWarp, WorldSpaceOffsetMode) == 0x0000F0, "Member 'UBTTask_ExecuteWarp::WorldSpaceOffsetMode' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteWarp, WorldSpaceOffset) == 0x0000F8, "Member 'UBTTask_ExecuteWarp::WorldSpaceOffset' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteWarp, WorldSpaceOffsetMin) == 0x000110, "Member 'UBTTask_ExecuteWarp::WorldSpaceOffsetMin' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteWarp, WorldSpaceOffsetMax) == 0x000128, "Member 'UBTTask_ExecuteWarp::WorldSpaceOffsetMax' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteWarp, bUseNavMesh) == 0x000140, "Member 'UBTTask_ExecuteWarp::bUseNavMesh' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteWarp, bSnapToGround) == 0x000141, "Member 'UBTTask_ExecuteWarp::bSnapToGround' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteWarp, HeightOffsetFromGround) == 0x000144, "Member 'UBTTask_ExecuteWarp::HeightOffsetFromGround' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteWarp, WarpCommandClass) == 0x000148, "Member 'UBTTask_ExecuteWarp::WarpCommandClass' has a wrong offset!");
static_assert(offsetof(UBTTask_ExecuteWarp, CommandClasses) == 0x000150, "Member 'UBTTask_ExecuteWarp::CommandClasses' has a wrong offset!");

// Class Zion.BTTask_FlyTo
// 0x00E0 (0x0190 - 0x00B0)
class UBTTask_FlyTo : public UBTTask_MoveTo
{
public:
	bool                                          bClampHeight;                                      // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 ClampHeightOriginKey;                              // 0x00B8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         MinHeight;                                         // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHeight;                                         // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClampWidth;                                       // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 ClampWidthOriginKey;                               // 0x00F0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         MinWidth;                                          // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWidth;                                          // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EFlyToTargetOffsetType                        TargetOffsetType;                                  // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldSpaceTargetOffset;                            // 0x0140(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                BoxMinWorldSpaceTargetOffset;                      // 0x0158(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                BoxMaxWorldSpaceTargetOffset;                      // 0x0170(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bProjectLocationToGround;                          // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundHeightOffset;                                // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FlyTo">();
	}
	static class UBTTask_FlyTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FlyTo>();
	}
};
static_assert(alignof(UBTTask_FlyTo) == 0x000008, "Wrong alignment on UBTTask_FlyTo");
static_assert(sizeof(UBTTask_FlyTo) == 0x000190, "Wrong size on UBTTask_FlyTo");
static_assert(offsetof(UBTTask_FlyTo, bClampHeight) == 0x0000B0, "Member 'UBTTask_FlyTo::bClampHeight' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, ClampHeightOriginKey) == 0x0000B8, "Member 'UBTTask_FlyTo::ClampHeightOriginKey' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, MinHeight) == 0x0000E0, "Member 'UBTTask_FlyTo::MinHeight' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, MaxHeight) == 0x0000E4, "Member 'UBTTask_FlyTo::MaxHeight' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, bClampWidth) == 0x0000E8, "Member 'UBTTask_FlyTo::bClampWidth' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, ClampWidthOriginKey) == 0x0000F0, "Member 'UBTTask_FlyTo::ClampWidthOriginKey' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, MinWidth) == 0x000118, "Member 'UBTTask_FlyTo::MinWidth' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, MaxWidth) == 0x00011C, "Member 'UBTTask_FlyTo::MaxWidth' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, TargetOffsetType) == 0x000138, "Member 'UBTTask_FlyTo::TargetOffsetType' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, WorldSpaceTargetOffset) == 0x000140, "Member 'UBTTask_FlyTo::WorldSpaceTargetOffset' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, BoxMinWorldSpaceTargetOffset) == 0x000158, "Member 'UBTTask_FlyTo::BoxMinWorldSpaceTargetOffset' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, BoxMaxWorldSpaceTargetOffset) == 0x000170, "Member 'UBTTask_FlyTo::BoxMaxWorldSpaceTargetOffset' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, bProjectLocationToGround) == 0x000188, "Member 'UBTTask_FlyTo::bProjectLocationToGround' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, GroundHeightOffset) == 0x00018C, "Member 'UBTTask_FlyTo::GroundHeightOffset' has a wrong offset!");

// Class Zion.EventAction_EquipCostume
// 0x0018 (0x0068 - 0x0050)
class UEventAction_EquipCostume final : public UEventAction
{
public:
	bool                                          bAutoGrantCostume;                                 // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    CostumeHandle;                                     // 0x0058(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_EquipCostume">();
	}
	static class UEventAction_EquipCostume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_EquipCostume>();
	}
};
static_assert(alignof(UEventAction_EquipCostume) == 0x000008, "Wrong alignment on UEventAction_EquipCostume");
static_assert(sizeof(UEventAction_EquipCostume) == 0x000068, "Wrong size on UEventAction_EquipCostume");
static_assert(offsetof(UEventAction_EquipCostume, bAutoGrantCostume) == 0x000050, "Member 'UEventAction_EquipCostume::bAutoGrantCostume' has a wrong offset!");
static_assert(offsetof(UEventAction_EquipCostume, CostumeHandle) == 0x000058, "Member 'UEventAction_EquipCostume::CostumeHandle' has a wrong offset!");

// Class Zion.BTTask_FlyTo_Height
// 0x0028 (0x01B8 - 0x0190)
class UBTTask_FlyTo_Height : public UBTTask_FlyTo
{
public:
	struct FBlackboardKeySelector                 MoveHeightOriginKey;                               // 0x0190(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FlyTo_Height">();
	}
	static class UBTTask_FlyTo_Height* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FlyTo_Height>();
	}
};
static_assert(alignof(UBTTask_FlyTo_Height) == 0x000008, "Wrong alignment on UBTTask_FlyTo_Height");
static_assert(sizeof(UBTTask_FlyTo_Height) == 0x0001B8, "Wrong size on UBTTask_FlyTo_Height");
static_assert(offsetof(UBTTask_FlyTo_Height, MoveHeightOriginKey) == 0x000190, "Member 'UBTTask_FlyTo_Height::MoveHeightOriginKey' has a wrong offset!");

// Class Zion.Passive_ExperiencePercentage
// 0x0008 (0x0038 - 0x0030)
class UPassive_ExperiencePercentage final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_ExperiencePercentage">();
	}
	static class UPassive_ExperiencePercentage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_ExperiencePercentage>();
	}
};
static_assert(alignof(UPassive_ExperiencePercentage) == 0x000008, "Wrong alignment on UPassive_ExperiencePercentage");
static_assert(sizeof(UPassive_ExperiencePercentage) == 0x000038, "Wrong size on UPassive_ExperiencePercentage");
static_assert(offsetof(UPassive_ExperiencePercentage, PercentageBonus) == 0x000030, "Member 'UPassive_ExperiencePercentage::PercentageBonus' has a wrong offset!");

// Class Zion.BTTask_FlyTo_Height_FixedOffset
// 0x0008 (0x01C0 - 0x01B8)
class UBTTask_FlyTo_Height_FixedOffset final : public UBTTask_FlyTo_Height
{
public:
	float                                         FixedHeightOffset;                                 // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FlyTo_Height_FixedOffset">();
	}
	static class UBTTask_FlyTo_Height_FixedOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FlyTo_Height_FixedOffset>();
	}
};
static_assert(alignof(UBTTask_FlyTo_Height_FixedOffset) == 0x000008, "Wrong alignment on UBTTask_FlyTo_Height_FixedOffset");
static_assert(sizeof(UBTTask_FlyTo_Height_FixedOffset) == 0x0001C0, "Wrong size on UBTTask_FlyTo_Height_FixedOffset");
static_assert(offsetof(UBTTask_FlyTo_Height_FixedOffset, FixedHeightOffset) == 0x0001B8, "Member 'UBTTask_FlyTo_Height_FixedOffset::FixedHeightOffset' has a wrong offset!");

// Class Zion.Passive_OnAttack
// 0x0018 (0x0048 - 0x0030)
class UPassive_OnAttack : public UPassive
{
public:
	TArray<EFaction>                              AffectedFactions;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_OnAttack">();
	}
	static class UPassive_OnAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_OnAttack>();
	}
};
static_assert(alignof(UPassive_OnAttack) == 0x000008, "Wrong alignment on UPassive_OnAttack");
static_assert(sizeof(UPassive_OnAttack) == 0x000048, "Wrong size on UPassive_OnAttack");
static_assert(offsetof(UPassive_OnAttack, AffectedFactions) == 0x000030, "Member 'UPassive_OnAttack::AffectedFactions' has a wrong offset!");

// Class Zion.FollowSplineComponent
// 0x0108 (0x01A8 - 0x00A0)
class UFollowSplineComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(bool bWasMoving)> OnStartedMovement;                               // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bWasMoving)> OnFinishedMovement;                              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x30];                                      // 0x00C0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToComplete;                                    // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsClosedLoop;                                     // 0x00F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMovementContinuous;                             // 0x00F5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseConstantVelocity;                              // 0x00F6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseMovementCurve;                                 // 0x00F7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     MovementCurve;                                     // 0x00F8(0x0088)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bSweep;                                            // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldTeleportWhenCalled;                         // 0x0181(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_182[0x2];                                      // 0x0182(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationWhenCalled;                                // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x20];                                     // 0x0188(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsClosedLoop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FollowSplineComponent">();
	}
	static class UFollowSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFollowSplineComponent>();
	}
};
static_assert(alignof(UFollowSplineComponent) == 0x000008, "Wrong alignment on UFollowSplineComponent");
static_assert(sizeof(UFollowSplineComponent) == 0x0001A8, "Wrong size on UFollowSplineComponent");
static_assert(offsetof(UFollowSplineComponent, OnStartedMovement) == 0x0000A0, "Member 'UFollowSplineComponent::OnStartedMovement' has a wrong offset!");
static_assert(offsetof(UFollowSplineComponent, OnFinishedMovement) == 0x0000B0, "Member 'UFollowSplineComponent::OnFinishedMovement' has a wrong offset!");
static_assert(offsetof(UFollowSplineComponent, TimeToComplete) == 0x0000F0, "Member 'UFollowSplineComponent::TimeToComplete' has a wrong offset!");
static_assert(offsetof(UFollowSplineComponent, bIsClosedLoop) == 0x0000F4, "Member 'UFollowSplineComponent::bIsClosedLoop' has a wrong offset!");
static_assert(offsetof(UFollowSplineComponent, bIsMovementContinuous) == 0x0000F5, "Member 'UFollowSplineComponent::bIsMovementContinuous' has a wrong offset!");
static_assert(offsetof(UFollowSplineComponent, bUseConstantVelocity) == 0x0000F6, "Member 'UFollowSplineComponent::bUseConstantVelocity' has a wrong offset!");
static_assert(offsetof(UFollowSplineComponent, bUseMovementCurve) == 0x0000F7, "Member 'UFollowSplineComponent::bUseMovementCurve' has a wrong offset!");
static_assert(offsetof(UFollowSplineComponent, MovementCurve) == 0x0000F8, "Member 'UFollowSplineComponent::MovementCurve' has a wrong offset!");
static_assert(offsetof(UFollowSplineComponent, bSweep) == 0x000180, "Member 'UFollowSplineComponent::bSweep' has a wrong offset!");
static_assert(offsetof(UFollowSplineComponent, bShouldTeleportWhenCalled) == 0x000181, "Member 'UFollowSplineComponent::bShouldTeleportWhenCalled' has a wrong offset!");
static_assert(offsetof(UFollowSplineComponent, DurationWhenCalled) == 0x000184, "Member 'UFollowSplineComponent::DurationWhenCalled' has a wrong offset!");

// Class Zion.BTTask_FlyTo_Height_Patrol
// 0x0010 (0x01C8 - 0x01B8)
class UBTTask_FlyTo_Height_Patrol final : public UBTTask_FlyTo_Height
{
public:
	float                                         MoveHeightMin;                                     // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveHeightMax;                                     // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x8];                                      // 0x01C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FlyTo_Height_Patrol">();
	}
	static class UBTTask_FlyTo_Height_Patrol* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FlyTo_Height_Patrol>();
	}
};
static_assert(alignof(UBTTask_FlyTo_Height_Patrol) == 0x000008, "Wrong alignment on UBTTask_FlyTo_Height_Patrol");
static_assert(sizeof(UBTTask_FlyTo_Height_Patrol) == 0x0001C8, "Wrong size on UBTTask_FlyTo_Height_Patrol");
static_assert(offsetof(UBTTask_FlyTo_Height_Patrol, MoveHeightMin) == 0x0001B8, "Member 'UBTTask_FlyTo_Height_Patrol::MoveHeightMin' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo_Height_Patrol, MoveHeightMax) == 0x0001BC, "Member 'UBTTask_FlyTo_Height_Patrol::MoveHeightMax' has a wrong offset!");

// Class Zion.BTTask_FlyTo_Height_Target
// 0x0028 (0x01E0 - 0x01B8)
class UBTTask_FlyTo_Height_Target final : public UBTTask_FlyTo_Height
{
public:
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x01B8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FlyTo_Height_Target">();
	}
	static class UBTTask_FlyTo_Height_Target* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FlyTo_Height_Target>();
	}
};
static_assert(alignof(UBTTask_FlyTo_Height_Target) == 0x000008, "Wrong alignment on UBTTask_FlyTo_Height_Target");
static_assert(sizeof(UBTTask_FlyTo_Height_Target) == 0x0001E0, "Wrong size on UBTTask_FlyTo_Height_Target");
static_assert(offsetof(UBTTask_FlyTo_Height_Target, TargetKey) == 0x0001B8, "Member 'UBTTask_FlyTo_Height_Target::TargetKey' has a wrong offset!");

// Class Zion.EditorDebugComponent
// 0x0008 (0x00A8 - 0x00A0)
class UEditorDebugComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorDebugComponent">();
	}
	static class UEditorDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorDebugComponent>();
	}
};
static_assert(alignof(UEditorDebugComponent) == 0x000008, "Wrong alignment on UEditorDebugComponent");
static_assert(sizeof(UEditorDebugComponent) == 0x0000A8, "Wrong size on UEditorDebugComponent");

// Class Zion.BTTask_FlyTo_Linear
// 0x0078 (0x0208 - 0x0190)
class UBTTask_FlyTo_Linear : public UBTTask_FlyTo
{
public:
	struct FBlackboardKeySelector                 MoveLineOriginKey;                                 // 0x0190(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 MoveLineOffsetMin;                                 // 0x01B8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 MoveLineOffsetMax;                                 // 0x01E0(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FlyTo_Linear">();
	}
	static class UBTTask_FlyTo_Linear* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FlyTo_Linear>();
	}
};
static_assert(alignof(UBTTask_FlyTo_Linear) == 0x000008, "Wrong alignment on UBTTask_FlyTo_Linear");
static_assert(sizeof(UBTTask_FlyTo_Linear) == 0x000208, "Wrong size on UBTTask_FlyTo_Linear");
static_assert(offsetof(UBTTask_FlyTo_Linear, MoveLineOriginKey) == 0x000190, "Member 'UBTTask_FlyTo_Linear::MoveLineOriginKey' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo_Linear, MoveLineOffsetMin) == 0x0001B8, "Member 'UBTTask_FlyTo_Linear::MoveLineOffsetMin' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo_Linear, MoveLineOffsetMax) == 0x0001E0, "Member 'UBTTask_FlyTo_Linear::MoveLineOffsetMax' has a wrong offset!");

// Class Zion.ContactDamageComponent
// 0x0210 (0x02B0 - 0x00A0)
class UContactDamageComponent final : public UActorComponent
{
public:
	struct FAbilityData                           AbilityData;                                       // 0x00A0(0x00E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         DelayBeforeReEntry;                                // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReTriggerAbility;                                 // 0x0184(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_185[0x3];                                      // 0x0185(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AbilityTriggerDelay;                               // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         Targets;                                           // 0x0190(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class AActor*, int32>                    InContactActors;                                   // 0x01A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F0[0xC0];                                     // 0x01F0(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitboxBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnHitboxEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContactDamageComponent">();
	}
	static class UContactDamageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContactDamageComponent>();
	}
};
static_assert(alignof(UContactDamageComponent) == 0x000010, "Wrong alignment on UContactDamageComponent");
static_assert(sizeof(UContactDamageComponent) == 0x0002B0, "Wrong size on UContactDamageComponent");
static_assert(offsetof(UContactDamageComponent, AbilityData) == 0x0000A0, "Member 'UContactDamageComponent::AbilityData' has a wrong offset!");
static_assert(offsetof(UContactDamageComponent, DelayBeforeReEntry) == 0x000180, "Member 'UContactDamageComponent::DelayBeforeReEntry' has a wrong offset!");
static_assert(offsetof(UContactDamageComponent, bReTriggerAbility) == 0x000184, "Member 'UContactDamageComponent::bReTriggerAbility' has a wrong offset!");
static_assert(offsetof(UContactDamageComponent, AbilityTriggerDelay) == 0x000188, "Member 'UContactDamageComponent::AbilityTriggerDelay' has a wrong offset!");
static_assert(offsetof(UContactDamageComponent, Targets) == 0x000190, "Member 'UContactDamageComponent::Targets' has a wrong offset!");
static_assert(offsetof(UContactDamageComponent, InContactActors) == 0x0001A0, "Member 'UContactDamageComponent::InContactActors' has a wrong offset!");

// Class Zion.BTTask_FlyTo_Linear_Patrol
// 0x0008 (0x0210 - 0x0208)
class UBTTask_FlyTo_Linear_Patrol final : public UBTTask_FlyTo_Linear
{
public:
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FlyTo_Linear_Patrol">();
	}
	static class UBTTask_FlyTo_Linear_Patrol* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FlyTo_Linear_Patrol>();
	}
};
static_assert(alignof(UBTTask_FlyTo_Linear_Patrol) == 0x000008, "Wrong alignment on UBTTask_FlyTo_Linear_Patrol");
static_assert(sizeof(UBTTask_FlyTo_Linear_Patrol) == 0x000210, "Wrong size on UBTTask_FlyTo_Linear_Patrol");

// Class Zion.BTTask_FlyTo_Linear_Target
// 0x0028 (0x0230 - 0x0208)
class UBTTask_FlyTo_Linear_Target final : public UBTTask_FlyTo_Linear
{
public:
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0208(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FlyTo_Linear_Target">();
	}
	static class UBTTask_FlyTo_Linear_Target* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FlyTo_Linear_Target>();
	}
};
static_assert(alignof(UBTTask_FlyTo_Linear_Target) == 0x000008, "Wrong alignment on UBTTask_FlyTo_Linear_Target");
static_assert(sizeof(UBTTask_FlyTo_Linear_Target) == 0x000230, "Wrong size on UBTTask_FlyTo_Linear_Target");
static_assert(offsetof(UBTTask_FlyTo_Linear_Target, TargetKey) == 0x000208, "Member 'UBTTask_FlyTo_Linear_Target::TargetKey' has a wrong offset!");

// Class Zion.BTTask_FlyTo_Target
// 0x0028 (0x01B8 - 0x0190)
class UBTTask_FlyTo_Target final : public UBTTask_FlyTo
{
public:
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0190(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FlyTo_Target">();
	}
	static class UBTTask_FlyTo_Target* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FlyTo_Target>();
	}
};
static_assert(alignof(UBTTask_FlyTo_Target) == 0x000008, "Wrong alignment on UBTTask_FlyTo_Target");
static_assert(sizeof(UBTTask_FlyTo_Target) == 0x0001B8, "Wrong size on UBTTask_FlyTo_Target");
static_assert(offsetof(UBTTask_FlyTo_Target, TargetKey) == 0x000190, "Member 'UBTTask_FlyTo_Target::TargetKey' has a wrong offset!");

// Class Zion.EventAction_GrantItemsBase
// 0x0030 (0x0080 - 0x0050)
class UEventAction_GrantItemsBase : public UEventAction
{
public:
	bool                                          bShowUI;                                           // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidgetItemGet>         UserWidgetClass;                                   // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x20];                                      // 0x0060(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWidgetDestruct();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_GrantItemsBase">();
	}
	static class UEventAction_GrantItemsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_GrantItemsBase>();
	}
};
static_assert(alignof(UEventAction_GrantItemsBase) == 0x000008, "Wrong alignment on UEventAction_GrantItemsBase");
static_assert(sizeof(UEventAction_GrantItemsBase) == 0x000080, "Wrong size on UEventAction_GrantItemsBase");
static_assert(offsetof(UEventAction_GrantItemsBase, bShowUI) == 0x000050, "Member 'UEventAction_GrantItemsBase::bShowUI' has a wrong offset!");
static_assert(offsetof(UEventAction_GrantItemsBase, UserWidgetClass) == 0x000058, "Member 'UEventAction_GrantItemsBase::UserWidgetClass' has a wrong offset!");

// Class Zion.EventAction_GrantItems
// 0x0028 (0x00A8 - 0x0080)
class UEventAction_GrantItems final : public UEventAction_GrantItemsBase
{
public:
	TArray<struct FItemHandleCount>               ItemHandleCounts;                                  // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bOverrideItemsOnEventRepeat;                       // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEventClearedCheckMode                        RepeatItemMode;                                    // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemHandleCount>               RepeatItemHandleCounts;                            // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_GrantItems">();
	}
	static class UEventAction_GrantItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_GrantItems>();
	}
};
static_assert(alignof(UEventAction_GrantItems) == 0x000008, "Wrong alignment on UEventAction_GrantItems");
static_assert(sizeof(UEventAction_GrantItems) == 0x0000A8, "Wrong size on UEventAction_GrantItems");
static_assert(offsetof(UEventAction_GrantItems, ItemHandleCounts) == 0x000080, "Member 'UEventAction_GrantItems::ItemHandleCounts' has a wrong offset!");
static_assert(offsetof(UEventAction_GrantItems, bOverrideItemsOnEventRepeat) == 0x000090, "Member 'UEventAction_GrantItems::bOverrideItemsOnEventRepeat' has a wrong offset!");
static_assert(offsetof(UEventAction_GrantItems, RepeatItemMode) == 0x000091, "Member 'UEventAction_GrantItems::RepeatItemMode' has a wrong offset!");
static_assert(offsetof(UEventAction_GrantItems, RepeatItemHandleCounts) == 0x000098, "Member 'UEventAction_GrantItems::RepeatItemHandleCounts' has a wrong offset!");

// Class Zion.BTTask_PlaySpineAnimations
// 0x0010 (0x0080 - 0x0070)
class UBTTask_PlaySpineAnimations final : public UBTTaskNode
{
public:
	TArray<struct FSpineAnimationDefinition>      Animations;                                        // 0x0070(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_PlaySpineAnimations">();
	}
	static class UBTTask_PlaySpineAnimations* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_PlaySpineAnimations>();
	}
};
static_assert(alignof(UBTTask_PlaySpineAnimations) == 0x000008, "Wrong alignment on UBTTask_PlaySpineAnimations");
static_assert(sizeof(UBTTask_PlaySpineAnimations) == 0x000080, "Wrong size on UBTTask_PlaySpineAnimations");
static_assert(offsetof(UBTTask_PlaySpineAnimations, Animations) == 0x000070, "Member 'UBTTask_PlaySpineAnimations::Animations' has a wrong offset!");

// Class Zion.Passive_JumpHigher
// 0x0000 (0x0030 - 0x0030)
class UPassive_JumpHigher final : public UPassive
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_JumpHigher">();
	}
	static class UPassive_JumpHigher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_JumpHigher>();
	}
};
static_assert(alignof(UPassive_JumpHigher) == 0x000008, "Wrong alignment on UPassive_JumpHigher");
static_assert(sizeof(UPassive_JumpHigher) == 0x000030, "Wrong size on UPassive_JumpHigher");

// Class Zion.BTTask_SelfKnockback
// 0x0058 (0x00C8 - 0x0070)
class UBTTask_SelfKnockback final : public UBTTaskNode
{
public:
	struct FKnockbackData                         KnockbackData;                                     // 0x0070(0x0058)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SelfKnockback">();
	}
	static class UBTTask_SelfKnockback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SelfKnockback>();
	}
};
static_assert(alignof(UBTTask_SelfKnockback) == 0x000008, "Wrong alignment on UBTTask_SelfKnockback");
static_assert(sizeof(UBTTask_SelfKnockback) == 0x0000C8, "Wrong size on UBTTask_SelfKnockback");
static_assert(offsetof(UBTTask_SelfKnockback, KnockbackData) == 0x000070, "Member 'UBTTask_SelfKnockback::KnockbackData' has a wrong offset!");

// Class Zion.Passive_OnKill
// 0x0018 (0x0048 - 0x0030)
class UPassive_OnKill : public UPassive
{
public:
	TArray<EFaction>                              AffectedFactions;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_OnKill">();
	}
	static class UPassive_OnKill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_OnKill>();
	}
};
static_assert(alignof(UPassive_OnKill) == 0x000008, "Wrong alignment on UPassive_OnKill");
static_assert(sizeof(UPassive_OnKill) == 0x000048, "Wrong size on UPassive_OnKill");
static_assert(offsetof(UPassive_OnKill, AffectedFactions) == 0x000030, "Member 'UPassive_OnKill::AffectedFactions' has a wrong offset!");

// Class Zion.Passive_OnKill_Restore
// 0x0010 (0x0058 - 0x0048)
class UPassive_OnKill_Restore : public UPassive_OnKill
{
public:
	EPassiveOnKillRestoreType                     RestoreType;                                       // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FlatAmountToRestore;                               // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         StatPercentageToRestore;                           // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_OnKill_Restore">();
	}
	static class UPassive_OnKill_Restore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_OnKill_Restore>();
	}
};
static_assert(alignof(UPassive_OnKill_Restore) == 0x000008, "Wrong alignment on UPassive_OnKill_Restore");
static_assert(sizeof(UPassive_OnKill_Restore) == 0x000058, "Wrong size on UPassive_OnKill_Restore");
static_assert(offsetof(UPassive_OnKill_Restore, RestoreType) == 0x000048, "Member 'UPassive_OnKill_Restore::RestoreType' has a wrong offset!");
static_assert(offsetof(UPassive_OnKill_Restore, FlatAmountToRestore) == 0x00004C, "Member 'UPassive_OnKill_Restore::FlatAmountToRestore' has a wrong offset!");
static_assert(offsetof(UPassive_OnKill_Restore, StatPercentageToRestore) == 0x000050, "Member 'UPassive_OnKill_Restore::StatPercentageToRestore' has a wrong offset!");

// Class Zion.GameMapChangeDataProviderInterface
// 0x0000 (0x0000 - 0x0000)
class IGameMapChangeDataProviderInterface final
{
public:
	void GetGameMapChangeProviderData(struct FGameMapChangeProviderData* OutGameMapChangeProviderData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMapChangeDataProviderInterface">();
	}
	static class IGameMapChangeDataProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameMapChangeDataProviderInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGameMapChangeDataProviderInterface) == 0x000001, "Wrong alignment on IGameMapChangeDataProviderInterface");
static_assert(sizeof(IGameMapChangeDataProviderInterface) == 0x000001, "Wrong size on IGameMapChangeDataProviderInterface");

// Class Zion.BTTask_SetFacing
// 0x0018 (0x0088 - 0x0070)
class UBTTask_SetFacing : public UBTTaskZion
{
public:
	bool                                          bInvert;                                           // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayAnimation;                                    // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      TurnAnimations;                                    // 0x0078(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetFacing">();
	}
	static class UBTTask_SetFacing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetFacing>();
	}
};
static_assert(alignof(UBTTask_SetFacing) == 0x000008, "Wrong alignment on UBTTask_SetFacing");
static_assert(sizeof(UBTTask_SetFacing) == 0x000088, "Wrong size on UBTTask_SetFacing");
static_assert(offsetof(UBTTask_SetFacing, bInvert) == 0x000070, "Member 'UBTTask_SetFacing::bInvert' has a wrong offset!");
static_assert(offsetof(UBTTask_SetFacing, bPlayAnimation) == 0x000071, "Member 'UBTTask_SetFacing::bPlayAnimation' has a wrong offset!");
static_assert(offsetof(UBTTask_SetFacing, TurnAnimations) == 0x000078, "Member 'UBTTask_SetFacing::TurnAnimations' has a wrong offset!");

// Class Zion.Passive_ElementalDamageUp
// 0x0008 (0x0038 - 0x0030)
class UPassive_ElementalDamageUp final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_ElementalDamageUp">();
	}
	static class UPassive_ElementalDamageUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_ElementalDamageUp>();
	}
};
static_assert(alignof(UPassive_ElementalDamageUp) == 0x000008, "Wrong alignment on UPassive_ElementalDamageUp");
static_assert(sizeof(UPassive_ElementalDamageUp) == 0x000038, "Wrong size on UPassive_ElementalDamageUp");
static_assert(offsetof(UPassive_ElementalDamageUp, PercentageBonus) == 0x000030, "Member 'UPassive_ElementalDamageUp::PercentageBonus' has a wrong offset!");

// Class Zion.BTTask_SetFacing_Target
// 0x0028 (0x00B0 - 0x0088)
class UBTTask_SetFacing_Target final : public UBTTask_SetFacing
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0088(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetFacing_Target">();
	}
	static class UBTTask_SetFacing_Target* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetFacing_Target>();
	}
};
static_assert(alignof(UBTTask_SetFacing_Target) == 0x000008, "Wrong alignment on UBTTask_SetFacing_Target");
static_assert(sizeof(UBTTask_SetFacing_Target) == 0x0000B0, "Wrong size on UBTTask_SetFacing_Target");
static_assert(offsetof(UBTTask_SetFacing_Target, Target) == 0x000088, "Member 'UBTTask_SetFacing_Target::Target' has a wrong offset!");

// Class Zion.EventCondition_IsDemoBuild
// 0x0000 (0x0030 - 0x0030)
class UEventCondition_IsDemoBuild final : public UEventCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCondition_IsDemoBuild">();
	}
	static class UEventCondition_IsDemoBuild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventCondition_IsDemoBuild>();
	}
};
static_assert(alignof(UEventCondition_IsDemoBuild) == 0x000008, "Wrong alignment on UEventCondition_IsDemoBuild");
static_assert(sizeof(UEventCondition_IsDemoBuild) == 0x000030, "Wrong size on UEventCondition_IsDemoBuild");

// Class Zion.BTTask_SetFacing_Toggle
// 0x0000 (0x0088 - 0x0088)
class UBTTask_SetFacing_Toggle final : public UBTTask_SetFacing
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetFacing_Toggle">();
	}
	static class UBTTask_SetFacing_Toggle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetFacing_Toggle>();
	}
};
static_assert(alignof(UBTTask_SetFacing_Toggle) == 0x000008, "Wrong alignment on UBTTask_SetFacing_Toggle");
static_assert(sizeof(UBTTask_SetFacing_Toggle) == 0x000088, "Wrong size on UBTTask_SetFacing_Toggle");

// Class Zion.DashChargeComponent
// 0x0DF0 (0x0E90 - 0x00A0)
class UDashChargeComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DashTimeForCharge;                                 // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DashTimeForChargeShort;                            // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ChargeDashSpeedFactorToAdd;                        // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0xC];                                       // 0x00C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           ChargingFXData;                                    // 0x00D0(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSoundData                             ChargingSoundData;                                 // 0x01D0(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           OnChargedFXData;                                   // 0x0200(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSoundData                             OnChargedSoundData;                                // 0x0300(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           ChargedAuraFXData;                                 // 0x0330(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             DashChargeStates;                                  // 0x0430(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FDashChargeSettings                    DefaultSettings;                                   // 0x0440(0x04C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FDashChargeSettings                    SwimmingSettings;                                  // 0x0900(0x04C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACharacterZionSpirit>       DefaultSpiritClass;                                // 0x0DC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACharacterZionSpirit>       SwimmingSpiritClass;                               // 0x0DC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DD0[0x50];                                     // 0x0DD0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      ChargingFX;                                        // 0x0E20(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODAudioComponent*                    ChargingAudio;                                     // 0x0E28(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      AuraFX;                                            // 0x0E30(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAbility*                               Ability;                                           // 0x0E38(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacterZionSpirit*                   Spirit;                                            // 0x0E40(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODAudioComponent*                    LoopAudioComponent;                                // 0x0E48(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E50[0x40];                                     // 0x0E50(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCommandStart(const class UCommand* Command);
	void OnStartAnimation(class UTrackEntry* TrackEntry);

	bool IsDashCharged() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DashChargeComponent">();
	}
	static class UDashChargeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDashChargeComponent>();
	}
};
static_assert(alignof(UDashChargeComponent) == 0x000010, "Wrong alignment on UDashChargeComponent");
static_assert(sizeof(UDashChargeComponent) == 0x000E90, "Wrong size on UDashChargeComponent");
static_assert(offsetof(UDashChargeComponent, DashTimeForCharge) == 0x0000B8, "Member 'UDashChargeComponent::DashTimeForCharge' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, DashTimeForChargeShort) == 0x0000BC, "Member 'UDashChargeComponent::DashTimeForChargeShort' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, ChargeDashSpeedFactorToAdd) == 0x0000C0, "Member 'UDashChargeComponent::ChargeDashSpeedFactorToAdd' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, ChargingFXData) == 0x0000D0, "Member 'UDashChargeComponent::ChargingFXData' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, ChargingSoundData) == 0x0001D0, "Member 'UDashChargeComponent::ChargingSoundData' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, OnChargedFXData) == 0x000200, "Member 'UDashChargeComponent::OnChargedFXData' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, OnChargedSoundData) == 0x000300, "Member 'UDashChargeComponent::OnChargedSoundData' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, ChargedAuraFXData) == 0x000330, "Member 'UDashChargeComponent::ChargedAuraFXData' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, DashChargeStates) == 0x000430, "Member 'UDashChargeComponent::DashChargeStates' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, DefaultSettings) == 0x000440, "Member 'UDashChargeComponent::DefaultSettings' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, SwimmingSettings) == 0x000900, "Member 'UDashChargeComponent::SwimmingSettings' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, DefaultSpiritClass) == 0x000DC0, "Member 'UDashChargeComponent::DefaultSpiritClass' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, SwimmingSpiritClass) == 0x000DC8, "Member 'UDashChargeComponent::SwimmingSpiritClass' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, ChargingFX) == 0x000E20, "Member 'UDashChargeComponent::ChargingFX' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, ChargingAudio) == 0x000E28, "Member 'UDashChargeComponent::ChargingAudio' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, AuraFX) == 0x000E30, "Member 'UDashChargeComponent::AuraFX' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, Ability) == 0x000E38, "Member 'UDashChargeComponent::Ability' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, Spirit) == 0x000E40, "Member 'UDashChargeComponent::Spirit' has a wrong offset!");
static_assert(offsetof(UDashChargeComponent, LoopAudioComponent) == 0x000E48, "Member 'UDashChargeComponent::LoopAudioComponent' has a wrong offset!");

// Class Zion.BTTask_SetFacing_Value
// 0x0008 (0x0090 - 0x0088)
class UBTTask_SetFacing_Value final : public UBTTask_SetFacing
{
public:
	EFacingType                                   FacingType;                                        // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetFacing_Value">();
	}
	static class UBTTask_SetFacing_Value* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetFacing_Value>();
	}
};
static_assert(alignof(UBTTask_SetFacing_Value) == 0x000008, "Wrong alignment on UBTTask_SetFacing_Value");
static_assert(sizeof(UBTTask_SetFacing_Value) == 0x000090, "Wrong size on UBTTask_SetFacing_Value");
static_assert(offsetof(UBTTask_SetFacing_Value, FacingType) == 0x000088, "Member 'UBTTask_SetFacing_Value::FacingType' has a wrong offset!");

// Class Zion.BTTask_SpineColor
// 0x0008 (0x0078 - 0x0070)
class UBTTask_SpineColor : public UBTTaskZion
{
public:
	float                                         LerpDuration;                                      // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SpineColor">();
	}
	static class UBTTask_SpineColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SpineColor>();
	}
};
static_assert(alignof(UBTTask_SpineColor) == 0x000008, "Wrong alignment on UBTTask_SpineColor");
static_assert(sizeof(UBTTask_SpineColor) == 0x000078, "Wrong size on UBTTask_SpineColor");
static_assert(offsetof(UBTTask_SpineColor, LerpDuration) == 0x000070, "Member 'UBTTask_SpineColor::LerpDuration' has a wrong offset!");

// Class Zion.BTTask_SpineColor_Set
// 0x0018 (0x0090 - 0x0078)
class UBTTask_SpineColor_Set final : public UBTTask_SpineColor
{
public:
	struct FLinearColor                           OverrideColor;                                     // 0x0078(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OverrideAlpha;                                     // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SpineColor_Set">();
	}
	static class UBTTask_SpineColor_Set* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SpineColor_Set>();
	}
};
static_assert(alignof(UBTTask_SpineColor_Set) == 0x000008, "Wrong alignment on UBTTask_SpineColor_Set");
static_assert(sizeof(UBTTask_SpineColor_Set) == 0x000090, "Wrong size on UBTTask_SpineColor_Set");
static_assert(offsetof(UBTTask_SpineColor_Set, OverrideColor) == 0x000078, "Member 'UBTTask_SpineColor_Set::OverrideColor' has a wrong offset!");
static_assert(offsetof(UBTTask_SpineColor_Set, OverrideAlpha) == 0x000088, "Member 'UBTTask_SpineColor_Set::OverrideAlpha' has a wrong offset!");

// Class Zion.EventAction_MoveTo_Location
// 0x0020 (0x00E8 - 0x00C8)
class UEventAction_MoveTo_Location final : public UEventAction_MoveTo
{
public:
	bool                                          bUseEventOrigin;                                   // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x00D0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_MoveTo_Location">();
	}
	static class UEventAction_MoveTo_Location* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_MoveTo_Location>();
	}
};
static_assert(alignof(UEventAction_MoveTo_Location) == 0x000008, "Wrong alignment on UEventAction_MoveTo_Location");
static_assert(sizeof(UEventAction_MoveTo_Location) == 0x0000E8, "Wrong size on UEventAction_MoveTo_Location");
static_assert(offsetof(UEventAction_MoveTo_Location, bUseEventOrigin) == 0x0000C8, "Member 'UEventAction_MoveTo_Location::bUseEventOrigin' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_Location, TargetLocation) == 0x0000D0, "Member 'UEventAction_MoveTo_Location::TargetLocation' has a wrong offset!");

// Class Zion.BTTask_SpineColor_Clear
// 0x0000 (0x0078 - 0x0078)
class UBTTask_SpineColor_Clear final : public UBTTask_SpineColor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SpineColor_Clear">();
	}
	static class UBTTask_SpineColor_Clear* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SpineColor_Clear>();
	}
};
static_assert(alignof(UBTTask_SpineColor_Clear) == 0x000008, "Wrong alignment on UBTTask_SpineColor_Clear");
static_assert(sizeof(UBTTask_SpineColor_Clear) == 0x000078, "Wrong size on UBTTask_SpineColor_Clear");

// Class Zion.Passive_OnKill_ReduceActiveCooldowns
// 0x0010 (0x0058 - 0x0048)
class UPassive_OnKill_ReduceActiveCooldowns final : public UPassive_OnKill
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivationPercentage;                              // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ReductionPercentage;                               // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_OnKill_ReduceActiveCooldowns">();
	}
	static class UPassive_OnKill_ReduceActiveCooldowns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_OnKill_ReduceActiveCooldowns>();
	}
};
static_assert(alignof(UPassive_OnKill_ReduceActiveCooldowns) == 0x000008, "Wrong alignment on UPassive_OnKill_ReduceActiveCooldowns");
static_assert(sizeof(UPassive_OnKill_ReduceActiveCooldowns) == 0x000058, "Wrong size on UPassive_OnKill_ReduceActiveCooldowns");
static_assert(offsetof(UPassive_OnKill_ReduceActiveCooldowns, ActivationPercentage) == 0x000050, "Member 'UPassive_OnKill_ReduceActiveCooldowns::ActivationPercentage' has a wrong offset!");
static_assert(offsetof(UPassive_OnKill_ReduceActiveCooldowns, ReductionPercentage) == 0x000054, "Member 'UPassive_OnKill_ReduceActiveCooldowns::ReductionPercentage' has a wrong offset!");

// Class Zion.BTTask_WaitAnimationCycle
// 0x0008 (0x0078 - 0x0070)
class UBTTask_WaitAnimationCycle final : public UBTTaskZion
{
public:
	int32                                         TrackIndex;                                        // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimationCycleMinPercentage;                       // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_WaitAnimationCycle">();
	}
	static class UBTTask_WaitAnimationCycle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_WaitAnimationCycle>();
	}
};
static_assert(alignof(UBTTask_WaitAnimationCycle) == 0x000008, "Wrong alignment on UBTTask_WaitAnimationCycle");
static_assert(sizeof(UBTTask_WaitAnimationCycle) == 0x000078, "Wrong size on UBTTask_WaitAnimationCycle");
static_assert(offsetof(UBTTask_WaitAnimationCycle, TrackIndex) == 0x000070, "Member 'UBTTask_WaitAnimationCycle::TrackIndex' has a wrong offset!");
static_assert(offsetof(UBTTask_WaitAnimationCycle, AnimationCycleMinPercentage) == 0x000074, "Member 'UBTTask_WaitAnimationCycle::AnimationCycleMinPercentage' has a wrong offset!");

// Class Zion.Passive_ShockDamage
// 0x0008 (0x0038 - 0x0030)
class UPassive_ShockDamage final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_ShockDamage">();
	}
	static class UPassive_ShockDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_ShockDamage>();
	}
};
static_assert(alignof(UPassive_ShockDamage) == 0x000008, "Wrong alignment on UPassive_ShockDamage");
static_assert(sizeof(UPassive_ShockDamage) == 0x000038, "Wrong size on UPassive_ShockDamage");
static_assert(offsetof(UPassive_ShockDamage, PercentageBonus) == 0x000030, "Member 'UPassive_ShockDamage::PercentageBonus' has a wrong offset!");

// Class Zion.EventAction_PlayBGM
// 0x0008 (0x0058 - 0x0050)
class UEventAction_PlayBGM final : public UEventAction
{
public:
	class UFMODEvent*                             BGM;                                               // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_PlayBGM">();
	}
	static class UEventAction_PlayBGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_PlayBGM>();
	}
};
static_assert(alignof(UEventAction_PlayBGM) == 0x000008, "Wrong alignment on UEventAction_PlayBGM");
static_assert(sizeof(UEventAction_PlayBGM) == 0x000058, "Wrong size on UEventAction_PlayBGM");
static_assert(offsetof(UEventAction_PlayBGM, BGM) == 0x000050, "Member 'UEventAction_PlayBGM::BGM' has a wrong offset!");

// Class Zion.Passive_DropPercentage
// 0x0008 (0x0038 - 0x0030)
class UPassive_DropPercentage final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DropPercentage">();
	}
	static class UPassive_DropPercentage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DropPercentage>();
	}
};
static_assert(alignof(UPassive_DropPercentage) == 0x000008, "Wrong alignment on UPassive_DropPercentage");
static_assert(sizeof(UPassive_DropPercentage) == 0x000038, "Wrong size on UPassive_DropPercentage");
static_assert(offsetof(UPassive_DropPercentage, PercentageBonus) == 0x000030, "Member 'UPassive_DropPercentage::PercentageBonus' has a wrong offset!");

// Class Zion.BTTask_WaitLocomotionCycle
// 0x0008 (0x0078 - 0x0070)
class UBTTask_WaitLocomotionCycle final : public UBTTaskZion
{
public:
	float                                         LocomotionCycleMinPercentage;                      // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_WaitLocomotionCycle">();
	}
	static class UBTTask_WaitLocomotionCycle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_WaitLocomotionCycle>();
	}
};
static_assert(alignof(UBTTask_WaitLocomotionCycle) == 0x000008, "Wrong alignment on UBTTask_WaitLocomotionCycle");
static_assert(sizeof(UBTTask_WaitLocomotionCycle) == 0x000078, "Wrong size on UBTTask_WaitLocomotionCycle");
static_assert(offsetof(UBTTask_WaitLocomotionCycle, LocomotionCycleMinPercentage) == 0x000070, "Member 'UBTTask_WaitLocomotionCycle::LocomotionCycleMinPercentage' has a wrong offset!");

// Class Zion.Passive_HigherMobility
// 0x0010 (0x0040 - 0x0030)
class UPassive_HigherMobility final : public UPassive
{
public:
	float                                         RunFactorBonus;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SwimFactorBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bApplyJumpHigher;                                  // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_HigherMobility">();
	}
	static class UPassive_HigherMobility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_HigherMobility>();
	}
};
static_assert(alignof(UPassive_HigherMobility) == 0x000008, "Wrong alignment on UPassive_HigherMobility");
static_assert(sizeof(UPassive_HigherMobility) == 0x000040, "Wrong size on UPassive_HigherMobility");
static_assert(offsetof(UPassive_HigherMobility, RunFactorBonus) == 0x000030, "Member 'UPassive_HigherMobility::RunFactorBonus' has a wrong offset!");
static_assert(offsetof(UPassive_HigherMobility, SwimFactorBonus) == 0x000034, "Member 'UPassive_HigherMobility::SwimFactorBonus' has a wrong offset!");
static_assert(offsetof(UPassive_HigherMobility, bApplyJumpHigher) == 0x000038, "Member 'UPassive_HigherMobility::bApplyJumpHigher' has a wrong offset!");

// Class Zion.BTTask_WarpToLocation
// 0x00F0 (0x0160 - 0x0070)
class UBTTask_WarpToLocation final : public UBTTaskZion
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0070(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TargetLocalSpaceOffset;                            // 0x00A0(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EWarpWorldSpaceOffsetType                     WorldSpaceOffsetType;                              // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetWorldSpaceOffset;                            // 0x0108(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TargetWorldSpaceOffsetMin;                         // 0x0120(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TargetWorldSpaceOffsetMax;                         // 0x0138(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWarpXAxis;                                        // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWarpYAxis;                                        // 0x0151(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWarpZAxis;                                        // 0x0152(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseNavMesh;                                       // 0x0153(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_154[0xC];                                      // 0x0154(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_WarpToLocation">();
	}
	static class UBTTask_WarpToLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_WarpToLocation>();
	}
};
static_assert(alignof(UBTTask_WarpToLocation) == 0x000010, "Wrong alignment on UBTTask_WarpToLocation");
static_assert(sizeof(UBTTask_WarpToLocation) == 0x000160, "Wrong size on UBTTask_WarpToLocation");
static_assert(offsetof(UBTTask_WarpToLocation, Target) == 0x000070, "Member 'UBTTask_WarpToLocation::Target' has a wrong offset!");
static_assert(offsetof(UBTTask_WarpToLocation, TargetLocalSpaceOffset) == 0x0000A0, "Member 'UBTTask_WarpToLocation::TargetLocalSpaceOffset' has a wrong offset!");
static_assert(offsetof(UBTTask_WarpToLocation, WorldSpaceOffsetType) == 0x000100, "Member 'UBTTask_WarpToLocation::WorldSpaceOffsetType' has a wrong offset!");
static_assert(offsetof(UBTTask_WarpToLocation, TargetWorldSpaceOffset) == 0x000108, "Member 'UBTTask_WarpToLocation::TargetWorldSpaceOffset' has a wrong offset!");
static_assert(offsetof(UBTTask_WarpToLocation, TargetWorldSpaceOffsetMin) == 0x000120, "Member 'UBTTask_WarpToLocation::TargetWorldSpaceOffsetMin' has a wrong offset!");
static_assert(offsetof(UBTTask_WarpToLocation, TargetWorldSpaceOffsetMax) == 0x000138, "Member 'UBTTask_WarpToLocation::TargetWorldSpaceOffsetMax' has a wrong offset!");
static_assert(offsetof(UBTTask_WarpToLocation, bWarpXAxis) == 0x000150, "Member 'UBTTask_WarpToLocation::bWarpXAxis' has a wrong offset!");
static_assert(offsetof(UBTTask_WarpToLocation, bWarpYAxis) == 0x000151, "Member 'UBTTask_WarpToLocation::bWarpYAxis' has a wrong offset!");
static_assert(offsetof(UBTTask_WarpToLocation, bWarpZAxis) == 0x000152, "Member 'UBTTask_WarpToLocation::bWarpZAxis' has a wrong offset!");
static_assert(offsetof(UBTTask_WarpToLocation, bUseNavMesh) == 0x000153, "Member 'UBTTask_WarpToLocation::bUseNavMesh' has a wrong offset!");

// Class Zion.FieldMessageAsset
// 0x0018 (0x0048 - 0x0030)
class UFieldMessageAsset final : public UDataAsset
{
public:
	EFieldMessageType                             FieldMessageType;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConditionedFieldMessageData>   ConditionedMessages;                               // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldMessageAsset">();
	}
	static class UFieldMessageAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldMessageAsset>();
	}
};
static_assert(alignof(UFieldMessageAsset) == 0x000008, "Wrong alignment on UFieldMessageAsset");
static_assert(sizeof(UFieldMessageAsset) == 0x000048, "Wrong size on UFieldMessageAsset");
static_assert(offsetof(UFieldMessageAsset, FieldMessageType) == 0x000030, "Member 'UFieldMessageAsset::FieldMessageType' has a wrong offset!");
static_assert(offsetof(UFieldMessageAsset, ConditionedMessages) == 0x000038, "Member 'UFieldMessageAsset::ConditionedMessages' has a wrong offset!");

// Class Zion.CharacterNotifyInterface
// 0x0000 (0x0000 - 0x0000)
class ICharacterNotifyInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterNotifyInterface">();
	}
	static class ICharacterNotifyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICharacterNotifyInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICharacterNotifyInterface) == 0x000001, "Wrong alignment on ICharacterNotifyInterface");
static_assert(sizeof(ICharacterNotifyInterface) == 0x000001, "Wrong size on ICharacterNotifyInterface");

// Class Zion.DeathProcess_Player
// 0x0090 (0x02D0 - 0x0240)
class UDeathProcess_Player : public UDeathProcess
{
public:
	TArray<struct FSpineAnimationDefinition>      DeathAnimations;                                   // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bCanUseBackAnimations;                             // 0x0250(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      BackDeathAnimations;                               // 0x0258(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             AdditionalDeathStates;                             // 0x0268(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bUseTimeDilation;                                  // 0x0278(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimedDilationData                     TimeDilation;                                      // 0x027C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         DelayBeforeFadeOut;                                // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFadeDescriptionData                   FadeOutDescription;                                // 0x0290(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           SystemMPC;                                         // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpineBone                                    LocationTargetBone;                                // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B9[0x17];                                     // 0x02B9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadeFinished();
	void OnTimerFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathProcess_Player">();
	}
	static class UDeathProcess_Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathProcess_Player>();
	}
};
static_assert(alignof(UDeathProcess_Player) == 0x000010, "Wrong alignment on UDeathProcess_Player");
static_assert(sizeof(UDeathProcess_Player) == 0x0002D0, "Wrong size on UDeathProcess_Player");
static_assert(offsetof(UDeathProcess_Player, DeathAnimations) == 0x000240, "Member 'UDeathProcess_Player::DeathAnimations' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Player, bCanUseBackAnimations) == 0x000250, "Member 'UDeathProcess_Player::bCanUseBackAnimations' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Player, BackDeathAnimations) == 0x000258, "Member 'UDeathProcess_Player::BackDeathAnimations' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Player, AdditionalDeathStates) == 0x000268, "Member 'UDeathProcess_Player::AdditionalDeathStates' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Player, bUseTimeDilation) == 0x000278, "Member 'UDeathProcess_Player::bUseTimeDilation' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Player, TimeDilation) == 0x00027C, "Member 'UDeathProcess_Player::TimeDilation' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Player, DelayBeforeFadeOut) == 0x00028C, "Member 'UDeathProcess_Player::DelayBeforeFadeOut' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Player, FadeOutDescription) == 0x000290, "Member 'UDeathProcess_Player::FadeOutDescription' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Player, SystemMPC) == 0x0002B0, "Member 'UDeathProcess_Player::SystemMPC' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Player, LocationTargetBone) == 0x0002B8, "Member 'UDeathProcess_Player::LocationTargetBone' has a wrong offset!");

// Class Zion.CharacterZion
// 0x0330 (0x09A0 - 0x0670)
class ACharacterZion : public ACharacter
{
public:
	uint8                                         Pad_668[0x28];                                     // 0x0668(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AAbility* Ability, class AActor* Source, const struct FHitData& HitData)> OnGotAbilityAppliedDelegate; // 0x0690(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AAbility* Ability, class AActor* Source, const struct FHitData& HitData)> OnGotAbilityAppliedPostActivateDelegate; // 0x06A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AAbility* Ability, class AActor* Source)> OnGuardedDelegate; // 0x06B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AAbility* Ability, class AActor* Source)> OnParriedDelegate; // 0x06C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDodgeDelegate;                                   // 0x06D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E0[0xC0];                                     // 0x06E0(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEventStartedDelegate;                            // 0x07A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEventStoppedDelegate;                            // 0x07B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C0[0x18];                                     // 0x07C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoyoteTime;                                        // 0x07D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInstantKillOnSwim;                                // 0x07DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInstantKillOnGround;                              // 0x07DD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpineBone                                    TargetPivotBone;                                   // 0x07DE(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7DF[0x1];                                      // 0x07DF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             PostParriedStates;                                 // 0x07E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         PostParriedStatesDuration;                         // 0x07F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7F4[0x4];                                      // 0x07F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             PostEventStates;                                   // 0x07F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         PostEventStatesDuration;                           // 0x0808(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80C[0x4];                                      // 0x080C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTalkLocationData                      TalkLocationData;                                  // 0x0810(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UZionInputComponent*                    ZionInputComponent;                                // 0x0878(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputBufferComponent*                  InputBufferComponent;                              // 0x0880(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocomotionComponent*                   LocomotionComponent;                               // 0x0888(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandComponent*                      CommandComponent;                                  // 0x0890(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStateComponent*                        StateComponent;                                    // 0x0898(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityComponent*                      AbilityComponent;                                  // 0x08A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCollisionComponent*                    CollisionComponent;                                // 0x08A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFactionComponent*                      FactionComponent;                                  // 0x08B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatHPComponent*                       StatHPComponent;                                   // 0x08B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKnockbackComponent*                    KnockbackComponent;                                // 0x08C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitStopComponent*                      HitStopComponent;                                  // 0x08C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UShakeComponent*                        ShakeComponent;                                    // 0x08D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDeathComponent*                        DeathComponent;                                    // 0x08D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIComponent*                           UIComponent;                                       // 0x08E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URenderLayerComponent*                  RenderLayerComponent;                              // 0x08E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundComponent*                        SoundComponent;                                    // 0x08F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        VisualPivotSceneComponent;                         // 0x08F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVisualPivotModifierComponent*          VisualPivotModifierComponent;                      // 0x0900(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineSkeletonRendererComponent*        SpineRendererComponent;                            // 0x0908(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineMeshMaskComponent*                SpineMaskRendererComponent;                        // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineSkeletonAnimationExComponent*     SpineAnimationComponent;                           // 0x0918(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineAnimatorComponent*                SpineAnimatorComponent;                            // 0x0920(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineBoneComponent*                    SpineBoneComponent;                                // 0x0928(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineHighlightComponent*               SpineHighlightComponent;                           // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFXComponent*                           FXComponent;                                       // 0x0938(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineRootMotionComponent*              SpineRootMotionComponent;                          // 0x0940(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffectComponent*                 StatusEffectComponent;                             // 0x0948(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatBurnComponent*                     StatBurnComponent;                                 // 0x0950(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatFreezeComponent*                   StatFreezeComponent;                               // 0x0958(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatShockComponent*                    StatShockComponent;                                // 0x0960(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineColorComponent*                   SpineColorComponent;                               // 0x0968(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZionCharacterMovementComponent*        ZionCharacterMovement;                             // 0x0970(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebugDisplayComponent*                 DebugDisplayComponent;                             // 0x0978(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_980[0x8];                                      // 0x0980(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        TargetPivotComponent;                              // 0x0988(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_990[0x10];                                     // 0x0990(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGuarded(class AAbility* Ability, class AActor* Source);
	void OnParried(class AAbility* Ability, class AActor* Source);
	void OnReceivedDamage(class AActor* Source, int32 Value);
	void ResetJumpCount();

	class UCollisionComponent* GetCollisionComponent() const;
	class UZionCharacterMovementComponent* GetZionCharacterMovement() const;
	bool IsInEvent() const;
	bool ShouldConsiderJumpAsAirborne() const;
	bool ShouldConsiderJumpAsGrounded() const;
	bool ShouldConsiderJumpAsHookAttach() const;
	bool ShouldConsiderJumpAsWallGrab() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterZion">();
	}
	static class ACharacterZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterZion>();
	}
};
static_assert(alignof(ACharacterZion) == 0x000010, "Wrong alignment on ACharacterZion");
static_assert(sizeof(ACharacterZion) == 0x0009A0, "Wrong size on ACharacterZion");
static_assert(offsetof(ACharacterZion, OnGotAbilityAppliedDelegate) == 0x000690, "Member 'ACharacterZion::OnGotAbilityAppliedDelegate' has a wrong offset!");
static_assert(offsetof(ACharacterZion, OnGotAbilityAppliedPostActivateDelegate) == 0x0006A0, "Member 'ACharacterZion::OnGotAbilityAppliedPostActivateDelegate' has a wrong offset!");
static_assert(offsetof(ACharacterZion, OnGuardedDelegate) == 0x0006B0, "Member 'ACharacterZion::OnGuardedDelegate' has a wrong offset!");
static_assert(offsetof(ACharacterZion, OnParriedDelegate) == 0x0006C0, "Member 'ACharacterZion::OnParriedDelegate' has a wrong offset!");
static_assert(offsetof(ACharacterZion, OnDodgeDelegate) == 0x0006D0, "Member 'ACharacterZion::OnDodgeDelegate' has a wrong offset!");
static_assert(offsetof(ACharacterZion, OnEventStartedDelegate) == 0x0007A0, "Member 'ACharacterZion::OnEventStartedDelegate' has a wrong offset!");
static_assert(offsetof(ACharacterZion, OnEventStoppedDelegate) == 0x0007B0, "Member 'ACharacterZion::OnEventStoppedDelegate' has a wrong offset!");
static_assert(offsetof(ACharacterZion, CoyoteTime) == 0x0007D8, "Member 'ACharacterZion::CoyoteTime' has a wrong offset!");
static_assert(offsetof(ACharacterZion, bInstantKillOnSwim) == 0x0007DC, "Member 'ACharacterZion::bInstantKillOnSwim' has a wrong offset!");
static_assert(offsetof(ACharacterZion, bInstantKillOnGround) == 0x0007DD, "Member 'ACharacterZion::bInstantKillOnGround' has a wrong offset!");
static_assert(offsetof(ACharacterZion, TargetPivotBone) == 0x0007DE, "Member 'ACharacterZion::TargetPivotBone' has a wrong offset!");
static_assert(offsetof(ACharacterZion, PostParriedStates) == 0x0007E0, "Member 'ACharacterZion::PostParriedStates' has a wrong offset!");
static_assert(offsetof(ACharacterZion, PostParriedStatesDuration) == 0x0007F0, "Member 'ACharacterZion::PostParriedStatesDuration' has a wrong offset!");
static_assert(offsetof(ACharacterZion, PostEventStates) == 0x0007F8, "Member 'ACharacterZion::PostEventStates' has a wrong offset!");
static_assert(offsetof(ACharacterZion, PostEventStatesDuration) == 0x000808, "Member 'ACharacterZion::PostEventStatesDuration' has a wrong offset!");
static_assert(offsetof(ACharacterZion, TalkLocationData) == 0x000810, "Member 'ACharacterZion::TalkLocationData' has a wrong offset!");
static_assert(offsetof(ACharacterZion, ZionInputComponent) == 0x000878, "Member 'ACharacterZion::ZionInputComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, InputBufferComponent) == 0x000880, "Member 'ACharacterZion::InputBufferComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, LocomotionComponent) == 0x000888, "Member 'ACharacterZion::LocomotionComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, CommandComponent) == 0x000890, "Member 'ACharacterZion::CommandComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, StateComponent) == 0x000898, "Member 'ACharacterZion::StateComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, AbilityComponent) == 0x0008A0, "Member 'ACharacterZion::AbilityComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, CollisionComponent) == 0x0008A8, "Member 'ACharacterZion::CollisionComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, FactionComponent) == 0x0008B0, "Member 'ACharacterZion::FactionComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, StatHPComponent) == 0x0008B8, "Member 'ACharacterZion::StatHPComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, KnockbackComponent) == 0x0008C0, "Member 'ACharacterZion::KnockbackComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, HitStopComponent) == 0x0008C8, "Member 'ACharacterZion::HitStopComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, ShakeComponent) == 0x0008D0, "Member 'ACharacterZion::ShakeComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, DeathComponent) == 0x0008D8, "Member 'ACharacterZion::DeathComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, UIComponent) == 0x0008E0, "Member 'ACharacterZion::UIComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, RenderLayerComponent) == 0x0008E8, "Member 'ACharacterZion::RenderLayerComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, SoundComponent) == 0x0008F0, "Member 'ACharacterZion::SoundComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, VisualPivotSceneComponent) == 0x0008F8, "Member 'ACharacterZion::VisualPivotSceneComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, VisualPivotModifierComponent) == 0x000900, "Member 'ACharacterZion::VisualPivotModifierComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, SpineRendererComponent) == 0x000908, "Member 'ACharacterZion::SpineRendererComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, SpineMaskRendererComponent) == 0x000910, "Member 'ACharacterZion::SpineMaskRendererComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, SpineAnimationComponent) == 0x000918, "Member 'ACharacterZion::SpineAnimationComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, SpineAnimatorComponent) == 0x000920, "Member 'ACharacterZion::SpineAnimatorComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, SpineBoneComponent) == 0x000928, "Member 'ACharacterZion::SpineBoneComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, SpineHighlightComponent) == 0x000930, "Member 'ACharacterZion::SpineHighlightComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, FXComponent) == 0x000938, "Member 'ACharacterZion::FXComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, SpineRootMotionComponent) == 0x000940, "Member 'ACharacterZion::SpineRootMotionComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, StatusEffectComponent) == 0x000948, "Member 'ACharacterZion::StatusEffectComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, StatBurnComponent) == 0x000950, "Member 'ACharacterZion::StatBurnComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, StatFreezeComponent) == 0x000958, "Member 'ACharacterZion::StatFreezeComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, StatShockComponent) == 0x000960, "Member 'ACharacterZion::StatShockComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, SpineColorComponent) == 0x000968, "Member 'ACharacterZion::SpineColorComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, ZionCharacterMovement) == 0x000970, "Member 'ACharacterZion::ZionCharacterMovement' has a wrong offset!");
static_assert(offsetof(ACharacterZion, DebugDisplayComponent) == 0x000978, "Member 'ACharacterZion::DebugDisplayComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZion, TargetPivotComponent) == 0x000988, "Member 'ACharacterZion::TargetPivotComponent' has a wrong offset!");

// Class Zion.CharacterZionNPC
// 0x0110 (0x0780 - 0x0670)
class ACharacterZionNPC : public ACharacter
{
public:
	uint8                                         Pad_668[0x18];                                     // 0x0668(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocomotionComponent*                   LocomotionComponent;                               // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCollisionComponent*                    CollisionComponent;                                // 0x0688(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFactionComponent*                      FactionComponent;                                  // 0x0690(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URenderLayerComponent*                  RenderLayerComponent;                              // 0x0698(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        VisualPivotSceneComponent;                         // 0x06A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVisualPivotModifierComponent*          VisualPivotModifierComponent;                      // 0x06A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineSkeletonRendererComponent*        SpineRendererComponent;                            // 0x06B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineMeshMaskComponent*                SpineMaskRendererComponent;                        // 0x06B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineSkeletonAnimationExComponent*     SpineAnimationComponent;                           // 0x06C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineAnimatorComponent*                SpineAnimatorComponent;                            // 0x06C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineBoneComponent*                    SpineBoneComponent;                                // 0x06D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineFXComponent*                      SpineFXComponent;                                  // 0x06D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineRootMotionComponent*              SpineRootMotionComponent;                          // 0x06E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineHighlightComponent*               SpineHighlightComponent;                           // 0x06E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZionCharacterMovementComponent*        ZionCharacterMovement;                             // 0x06F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebugDisplayComponent*                 DebugDisplayComponent;                             // 0x06F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      IdleOverrideAnimations;                            // 0x0700(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FTalkLocationData                      TalkLocationData;                                  // 0x0710(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_778[0x8];                                      // 0x0778(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIdleOverrideAnimations(const TArray<struct FSpineAnimationDefinition>& NewIdleOverrideAnimations);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterZionNPC">();
	}
	static class ACharacterZionNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterZionNPC>();
	}
};
static_assert(alignof(ACharacterZionNPC) == 0x000010, "Wrong alignment on ACharacterZionNPC");
static_assert(sizeof(ACharacterZionNPC) == 0x000780, "Wrong size on ACharacterZionNPC");
static_assert(offsetof(ACharacterZionNPC, LocomotionComponent) == 0x000680, "Member 'ACharacterZionNPC::LocomotionComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, CollisionComponent) == 0x000688, "Member 'ACharacterZionNPC::CollisionComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, FactionComponent) == 0x000690, "Member 'ACharacterZionNPC::FactionComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, RenderLayerComponent) == 0x000698, "Member 'ACharacterZionNPC::RenderLayerComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, VisualPivotSceneComponent) == 0x0006A0, "Member 'ACharacterZionNPC::VisualPivotSceneComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, VisualPivotModifierComponent) == 0x0006A8, "Member 'ACharacterZionNPC::VisualPivotModifierComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, SpineRendererComponent) == 0x0006B0, "Member 'ACharacterZionNPC::SpineRendererComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, SpineMaskRendererComponent) == 0x0006B8, "Member 'ACharacterZionNPC::SpineMaskRendererComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, SpineAnimationComponent) == 0x0006C0, "Member 'ACharacterZionNPC::SpineAnimationComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, SpineAnimatorComponent) == 0x0006C8, "Member 'ACharacterZionNPC::SpineAnimatorComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, SpineBoneComponent) == 0x0006D0, "Member 'ACharacterZionNPC::SpineBoneComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, SpineFXComponent) == 0x0006D8, "Member 'ACharacterZionNPC::SpineFXComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, SpineRootMotionComponent) == 0x0006E0, "Member 'ACharacterZionNPC::SpineRootMotionComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, SpineHighlightComponent) == 0x0006E8, "Member 'ACharacterZionNPC::SpineHighlightComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, ZionCharacterMovement) == 0x0006F0, "Member 'ACharacterZionNPC::ZionCharacterMovement' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, DebugDisplayComponent) == 0x0006F8, "Member 'ACharacterZionNPC::DebugDisplayComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, IdleOverrideAnimations) == 0x000700, "Member 'ACharacterZionNPC::IdleOverrideAnimations' has a wrong offset!");
static_assert(offsetof(ACharacterZionNPC, TalkLocationData) == 0x000710, "Member 'ACharacterZionNPC::TalkLocationData' has a wrong offset!");

// Class Zion.CharacterZionSpirit
// 0x05A0 (0x0C10 - 0x0670)
class ACharacterZionSpirit : public ACharacter
{
public:
	uint8                                         Pad_668[0x70];                                     // 0x0668(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     FadeInCurve;                                       // 0x06D8(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     FadeInFilterCurve;                                 // 0x0760(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     FadeOutCurve;                                      // 0x07E8(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSpineFXData                           FadeInFXData;                                      // 0x0870(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSpineFXData                           FadeOutFXData;                                     // 0x0970(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bInjectSummonerMovementMode;                       // 0x0A70(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A71[0x7];                                      // 0x0A71(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             DismissStates;                                     // 0x0A78(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSubclassOf<class ASpiritCooldown>            SpiritCooldownClass;                               // 0x0A88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZionInputComponent*                    ZionInputComponent;                                // 0x0A90(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputBufferComponent*                  InputBufferComponent;                              // 0x0A98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocomotionComponent*                   LocomotionComponent;                               // 0x0AA0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandComponent*                      CommandComponent;                                  // 0x0AA8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStateComponent*                        StateComponent;                                    // 0x0AB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityComponent*                      AbilityComponent;                                  // 0x0AB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCollisionComponent*                    CollisionComponent;                                // 0x0AC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFactionComponent*                      FactionComponent;                                  // 0x0AC8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitStopComponent*                      HitStopComponent;                                  // 0x0AD0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URenderLayerComponent*                  RenderLayerComponent;                              // 0x0AD8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        VisualPivotSceneComponent;                         // 0x0AE0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVisualPivotModifierComponent*          VisualPivotModifierComponent;                      // 0x0AE8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineSkeletonRendererComponent*        SpineRendererComponent;                            // 0x0AF0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineMeshMaskComponent*                SpineMaskRendererComponent;                        // 0x0AF8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineSkeletonAnimationExComponent*     SpineAnimationComponent;                           // 0x0B00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineAnimatorComponent*                SpineAnimatorComponent;                            // 0x0B08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineBoneComponent*                    SpineBoneComponent;                                // 0x0B10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineFXComponent*                      SpineFXComponent;                                  // 0x0B18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineRootMotionComponent*              SpineRootMotionComponent;                          // 0x0B20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineHighlightComponent*               SpineHighlightComponent;                           // 0x0B28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpiritStatsSnapshotComponent*          SpiritStatsSnapshot;                               // 0x0B30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZionCharacterMovementComponent*        ZionCharacterMovement;                             // 0x0B38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFallThroughComponent*                  FallThroughComponent;                              // 0x0B40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebugDisplayComponent*                 DebugDisplayComponent;                             // 0x0B48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B50[0xA0];                                     // 0x0B50(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           InvokedByInputAction;                              // 0x0BF0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandSet*                            InvokedByCommandSet;                               // 0x0BF8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAIControllerZion*                      AIController;                                      // 0x0C00(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C08[0x8];                                      // 0x0C08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelayedDismiss(float Delay);
	void Dismiss(bool bInstant);
	void OnActivate();
	void OnDeactivate();
	void OnDismiss();
	void OnLocationBlendEnd(const struct FVector& StartLocation, const struct FVector& EndLocation);
	void OnLocationBlendStart(const struct FVector& StartLocation, const struct FVector& EndLocation);
	void OnPreSummon();
	void OnSummon();
	void OnTeleport(const struct FVector& From, const struct FVector& To);
	void SetActive(bool bNewActive);

	class AActor* GetSummoner() const;
	bool IsActive() const;
	bool IsSummoned() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterZionSpirit">();
	}
	static class ACharacterZionSpirit* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterZionSpirit>();
	}
};
static_assert(alignof(ACharacterZionSpirit) == 0x000010, "Wrong alignment on ACharacterZionSpirit");
static_assert(sizeof(ACharacterZionSpirit) == 0x000C10, "Wrong size on ACharacterZionSpirit");
static_assert(offsetof(ACharacterZionSpirit, FadeInCurve) == 0x0006D8, "Member 'ACharacterZionSpirit::FadeInCurve' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, FadeInFilterCurve) == 0x000760, "Member 'ACharacterZionSpirit::FadeInFilterCurve' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, FadeOutCurve) == 0x0007E8, "Member 'ACharacterZionSpirit::FadeOutCurve' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, FadeInFXData) == 0x000870, "Member 'ACharacterZionSpirit::FadeInFXData' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, FadeOutFXData) == 0x000970, "Member 'ACharacterZionSpirit::FadeOutFXData' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, bInjectSummonerMovementMode) == 0x000A70, "Member 'ACharacterZionSpirit::bInjectSummonerMovementMode' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, DismissStates) == 0x000A78, "Member 'ACharacterZionSpirit::DismissStates' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, SpiritCooldownClass) == 0x000A88, "Member 'ACharacterZionSpirit::SpiritCooldownClass' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, ZionInputComponent) == 0x000A90, "Member 'ACharacterZionSpirit::ZionInputComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, InputBufferComponent) == 0x000A98, "Member 'ACharacterZionSpirit::InputBufferComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, LocomotionComponent) == 0x000AA0, "Member 'ACharacterZionSpirit::LocomotionComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, CommandComponent) == 0x000AA8, "Member 'ACharacterZionSpirit::CommandComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, StateComponent) == 0x000AB0, "Member 'ACharacterZionSpirit::StateComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, AbilityComponent) == 0x000AB8, "Member 'ACharacterZionSpirit::AbilityComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, CollisionComponent) == 0x000AC0, "Member 'ACharacterZionSpirit::CollisionComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, FactionComponent) == 0x000AC8, "Member 'ACharacterZionSpirit::FactionComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, HitStopComponent) == 0x000AD0, "Member 'ACharacterZionSpirit::HitStopComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, RenderLayerComponent) == 0x000AD8, "Member 'ACharacterZionSpirit::RenderLayerComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, VisualPivotSceneComponent) == 0x000AE0, "Member 'ACharacterZionSpirit::VisualPivotSceneComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, VisualPivotModifierComponent) == 0x000AE8, "Member 'ACharacterZionSpirit::VisualPivotModifierComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, SpineRendererComponent) == 0x000AF0, "Member 'ACharacterZionSpirit::SpineRendererComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, SpineMaskRendererComponent) == 0x000AF8, "Member 'ACharacterZionSpirit::SpineMaskRendererComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, SpineAnimationComponent) == 0x000B00, "Member 'ACharacterZionSpirit::SpineAnimationComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, SpineAnimatorComponent) == 0x000B08, "Member 'ACharacterZionSpirit::SpineAnimatorComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, SpineBoneComponent) == 0x000B10, "Member 'ACharacterZionSpirit::SpineBoneComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, SpineFXComponent) == 0x000B18, "Member 'ACharacterZionSpirit::SpineFXComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, SpineRootMotionComponent) == 0x000B20, "Member 'ACharacterZionSpirit::SpineRootMotionComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, SpineHighlightComponent) == 0x000B28, "Member 'ACharacterZionSpirit::SpineHighlightComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, SpiritStatsSnapshot) == 0x000B30, "Member 'ACharacterZionSpirit::SpiritStatsSnapshot' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, ZionCharacterMovement) == 0x000B38, "Member 'ACharacterZionSpirit::ZionCharacterMovement' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, FallThroughComponent) == 0x000B40, "Member 'ACharacterZionSpirit::FallThroughComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, DebugDisplayComponent) == 0x000B48, "Member 'ACharacterZionSpirit::DebugDisplayComponent' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, InvokedByInputAction) == 0x000BF0, "Member 'ACharacterZionSpirit::InvokedByInputAction' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, InvokedByCommandSet) == 0x000BF8, "Member 'ACharacterZionSpirit::InvokedByCommandSet' has a wrong offset!");
static_assert(offsetof(ACharacterZionSpirit, AIController) == 0x000C00, "Member 'ACharacterZionSpirit::AIController' has a wrong offset!");

// Class Zion.StatsComponent
// 0x0710 (0x07B0 - 0x00A0)
class UStatsComponent : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatsLevelData                        DefaultStatsLevelData;                             // 0x00B0(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         DefaultElementalFactor;                            // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FreezeCriticalFactor;                              // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EAttackElement, float>                   ElementalFactors;                                  // 0x00F8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x668];                                    // 0x0148(0x0668)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetAttack() const;
	int32 GetDamageCutPercentage(EAttackType Type) const;
	int32 GetDefense() const;
	int32 GetStaminaCutPercentage(EAttackType Type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatsComponent">();
	}
	static class UStatsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatsComponent>();
	}
};
static_assert(alignof(UStatsComponent) == 0x000008, "Wrong alignment on UStatsComponent");
static_assert(sizeof(UStatsComponent) == 0x0007B0, "Wrong size on UStatsComponent");
static_assert(offsetof(UStatsComponent, DefaultStatsLevelData) == 0x0000B0, "Member 'UStatsComponent::DefaultStatsLevelData' has a wrong offset!");
static_assert(offsetof(UStatsComponent, DefaultElementalFactor) == 0x0000F0, "Member 'UStatsComponent::DefaultElementalFactor' has a wrong offset!");
static_assert(offsetof(UStatsComponent, FreezeCriticalFactor) == 0x0000F4, "Member 'UStatsComponent::FreezeCriticalFactor' has a wrong offset!");
static_assert(offsetof(UStatsComponent, ElementalFactors) == 0x0000F8, "Member 'UStatsComponent::ElementalFactors' has a wrong offset!");

// Class Zion.ClearComponent
// 0x0058 (0x00F8 - 0x00A0)
class UClearComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(EClearStatus ClearStatus)> OnClearedStatusChecked;                 // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x2];                                       // 0x00B0(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnabled;                                          // 0x00B2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSaveClearStatus;                                  // 0x00B3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckPreviousRuns;                                // 0x00B4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCountForZoneCompletion;                           // 0x00B5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCountForZoneReveal;                               // 0x00B6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDestroyActorOnClear;                              // 0x00B7(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideClearWorld;                               // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UWorld>                  OverrideClearWorld;                                // 0x00C0(0x0028)(Edit, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FClearActorData                        ClearActorData;                                    // 0x00E8(0x0010)(Edit, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void MarkAsCleared();

	EClearStatus GetClearStatus() const;
	EClearStatus GetPreviousRunsClearStatus() const;
	bool IsCleared() const;
	bool WasClearedOnPreviousRuns() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClearComponent">();
	}
	static class UClearComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClearComponent>();
	}
};
static_assert(alignof(UClearComponent) == 0x000008, "Wrong alignment on UClearComponent");
static_assert(sizeof(UClearComponent) == 0x0000F8, "Wrong size on UClearComponent");
static_assert(offsetof(UClearComponent, OnClearedStatusChecked) == 0x0000A0, "Member 'UClearComponent::OnClearedStatusChecked' has a wrong offset!");
static_assert(offsetof(UClearComponent, bEnabled) == 0x0000B2, "Member 'UClearComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UClearComponent, bSaveClearStatus) == 0x0000B3, "Member 'UClearComponent::bSaveClearStatus' has a wrong offset!");
static_assert(offsetof(UClearComponent, bCheckPreviousRuns) == 0x0000B4, "Member 'UClearComponent::bCheckPreviousRuns' has a wrong offset!");
static_assert(offsetof(UClearComponent, bCountForZoneCompletion) == 0x0000B5, "Member 'UClearComponent::bCountForZoneCompletion' has a wrong offset!");
static_assert(offsetof(UClearComponent, bCountForZoneReveal) == 0x0000B6, "Member 'UClearComponent::bCountForZoneReveal' has a wrong offset!");
static_assert(offsetof(UClearComponent, bDestroyActorOnClear) == 0x0000B7, "Member 'UClearComponent::bDestroyActorOnClear' has a wrong offset!");
static_assert(offsetof(UClearComponent, bOverrideClearWorld) == 0x0000B8, "Member 'UClearComponent::bOverrideClearWorld' has a wrong offset!");
static_assert(offsetof(UClearComponent, OverrideClearWorld) == 0x0000C0, "Member 'UClearComponent::OverrideClearWorld' has a wrong offset!");
static_assert(offsetof(UClearComponent, ClearActorData) == 0x0000E8, "Member 'UClearComponent::ClearActorData' has a wrong offset!");

// Class Zion.Passive_RunFaster
// 0x0008 (0x0038 - 0x0030)
class UPassive_RunFaster final : public UPassive
{
public:
	float                                         FactorBonus;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_RunFaster">();
	}
	static class UPassive_RunFaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_RunFaster>();
	}
};
static_assert(alignof(UPassive_RunFaster) == 0x000008, "Wrong alignment on UPassive_RunFaster");
static_assert(sizeof(UPassive_RunFaster) == 0x000038, "Wrong size on UPassive_RunFaster");
static_assert(offsetof(UPassive_RunFaster, FactorBonus) == 0x000030, "Member 'UPassive_RunFaster::FactorBonus' has a wrong offset!");

// Class Zion.ClearManagerComponent
// 0x0250 (0x02F0 - 0x00A0)
class UClearManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x30];                                      // 0x00A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FNameSet>            ClearedActors;                                     // 0x00D0(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FNameSet>            ClearedSavedActors;                                // 0x0120(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FNameSet>            PreviousRunsClearedSavedActors;                    // 0x0170(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x10];                                     // 0x01C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClearComponent*>                DeferredMarkAsClears;                              // 0x01D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E0[0x110];                                    // 0x01E0(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClearManagerComponent* Get(const class UObject* WorldContextObject);

	void ResetClearedObjects();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClearManagerComponent">();
	}
	static class UClearManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClearManagerComponent>();
	}
};
static_assert(alignof(UClearManagerComponent) == 0x000008, "Wrong alignment on UClearManagerComponent");
static_assert(sizeof(UClearManagerComponent) == 0x0002F0, "Wrong size on UClearManagerComponent");
static_assert(offsetof(UClearManagerComponent, ClearedActors) == 0x0000D0, "Member 'UClearManagerComponent::ClearedActors' has a wrong offset!");
static_assert(offsetof(UClearManagerComponent, ClearedSavedActors) == 0x000120, "Member 'UClearManagerComponent::ClearedSavedActors' has a wrong offset!");
static_assert(offsetof(UClearManagerComponent, PreviousRunsClearedSavedActors) == 0x000170, "Member 'UClearManagerComponent::PreviousRunsClearedSavedActors' has a wrong offset!");
static_assert(offsetof(UClearManagerComponent, DeferredMarkAsClears) == 0x0001D0, "Member 'UClearManagerComponent::DeferredMarkAsClears' has a wrong offset!");

// Class Zion.Collectable_Drop
// 0x01F8 (0x04F8 - 0x0300)
class ACollectable_Drop final : public ACollectable
{
public:
	uint8                                         Pad_300[0x1F8];                                    // 0x0300(0x01F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Collectable_Drop">();
	}
	static class ACollectable_Drop* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectable_Drop>();
	}
};
static_assert(alignof(ACollectable_Drop) == 0x000008, "Wrong alignment on ACollectable_Drop");
static_assert(sizeof(ACollectable_Drop) == 0x0004F8, "Wrong size on ACollectable_Drop");

// Class Zion.EventAction_Fade
// 0x0030 (0x0080 - 0x0050)
class UEventAction_Fade final : public UEventAction
{
public:
	EFadeType                                     FadeType;                                          // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFadeDescriptionData                   FadeDescription;                                   // 0x0058(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	EFadeLayer                                    FadeLayer;                                         // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadeCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_Fade">();
	}
	static class UEventAction_Fade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_Fade>();
	}
};
static_assert(alignof(UEventAction_Fade) == 0x000008, "Wrong alignment on UEventAction_Fade");
static_assert(sizeof(UEventAction_Fade) == 0x000080, "Wrong size on UEventAction_Fade");
static_assert(offsetof(UEventAction_Fade, FadeType) == 0x000050, "Member 'UEventAction_Fade::FadeType' has a wrong offset!");
static_assert(offsetof(UEventAction_Fade, FadeDescription) == 0x000058, "Member 'UEventAction_Fade::FadeDescription' has a wrong offset!");
static_assert(offsetof(UEventAction_Fade, FadeLayer) == 0x000078, "Member 'UEventAction_Fade::FadeLayer' has a wrong offset!");

// Class Zion.UserWidgetRestPointList
// 0x0078 (0x04D8 - 0x0460)
class UUserWidgetRestPointList : public UUserWidgetZion
{
public:
	TMulticastInlineDelegate<void(class UUserWidgetMapIcon_RestPoint* RestPointIcon)> OnRestPointEntryFocused; // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FMapRestPointData& RestPointData)> OnRestPointEntryPressed; // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UVerticalBox*                           RestPointListHolder;                               // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   RestPointListMapAreaSoftClass;                     // 0x0488(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUserWidgetRestPointListMapArea*> RestPointListMapAreas;                            // 0x04B0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRestPointListData>             RestPointListData;                                 // 0x04C0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UUserWidgetMapIcon_RestPoint* ChangeMapArea(int32 IndexOffset);
	void Close(bool bInstant);
	class UUserWidgetMapIcon_RestPoint* FindNearestRestPointIcon(const struct FVector2D& CurrentMapPosition, int32* OutMapAreaIndex);
	void GoToMapAreaFromIndex(int32 MapAreaIndex, class UUserWidgetMapIcon_RestPoint* NearestRestPointIcon);
	void GoToNextMapArea();
	void GoToPreviousMapArea();
	void InstantiateRestPointList(const TArray<struct FRestPointListData>& ListData);
	void OnClosed(bool bInstant);
	void OnOpened(bool bInstant);
	void Open(const struct FVector2D& CurrentMapPosition, bool bInstant);
	void RestPointEntryFocused(int32 MapAreaIndex, class UUserWidgetMapIcon_RestPoint* RestPointIcon);
	void RestPointEntryPressed(const struct FMapRestPointData& RestPointData);
	int32 SetCurrentMapAreaIndex(int32 NewMapAreaIndex);

	bool CanBeOpened() const;
	bool CanChangeMapArea() const;
	int32 GetIndexFromMapAreaName(const class FName& MapAreaName) const;
	int32 GetNewMapAreaIndex(int32 IndexOffset) const;
	bool IsOpened() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetRestPointList">();
	}
	static class UUserWidgetRestPointList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetRestPointList>();
	}
};
static_assert(alignof(UUserWidgetRestPointList) == 0x000008, "Wrong alignment on UUserWidgetRestPointList");
static_assert(sizeof(UUserWidgetRestPointList) == 0x0004D8, "Wrong size on UUserWidgetRestPointList");
static_assert(offsetof(UUserWidgetRestPointList, OnRestPointEntryFocused) == 0x000460, "Member 'UUserWidgetRestPointList::OnRestPointEntryFocused' has a wrong offset!");
static_assert(offsetof(UUserWidgetRestPointList, OnRestPointEntryPressed) == 0x000470, "Member 'UUserWidgetRestPointList::OnRestPointEntryPressed' has a wrong offset!");
static_assert(offsetof(UUserWidgetRestPointList, RestPointListHolder) == 0x000480, "Member 'UUserWidgetRestPointList::RestPointListHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetRestPointList, RestPointListMapAreaSoftClass) == 0x000488, "Member 'UUserWidgetRestPointList::RestPointListMapAreaSoftClass' has a wrong offset!");
static_assert(offsetof(UUserWidgetRestPointList, RestPointListMapAreas) == 0x0004B0, "Member 'UUserWidgetRestPointList::RestPointListMapAreas' has a wrong offset!");
static_assert(offsetof(UUserWidgetRestPointList, RestPointListData) == 0x0004C0, "Member 'UUserWidgetRestPointList::RestPointListData' has a wrong offset!");

// Class Zion.Collectable_Experience
// 0x0008 (0x0308 - 0x0300)
class ACollectable_Experience : public ACollectable
{
public:
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Collectable_Experience">();
	}
	static class ACollectable_Experience* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectable_Experience>();
	}
};
static_assert(alignof(ACollectable_Experience) == 0x000008, "Wrong alignment on ACollectable_Experience");
static_assert(sizeof(ACollectable_Experience) == 0x000308, "Wrong size on ACollectable_Experience");

// Class Zion.UserWidgetMapTransition
// 0x0020 (0x0480 - 0x0460)
class UUserWidgetMapTransition : public UUserWidgetZion
{
public:
	struct FDataTableRowHandle                    MapTransitionHandle;                               // 0x0460(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bShowStartPoint;                                   // 0x0470(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowEndPoint;                                     // 0x0471(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_472[0x2];                                      // 0x0472(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinkSize;                                          // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Angle;                                             // 0x0478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideMapTransition();
	void OnSetIconsVisibility(bool bVisible);
	void OnSetScale(float NewScale);
	void SetIconsVisibility(bool bVisible);
	void SetScale(float NewScale);
	void ShowMapTransition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapTransition">();
	}
	static class UUserWidgetMapTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapTransition>();
	}
};
static_assert(alignof(UUserWidgetMapTransition) == 0x000008, "Wrong alignment on UUserWidgetMapTransition");
static_assert(sizeof(UUserWidgetMapTransition) == 0x000480, "Wrong size on UUserWidgetMapTransition");
static_assert(offsetof(UUserWidgetMapTransition, MapTransitionHandle) == 0x000460, "Member 'UUserWidgetMapTransition::MapTransitionHandle' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapTransition, bShowStartPoint) == 0x000470, "Member 'UUserWidgetMapTransition::bShowStartPoint' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapTransition, bShowEndPoint) == 0x000471, "Member 'UUserWidgetMapTransition::bShowEndPoint' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapTransition, LinkSize) == 0x000474, "Member 'UUserWidgetMapTransition::LinkSize' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapTransition, Angle) == 0x000478, "Member 'UUserWidgetMapTransition::Angle' has a wrong offset!");

// Class Zion.CollisionComponent
// 0x01A0 (0x0240 - 0x00A0)
class UCollisionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideResponses;                                // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCollisionResponseContainer            ResponseOverrides;                                 // 0x00B9(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECollisionChannel, ECollisionResponse>   SpecificResponseOverrides;                         // 0x00E0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FComponentReference>            HurtboxReferences;                                 // 0x0130(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FComponentReference> CustomHurtboxReferences;                           // 0x0140(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class FName>                           CustomParryHurtboxes;                              // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FComponentReference>            HitboxReferences;                                  // 0x01A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bOverrideCollisionResponseToPlayer;                // 0x01B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionResponse                            OverrideCollisionResponseToPlayer;                 // 0x01B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionProfile                             CollisionProfile;                                  // 0x01B2(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B3[0x8D];                                     // 0x01B3(0x008D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RefreshHitboxVisuals();
	void RefreshHurtboxVisuals();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollisionComponent">();
	}
	static class UCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollisionComponent>();
	}
};
static_assert(alignof(UCollisionComponent) == 0x000008, "Wrong alignment on UCollisionComponent");
static_assert(sizeof(UCollisionComponent) == 0x000240, "Wrong size on UCollisionComponent");
static_assert(offsetof(UCollisionComponent, bOverrideResponses) == 0x0000B8, "Member 'UCollisionComponent::bOverrideResponses' has a wrong offset!");
static_assert(offsetof(UCollisionComponent, ResponseOverrides) == 0x0000B9, "Member 'UCollisionComponent::ResponseOverrides' has a wrong offset!");
static_assert(offsetof(UCollisionComponent, SpecificResponseOverrides) == 0x0000E0, "Member 'UCollisionComponent::SpecificResponseOverrides' has a wrong offset!");
static_assert(offsetof(UCollisionComponent, HurtboxReferences) == 0x000130, "Member 'UCollisionComponent::HurtboxReferences' has a wrong offset!");
static_assert(offsetof(UCollisionComponent, CustomHurtboxReferences) == 0x000140, "Member 'UCollisionComponent::CustomHurtboxReferences' has a wrong offset!");
static_assert(offsetof(UCollisionComponent, CustomParryHurtboxes) == 0x000190, "Member 'UCollisionComponent::CustomParryHurtboxes' has a wrong offset!");
static_assert(offsetof(UCollisionComponent, HitboxReferences) == 0x0001A0, "Member 'UCollisionComponent::HitboxReferences' has a wrong offset!");
static_assert(offsetof(UCollisionComponent, bOverrideCollisionResponseToPlayer) == 0x0001B0, "Member 'UCollisionComponent::bOverrideCollisionResponseToPlayer' has a wrong offset!");
static_assert(offsetof(UCollisionComponent, OverrideCollisionResponseToPlayer) == 0x0001B1, "Member 'UCollisionComponent::OverrideCollisionResponseToPlayer' has a wrong offset!");
static_assert(offsetof(UCollisionComponent, CollisionProfile) == 0x0001B2, "Member 'UCollisionComponent::CollisionProfile' has a wrong offset!");

// Class Zion.ComboBoxStringZion
// 0x0000 (0x1DE0 - 0x1DE0)
class UComboBoxStringZion final : public UComboBoxString
{
public:
	void AddOptions(const TArray<class FString>& OptionsToAdd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboBoxStringZion">();
	}
	static class UComboBoxStringZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboBoxStringZion>();
	}
};
static_assert(alignof(UComboBoxStringZion) == 0x000010, "Wrong alignment on UComboBoxStringZion");
static_assert(sizeof(UComboBoxStringZion) == 0x001DE0, "Wrong size on UComboBoxStringZion");

// Class Zion.CommandModule_Dummy
// 0x0000 (0x0038 - 0x0038)
class UCommandModule_Dummy final : public UCommandModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_Dummy">();
	}
	static class UCommandModule_Dummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_Dummy>();
	}
};
static_assert(alignof(UCommandModule_Dummy) == 0x000008, "Wrong alignment on UCommandModule_Dummy");
static_assert(sizeof(UCommandModule_Dummy) == 0x000038, "Wrong size on UCommandModule_Dummy");

// Class Zion.CommandChargeReleaseInput
// 0x0010 (0x00E0 - 0x00D0)
class UCommandChargeReleaseInput : public UCommandCharge
{
public:
	class UInputAction*                           ReleaseInputAction;                                // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandChargeReleaseInput">();
	}
	static class UCommandChargeReleaseInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandChargeReleaseInput>();
	}
};
static_assert(alignof(UCommandChargeReleaseInput) == 0x000008, "Wrong alignment on UCommandChargeReleaseInput");
static_assert(sizeof(UCommandChargeReleaseInput) == 0x0000E0, "Wrong size on UCommandChargeReleaseInput");
static_assert(offsetof(UCommandChargeReleaseInput, ReleaseInputAction) == 0x0000D0, "Member 'UCommandChargeReleaseInput::ReleaseInputAction' has a wrong offset!");

// Class Zion.CommandComponent
// 0x02B8 (0x0358 - 0x00A0)
class UCommandComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnCommandQueueCleared;                             // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UCommand* Command)> OnPreStartCommand;                 // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UCommand* Command)> OnPostStartCommand;                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UCommand* Command, ECommandFinishType FinishType)> OnFinishCommand; // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UCommandSet* CommandSet, bool bReset)> OnCommandFinishCooldown; // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommandSet*                            DefaultCommandSet;                                 // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FCommandSettingsContainer>      CommandSettingsContainers;                         // 0x0108(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x18];                                     // 0x0118(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class UCommand>, struct FCachedCommands> CommandsForClasses;                    // 0x0130(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<ECommandLayerType, struct FCommandLayer> CommandLayers;                                     // 0x0180(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D0[0x118];                                    // 0x01D0(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           FallbackInputAction;                               // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x68];                                     // 0x02F0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddCommands(const TArray<struct FCommandSettings>& CommandSettingsArray, const class UCommandSet* OverrideCommandSet);
	void AddCommandsFromClasses(const TArray<TSubclassOf<class UCommand>>& CommandClasses, const class UInputAction* InvokedByInputAction, ECommandLayerType CommandLayerType, bool bRemoveOnStartFailure, const class UCommandSet* OverrideCommandSet);
	void AddCommandsToVirtualBufferFromClasses(const TArray<TSubclassOf<class UCommand>>& CommandClasses, const class UInputAction* InvokedByInputAction, ECommandLayerType CommandLayerType, float BufferTTL);
	void ClearCommands(bool bStopCurrentCommand);
	void OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void ResetFallingExecutionCounts();
	void ResetFallingExecutionCountsOfCategories(const TArray<ECommandCategory>& CategoriesToReset);

	float GetCooldownForCommandSet(const class UCommandSet* CommandSet) const;
	float GetCooldownRatioForCommandSet(const class UCommandSet* CommandSet) const;
	bool HasCommand() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandComponent">();
	}
	static class UCommandComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandComponent>();
	}
};
static_assert(alignof(UCommandComponent) == 0x000008, "Wrong alignment on UCommandComponent");
static_assert(sizeof(UCommandComponent) == 0x000358, "Wrong size on UCommandComponent");
static_assert(offsetof(UCommandComponent, OnCommandQueueCleared) == 0x0000A0, "Member 'UCommandComponent::OnCommandQueueCleared' has a wrong offset!");
static_assert(offsetof(UCommandComponent, OnPreStartCommand) == 0x0000B0, "Member 'UCommandComponent::OnPreStartCommand' has a wrong offset!");
static_assert(offsetof(UCommandComponent, OnPostStartCommand) == 0x0000C0, "Member 'UCommandComponent::OnPostStartCommand' has a wrong offset!");
static_assert(offsetof(UCommandComponent, OnFinishCommand) == 0x0000D0, "Member 'UCommandComponent::OnFinishCommand' has a wrong offset!");
static_assert(offsetof(UCommandComponent, OnCommandFinishCooldown) == 0x0000E0, "Member 'UCommandComponent::OnCommandFinishCooldown' has a wrong offset!");
static_assert(offsetof(UCommandComponent, DefaultCommandSet) == 0x000100, "Member 'UCommandComponent::DefaultCommandSet' has a wrong offset!");
static_assert(offsetof(UCommandComponent, CommandSettingsContainers) == 0x000108, "Member 'UCommandComponent::CommandSettingsContainers' has a wrong offset!");
static_assert(offsetof(UCommandComponent, CommandsForClasses) == 0x000130, "Member 'UCommandComponent::CommandsForClasses' has a wrong offset!");
static_assert(offsetof(UCommandComponent, CommandLayers) == 0x000180, "Member 'UCommandComponent::CommandLayers' has a wrong offset!");
static_assert(offsetof(UCommandComponent, FallbackInputAction) == 0x0002E8, "Member 'UCommandComponent::FallbackInputAction' has a wrong offset!");

// Class Zion.EventAction_MarkGameEndingReached
// 0x0008 (0x0058 - 0x0050)
class UEventAction_MarkGameEndingReached final : public UEventAction
{
public:
	EGameEndingType                               ReachedEnding;                                     // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_MarkGameEndingReached">();
	}
	static class UEventAction_MarkGameEndingReached* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_MarkGameEndingReached>();
	}
};
static_assert(alignof(UEventAction_MarkGameEndingReached) == 0x000008, "Wrong alignment on UEventAction_MarkGameEndingReached");
static_assert(sizeof(UEventAction_MarkGameEndingReached) == 0x000058, "Wrong size on UEventAction_MarkGameEndingReached");
static_assert(offsetof(UEventAction_MarkGameEndingReached, ReachedEnding) == 0x000050, "Member 'UEventAction_MarkGameEndingReached::ReachedEnding' has a wrong offset!");

// Class Zion.UserWidgetWorldSpaceText
// 0x0000 (0x0318 - 0x0318)
class UUserWidgetWorldSpaceText : public UUserWidgetWorldSpace
{
public:
	void SetText(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetWorldSpaceText">();
	}
	static class UUserWidgetWorldSpaceText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetWorldSpaceText>();
	}
};
static_assert(alignof(UUserWidgetWorldSpaceText) == 0x000008, "Wrong alignment on UUserWidgetWorldSpaceText");
static_assert(sizeof(UUserWidgetWorldSpaceText) == 0x000318, "Wrong size on UUserWidgetWorldSpaceText");

// Class Zion.UserWidgetWorldSpaceText_Interact
// 0x0000 (0x0318 - 0x0318)
class UUserWidgetWorldSpaceText_Interact : public UUserWidgetWorldSpaceText
{
public:
	void SetAvailable(bool bAvailable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetWorldSpaceText_Interact">();
	}
	static class UUserWidgetWorldSpaceText_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetWorldSpaceText_Interact>();
	}
};
static_assert(alignof(UUserWidgetWorldSpaceText_Interact) == 0x000008, "Wrong alignment on UUserWidgetWorldSpaceText_Interact");
static_assert(sizeof(UUserWidgetWorldSpaceText_Interact) == 0x000318, "Wrong size on UUserWidgetWorldSpaceText_Interact");

// Class Zion.EmulatedFogInterface
// 0x0000 (0x0000 - 0x0000)
class IEmulatedFogInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmulatedFogInterface">();
	}
	static class IEmulatedFogInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEmulatedFogInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEmulatedFogInterface) == 0x000001, "Wrong alignment on IEmulatedFogInterface");
static_assert(sizeof(IEmulatedFogInterface) == 0x000001, "Wrong size on IEmulatedFogInterface");

// Class Zion.CommandCondition_AnyInput
// 0x0008 (0x0040 - 0x0038)
class UCommandCondition_AnyInput final : public UCommandCondition
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_AnyInput">();
	}
	static class UCommandCondition_AnyInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_AnyInput>();
	}
};
static_assert(alignof(UCommandCondition_AnyInput) == 0x000008, "Wrong alignment on UCommandCondition_AnyInput");
static_assert(sizeof(UCommandCondition_AnyInput) == 0x000040, "Wrong size on UCommandCondition_AnyInput");

// Class Zion.UserWidgetRestPointListMapArea
// 0x0070 (0x04D0 - 0x0460)
class UUserWidgetRestPointListMapArea : public UUserWidgetZion
{
public:
	TMulticastInlineDelegate<void(int32 MapAreaIndex, class UUserWidgetMapIcon_RestPoint* RestPointIcon)> OnEntryFocused; // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FMapRestPointData& RestPointData)> OnEntryPressed;    // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UUserWidgetMapIcon_RestPoint> CachedRestPointIcon;                          // 0x0480(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           EntriesHolder;                                     // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   RestPointListEntrySoftClass;                       // 0x0490(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   MapAreaName;                                       // 0x04B8(0x0010)(Edit, BlueprintVisible, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	int32                                         MapAreaIndex;                                      // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCompleted;                                        // 0x04CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CD[0x3];                                      // 0x04CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GenerateRestPointListEntries(const TArray<class UUserWidgetMapIcon_RestPoint*>& RestPointIcons);
	void RestPointEntryFocused(class UUserWidgetMapIcon_RestPoint* RestPointIcon);
	void RestPointEntryPressed(const struct FMapRestPointData& RestPointData);
	void SetCompleted(bool bIsCompleted);
	void SetMapAreaIndex(const int32 NewMapAreaIndex);
	void SetMapAreaName(const class FText& NewMapAreaName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetRestPointListMapArea">();
	}
	static class UUserWidgetRestPointListMapArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetRestPointListMapArea>();
	}
};
static_assert(alignof(UUserWidgetRestPointListMapArea) == 0x000008, "Wrong alignment on UUserWidgetRestPointListMapArea");
static_assert(sizeof(UUserWidgetRestPointListMapArea) == 0x0004D0, "Wrong size on UUserWidgetRestPointListMapArea");
static_assert(offsetof(UUserWidgetRestPointListMapArea, OnEntryFocused) == 0x000460, "Member 'UUserWidgetRestPointListMapArea::OnEntryFocused' has a wrong offset!");
static_assert(offsetof(UUserWidgetRestPointListMapArea, OnEntryPressed) == 0x000470, "Member 'UUserWidgetRestPointListMapArea::OnEntryPressed' has a wrong offset!");
static_assert(offsetof(UUserWidgetRestPointListMapArea, CachedRestPointIcon) == 0x000480, "Member 'UUserWidgetRestPointListMapArea::CachedRestPointIcon' has a wrong offset!");
static_assert(offsetof(UUserWidgetRestPointListMapArea, EntriesHolder) == 0x000488, "Member 'UUserWidgetRestPointListMapArea::EntriesHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetRestPointListMapArea, RestPointListEntrySoftClass) == 0x000490, "Member 'UUserWidgetRestPointListMapArea::RestPointListEntrySoftClass' has a wrong offset!");
static_assert(offsetof(UUserWidgetRestPointListMapArea, MapAreaName) == 0x0004B8, "Member 'UUserWidgetRestPointListMapArea::MapAreaName' has a wrong offset!");
static_assert(offsetof(UUserWidgetRestPointListMapArea, MapAreaIndex) == 0x0004C8, "Member 'UUserWidgetRestPointListMapArea::MapAreaIndex' has a wrong offset!");
static_assert(offsetof(UUserWidgetRestPointListMapArea, bCompleted) == 0x0004CC, "Member 'UUserWidgetRestPointListMapArea::bCompleted' has a wrong offset!");

// Class Zion.CommandCondition_CommandLevel_Check
// 0x0010 (0x0048 - 0x0038)
class UCommandCondition_CommandLevel_Check final : public UCommandCondition
{
public:
	int32                                         MaxCommandLevel;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0xC];                                       // 0x003C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_CommandLevel_Check">();
	}
	static class UCommandCondition_CommandLevel_Check* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_CommandLevel_Check>();
	}
};
static_assert(alignof(UCommandCondition_CommandLevel_Check) == 0x000008, "Wrong alignment on UCommandCondition_CommandLevel_Check");
static_assert(sizeof(UCommandCondition_CommandLevel_Check) == 0x000048, "Wrong size on UCommandCondition_CommandLevel_Check");
static_assert(offsetof(UCommandCondition_CommandLevel_Check, MaxCommandLevel) == 0x000038, "Member 'UCommandCondition_CommandLevel_Check::MaxCommandLevel' has a wrong offset!");

// Class Zion.CommandCondition_Cooldown
// 0x0010 (0x0048 - 0x0038)
class UCommandCondition_Cooldown final : public UCommandCondition
{
public:
	float                                         Cooldown;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0xC];                                       // 0x003C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_Cooldown">();
	}
	static class UCommandCondition_Cooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_Cooldown>();
	}
};
static_assert(alignof(UCommandCondition_Cooldown) == 0x000008, "Wrong alignment on UCommandCondition_Cooldown");
static_assert(sizeof(UCommandCondition_Cooldown) == 0x000048, "Wrong size on UCommandCondition_Cooldown");
static_assert(offsetof(UCommandCondition_Cooldown, Cooldown) == 0x000038, "Member 'UCommandCondition_Cooldown::Cooldown' has a wrong offset!");

// Class Zion.CommandModule_PhaseLevel_Increment
// 0x0008 (0x0040 - 0x0038)
class UCommandModule_PhaseLevel_Increment final : public UCommandModule
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_PhaseLevel_Increment">();
	}
	static class UCommandModule_PhaseLevel_Increment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_PhaseLevel_Increment>();
	}
};
static_assert(alignof(UCommandModule_PhaseLevel_Increment) == 0x000008, "Wrong alignment on UCommandModule_PhaseLevel_Increment");
static_assert(sizeof(UCommandModule_PhaseLevel_Increment) == 0x000040, "Wrong size on UCommandModule_PhaseLevel_Increment");

// Class Zion.CommandCondition_DashChargeMode
// 0x0018 (0x0050 - 0x0038)
class UCommandCondition_DashChargeMode final : public UCommandCondition
{
public:
	TArray<EDashChargeMode>                       ValidModes;                                        // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_DashChargeMode">();
	}
	static class UCommandCondition_DashChargeMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_DashChargeMode>();
	}
};
static_assert(alignof(UCommandCondition_DashChargeMode) == 0x000008, "Wrong alignment on UCommandCondition_DashChargeMode");
static_assert(sizeof(UCommandCondition_DashChargeMode) == 0x000050, "Wrong size on UCommandCondition_DashChargeMode");
static_assert(offsetof(UCommandCondition_DashChargeMode, ValidModes) == 0x000038, "Member 'UCommandCondition_DashChargeMode::ValidModes' has a wrong offset!");

// Class Zion.MaterialSEMatrixData
// 0x00C8 (0x00F8 - 0x0030)
class UMaterialSEMatrixData final : public UDataAsset
{
public:
	TMap<EEffectAttackType, struct FActionToMaterialMap> SEMatrix;                                   // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EEffectAttackType, struct FGuardMaterialToSoundMap> SEGuards;                               // 0x0080(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoundDataGroup                        FallbackSoundDataGroup;                            // 0x00D0(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialSEMatrixData">();
	}
	static class UMaterialSEMatrixData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialSEMatrixData>();
	}
};
static_assert(alignof(UMaterialSEMatrixData) == 0x000008, "Wrong alignment on UMaterialSEMatrixData");
static_assert(sizeof(UMaterialSEMatrixData) == 0x0000F8, "Wrong size on UMaterialSEMatrixData");
static_assert(offsetof(UMaterialSEMatrixData, SEMatrix) == 0x000030, "Member 'UMaterialSEMatrixData::SEMatrix' has a wrong offset!");
static_assert(offsetof(UMaterialSEMatrixData, SEGuards) == 0x000080, "Member 'UMaterialSEMatrixData::SEGuards' has a wrong offset!");
static_assert(offsetof(UMaterialSEMatrixData, FallbackSoundDataGroup) == 0x0000D0, "Member 'UMaterialSEMatrixData::FallbackSoundDataGroup' has a wrong offset!");

// Class Zion.CommandCondition_DodgeStill_InputSetting
// 0x0018 (0x0050 - 0x0038)
class UCommandCondition_DodgeStill_InputSetting final : public UCommandCondition
{
public:
	TArray<EInputDirection>                       ValidInputDirections;                              // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_DodgeStill_InputSetting">();
	}
	static class UCommandCondition_DodgeStill_InputSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_DodgeStill_InputSetting>();
	}
};
static_assert(alignof(UCommandCondition_DodgeStill_InputSetting) == 0x000008, "Wrong alignment on UCommandCondition_DodgeStill_InputSetting");
static_assert(sizeof(UCommandCondition_DodgeStill_InputSetting) == 0x000050, "Wrong size on UCommandCondition_DodgeStill_InputSetting");
static_assert(offsetof(UCommandCondition_DodgeStill_InputSetting, ValidInputDirections) == 0x000038, "Member 'UCommandCondition_DodgeStill_InputSetting::ValidInputDirections' has a wrong offset!");

// Class Zion.CommandCondition_FallingExecutionCount
// 0x0010 (0x0048 - 0x0038)
class UCommandCondition_FallingExecutionCount final : public UCommandCondition
{
public:
	EFallingExecutionCountType                    CountType;                                         // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxFallingExecutionCount;                          // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_FallingExecutionCount">();
	}
	static class UCommandCondition_FallingExecutionCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_FallingExecutionCount>();
	}
};
static_assert(alignof(UCommandCondition_FallingExecutionCount) == 0x000008, "Wrong alignment on UCommandCondition_FallingExecutionCount");
static_assert(sizeof(UCommandCondition_FallingExecutionCount) == 0x000048, "Wrong size on UCommandCondition_FallingExecutionCount");
static_assert(offsetof(UCommandCondition_FallingExecutionCount, CountType) == 0x000038, "Member 'UCommandCondition_FallingExecutionCount::CountType' has a wrong offset!");
static_assert(offsetof(UCommandCondition_FallingExecutionCount, MaxFallingExecutionCount) == 0x00003C, "Member 'UCommandCondition_FallingExecutionCount::MaxFallingExecutionCount' has a wrong offset!");

// Class Zion.WaitGameUnpaused
// 0x0020 (0x0050 - 0x0030)
class UWaitGameUnpaused final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UWaitGameUnpaused* WaitGameUnpaused(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaitGameUnpaused">();
	}
	static class UWaitGameUnpaused* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaitGameUnpaused>();
	}
};
static_assert(alignof(UWaitGameUnpaused) == 0x000008, "Wrong alignment on UWaitGameUnpaused");
static_assert(sizeof(UWaitGameUnpaused) == 0x000050, "Wrong size on UWaitGameUnpaused");
static_assert(offsetof(UWaitGameUnpaused, OnFinish) == 0x000030, "Member 'UWaitGameUnpaused::OnFinish' has a wrong offset!");

// Class Zion.CommandCondition_HasEnoughSP
// 0x0010 (0x0048 - 0x0038)
class UCommandCondition_HasEnoughSP final : public UCommandCondition
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_HasEnoughSP">();
	}
	static class UCommandCondition_HasEnoughSP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_HasEnoughSP>();
	}
};
static_assert(alignof(UCommandCondition_HasEnoughSP) == 0x000008, "Wrong alignment on UCommandCondition_HasEnoughSP");
static_assert(sizeof(UCommandCondition_HasEnoughSP) == 0x000048, "Wrong size on UCommandCondition_HasEnoughSP");

// Class Zion.EventAction_ClearStashedSpirits
// 0x0000 (0x0050 - 0x0050)
class UEventAction_ClearStashedSpirits final : public UEventAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_ClearStashedSpirits">();
	}
	static class UEventAction_ClearStashedSpirits* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_ClearStashedSpirits>();
	}
};
static_assert(alignof(UEventAction_ClearStashedSpirits) == 0x000008, "Wrong alignment on UEventAction_ClearStashedSpirits");
static_assert(sizeof(UEventAction_ClearStashedSpirits) == 0x000050, "Wrong size on UEventAction_ClearStashedSpirits");

// Class Zion.CommandCondition_HasRemainingHeals
// 0x0008 (0x0040 - 0x0038)
class UCommandCondition_HasRemainingHeals final : public UCommandCondition
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_HasRemainingHeals">();
	}
	static class UCommandCondition_HasRemainingHeals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_HasRemainingHeals>();
	}
};
static_assert(alignof(UCommandCondition_HasRemainingHeals) == 0x000008, "Wrong alignment on UCommandCondition_HasRemainingHeals");
static_assert(sizeof(UCommandCondition_HasRemainingHeals) == 0x000040, "Wrong size on UCommandCondition_HasRemainingHeals");

// Class Zion.UserWidgetWorldSpaceGauge
// 0x0000 (0x0318 - 0x0318)
class UUserWidgetWorldSpaceGauge : public UUserWidgetWorldSpace
{
public:
	void SetCurrentRatio(float CurrentRatio);
	void SetTargetActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetWorldSpaceGauge">();
	}
	static class UUserWidgetWorldSpaceGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetWorldSpaceGauge>();
	}
};
static_assert(alignof(UUserWidgetWorldSpaceGauge) == 0x000008, "Wrong alignment on UUserWidgetWorldSpaceGauge");
static_assert(sizeof(UUserWidgetWorldSpaceGauge) == 0x000318, "Wrong size on UUserWidgetWorldSpaceGauge");

// Class Zion.CommandCondition_HasState
// 0x0020 (0x0058 - 0x0038)
class UCommandCondition_HasState final : public UCommandCondition
{
public:
	EHasStateConditionType                        CheckType;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             States;                                            // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_HasState">();
	}
	static class UCommandCondition_HasState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_HasState>();
	}
};
static_assert(alignof(UCommandCondition_HasState) == 0x000008, "Wrong alignment on UCommandCondition_HasState");
static_assert(sizeof(UCommandCondition_HasState) == 0x000058, "Wrong size on UCommandCondition_HasState");
static_assert(offsetof(UCommandCondition_HasState, CheckType) == 0x000038, "Member 'UCommandCondition_HasState::CheckType' has a wrong offset!");
static_assert(offsetof(UCommandCondition_HasState, States) == 0x000040, "Member 'UCommandCondition_HasState::States' has a wrong offset!");

// Class Zion.CommandCondition_HasStatusEffect
// 0x0020 (0x0058 - 0x0038)
class UCommandCondition_HasStatusEffect final : public UCommandCondition
{
public:
	EConditionOperator                            CheckOperator;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EStatusEffectType>                     StatusEffects;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_HasStatusEffect">();
	}
	static class UCommandCondition_HasStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_HasStatusEffect>();
	}
};
static_assert(alignof(UCommandCondition_HasStatusEffect) == 0x000008, "Wrong alignment on UCommandCondition_HasStatusEffect");
static_assert(sizeof(UCommandCondition_HasStatusEffect) == 0x000058, "Wrong size on UCommandCondition_HasStatusEffect");
static_assert(offsetof(UCommandCondition_HasStatusEffect, CheckOperator) == 0x000038, "Member 'UCommandCondition_HasStatusEffect::CheckOperator' has a wrong offset!");
static_assert(offsetof(UCommandCondition_HasStatusEffect, StatusEffects) == 0x000040, "Member 'UCommandCondition_HasStatusEffect::StatusEffects' has a wrong offset!");

// Class Zion.CommandModule_Spawn
// 0x00A8 (0x00E0 - 0x0038)
class UCommandModule_Spawn final : public UCommandModule
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpawnData                             SpawnData;                                         // 0x0040(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         StartTime;                                         // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0xC];                                       // 0x00D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_Spawn">();
	}
	static class UCommandModule_Spawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_Spawn>();
	}
};
static_assert(alignof(UCommandModule_Spawn) == 0x000010, "Wrong alignment on UCommandModule_Spawn");
static_assert(sizeof(UCommandModule_Spawn) == 0x0000E0, "Wrong size on UCommandModule_Spawn");
static_assert(offsetof(UCommandModule_Spawn, SpawnData) == 0x000040, "Member 'UCommandModule_Spawn::SpawnData' has a wrong offset!");
static_assert(offsetof(UCommandModule_Spawn, StartTime) == 0x0000D0, "Member 'UCommandModule_Spawn::StartTime' has a wrong offset!");

// Class Zion.CommandCondition_ImmersionDepth
// 0x0010 (0x0048 - 0x0038)
class UCommandCondition_ImmersionDepth final : public UCommandCondition
{
public:
	ECommonOperator                               Operator;                                          // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ComparingImmersionDepth;                           // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_ImmersionDepth">();
	}
	static class UCommandCondition_ImmersionDepth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_ImmersionDepth>();
	}
};
static_assert(alignof(UCommandCondition_ImmersionDepth) == 0x000008, "Wrong alignment on UCommandCondition_ImmersionDepth");
static_assert(sizeof(UCommandCondition_ImmersionDepth) == 0x000048, "Wrong size on UCommandCondition_ImmersionDepth");
static_assert(offsetof(UCommandCondition_ImmersionDepth, Operator) == 0x000038, "Member 'UCommandCondition_ImmersionDepth::Operator' has a wrong offset!");
static_assert(offsetof(UCommandCondition_ImmersionDepth, ComparingImmersionDepth) == 0x00003C, "Member 'UCommandCondition_ImmersionDepth::ComparingImmersionDepth' has a wrong offset!");

// Class Zion.FactionComponent
// 0x0020 (0x00C0 - 0x00A0)
class UFactionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EFaction                                      Faction;                                           // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FactionComponent">();
	}
	static class UFactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFactionComponent>();
	}
};
static_assert(alignof(UFactionComponent) == 0x000008, "Wrong alignment on UFactionComponent");
static_assert(sizeof(UFactionComponent) == 0x0000C0, "Wrong size on UFactionComponent");
static_assert(offsetof(UFactionComponent, Faction) == 0x0000B8, "Member 'UFactionComponent::Faction' has a wrong offset!");

// Class Zion.CommandCondition_InputDirection
// 0x0018 (0x0050 - 0x0038)
class UCommandCondition_InputDirection : public UCommandCondition
{
public:
	bool                                          bIgnoreCanMoveCheck;                               // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x17];                                      // 0x0039(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_InputDirection">();
	}
	static class UCommandCondition_InputDirection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_InputDirection>();
	}
};
static_assert(alignof(UCommandCondition_InputDirection) == 0x000008, "Wrong alignment on UCommandCondition_InputDirection");
static_assert(sizeof(UCommandCondition_InputDirection) == 0x000050, "Wrong size on UCommandCondition_InputDirection");
static_assert(offsetof(UCommandCondition_InputDirection, bIgnoreCanMoveCheck) == 0x000038, "Member 'UCommandCondition_InputDirection::bIgnoreCanMoveCheck' has a wrong offset!");

// Class Zion.CommandCondition_InputDirection_Custom
// 0x0010 (0x0060 - 0x0050)
class UCommandCondition_InputDirection_Custom final : public UCommandCondition_InputDirection
{
public:
	TArray<EInputDirection>                       ValidInputDirections;                              // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_InputDirection_Custom">();
	}
	static class UCommandCondition_InputDirection_Custom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_InputDirection_Custom>();
	}
};
static_assert(alignof(UCommandCondition_InputDirection_Custom) == 0x000008, "Wrong alignment on UCommandCondition_InputDirection_Custom");
static_assert(sizeof(UCommandCondition_InputDirection_Custom) == 0x000060, "Wrong size on UCommandCondition_InputDirection_Custom");
static_assert(offsetof(UCommandCondition_InputDirection_Custom, ValidInputDirections) == 0x000050, "Member 'UCommandCondition_InputDirection_Custom::ValidInputDirections' has a wrong offset!");

// Class Zion.CommandCondition_InputDirection_Lateral
// 0x0010 (0x0060 - 0x0050)
class UCommandCondition_InputDirection_Lateral final : public UCommandCondition_InputDirection
{
public:
	TArray<EInputDirection>                       ValidInputDirections;                              // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_InputDirection_Lateral">();
	}
	static class UCommandCondition_InputDirection_Lateral* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_InputDirection_Lateral>();
	}
};
static_assert(alignof(UCommandCondition_InputDirection_Lateral) == 0x000008, "Wrong alignment on UCommandCondition_InputDirection_Lateral");
static_assert(sizeof(UCommandCondition_InputDirection_Lateral) == 0x000060, "Wrong size on UCommandCondition_InputDirection_Lateral");
static_assert(offsetof(UCommandCondition_InputDirection_Lateral, ValidInputDirections) == 0x000050, "Member 'UCommandCondition_InputDirection_Lateral::ValidInputDirections' has a wrong offset!");

// Class Zion.DeathComponent
// 0x0048 (0x00E8 - 0x00A0)
class UDeathComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnDeathProcessStart;                               // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDeathProcessEnd;                                 // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UDeathProcess>              DeathProcessClass;                                 // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDestroyActor;                                     // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDeathProcess*                          DeathProcess;                                      // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHPReachedZero();

	bool IsDead() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathComponent">();
	}
	static class UDeathComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathComponent>();
	}
};
static_assert(alignof(UDeathComponent) == 0x000008, "Wrong alignment on UDeathComponent");
static_assert(sizeof(UDeathComponent) == 0x0000E8, "Wrong size on UDeathComponent");
static_assert(offsetof(UDeathComponent, OnDeathProcessStart) == 0x0000A0, "Member 'UDeathComponent::OnDeathProcessStart' has a wrong offset!");
static_assert(offsetof(UDeathComponent, OnDeathProcessEnd) == 0x0000B0, "Member 'UDeathComponent::OnDeathProcessEnd' has a wrong offset!");
static_assert(offsetof(UDeathComponent, DeathProcessClass) == 0x0000C0, "Member 'UDeathComponent::DeathProcessClass' has a wrong offset!");
static_assert(offsetof(UDeathComponent, bDestroyActor) == 0x0000C8, "Member 'UDeathComponent::bDestroyActor' has a wrong offset!");
static_assert(offsetof(UDeathComponent, DeathProcess) == 0x0000D0, "Member 'UDeathComponent::DeathProcess' has a wrong offset!");

// Class Zion.CommandCondition_IsFullHP
// 0x0008 (0x0040 - 0x0038)
class UCommandCondition_IsFullHP final : public UCommandCondition
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_IsFullHP">();
	}
	static class UCommandCondition_IsFullHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_IsFullHP>();
	}
};
static_assert(alignof(UCommandCondition_IsFullHP) == 0x000008, "Wrong alignment on UCommandCondition_IsFullHP");
static_assert(sizeof(UCommandCondition_IsFullHP) == 0x000040, "Wrong size on UCommandCondition_IsFullHP");

// Class Zion.EventAction_ExecuteFastTravel
// 0x0008 (0x0058 - 0x0050)
class UEventAction_ExecuteFastTravel final : public UEventAction
{
public:
	class FName                                   FastTravelDestinationKey;                          // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_ExecuteFastTravel">();
	}
	static class UEventAction_ExecuteFastTravel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_ExecuteFastTravel>();
	}
};
static_assert(alignof(UEventAction_ExecuteFastTravel) == 0x000008, "Wrong alignment on UEventAction_ExecuteFastTravel");
static_assert(sizeof(UEventAction_ExecuteFastTravel) == 0x000058, "Wrong size on UEventAction_ExecuteFastTravel");
static_assert(offsetof(UEventAction_ExecuteFastTravel, FastTravelDestinationKey) == 0x000050, "Member 'UEventAction_ExecuteFastTravel::FastTravelDestinationKey' has a wrong offset!");

// Class Zion.CommandCondition_IsInvokedInputPressed
// 0x0000 (0x0038 - 0x0038)
class UCommandCondition_IsInvokedInputPressed final : public UCommandCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_IsInvokedInputPressed">();
	}
	static class UCommandCondition_IsInvokedInputPressed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_IsInvokedInputPressed>();
	}
};
static_assert(alignof(UCommandCondition_IsInvokedInputPressed) == 0x000008, "Wrong alignment on UCommandCondition_IsInvokedInputPressed");
static_assert(sizeof(UCommandCondition_IsInvokedInputPressed) == 0x000038, "Wrong size on UCommandCondition_IsInvokedInputPressed");

// Class Zion.WallGrabComponent
// 0x0160 (0x0200 - 0x00A0)
class UWallGrabComponent final : public UActorComponent
{
public:
	float                                         MinVerticalityForWallGrab;                         // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DistanceToWallGrabOffset;                          // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TopOffsetForLineCast;                              // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BottomOffsetForLineCast;                           // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxZVelocityForGrab;                               // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalSpaceWallGrabLocationOffset;                  // 0x00B8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             IgnoreWallGrabStates;                              // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             WallGrabStates;                                    // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             TransitionToWallDashBumpingStates;                 // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x30];                                     // 0x0100(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACharacterZionSpirit>       SpiritClass;                                       // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSpiritSummonParameters                SummonParameters;                                  // 0x0138(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      WallGrabStartAnimations;                           // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      WallDashBumpingAnimations;                         // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FSpineAnimationDefinition> AnimationDataForNames;                     // 0x01A0(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F0[0x10];                                     // 0x01F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveBlocked(const struct FHitResult& Impact);
	void OnMovementModeChanged(class ACharacter* InCharacter, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void OnStartAnimation(class UTrackEntry* TrackEntry);
	void OnWallGrab();
	void RefreshWallGrab();

	bool IsGrabbingWall() const;
	bool IsWallOnRight() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WallGrabComponent">();
	}
	static class UWallGrabComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWallGrabComponent>();
	}
};
static_assert(alignof(UWallGrabComponent) == 0x000008, "Wrong alignment on UWallGrabComponent");
static_assert(sizeof(UWallGrabComponent) == 0x000200, "Wrong size on UWallGrabComponent");
static_assert(offsetof(UWallGrabComponent, MinVerticalityForWallGrab) == 0x0000A0, "Member 'UWallGrabComponent::MinVerticalityForWallGrab' has a wrong offset!");
static_assert(offsetof(UWallGrabComponent, DistanceToWallGrabOffset) == 0x0000A4, "Member 'UWallGrabComponent::DistanceToWallGrabOffset' has a wrong offset!");
static_assert(offsetof(UWallGrabComponent, TopOffsetForLineCast) == 0x0000A8, "Member 'UWallGrabComponent::TopOffsetForLineCast' has a wrong offset!");
static_assert(offsetof(UWallGrabComponent, BottomOffsetForLineCast) == 0x0000AC, "Member 'UWallGrabComponent::BottomOffsetForLineCast' has a wrong offset!");
static_assert(offsetof(UWallGrabComponent, MaxZVelocityForGrab) == 0x0000B0, "Member 'UWallGrabComponent::MaxZVelocityForGrab' has a wrong offset!");
static_assert(offsetof(UWallGrabComponent, LocalSpaceWallGrabLocationOffset) == 0x0000B8, "Member 'UWallGrabComponent::LocalSpaceWallGrabLocationOffset' has a wrong offset!");
static_assert(offsetof(UWallGrabComponent, IgnoreWallGrabStates) == 0x0000D0, "Member 'UWallGrabComponent::IgnoreWallGrabStates' has a wrong offset!");
static_assert(offsetof(UWallGrabComponent, WallGrabStates) == 0x0000E0, "Member 'UWallGrabComponent::WallGrabStates' has a wrong offset!");
static_assert(offsetof(UWallGrabComponent, TransitionToWallDashBumpingStates) == 0x0000F0, "Member 'UWallGrabComponent::TransitionToWallDashBumpingStates' has a wrong offset!");
static_assert(offsetof(UWallGrabComponent, SpiritClass) == 0x000130, "Member 'UWallGrabComponent::SpiritClass' has a wrong offset!");
static_assert(offsetof(UWallGrabComponent, SummonParameters) == 0x000138, "Member 'UWallGrabComponent::SummonParameters' has a wrong offset!");
static_assert(offsetof(UWallGrabComponent, WallGrabStartAnimations) == 0x000180, "Member 'UWallGrabComponent::WallGrabStartAnimations' has a wrong offset!");
static_assert(offsetof(UWallGrabComponent, WallDashBumpingAnimations) == 0x000190, "Member 'UWallGrabComponent::WallDashBumpingAnimations' has a wrong offset!");
static_assert(offsetof(UWallGrabComponent, AnimationDataForNames) == 0x0001A0, "Member 'UWallGrabComponent::AnimationDataForNames' has a wrong offset!");

// Class Zion.CommandCondition_IsPlayingAnimation
// 0x0010 (0x0048 - 0x0038)
class UCommandCondition_IsPlayingAnimation final : public UCommandCondition
{
public:
	ESpineAnimatorLayer                           AnimatorLayer;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0xF];                                       // 0x0039(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_IsPlayingAnimation">();
	}
	static class UCommandCondition_IsPlayingAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_IsPlayingAnimation>();
	}
};
static_assert(alignof(UCommandCondition_IsPlayingAnimation) == 0x000008, "Wrong alignment on UCommandCondition_IsPlayingAnimation");
static_assert(sizeof(UCommandCondition_IsPlayingAnimation) == 0x000048, "Wrong size on UCommandCondition_IsPlayingAnimation");
static_assert(offsetof(UCommandCondition_IsPlayingAnimation, AnimatorLayer) == 0x000038, "Member 'UCommandCondition_IsPlayingAnimation::AnimatorLayer' has a wrong offset!");

// Class Zion.CommandCondition_IsSpiritActive
// 0x0068 (0x00A0 - 0x0038)
class UCommandCondition_IsSpiritActive final : public UCommandCondition
{
public:
	TSubclassOf<class ACharacterZionSpirit>       SpiritClass;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpiritActivationCheckMode                    CheckMode;                                         // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<ECommandSetCategory>                     ValidCategories;                                   // 0x0048(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_IsSpiritActive">();
	}
	static class UCommandCondition_IsSpiritActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_IsSpiritActive>();
	}
};
static_assert(alignof(UCommandCondition_IsSpiritActive) == 0x000008, "Wrong alignment on UCommandCondition_IsSpiritActive");
static_assert(sizeof(UCommandCondition_IsSpiritActive) == 0x0000A0, "Wrong size on UCommandCondition_IsSpiritActive");
static_assert(offsetof(UCommandCondition_IsSpiritActive, SpiritClass) == 0x000038, "Member 'UCommandCondition_IsSpiritActive::SpiritClass' has a wrong offset!");
static_assert(offsetof(UCommandCondition_IsSpiritActive, CheckMode) == 0x000040, "Member 'UCommandCondition_IsSpiritActive::CheckMode' has a wrong offset!");
static_assert(offsetof(UCommandCondition_IsSpiritActive, ValidCategories) == 0x000048, "Member 'UCommandCondition_IsSpiritActive::ValidCategories' has a wrong offset!");

// Class Zion.CommandCondition_MovementMode
// 0x0018 (0x0050 - 0x0038)
class UCommandCondition_MovementMode final : public UCommandCondition
{
public:
	TArray<struct FMovementModeData>              ValidMovementModes;                                // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_MovementMode">();
	}
	static class UCommandCondition_MovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_MovementMode>();
	}
};
static_assert(alignof(UCommandCondition_MovementMode) == 0x000008, "Wrong alignment on UCommandCondition_MovementMode");
static_assert(sizeof(UCommandCondition_MovementMode) == 0x000050, "Wrong size on UCommandCondition_MovementMode");
static_assert(offsetof(UCommandCondition_MovementMode, ValidMovementModes) == 0x000038, "Member 'UCommandCondition_MovementMode::ValidMovementModes' has a wrong offset!");

// Class Zion.CommandCondition_PassiveEquipped
// 0x0018 (0x0050 - 0x0038)
class UCommandCondition_PassiveEquipped final : public UCommandCondition
{
public:
	struct FDataTableRowHandle                    PassiveHandle;                                     // 0x0038(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandCondition_PassiveEquipped">();
	}
	static class UCommandCondition_PassiveEquipped* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandCondition_PassiveEquipped>();
	}
};
static_assert(alignof(UCommandCondition_PassiveEquipped) == 0x000008, "Wrong alignment on UCommandCondition_PassiveEquipped");
static_assert(sizeof(UCommandCondition_PassiveEquipped) == 0x000050, "Wrong size on UCommandCondition_PassiveEquipped");
static_assert(offsetof(UCommandCondition_PassiveEquipped, PassiveHandle) == 0x000038, "Member 'UCommandCondition_PassiveEquipped::PassiveHandle' has a wrong offset!");

// Class Zion.CommandModule_AbilityInstant
// 0x0188 (0x01C0 - 0x0038)
class UCommandModule_AbilityInstant final : public UCommandModule
{
public:
	EAbilityInstantTarget                         TargetType;                                        // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFaction                                      TargetFaction;                                     // 0x0039(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAbilityInstantTriggerCondition               ConditionType;                                     // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<EFaction>                                ParriedActorValidFactions;                         // 0x0048(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityData                           AbilityData;                                       // 0x00A0(0x00E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAbilityAdditionalData                 AbilityAdditionalData;                             // 0x0180(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         DelayBeforeLaunch;                                 // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLoop;                                             // 0x0194(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_195[0x3];                                      // 0x0195(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoopMaxCount;                                      // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LoopTimer;                                         // 0x019C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x20];                                     // 0x01A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_AbilityInstant">();
	}
	static class UCommandModule_AbilityInstant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_AbilityInstant>();
	}
};
static_assert(alignof(UCommandModule_AbilityInstant) == 0x000010, "Wrong alignment on UCommandModule_AbilityInstant");
static_assert(sizeof(UCommandModule_AbilityInstant) == 0x0001C0, "Wrong size on UCommandModule_AbilityInstant");
static_assert(offsetof(UCommandModule_AbilityInstant, TargetType) == 0x000038, "Member 'UCommandModule_AbilityInstant::TargetType' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityInstant, TargetFaction) == 0x000039, "Member 'UCommandModule_AbilityInstant::TargetFaction' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityInstant, Radius) == 0x00003C, "Member 'UCommandModule_AbilityInstant::Radius' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityInstant, ConditionType) == 0x000040, "Member 'UCommandModule_AbilityInstant::ConditionType' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityInstant, ParriedActorValidFactions) == 0x000048, "Member 'UCommandModule_AbilityInstant::ParriedActorValidFactions' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityInstant, AbilityData) == 0x0000A0, "Member 'UCommandModule_AbilityInstant::AbilityData' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityInstant, AbilityAdditionalData) == 0x000180, "Member 'UCommandModule_AbilityInstant::AbilityAdditionalData' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityInstant, DelayBeforeLaunch) == 0x000190, "Member 'UCommandModule_AbilityInstant::DelayBeforeLaunch' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityInstant, bLoop) == 0x000194, "Member 'UCommandModule_AbilityInstant::bLoop' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityInstant, LoopMaxCount) == 0x000198, "Member 'UCommandModule_AbilityInstant::LoopMaxCount' has a wrong offset!");
static_assert(offsetof(UCommandModule_AbilityInstant, LoopTimer) == 0x00019C, "Member 'UCommandModule_AbilityInstant::LoopTimer' has a wrong offset!");

// Class Zion.CommandModule_AddCommands
// 0x0038 (0x0070 - 0x0038)
class UCommandModule_AddCommands final : public UCommandModule
{
public:
	TArray<class UCommandCondition*>              Conditions;                                        // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bAbortOnSuccess;                                   // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECommandModuleActiveType                      ActiveType;                                        // 0x0059(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EndTime;                                           // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_AddCommands">();
	}
	static class UCommandModule_AddCommands* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_AddCommands>();
	}
};
static_assert(alignof(UCommandModule_AddCommands) == 0x000008, "Wrong alignment on UCommandModule_AddCommands");
static_assert(sizeof(UCommandModule_AddCommands) == 0x000070, "Wrong size on UCommandModule_AddCommands");
static_assert(offsetof(UCommandModule_AddCommands, Conditions) == 0x000038, "Member 'UCommandModule_AddCommands::Conditions' has a wrong offset!");
static_assert(offsetof(UCommandModule_AddCommands, CommandClasses) == 0x000048, "Member 'UCommandModule_AddCommands::CommandClasses' has a wrong offset!");
static_assert(offsetof(UCommandModule_AddCommands, bAbortOnSuccess) == 0x000058, "Member 'UCommandModule_AddCommands::bAbortOnSuccess' has a wrong offset!");
static_assert(offsetof(UCommandModule_AddCommands, ActiveType) == 0x000059, "Member 'UCommandModule_AddCommands::ActiveType' has a wrong offset!");
static_assert(offsetof(UCommandModule_AddCommands, StartTime) == 0x00005C, "Member 'UCommandModule_AddCommands::StartTime' has a wrong offset!");
static_assert(offsetof(UCommandModule_AddCommands, EndTime) == 0x000060, "Member 'UCommandModule_AddCommands::EndTime' has a wrong offset!");

// Class Zion.CommandModule_CommandLevel_Reset
// 0x0008 (0x0040 - 0x0038)
class UCommandModule_CommandLevel_Reset final : public UCommandModule
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_CommandLevel_Reset">();
	}
	static class UCommandModule_CommandLevel_Reset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_CommandLevel_Reset>();
	}
};
static_assert(alignof(UCommandModule_CommandLevel_Reset) == 0x000008, "Wrong alignment on UCommandModule_CommandLevel_Reset");
static_assert(sizeof(UCommandModule_CommandLevel_Reset) == 0x000040, "Wrong size on UCommandModule_CommandLevel_Reset");

// Class Zion.CommandModule_ConsumeSP
// 0x0018 (0x0050 - 0x0038)
class UCommandModule_ConsumeSP final : public UCommandModule
{
public:
	class UFMODEvent*                             UISoundEvent;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_ConsumeSP">();
	}
	static class UCommandModule_ConsumeSP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_ConsumeSP>();
	}
};
static_assert(alignof(UCommandModule_ConsumeSP) == 0x000008, "Wrong alignment on UCommandModule_ConsumeSP");
static_assert(sizeof(UCommandModule_ConsumeSP) == 0x000050, "Wrong size on UCommandModule_ConsumeSP");
static_assert(offsetof(UCommandModule_ConsumeSP, UISoundEvent) == 0x000038, "Member 'UCommandModule_ConsumeSP::UISoundEvent' has a wrong offset!");

// Class Zion.CommandModule_DeactivateAuraFXs
// 0x0020 (0x0058 - 0x0038)
class UCommandModule_DeactivateAuraFXs final : public UCommandModule
{
public:
	class FName                                   AuraFXTag;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeactivationTime;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnsureDeactivation;                               // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45[0x13];                                      // 0x0045(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_DeactivateAuraFXs">();
	}
	static class UCommandModule_DeactivateAuraFXs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_DeactivateAuraFXs>();
	}
};
static_assert(alignof(UCommandModule_DeactivateAuraFXs) == 0x000008, "Wrong alignment on UCommandModule_DeactivateAuraFXs");
static_assert(sizeof(UCommandModule_DeactivateAuraFXs) == 0x000058, "Wrong size on UCommandModule_DeactivateAuraFXs");
static_assert(offsetof(UCommandModule_DeactivateAuraFXs, AuraFXTag) == 0x000038, "Member 'UCommandModule_DeactivateAuraFXs::AuraFXTag' has a wrong offset!");
static_assert(offsetof(UCommandModule_DeactivateAuraFXs, DeactivationTime) == 0x000040, "Member 'UCommandModule_DeactivateAuraFXs::DeactivationTime' has a wrong offset!");
static_assert(offsetof(UCommandModule_DeactivateAuraFXs, bEnsureDeactivation) == 0x000044, "Member 'UCommandModule_DeactivateAuraFXs::bEnsureDeactivation' has a wrong offset!");

// Class Zion.CommandModule_EnableCustomHurtbox
// 0x0028 (0x0060 - 0x0038)
class UCommandModule_EnableCustomHurtbox final : public UCommandModule
{
public:
	TArray<class FName>                           HurtboxTags;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EEnableCustomHurtboxActiveType                ActiveType;                                        // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EndTime;                                           // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0xC];                                       // 0x0054(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_EnableCustomHurtbox">();
	}
	static class UCommandModule_EnableCustomHurtbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_EnableCustomHurtbox>();
	}
};
static_assert(alignof(UCommandModule_EnableCustomHurtbox) == 0x000008, "Wrong alignment on UCommandModule_EnableCustomHurtbox");
static_assert(sizeof(UCommandModule_EnableCustomHurtbox) == 0x000060, "Wrong size on UCommandModule_EnableCustomHurtbox");
static_assert(offsetof(UCommandModule_EnableCustomHurtbox, HurtboxTags) == 0x000038, "Member 'UCommandModule_EnableCustomHurtbox::HurtboxTags' has a wrong offset!");
static_assert(offsetof(UCommandModule_EnableCustomHurtbox, ActiveType) == 0x000048, "Member 'UCommandModule_EnableCustomHurtbox::ActiveType' has a wrong offset!");
static_assert(offsetof(UCommandModule_EnableCustomHurtbox, StartTime) == 0x00004C, "Member 'UCommandModule_EnableCustomHurtbox::StartTime' has a wrong offset!");
static_assert(offsetof(UCommandModule_EnableCustomHurtbox, EndTime) == 0x000050, "Member 'UCommandModule_EnableCustomHurtbox::EndTime' has a wrong offset!");

// Class Zion.CommandModule_LaunchStatusEffect
// 0x0018 (0x0050 - 0x0038)
class UCommandModule_LaunchStatusEffect final : public UCommandModule
{
public:
	TArray<TSubclassOf<class UStatusEffect>>      StatusEffectClasses;                               // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_LaunchStatusEffect">();
	}
	static class UCommandModule_LaunchStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_LaunchStatusEffect>();
	}
};
static_assert(alignof(UCommandModule_LaunchStatusEffect) == 0x000008, "Wrong alignment on UCommandModule_LaunchStatusEffect");
static_assert(sizeof(UCommandModule_LaunchStatusEffect) == 0x000050, "Wrong size on UCommandModule_LaunchStatusEffect");
static_assert(offsetof(UCommandModule_LaunchStatusEffect, StatusEffectClasses) == 0x000038, "Member 'UCommandModule_LaunchStatusEffect::StatusEffectClasses' has a wrong offset!");

// Class Zion.CommandModule_OrientToTarget
// 0x0020 (0x0058 - 0x0038)
class UCommandModule_OrientToTarget final : public UCommandModule
{
public:
	float                                         StartTime;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseEndTime;                                       // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndTime;                                           // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERotationBlendMode                            BlendMode;                                         // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInjectionSpeed;                               // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationSpeed;                                     // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_OrientToTarget">();
	}
	static class UCommandModule_OrientToTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_OrientToTarget>();
	}
};
static_assert(alignof(UCommandModule_OrientToTarget) == 0x000008, "Wrong alignment on UCommandModule_OrientToTarget");
static_assert(sizeof(UCommandModule_OrientToTarget) == 0x000058, "Wrong size on UCommandModule_OrientToTarget");
static_assert(offsetof(UCommandModule_OrientToTarget, StartTime) == 0x000038, "Member 'UCommandModule_OrientToTarget::StartTime' has a wrong offset!");
static_assert(offsetof(UCommandModule_OrientToTarget, bUseEndTime) == 0x00003C, "Member 'UCommandModule_OrientToTarget::bUseEndTime' has a wrong offset!");
static_assert(offsetof(UCommandModule_OrientToTarget, EndTime) == 0x000040, "Member 'UCommandModule_OrientToTarget::EndTime' has a wrong offset!");
static_assert(offsetof(UCommandModule_OrientToTarget, BlendMode) == 0x000044, "Member 'UCommandModule_OrientToTarget::BlendMode' has a wrong offset!");
static_assert(offsetof(UCommandModule_OrientToTarget, BlendInjectionSpeed) == 0x000048, "Member 'UCommandModule_OrientToTarget::BlendInjectionSpeed' has a wrong offset!");
static_assert(offsetof(UCommandModule_OrientToTarget, RotationSpeed) == 0x00004C, "Member 'UCommandModule_OrientToTarget::RotationSpeed' has a wrong offset!");

// Class Zion.CommandModule_PlayAnimation_InputDirection
// 0x0058 (0x0150 - 0x00F8)
class UCommandModule_PlayAnimation_InputDirection final : public UCommandModule_PlayAnimation
{
public:
	TMap<EInputDirection, struct FAnimationDefinitionList> AnimationsForDirections;                  // 0x00F8(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_PlayAnimation_InputDirection">();
	}
	static class UCommandModule_PlayAnimation_InputDirection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_PlayAnimation_InputDirection>();
	}
};
static_assert(alignof(UCommandModule_PlayAnimation_InputDirection) == 0x000008, "Wrong alignment on UCommandModule_PlayAnimation_InputDirection");
static_assert(sizeof(UCommandModule_PlayAnimation_InputDirection) == 0x000150, "Wrong size on UCommandModule_PlayAnimation_InputDirection");
static_assert(offsetof(UCommandModule_PlayAnimation_InputDirection, AnimationsForDirections) == 0x0000F8, "Member 'UCommandModule_PlayAnimation_InputDirection::AnimationsForDirections' has a wrong offset!");

// Class Zion.CommandModule_ResetVelocity
// 0x0008 (0x0040 - 0x0038)
class UCommandModule_ResetVelocity final : public UCommandModule
{
public:
	bool                                          bResetVelocityX;                                   // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bResetVelocityY;                                   // 0x0039(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bResetVelocityZ;                                   // 0x003A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_ResetVelocity">();
	}
	static class UCommandModule_ResetVelocity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_ResetVelocity>();
	}
};
static_assert(alignof(UCommandModule_ResetVelocity) == 0x000008, "Wrong alignment on UCommandModule_ResetVelocity");
static_assert(sizeof(UCommandModule_ResetVelocity) == 0x000040, "Wrong size on UCommandModule_ResetVelocity");
static_assert(offsetof(UCommandModule_ResetVelocity, bResetVelocityX) == 0x000038, "Member 'UCommandModule_ResetVelocity::bResetVelocityX' has a wrong offset!");
static_assert(offsetof(UCommandModule_ResetVelocity, bResetVelocityY) == 0x000039, "Member 'UCommandModule_ResetVelocity::bResetVelocityY' has a wrong offset!");
static_assert(offsetof(UCommandModule_ResetVelocity, bResetVelocityZ) == 0x00003A, "Member 'UCommandModule_ResetVelocity::bResetVelocityZ' has a wrong offset!");

// Class Zion.CommandModule_Sound
// 0x0030 (0x0068 - 0x0038)
class UCommandModule_Sound final : public UCommandModule
{
public:
	class UFMODEvent*                             SoundEvent;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Delay;                                             // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAttach;                                           // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundSubsystem*                        SoundSubsystem;                                    // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_Sound">();
	}
	static class UCommandModule_Sound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_Sound>();
	}
};
static_assert(alignof(UCommandModule_Sound) == 0x000008, "Wrong alignment on UCommandModule_Sound");
static_assert(sizeof(UCommandModule_Sound) == 0x000068, "Wrong size on UCommandModule_Sound");
static_assert(offsetof(UCommandModule_Sound, SoundEvent) == 0x000038, "Member 'UCommandModule_Sound::SoundEvent' has a wrong offset!");
static_assert(offsetof(UCommandModule_Sound, Delay) == 0x000040, "Member 'UCommandModule_Sound::Delay' has a wrong offset!");
static_assert(offsetof(UCommandModule_Sound, bAttach) == 0x000044, "Member 'UCommandModule_Sound::bAttach' has a wrong offset!");
static_assert(offsetof(UCommandModule_Sound, SoundSubsystem) == 0x000048, "Member 'UCommandModule_Sound::SoundSubsystem' has a wrong offset!");

// Class Zion.CommandModule_SpineActor
// 0x00A8 (0x00E0 - 0x0038)
class UCommandModule_SpineActor final : public UCommandModule
{
public:
	TSubclassOf<class ASpineActor>                SpineActorClass;                                   // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSpineSimpleAnimationDefinition> DefaultAnimationDefinitions;                      // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<struct FMovementModeData, struct FSimpleAnimationDefinitionList> OverrideForMovementModes;  // 0x0050(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	ESpineBone                                    OriginBone;                                        // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OriginBoneCustomName;                              // 0x00A4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalSpaceOffset;                                  // 0x00B0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASpineActor*                            SpineActor;                                        // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_SpineActor">();
	}
	static class UCommandModule_SpineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_SpineActor>();
	}
};
static_assert(alignof(UCommandModule_SpineActor) == 0x000008, "Wrong alignment on UCommandModule_SpineActor");
static_assert(sizeof(UCommandModule_SpineActor) == 0x0000E0, "Wrong size on UCommandModule_SpineActor");
static_assert(offsetof(UCommandModule_SpineActor, SpineActorClass) == 0x000038, "Member 'UCommandModule_SpineActor::SpineActorClass' has a wrong offset!");
static_assert(offsetof(UCommandModule_SpineActor, DefaultAnimationDefinitions) == 0x000040, "Member 'UCommandModule_SpineActor::DefaultAnimationDefinitions' has a wrong offset!");
static_assert(offsetof(UCommandModule_SpineActor, OverrideForMovementModes) == 0x000050, "Member 'UCommandModule_SpineActor::OverrideForMovementModes' has a wrong offset!");
static_assert(offsetof(UCommandModule_SpineActor, OriginBone) == 0x0000A0, "Member 'UCommandModule_SpineActor::OriginBone' has a wrong offset!");
static_assert(offsetof(UCommandModule_SpineActor, OriginBoneCustomName) == 0x0000A4, "Member 'UCommandModule_SpineActor::OriginBoneCustomName' has a wrong offset!");
static_assert(offsetof(UCommandModule_SpineActor, LocalSpaceOffset) == 0x0000B0, "Member 'UCommandModule_SpineActor::LocalSpaceOffset' has a wrong offset!");
static_assert(offsetof(UCommandModule_SpineActor, SpineActor) == 0x0000C8, "Member 'UCommandModule_SpineActor::SpineActor' has a wrong offset!");

// Class Zion.CommandModule_SummonAuto
// 0x01A8 (0x0248 - 0x00A0)
class UCommandModule_SummonAuto final : public UCommandModule_Summon
{
public:
	struct FSpiritAutoSummonParameters            AutoParameters;                                    // 0x00A0(0x01A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_SummonAuto">();
	}
	static class UCommandModule_SummonAuto* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_SummonAuto>();
	}
};
static_assert(alignof(UCommandModule_SummonAuto) == 0x000008, "Wrong alignment on UCommandModule_SummonAuto");
static_assert(sizeof(UCommandModule_SummonAuto) == 0x000248, "Wrong size on UCommandModule_SummonAuto");
static_assert(offsetof(UCommandModule_SummonAuto, AutoParameters) == 0x0000A0, "Member 'UCommandModule_SummonAuto::AutoParameters' has a wrong offset!");

// Class Zion.CommandModule_SummonRepeat
// 0x0090 (0x0130 - 0x00A0)
class UCommandModule_SummonRepeat final : public UCommandModule_Summon
{
public:
	struct FSpiritRepeatSummonParameters          RepeatParameters;                                  // 0x00A0(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_SummonRepeat">();
	}
	static class UCommandModule_SummonRepeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_SummonRepeat>();
	}
};
static_assert(alignof(UCommandModule_SummonRepeat) == 0x000008, "Wrong alignment on UCommandModule_SummonRepeat");
static_assert(sizeof(UCommandModule_SummonRepeat) == 0x000130, "Wrong size on UCommandModule_SummonRepeat");
static_assert(offsetof(UCommandModule_SummonRepeat, RepeatParameters) == 0x0000A0, "Member 'UCommandModule_SummonRepeat::RepeatParameters' has a wrong offset!");

// Class Zion.CommandModule_TimeDilation
// 0x0028 (0x0060 - 0x0038)
class UCommandModule_TimeDilation final : public UCommandModule
{
public:
	float                                         StartTime;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimedDilationData                     Settings;                                          // 0x003C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x14];                                      // 0x004C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_TimeDilation">();
	}
	static class UCommandModule_TimeDilation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_TimeDilation>();
	}
};
static_assert(alignof(UCommandModule_TimeDilation) == 0x000008, "Wrong alignment on UCommandModule_TimeDilation");
static_assert(sizeof(UCommandModule_TimeDilation) == 0x000060, "Wrong size on UCommandModule_TimeDilation");
static_assert(offsetof(UCommandModule_TimeDilation, StartTime) == 0x000038, "Member 'UCommandModule_TimeDilation::StartTime' has a wrong offset!");
static_assert(offsetof(UCommandModule_TimeDilation, Settings) == 0x00003C, "Member 'UCommandModule_TimeDilation::Settings' has a wrong offset!");

// Class Zion.CommandModule_Timeline_Ability
// 0x01E8 (0x0220 - 0x0038)
class UCommandModule_Timeline_Ability final : public UCommandModule_Timeline
{
public:
	EAbilityOffsetMode                            GlobalOffsetMode;                                  // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimelineAbility                       TimelineAbility;                                   // 0x0040(0x01D0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x10];                                     // 0x0210(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_Timeline_Ability">();
	}
	static class UCommandModule_Timeline_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_Timeline_Ability>();
	}
};
static_assert(alignof(UCommandModule_Timeline_Ability) == 0x000010, "Wrong alignment on UCommandModule_Timeline_Ability");
static_assert(sizeof(UCommandModule_Timeline_Ability) == 0x000220, "Wrong size on UCommandModule_Timeline_Ability");
static_assert(offsetof(UCommandModule_Timeline_Ability, GlobalOffsetMode) == 0x000038, "Member 'UCommandModule_Timeline_Ability::GlobalOffsetMode' has a wrong offset!");
static_assert(offsetof(UCommandModule_Timeline_Ability, TimelineAbility) == 0x000040, "Member 'UCommandModule_Timeline_Ability::TimelineAbility' has a wrong offset!");

// Class Zion.CommandModule_Timeline_Move
// 0x0048 (0x0080 - 0x0038)
class UCommandModule_Timeline_Move final : public UCommandModule_Timeline
{
public:
	struct FTimelineMove                          TimelineMove;                                      // 0x0038(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EMoveTimelineRotation                         RotationMode;                                      // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMoveTimelineMovementModeChangeBehavior       MovementModeChangedBehavior;                       // 0x0069(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A[0x16];                                      // 0x006A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMovementModeChanged(class ACharacter* InCharacter, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_Timeline_Move">();
	}
	static class UCommandModule_Timeline_Move* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_Timeline_Move>();
	}
};
static_assert(alignof(UCommandModule_Timeline_Move) == 0x000008, "Wrong alignment on UCommandModule_Timeline_Move");
static_assert(sizeof(UCommandModule_Timeline_Move) == 0x000080, "Wrong size on UCommandModule_Timeline_Move");
static_assert(offsetof(UCommandModule_Timeline_Move, TimelineMove) == 0x000038, "Member 'UCommandModule_Timeline_Move::TimelineMove' has a wrong offset!");
static_assert(offsetof(UCommandModule_Timeline_Move, RotationMode) == 0x000068, "Member 'UCommandModule_Timeline_Move::RotationMode' has a wrong offset!");
static_assert(offsetof(UCommandModule_Timeline_Move, MovementModeChangedBehavior) == 0x000069, "Member 'UCommandModule_Timeline_Move::MovementModeChangedBehavior' has a wrong offset!");

// Class Zion.CommandModule_Timeline_State
// 0x0030 (0x0068 - 0x0038)
class UCommandModule_Timeline_State final : public UCommandModule_Timeline
{
public:
	struct FTimelineState                         TimelineState;                                     // 0x0038(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_Timeline_State">();
	}
	static class UCommandModule_Timeline_State* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_Timeline_State>();
	}
};
static_assert(alignof(UCommandModule_Timeline_State) == 0x000008, "Wrong alignment on UCommandModule_Timeline_State");
static_assert(sizeof(UCommandModule_Timeline_State) == 0x000068, "Wrong size on UCommandModule_Timeline_State");
static_assert(offsetof(UCommandModule_Timeline_State, TimelineState) == 0x000038, "Member 'UCommandModule_Timeline_State::TimelineState' has a wrong offset!");

// Class Zion.CommandModule_TriggerLeadFx
// 0x0118 (0x0150 - 0x0038)
class UCommandModule_TriggerLeadFx final : public UCommandModule
{
public:
	float                                         TriggerTime;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideLeadFX;                                   // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           OverrideLeadFX;                                    // 0x0040(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_TriggerLeadFx">();
	}
	static class UCommandModule_TriggerLeadFx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_TriggerLeadFx>();
	}
};
static_assert(alignof(UCommandModule_TriggerLeadFx) == 0x000010, "Wrong alignment on UCommandModule_TriggerLeadFx");
static_assert(sizeof(UCommandModule_TriggerLeadFx) == 0x000150, "Wrong size on UCommandModule_TriggerLeadFx");
static_assert(offsetof(UCommandModule_TriggerLeadFx, TriggerTime) == 0x000038, "Member 'UCommandModule_TriggerLeadFx::TriggerTime' has a wrong offset!");
static_assert(offsetof(UCommandModule_TriggerLeadFx, bOverrideLeadFX) == 0x00003C, "Member 'UCommandModule_TriggerLeadFx::bOverrideLeadFX' has a wrong offset!");
static_assert(offsetof(UCommandModule_TriggerLeadFx, OverrideLeadFX) == 0x000040, "Member 'UCommandModule_TriggerLeadFx::OverrideLeadFX' has a wrong offset!");

// Class Zion.CommandModule_TriggerPlayerUIAnimation
// 0x0010 (0x0048 - 0x0038)
class UCommandModule_TriggerPlayerUIAnimation final : public UCommandModule
{
public:
	EPlayerUIAnimation                            Animation;                                         // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0xF];                                       // 0x0039(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandModule_TriggerPlayerUIAnimation">();
	}
	static class UCommandModule_TriggerPlayerUIAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandModule_TriggerPlayerUIAnimation>();
	}
};
static_assert(alignof(UCommandModule_TriggerPlayerUIAnimation) == 0x000008, "Wrong alignment on UCommandModule_TriggerPlayerUIAnimation");
static_assert(sizeof(UCommandModule_TriggerPlayerUIAnimation) == 0x000048, "Wrong size on UCommandModule_TriggerPlayerUIAnimation");
static_assert(offsetof(UCommandModule_TriggerPlayerUIAnimation, Animation) == 0x000038, "Member 'UCommandModule_TriggerPlayerUIAnimation::Animation' has a wrong offset!");

// Class Zion.CommandSettingsData
// 0x0020 (0x0050 - 0x0030)
class UCommandSettingsData final : public UDataAsset
{
public:
	struct FCommandSettings                       CommandSettings;                                   // 0x0030(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandSettingsData">();
	}
	static class UCommandSettingsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandSettingsData>();
	}
};
static_assert(alignof(UCommandSettingsData) == 0x000008, "Wrong alignment on UCommandSettingsData");
static_assert(sizeof(UCommandSettingsData) == 0x000050, "Wrong size on UCommandSettingsData");
static_assert(offsetof(UCommandSettingsData, CommandSettings) == 0x000030, "Member 'UCommandSettingsData::CommandSettings' has a wrong offset!");

// Class Zion.Command_AI_WarpTo
// 0x0090 (0x0138 - 0x00A8)
class UCommand_AI_WarpTo : public UCommand
{
public:
	EWarpLocationComputationTiming                WarpLocationComputationTiming;                     // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSweepToTeleportLocation;                          // 0x00A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EWarpExecutionTiming                          WarpExecutionTiming;                               // 0x00AA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AB[0x1];                                       // 0x00AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WarpExecutionTime;                                 // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AnimationStartName;                                // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOffsetByHalfHeight;                               // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EWarpFacingMode                               WarpFacingMode;                                    // 0x00C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxGroundDistance;                                 // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             SnapToGroundCollisionChannel;                      // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWarpYAxis;                                        // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWarpZAxis;                                        // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CB[0x6D];                                      // 0x00CB(0x006D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationStart(class UTrackEntry* TrackEntry);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command_AI_WarpTo">();
	}
	static class UCommand_AI_WarpTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand_AI_WarpTo>();
	}
};
static_assert(alignof(UCommand_AI_WarpTo) == 0x000008, "Wrong alignment on UCommand_AI_WarpTo");
static_assert(sizeof(UCommand_AI_WarpTo) == 0x000138, "Wrong size on UCommand_AI_WarpTo");
static_assert(offsetof(UCommand_AI_WarpTo, WarpLocationComputationTiming) == 0x0000A8, "Member 'UCommand_AI_WarpTo::WarpLocationComputationTiming' has a wrong offset!");
static_assert(offsetof(UCommand_AI_WarpTo, bSweepToTeleportLocation) == 0x0000A9, "Member 'UCommand_AI_WarpTo::bSweepToTeleportLocation' has a wrong offset!");
static_assert(offsetof(UCommand_AI_WarpTo, WarpExecutionTiming) == 0x0000AA, "Member 'UCommand_AI_WarpTo::WarpExecutionTiming' has a wrong offset!");
static_assert(offsetof(UCommand_AI_WarpTo, WarpExecutionTime) == 0x0000AC, "Member 'UCommand_AI_WarpTo::WarpExecutionTime' has a wrong offset!");
static_assert(offsetof(UCommand_AI_WarpTo, AnimationStartName) == 0x0000B0, "Member 'UCommand_AI_WarpTo::AnimationStartName' has a wrong offset!");
static_assert(offsetof(UCommand_AI_WarpTo, bOffsetByHalfHeight) == 0x0000C0, "Member 'UCommand_AI_WarpTo::bOffsetByHalfHeight' has a wrong offset!");
static_assert(offsetof(UCommand_AI_WarpTo, WarpFacingMode) == 0x0000C1, "Member 'UCommand_AI_WarpTo::WarpFacingMode' has a wrong offset!");
static_assert(offsetof(UCommand_AI_WarpTo, MaxGroundDistance) == 0x0000C4, "Member 'UCommand_AI_WarpTo::MaxGroundDistance' has a wrong offset!");
static_assert(offsetof(UCommand_AI_WarpTo, SnapToGroundCollisionChannel) == 0x0000C8, "Member 'UCommand_AI_WarpTo::SnapToGroundCollisionChannel' has a wrong offset!");
static_assert(offsetof(UCommand_AI_WarpTo, bWarpYAxis) == 0x0000C9, "Member 'UCommand_AI_WarpTo::bWarpYAxis' has a wrong offset!");
static_assert(offsetof(UCommand_AI_WarpTo, bWarpZAxis) == 0x0000CA, "Member 'UCommand_AI_WarpTo::bWarpZAxis' has a wrong offset!");

// Class Zion.Command_Dodge
// 0x0018 (0x00C0 - 0x00A8)
class UCommand_Dodge : public UCommand
{
public:
	bool                                          bSetMovementSpeedFastOnFinish;                     // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x17];                                      // 0x00A9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command_Dodge">();
	}
	static class UCommand_Dodge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand_Dodge>();
	}
};
static_assert(alignof(UCommand_Dodge) == 0x000008, "Wrong alignment on UCommand_Dodge");
static_assert(sizeof(UCommand_Dodge) == 0x0000C0, "Wrong size on UCommand_Dodge");
static_assert(offsetof(UCommand_Dodge, bSetMovementSpeedFastOnFinish) == 0x0000A8, "Member 'UCommand_Dodge::bSetMovementSpeedFastOnFinish' has a wrong offset!");

// Class Zion.Command_Fall
// 0x0028 (0x00D0 - 0x00A8)
class UCommand_Fall : public UCommand
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UCommand>>           LandingCommandClasses;                             // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command_Fall">();
	}
	static class UCommand_Fall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand_Fall>();
	}
};
static_assert(alignof(UCommand_Fall) == 0x000008, "Wrong alignment on UCommand_Fall");
static_assert(sizeof(UCommand_Fall) == 0x0000D0, "Wrong size on UCommand_Fall");
static_assert(offsetof(UCommand_Fall, LandingCommandClasses) == 0x0000C0, "Member 'UCommand_Fall::LandingCommandClasses' has a wrong offset!");

// Class Zion.Command_FinalAbility
// 0x0040 (0x00E8 - 0x00A8)
class UCommand_FinalAbility final : public UCommand
{
public:
	TArray<ECommandFinishType>                    ValidFinishTypes;                                  // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FAbilityData>                   AbilityDataList;                                   // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bKillCharacter;                                    // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KillDelay;                                         // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command_FinalAbility">();
	}
	static class UCommand_FinalAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand_FinalAbility>();
	}
};
static_assert(alignof(UCommand_FinalAbility) == 0x000008, "Wrong alignment on UCommand_FinalAbility");
static_assert(sizeof(UCommand_FinalAbility) == 0x0000E8, "Wrong size on UCommand_FinalAbility");
static_assert(offsetof(UCommand_FinalAbility, ValidFinishTypes) == 0x0000A8, "Member 'UCommand_FinalAbility::ValidFinishTypes' has a wrong offset!");
static_assert(offsetof(UCommand_FinalAbility, AbilityDataList) == 0x0000B8, "Member 'UCommand_FinalAbility::AbilityDataList' has a wrong offset!");
static_assert(offsetof(UCommand_FinalAbility, bKillCharacter) == 0x0000C8, "Member 'UCommand_FinalAbility::bKillCharacter' has a wrong offset!");
static_assert(offsetof(UCommand_FinalAbility, KillDelay) == 0x0000CC, "Member 'UCommand_FinalAbility::KillDelay' has a wrong offset!");

// Class Zion.Command_HighJump_Release
// 0x05A8 (0x0650 - 0x00A8)
class UCommand_HighJump_Release : public UCommand
{
public:
	EHighJumpStopCondition                        HighJumpStopCondition;                             // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HighJumpMaxDistance;                               // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HighJumpMaxDuration;                               // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0xC];                                       // 0x00B4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityData                           AbilityData;                                       // 0x00C0(0x00E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bUseAbilityRelativeOffset;                         // 0x01A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeVectorCurve                    AbilityRelativeOffsetCurve;                        // 0x01A8(0x0188)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         MinExecutionTimeForHighCeiling;                    // 0x0330(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HighJumpBlockedEndTime;                            // 0x0334(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HighJumpStoppedEndTime;                            // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33C[0x54];                                     // 0x033C(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACharacterZionSpirit>       SpiritClass;                                       // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UCommand>>           CommandClasses_Release;                            // 0x0398(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FSpiritSummonParameters                SummonParameters_Release;                          // 0x03A8(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UCommand>>           CommandClasses_Blocked;                            // 0x03E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FSpiritSummonParameters                SummonParameters_Blocked;                          // 0x03F0(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRuntimeVectorCurve                    BlockedSummonLocalSpaceOffsetCurve;                // 0x0428(0x0188)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B0[0x10];                                     // 0x05B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimelineState                         TimelineState_Release;                             // 0x05C0(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTimelineState                         TimelineState_Blocked;                             // 0x05F0(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      AnimationDefinitions_Release;                      // 0x0620(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      AnimationDefinitions_Blocked;                      // 0x0630(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_640[0x10];                                     // 0x0640(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command_HighJump_Release">();
	}
	static class UCommand_HighJump_Release* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand_HighJump_Release>();
	}
};
static_assert(alignof(UCommand_HighJump_Release) == 0x000010, "Wrong alignment on UCommand_HighJump_Release");
static_assert(sizeof(UCommand_HighJump_Release) == 0x000650, "Wrong size on UCommand_HighJump_Release");
static_assert(offsetof(UCommand_HighJump_Release, HighJumpStopCondition) == 0x0000A8, "Member 'UCommand_HighJump_Release::HighJumpStopCondition' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, HighJumpMaxDistance) == 0x0000AC, "Member 'UCommand_HighJump_Release::HighJumpMaxDistance' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, HighJumpMaxDuration) == 0x0000B0, "Member 'UCommand_HighJump_Release::HighJumpMaxDuration' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, AbilityData) == 0x0000C0, "Member 'UCommand_HighJump_Release::AbilityData' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, bUseAbilityRelativeOffset) == 0x0001A0, "Member 'UCommand_HighJump_Release::bUseAbilityRelativeOffset' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, AbilityRelativeOffsetCurve) == 0x0001A8, "Member 'UCommand_HighJump_Release::AbilityRelativeOffsetCurve' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, MinExecutionTimeForHighCeiling) == 0x000330, "Member 'UCommand_HighJump_Release::MinExecutionTimeForHighCeiling' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, HighJumpBlockedEndTime) == 0x000334, "Member 'UCommand_HighJump_Release::HighJumpBlockedEndTime' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, HighJumpStoppedEndTime) == 0x000338, "Member 'UCommand_HighJump_Release::HighJumpStoppedEndTime' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, SpiritClass) == 0x000390, "Member 'UCommand_HighJump_Release::SpiritClass' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, CommandClasses_Release) == 0x000398, "Member 'UCommand_HighJump_Release::CommandClasses_Release' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, SummonParameters_Release) == 0x0003A8, "Member 'UCommand_HighJump_Release::SummonParameters_Release' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, CommandClasses_Blocked) == 0x0003E0, "Member 'UCommand_HighJump_Release::CommandClasses_Blocked' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, SummonParameters_Blocked) == 0x0003F0, "Member 'UCommand_HighJump_Release::SummonParameters_Blocked' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, BlockedSummonLocalSpaceOffsetCurve) == 0x000428, "Member 'UCommand_HighJump_Release::BlockedSummonLocalSpaceOffsetCurve' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, TimelineState_Release) == 0x0005C0, "Member 'UCommand_HighJump_Release::TimelineState_Release' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, TimelineState_Blocked) == 0x0005F0, "Member 'UCommand_HighJump_Release::TimelineState_Blocked' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, AnimationDefinitions_Release) == 0x000620, "Member 'UCommand_HighJump_Release::AnimationDefinitions_Release' has a wrong offset!");
static_assert(offsetof(UCommand_HighJump_Release, AnimationDefinitions_Blocked) == 0x000630, "Member 'UCommand_HighJump_Release::AnimationDefinitions_Blocked' has a wrong offset!");

// Class Zion.Command_Hook
// 0x0358 (0x0400 - 0x00A8)
class UCommand_Hook : public UCommand
{
public:
	TArray<EInputDirection>                       InvalidInputDirections;                            // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         MinLaunchSize;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxLaunchSize;                                     // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DelayBeforeLaunch;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      Hook_Ground_Up;                                    // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      Hook_Ground_HalfUp;                                // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      Hook_Ground_Forward;                               // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      Hook_Ground_HalfDown;                              // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      Hook_Ground_Down;                                  // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      Hook_Air_Up;                                       // 0x0118(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      Hook_Air_HalfUp;                                   // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      Hook_Air_Forward;                                  // 0x0138(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      Hook_Air_HalfDown;                                 // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      Hook_Air_Down;                                     // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           HookFX;                                            // 0x0170(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         HookFXLaunchTime;                                  // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HookBlendTime;                                     // 0x0274(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoundData                             ShootSoundEvent;                                   // 0x0278(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FSoundData                             AttachSoundEvent;                                  // 0x02A0(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FSoundData                             LaunchSoundEvent;                                  // 0x02C8(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0xE0];                                     // 0x02F0(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      HookFXInstance;                                    // 0x03D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x28];                                     // 0x03D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveBlocked(const struct FHitResult& HitResult);
	void OnMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command_Hook">();
	}
	static class UCommand_Hook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand_Hook>();
	}
};
static_assert(alignof(UCommand_Hook) == 0x000010, "Wrong alignment on UCommand_Hook");
static_assert(sizeof(UCommand_Hook) == 0x000400, "Wrong size on UCommand_Hook");
static_assert(offsetof(UCommand_Hook, InvalidInputDirections) == 0x0000A8, "Member 'UCommand_Hook::InvalidInputDirections' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, MinLaunchSize) == 0x0000B8, "Member 'UCommand_Hook::MinLaunchSize' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, MaxLaunchSize) == 0x0000BC, "Member 'UCommand_Hook::MaxLaunchSize' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, DelayBeforeLaunch) == 0x0000C0, "Member 'UCommand_Hook::DelayBeforeLaunch' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, Hook_Ground_Up) == 0x0000C8, "Member 'UCommand_Hook::Hook_Ground_Up' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, Hook_Ground_HalfUp) == 0x0000D8, "Member 'UCommand_Hook::Hook_Ground_HalfUp' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, Hook_Ground_Forward) == 0x0000E8, "Member 'UCommand_Hook::Hook_Ground_Forward' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, Hook_Ground_HalfDown) == 0x0000F8, "Member 'UCommand_Hook::Hook_Ground_HalfDown' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, Hook_Ground_Down) == 0x000108, "Member 'UCommand_Hook::Hook_Ground_Down' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, Hook_Air_Up) == 0x000118, "Member 'UCommand_Hook::Hook_Air_Up' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, Hook_Air_HalfUp) == 0x000128, "Member 'UCommand_Hook::Hook_Air_HalfUp' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, Hook_Air_Forward) == 0x000138, "Member 'UCommand_Hook::Hook_Air_Forward' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, Hook_Air_HalfDown) == 0x000148, "Member 'UCommand_Hook::Hook_Air_HalfDown' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, Hook_Air_Down) == 0x000158, "Member 'UCommand_Hook::Hook_Air_Down' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, HookFX) == 0x000170, "Member 'UCommand_Hook::HookFX' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, HookFXLaunchTime) == 0x000270, "Member 'UCommand_Hook::HookFXLaunchTime' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, HookBlendTime) == 0x000274, "Member 'UCommand_Hook::HookBlendTime' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, ShootSoundEvent) == 0x000278, "Member 'UCommand_Hook::ShootSoundEvent' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, AttachSoundEvent) == 0x0002A0, "Member 'UCommand_Hook::AttachSoundEvent' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, LaunchSoundEvent) == 0x0002C8, "Member 'UCommand_Hook::LaunchSoundEvent' has a wrong offset!");
static_assert(offsetof(UCommand_Hook, HookFXInstance) == 0x0003D0, "Member 'UCommand_Hook::HookFXInstance' has a wrong offset!");

// Class Zion.Command_WallDash_Release
// 0x0018 (0x00C0 - 0x00A8)
class UCommand_WallDash_Release : public UCommand
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveBlocked(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Command_WallDash_Release">();
	}
	static class UCommand_WallDash_Release* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommand_WallDash_Release>();
	}
};
static_assert(alignof(UCommand_WallDash_Release) == 0x000008, "Wrong alignment on UCommand_WallDash_Release");
static_assert(sizeof(UCommand_WallDash_Release) == 0x0000C0, "Wrong size on UCommand_WallDash_Release");

// Class Zion.ConditionedTextureData
// 0x0010 (0x0040 - 0x0030)
class UConditionedTextureData final : public UDataAsset
{
public:
	TArray<struct FConditionedTexture>            ConditionedTextures;                               // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	const TArray<struct FConditionedTexture> GetConditionedTextures() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionedTextureData">();
	}
	static class UConditionedTextureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionedTextureData>();
	}
};
static_assert(alignof(UConditionedTextureData) == 0x000008, "Wrong alignment on UConditionedTextureData");
static_assert(sizeof(UConditionedTextureData) == 0x000040, "Wrong size on UConditionedTextureData");
static_assert(offsetof(UConditionedTextureData, ConditionedTextures) == 0x000030, "Member 'UConditionedTextureData::ConditionedTextures' has a wrong offset!");

// Class Zion.CustomCableComponent
// 0x0000 (0x0600 - 0x0600)
class UCustomCableComponent final : public UCableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCableComponent">();
	}
	static class UCustomCableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCableComponent>();
	}
};
static_assert(alignof(UCustomCableComponent) == 0x000010, "Wrong alignment on UCustomCableComponent");
static_assert(sizeof(UCustomCableComponent) == 0x000600, "Wrong size on UCustomCableComponent");

// Class Zion.PlayerControllerZion
// 0x0528 (0x0D80 - 0x0858)
class APlayerControllerZion : public APlayerControllerZionBase
{
public:
	uint8                                         Pad_858[0xC8];                                     // 0x0858(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    DefaultRespawnRestPointData;                       // 0x0920(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidgetPlayerUI>        PlayerUIClass;                                     // 0x0930(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidgetMap>             WidgetMapClass;                                    // 0x0938(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           SystemMPC;                                         // 0x0940(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NewGameHPPercentage;                               // 0x0948(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94C[0x4];                                      // 0x094C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkillComponent*                        SkillComponent;                                    // 0x0950(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentComponent*                    EquipmentComponent;                                // 0x0958(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssistComponent*                       AssistComponent;                                   // 0x0960(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPassiveComponent*                      PassiveComponent;                                  // 0x0968(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatsControllerPlayerComponent*        StatsControllerPlayerComponent;                    // 0x0970(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryComponent*                    InventoryComponent;                                // 0x0978(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatsWatcherComponent*             ItemStatsWatcherComponent;                         // 0x0980(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHealComponent*                         HealComponent;                                     // 0x0988(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerCostumeComponent*                PlayerCostumeComponent;                            // 0x0990(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UShopInfoComponent*                     ShopInfoComponent;                                 // 0x0998(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFieldTalkComponent*                    FieldTalkComponent;                                // 0x09A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFogOfWarComponent*                     FogOfWarComponent;                                 // 0x09A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStoryLevelComponent*                   StoryLevelComponent;                               // 0x09B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomMarkerComponent*                 CustomMarkerComponent;                             // 0x09B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPathFollowingComponent*                PathFollowingComponent;                            // 0x09C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidgetPlayerUI*                    PlayerUI;                                          // 0x09C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidgetMap*                         WidgetMap;                                         // 0x09D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   RespawnRestPointID;                                // 0x09D8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class FName>                             ClearedEvents;                                     // 0x09E0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<class FName>                             PreviousRunsClearedEvents;                         // 0x0A30(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<struct FClearActorData>                  VisitedZones;                                      // 0x0A80(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<class FName>                             VisitedAreas;                                      // 0x0AD0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<class FName>                             DisplayedAreaNames;                                // 0x0B20(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<struct FMapTransitionSpawnPointData>     UsedMapTransitionSpawnPoints;                      // 0x0B70(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FName>                           AvailableRestPointEvents;                          // 0x0BC0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FName>                           ClearedRestPointEvents;                            // 0x0BD0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<class FName>                             CheckedRecollectionItems;                          // 0x0BE0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<class FName>                             KilledEnemies;                                     // 0x0C30(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<class FName>                             AvailableExtraEnemyInfoItems;                      // 0x0C80(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	EWidgetMinimapDisplayMode                     MinimapDisplayMode;                                // 0x0CD0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CD1[0x7];                                      // 0x0CD1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeCheckpointData                 RuntimeCheckpointData;                             // 0x0CD8(0x0018)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CF0[0x13];                                     // 0x0CF0(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPlayerTrailEnabled;                               // 0x0D03(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CachePlayerTrailDataDelay;                         // 0x0D04(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxPlayerTrailDataCount;                           // 0x0D08(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerTrailDataDistanceThreshold;                  // 0x0D0C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<ERespawnReason>                        ClearPlayerTrailRespawnReasons;                    // 0x0D10(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D20[0x30];                                     // 0x0D20(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSummonStashElement>            SummonStash;                                       // 0x0D50(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D60[0x20];                                     // 0x0D60(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class APlayerControllerZion* Get(const class UObject* WorldContextObject, int32 PlayerIndex);

	void AddRestEvent(const class FName& RestEventID);
	void DBG_SetRestEventAvailable(const class FName& RestEventID, bool bAvailable);
	bool DebugMarkEventAsCleared(const class FName& EventId, bool bCleared);
	void DisplayAreaName(const class FName& AreaName);
	void FlushSpiritCache();
	void FullyRestore();
	bool GetAvailableRestEvent(struct FDataTableRowHandle* out_RestPointEventRowHandle, struct FRestPointEventData* out_RestPointEventData);
	void HidePlayerUI(bool bInstant);
	void LaunchTutorialHook(ETutorialHook TutorialHook);
	void LockFastTravel();
	void MarkEnemyAsKilled(const struct FDataTableRowHandle& EnemyDataHandle);
	void MarkEventAsCleared(const class UEventAsset* EventAsset);
	void MarkExtraEnemyInfoAsAvailable(const struct FDataTableRowHandle& ExtraEnemyInfoItem);
	void MarkRecollectionItemAsChecked(const struct FDataTableRowHandle& RecollectionItem);
	void MarkRestEventAsSeen(const class FName& RestEventID);
	void OnAchievementUnlocked(const class FName& AchievementID);
	void OnDisplayAreaName(const class FName& AreaName);
	void OnGameMapChangeFinished(const class FName& GameMapID);
	void OnGameMapChangeStart();
	void OnGameReady();
	void OnPawnDeathProcessEnd();
	void OnRequestTutorials(const TArray<class FName>& TutorialIDs);
	void OnRespawnCompleted(ERespawnReason RespawnReason);
	void OnStoryLevelChanged();
	EWidgetMinimapDisplayMode SetMinimapDisplayMode(const EWidgetMinimapDisplayMode& NewMinimapDisplayMode);
	void SetRespawnRestPoint(const class FName& InRespawnRestPointID);
	struct FRuntimeCheckpointData SetRuntimeCheckpointData(const struct FRuntimeCheckpointData& NewRuntimeCheckpointData);
	void ShowPlayerUI();
	void UnlockFastTravel();

	EWidgetMinimapDisplayMode GetMinimapDisplayMode() const;
	class UUserWidgetPlayerUI* GetPlayerUI() const;
	const class FName GetRespawnRestPointID() const;
	struct FRuntimeCheckpointData GetRuntimeCheckpointData() const;
	class UUserWidgetMap* GetWidgetMap() const;
	bool HasAvailableRestEvent() const;
	bool IsAreaNameDisplayed(const class FName& AreaName) const;
	bool IsAreaVisited(const class FName& AreaName) const;
	bool IsBackToRestPointLocked() const;
	bool IsEnemyKilled(const struct FDataTableRowHandle& EnemyDataHandle) const;
	bool IsEventCleared(const class FName EventId, const EEventClearedCheckMode CheckMode) const;
	bool IsExtraEnemyInfoAvailable(const struct FDataTableRowHandle& ExtraEnemyInfoItem) const;
	bool IsFastTravelLocked() const;
	bool IsInEvent() const;
	bool IsMapTransitionSpawnPointUsed(const struct FMapTransitionSpawnPointData& MapTransitionSpawnPointData) const;
	bool IsRecollectionItemChecked(const struct FDataTableRowHandle& RecollectionItem) const;
	bool IsRestEventAvailable(const class FName& RestEventID) const;
	bool IsSoftEventCleared(const TSoftObjectPtr<class UEventAsset>& EventAsset) const;
	bool IsZoneVisited(const struct FClearActorData& ZoneActorData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerZion">();
	}
	static class APlayerControllerZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerControllerZion>();
	}
};
static_assert(alignof(APlayerControllerZion) == 0x000008, "Wrong alignment on APlayerControllerZion");
static_assert(sizeof(APlayerControllerZion) == 0x000D80, "Wrong size on APlayerControllerZion");
static_assert(offsetof(APlayerControllerZion, DefaultRespawnRestPointData) == 0x000920, "Member 'APlayerControllerZion::DefaultRespawnRestPointData' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, PlayerUIClass) == 0x000930, "Member 'APlayerControllerZion::PlayerUIClass' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, WidgetMapClass) == 0x000938, "Member 'APlayerControllerZion::WidgetMapClass' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, SystemMPC) == 0x000940, "Member 'APlayerControllerZion::SystemMPC' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, NewGameHPPercentage) == 0x000948, "Member 'APlayerControllerZion::NewGameHPPercentage' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, SkillComponent) == 0x000950, "Member 'APlayerControllerZion::SkillComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, EquipmentComponent) == 0x000958, "Member 'APlayerControllerZion::EquipmentComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, AssistComponent) == 0x000960, "Member 'APlayerControllerZion::AssistComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, PassiveComponent) == 0x000968, "Member 'APlayerControllerZion::PassiveComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, StatsControllerPlayerComponent) == 0x000970, "Member 'APlayerControllerZion::StatsControllerPlayerComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, InventoryComponent) == 0x000978, "Member 'APlayerControllerZion::InventoryComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, ItemStatsWatcherComponent) == 0x000980, "Member 'APlayerControllerZion::ItemStatsWatcherComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, HealComponent) == 0x000988, "Member 'APlayerControllerZion::HealComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, PlayerCostumeComponent) == 0x000990, "Member 'APlayerControllerZion::PlayerCostumeComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, ShopInfoComponent) == 0x000998, "Member 'APlayerControllerZion::ShopInfoComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, FieldTalkComponent) == 0x0009A0, "Member 'APlayerControllerZion::FieldTalkComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, FogOfWarComponent) == 0x0009A8, "Member 'APlayerControllerZion::FogOfWarComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, StoryLevelComponent) == 0x0009B0, "Member 'APlayerControllerZion::StoryLevelComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, CustomMarkerComponent) == 0x0009B8, "Member 'APlayerControllerZion::CustomMarkerComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, PathFollowingComponent) == 0x0009C0, "Member 'APlayerControllerZion::PathFollowingComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, PlayerUI) == 0x0009C8, "Member 'APlayerControllerZion::PlayerUI' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, WidgetMap) == 0x0009D0, "Member 'APlayerControllerZion::WidgetMap' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, RespawnRestPointID) == 0x0009D8, "Member 'APlayerControllerZion::RespawnRestPointID' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, ClearedEvents) == 0x0009E0, "Member 'APlayerControllerZion::ClearedEvents' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, PreviousRunsClearedEvents) == 0x000A30, "Member 'APlayerControllerZion::PreviousRunsClearedEvents' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, VisitedZones) == 0x000A80, "Member 'APlayerControllerZion::VisitedZones' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, VisitedAreas) == 0x000AD0, "Member 'APlayerControllerZion::VisitedAreas' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, DisplayedAreaNames) == 0x000B20, "Member 'APlayerControllerZion::DisplayedAreaNames' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, UsedMapTransitionSpawnPoints) == 0x000B70, "Member 'APlayerControllerZion::UsedMapTransitionSpawnPoints' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, AvailableRestPointEvents) == 0x000BC0, "Member 'APlayerControllerZion::AvailableRestPointEvents' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, ClearedRestPointEvents) == 0x000BD0, "Member 'APlayerControllerZion::ClearedRestPointEvents' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, CheckedRecollectionItems) == 0x000BE0, "Member 'APlayerControllerZion::CheckedRecollectionItems' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, KilledEnemies) == 0x000C30, "Member 'APlayerControllerZion::KilledEnemies' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, AvailableExtraEnemyInfoItems) == 0x000C80, "Member 'APlayerControllerZion::AvailableExtraEnemyInfoItems' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, MinimapDisplayMode) == 0x000CD0, "Member 'APlayerControllerZion::MinimapDisplayMode' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, RuntimeCheckpointData) == 0x000CD8, "Member 'APlayerControllerZion::RuntimeCheckpointData' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, bPlayerTrailEnabled) == 0x000D03, "Member 'APlayerControllerZion::bPlayerTrailEnabled' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, CachePlayerTrailDataDelay) == 0x000D04, "Member 'APlayerControllerZion::CachePlayerTrailDataDelay' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, MaxPlayerTrailDataCount) == 0x000D08, "Member 'APlayerControllerZion::MaxPlayerTrailDataCount' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, PlayerTrailDataDistanceThreshold) == 0x000D0C, "Member 'APlayerControllerZion::PlayerTrailDataDistanceThreshold' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, ClearPlayerTrailRespawnReasons) == 0x000D10, "Member 'APlayerControllerZion::ClearPlayerTrailRespawnReasons' has a wrong offset!");
static_assert(offsetof(APlayerControllerZion, SummonStash) == 0x000D50, "Member 'APlayerControllerZion::SummonStash' has a wrong offset!");

// Class Zion.CustomStyleCharColorDecorator
// 0x0008 (0x0030 - 0x0028)
class UCustomStyleCharColorDecorator final : public URichTextBlockDecorator
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomStyleCharColorDecorator">();
	}
	static class UCustomStyleCharColorDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomStyleCharColorDecorator>();
	}
};
static_assert(alignof(UCustomStyleCharColorDecorator) == 0x000008, "Wrong alignment on UCustomStyleCharColorDecorator");
static_assert(sizeof(UCustomStyleCharColorDecorator) == 0x000030, "Wrong size on UCustomStyleCharColorDecorator");

// Class Zion.DummyStatsComponent
// 0x0040 (0x07F0 - 0x07B0)
class UDummyStatsComponent final : public UStatsComponent
{
public:
	uint8                                         Pad_7B0[0x40];                                     // 0x07B0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DummyStatsComponent">();
	}
	static class UDummyStatsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDummyStatsComponent>();
	}
};
static_assert(alignof(UDummyStatsComponent) == 0x000008, "Wrong alignment on UDummyStatsComponent");
static_assert(sizeof(UDummyStatsComponent) == 0x0007F0, "Wrong size on UDummyStatsComponent");

// Class Zion.DataTableBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class UDataTableBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetInventoryItemData(const struct FDataTableRowHandle& Handle, struct FInventoryItemData* out_ItemData);
	static bool GetItemAptitudeDataFromType(class UDataTable* DataTable, EAptitudeType AptitudeType, struct FInventoryItemAptitudeData* out_AptitudeData);
	static bool GetItemAssistData(const struct FDataTableRowHandle& Handle, struct FInventoryItemAssistData* out_ItemData);
	static bool GetItemBaseEquipmentData(const struct FDataTableRowHandle& Handle, struct FInventoryItemBaseEquipmentData* out_ItemData);
	static bool GetItemCostumeData(const struct FDataTableRowHandle& Handle, struct FInventoryItemCostumeData* out_ItemData);
	static bool GetItemEnemyInfoData(const struct FDataTableRowHandle& Handle, struct FInventoryItemEnemyInfoData* out_ItemData);
	static bool GetItemEquipmentData(const struct FDataTableRowHandle& Handle, struct FInventoryItemEquipmentData* out_ItemData);
	static bool GetItemGalleryData(const struct FDataTableRowHandle& Handle, struct FInventoryItemGalleryData* out_ItemData);
	static bool GetItemGenericInfoData(const struct FDataTableRowHandle& Handle, struct FInventoryItemGenericInfoData* out_ItemData);
	static bool GetItemNPCInfoData(const struct FDataTableRowHandle& Handle, struct FInventoryItemNPCInfoData* out_ItemData);
	static bool GetItemPassiveData(const struct FDataTableRowHandle& Handle, struct FInventoryItemPassiveData* out_ItemData);
	static bool GetItemSkillData(const struct FDataTableRowHandle& Handle, struct FInventoryItemSkillData* out_ItemData);
	static bool GetItemSpiritData(const struct FDataTableRowHandle& Handle, struct FInventoryItemSpiritData* out_ItemData);
	static bool GetItemTipData(const struct FDataTableRowHandle& Handle, struct FInventoryItemTipData* out_ItemData);
	static bool GetItemTutorialData(const struct FDataTableRowHandle& Handle, struct FInventoryItemTutorialData* out_ItemData);
	static bool GetMapTransitionRowHandleFromTransitionSpawnPointData(const class UDataTable* MapTransitionDataTable, const struct FMapTransitionSpawnPointData& MapTransitionSpawnPointData, struct FDataTableRowHandle* out_MapTransitionRowHandle);
	static bool GetRecollectionItemData(const struct FDataTableRowHandle& Handle, ERecollectionItemType RecollectionItemType, struct FRecollectionItemData* out_RecollectionItemData);
	static bool GetRestPointData(const struct FDataTableRowHandle& Handle, struct FRestPointData* out_RestPointData);
	static bool GetRestPointEventData(const struct FDataTableRowHandle& Handle, struct FRestPointEventData* out_RestPointEventData);
	static bool GetSkillLevelDataFromItemSkillData(const struct FInventoryItemSkillData& ItemSkillData, int32 Level, struct FSkillLevelData* out_SkillData);
	static bool IsAllRecollectionItemsChecked(class APlayerControllerZion* PlayerControllerZion, const class UDataTable* DataTable, ERecollectionItemType RecollectionItemType);
	static bool IsAnyRecollectionItemVisible(class APlayerControllerZion* PlayerControllerZion, const class UDataTable* DataTable, ERecollectionItemType RecollectionItemType);
	static bool IsEqual(const struct FDataTableRowHandle& A, const struct FDataTableRowHandle& B);
	static bool IsItemEnemyInfoVisible(const class APlayerControllerZion* PlayerControllerZion, const struct FDataTableRowHandle& Handle);
	static bool IsItemGalleryVisible(class APlayerControllerZion* PlayerControllerZion, const struct FDataTableRowHandle& Handle);
	static bool IsItemGenericAnimationVisible(class APlayerControllerZion* PlayerControllerZion, const struct FItemGenericAnimationConditionData& AnimationConditions);
	static bool IsItemNPCInfoVisible(class APlayerControllerZion* PlayerControllerZion, const struct FDataTableRowHandle& Handle);
	static bool IsProgressionItem(const struct FDataTableRowHandle& ItemHandle);
	static bool IsRecollectionItemVisible(class APlayerControllerZion* PlayerControllerZion, const struct FDataTableRowHandle& Handle, ERecollectionItemType RecollectionItemType);
	static bool IsValid(const struct FDataTableRowHandle& Handle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataTableBPFLibrary">();
	}
	static class UDataTableBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataTableBPFLibrary>();
	}
};
static_assert(alignof(UDataTableBPFLibrary) == 0x000008, "Wrong alignment on UDataTableBPFLibrary");
static_assert(sizeof(UDataTableBPFLibrary) == 0x000028, "Wrong size on UDataTableBPFLibrary");

// Class Zion.DeathProcess_Dissolve
// 0x00B0 (0x02F0 - 0x0240)
#pragma pack(push, 0x1)
class alignas(0x10) UDeathProcess_Dissolve : public UDeathProcess
{
public:
	struct FRuntimeFloatCurve                     DissolveCurve;                                     // 0x0240(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMeshComponent*>           StaticMeshComponents;                              // 0x02D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathProcess_Dissolve">();
	}
	static class UDeathProcess_Dissolve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathProcess_Dissolve>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDeathProcess_Dissolve) == 0x000010, "Wrong alignment on UDeathProcess_Dissolve");
static_assert(sizeof(UDeathProcess_Dissolve) == 0x0002F0, "Wrong size on UDeathProcess_Dissolve");
static_assert(offsetof(UDeathProcess_Dissolve, DissolveCurve) == 0x000240, "Member 'UDeathProcess_Dissolve::DissolveCurve' has a wrong offset!");
static_assert(offsetof(UDeathProcess_Dissolve, StaticMeshComponents) == 0x0002D8, "Member 'UDeathProcess_Dissolve::StaticMeshComponents' has a wrong offset!");

// Class Zion.DeathProcess_Enemy
// 0x0010 (0x0300 - 0x02F0)
class UDeathProcess_Enemy : public UDeathProcess_Dissolve
{
public:
	TArray<struct FSpineAnimationDefinition>      DeathAnimations;                                   // 0x02E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathProcess_Enemy">();
	}
	static class UDeathProcess_Enemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathProcess_Enemy>();
	}
};
static_assert(alignof(UDeathProcess_Enemy) == 0x000010, "Wrong alignment on UDeathProcess_Enemy");
static_assert(sizeof(UDeathProcess_Enemy) == 0x000300, "Wrong size on UDeathProcess_Enemy");
static_assert(offsetof(UDeathProcess_Enemy, DeathAnimations) == 0x0002E8, "Member 'UDeathProcess_Enemy::DeathAnimations' has a wrong offset!");

// Class Zion.DeathProcess_SpineAnimation
// 0x0040 (0x0280 - 0x0240)
class UDeathProcess_SpineAnimation : public UDeathProcess
{
public:
	int32                                         TrackIndex;                                        // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnimationName;                                     // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanUseBackAnimations;                             // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BackAnimationName;                                 // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLoop;                                             // 0x0270(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271[0xF];                                      // 0x0271(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationFinished(class UTrackEntry* TrackEntry);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathProcess_SpineAnimation">();
	}
	static class UDeathProcess_SpineAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathProcess_SpineAnimation>();
	}
};
static_assert(alignof(UDeathProcess_SpineAnimation) == 0x000010, "Wrong alignment on UDeathProcess_SpineAnimation");
static_assert(sizeof(UDeathProcess_SpineAnimation) == 0x000280, "Wrong size on UDeathProcess_SpineAnimation");
static_assert(offsetof(UDeathProcess_SpineAnimation, TrackIndex) == 0x000240, "Member 'UDeathProcess_SpineAnimation::TrackIndex' has a wrong offset!");
static_assert(offsetof(UDeathProcess_SpineAnimation, AnimationName) == 0x000248, "Member 'UDeathProcess_SpineAnimation::AnimationName' has a wrong offset!");
static_assert(offsetof(UDeathProcess_SpineAnimation, bCanUseBackAnimations) == 0x000258, "Member 'UDeathProcess_SpineAnimation::bCanUseBackAnimations' has a wrong offset!");
static_assert(offsetof(UDeathProcess_SpineAnimation, BackAnimationName) == 0x000260, "Member 'UDeathProcess_SpineAnimation::BackAnimationName' has a wrong offset!");
static_assert(offsetof(UDeathProcess_SpineAnimation, bLoop) == 0x000270, "Member 'UDeathProcess_SpineAnimation::bLoop' has a wrong offset!");

// Class Zion.DelayRealTimeAsyncAction
// 0x0028 (0x0058 - 0x0030)
class UDelayRealTimeAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDelayRealTimeAsyncAction* DelayRealTime(const class UObject* WorldContextObject, float DelayInSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelayRealTimeAsyncAction">();
	}
	static class UDelayRealTimeAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelayRealTimeAsyncAction>();
	}
};
static_assert(alignof(UDelayRealTimeAsyncAction) == 0x000008, "Wrong alignment on UDelayRealTimeAsyncAction");
static_assert(sizeof(UDelayRealTimeAsyncAction) == 0x000058, "Wrong size on UDelayRealTimeAsyncAction");
static_assert(offsetof(UDelayRealTimeAsyncAction, OnFinish) == 0x000030, "Member 'UDelayRealTimeAsyncAction::OnFinish' has a wrong offset!");

// Class Zion.DelayUndilatedAsyncAction
// 0x0028 (0x0058 - 0x0030)
class UDelayUndilatedAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDelayUndilatedAsyncAction* DelayUndilated(const class UObject* WorldContextObject, float DelayInSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelayUndilatedAsyncAction">();
	}
	static class UDelayUndilatedAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelayUndilatedAsyncAction>();
	}
};
static_assert(alignof(UDelayUndilatedAsyncAction) == 0x000008, "Wrong alignment on UDelayUndilatedAsyncAction");
static_assert(sizeof(UDelayUndilatedAsyncAction) == 0x000058, "Wrong size on UDelayUndilatedAsyncAction");
static_assert(offsetof(UDelayUndilatedAsyncAction, OnFinish) == 0x000030, "Member 'UDelayUndilatedAsyncAction::OnFinish' has a wrong offset!");

// Class Zion.DifficultySystemComponent
// 0x03E0 (0x0480 - 0x00A0)
class UDifficultySystemComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x30];                                      // 0x00A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDifficultyPreset, struct FDifficultySettings> DifficultyForPresets;                        // 0x00D0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         MinCurrencyFactor;                                 // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxCurrencyFactor;                                 // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     MaxHPFactorCurrencyCurve;                          // 0x0128(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     AttackFactorCurrencyCurve;                         // 0x01B0(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     ActionFrequencyCurrencyCurve;                      // 0x0238(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     StaminaFactorCurrencyCurve;                        // 0x02C0(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     StaminaRecoverySpeedFactorCurrencyCurve;           // 0x0348(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDifficultyMode, EDifficultyPreset>      DifficultyPresets;                                 // 0x03D8(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<EDifficultyMode, struct FDifficultySettings> DifficultySettings;                            // 0x0428(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDifficultySystemComponent* Get(const class UObject* WorldContextObject);

	EDifficultyPreset GetDifficultyPresetFromSettings(const struct FDifficultySettings& InDifficultySettings);
	void SetDifficultyMode(EDifficultyMode NewDifficultyMode);
	void SetDifficultyPresetAndSettings(EDifficultyPreset NewDifficultyPreset, const struct FDifficultySettings& NewDifficultySettings);

	float GetCurrencyFactor() const;
	float GetCurrencyFactorRatio() const;
	EDifficultyMode GetDifficultyMode() const;
	EDifficultyPreset GetDifficultyPreset() const;
	EDifficultyPreset GetDifficultyPresetForMode(EDifficultyMode InDifficultyMode) const;
	const struct FDifficultySettings GetDifficultySettings() const;
	const struct FDifficultySettings GetDifficultySettingsForMode(EDifficultyMode InDifficultyMode) const;
	const struct FDifficultySettings GetDifficultySettingsForPreset(EDifficultyPreset InDifficultyPreset) const;
	bool HasAnyChallengeEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DifficultySystemComponent">();
	}
	static class UDifficultySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDifficultySystemComponent>();
	}
};
static_assert(alignof(UDifficultySystemComponent) == 0x000008, "Wrong alignment on UDifficultySystemComponent");
static_assert(sizeof(UDifficultySystemComponent) == 0x000480, "Wrong size on UDifficultySystemComponent");
static_assert(offsetof(UDifficultySystemComponent, DifficultyForPresets) == 0x0000D0, "Member 'UDifficultySystemComponent::DifficultyForPresets' has a wrong offset!");
static_assert(offsetof(UDifficultySystemComponent, MinCurrencyFactor) == 0x000120, "Member 'UDifficultySystemComponent::MinCurrencyFactor' has a wrong offset!");
static_assert(offsetof(UDifficultySystemComponent, MaxCurrencyFactor) == 0x000124, "Member 'UDifficultySystemComponent::MaxCurrencyFactor' has a wrong offset!");
static_assert(offsetof(UDifficultySystemComponent, MaxHPFactorCurrencyCurve) == 0x000128, "Member 'UDifficultySystemComponent::MaxHPFactorCurrencyCurve' has a wrong offset!");
static_assert(offsetof(UDifficultySystemComponent, AttackFactorCurrencyCurve) == 0x0001B0, "Member 'UDifficultySystemComponent::AttackFactorCurrencyCurve' has a wrong offset!");
static_assert(offsetof(UDifficultySystemComponent, ActionFrequencyCurrencyCurve) == 0x000238, "Member 'UDifficultySystemComponent::ActionFrequencyCurrencyCurve' has a wrong offset!");
static_assert(offsetof(UDifficultySystemComponent, StaminaFactorCurrencyCurve) == 0x0002C0, "Member 'UDifficultySystemComponent::StaminaFactorCurrencyCurve' has a wrong offset!");
static_assert(offsetof(UDifficultySystemComponent, StaminaRecoverySpeedFactorCurrencyCurve) == 0x000348, "Member 'UDifficultySystemComponent::StaminaRecoverySpeedFactorCurrencyCurve' has a wrong offset!");
static_assert(offsetof(UDifficultySystemComponent, DifficultyPresets) == 0x0003D8, "Member 'UDifficultySystemComponent::DifficultyPresets' has a wrong offset!");
static_assert(offsetof(UDifficultySystemComponent, DifficultySettings) == 0x000428, "Member 'UDifficultySystemComponent::DifficultySettings' has a wrong offset!");

// Class Zion.DropComponent
// 0x0028 (0x00C8 - 0x00A0)
class UDropComponent final : public UActorComponent
{
public:
	int32                                         ExperienceDropAmount;                              // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ExperienceDrop;                                    // 0x00A4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    DropDataHandle;                                    // 0x00A8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LaunchDropProcess();
	void OnDeath();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropComponent">();
	}
	static class UDropComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropComponent>();
	}
};
static_assert(alignof(UDropComponent) == 0x000008, "Wrong alignment on UDropComponent");
static_assert(sizeof(UDropComponent) == 0x0000C8, "Wrong size on UDropComponent");
static_assert(offsetof(UDropComponent, ExperienceDropAmount) == 0x0000A0, "Member 'UDropComponent::ExperienceDropAmount' has a wrong offset!");
static_assert(offsetof(UDropComponent, ExperienceDrop) == 0x0000A4, "Member 'UDropComponent::ExperienceDrop' has a wrong offset!");
static_assert(offsetof(UDropComponent, DropDataHandle) == 0x0000A8, "Member 'UDropComponent::DropDataHandle' has a wrong offset!");

// Class Zion.DropSystemComponent
// 0x0028 (0x00C8 - 0x00A0)
class UDropSystemComponent final : public UActorComponent
{
public:
	TSubclassOf<class ACollectable_Experience>    CollectableExperienceClass;                        // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        HistoryTime;                                       // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDropSystemComponent* Get(const class UObject* WorldContextObject);

	void LaunchExperienceDrop(int32 Experience, const struct FTransform& Origin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropSystemComponent">();
	}
	static class UDropSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropSystemComponent>();
	}
};
static_assert(alignof(UDropSystemComponent) == 0x000008, "Wrong alignment on UDropSystemComponent");
static_assert(sizeof(UDropSystemComponent) == 0x0000C8, "Wrong size on UDropSystemComponent");
static_assert(offsetof(UDropSystemComponent, CollectableExperienceClass) == 0x0000A0, "Member 'UDropSystemComponent::CollectableExperienceClass' has a wrong offset!");
static_assert(offsetof(UDropSystemComponent, HistoryTime) == 0x0000A8, "Member 'UDropSystemComponent::HistoryTime' has a wrong offset!");

// Class Zion.MaterialFXMatrixData
// 0x0050 (0x0080 - 0x0030)
class UMaterialFXMatrixData final : public UDataAsset
{
public:
	TMap<EEffectAttackType, struct FActionToFXMap> FXMatrix;                                         // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialFXMatrixData">();
	}
	static class UMaterialFXMatrixData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialFXMatrixData>();
	}
};
static_assert(alignof(UMaterialFXMatrixData) == 0x000008, "Wrong alignment on UMaterialFXMatrixData");
static_assert(sizeof(UMaterialFXMatrixData) == 0x000080, "Wrong size on UMaterialFXMatrixData");
static_assert(offsetof(UMaterialFXMatrixData, FXMatrix) == 0x000030, "Member 'UMaterialFXMatrixData::FXMatrix' has a wrong offset!");

// Class Zion.ElevatorDestinationComponent
// 0x0000 (0x0230 - 0x0230)
class UElevatorDestinationComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ElevatorDestinationComponent">();
	}
	static class UElevatorDestinationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UElevatorDestinationComponent>();
	}
};
static_assert(alignof(UElevatorDestinationComponent) == 0x000010, "Wrong alignment on UElevatorDestinationComponent");
static_assert(sizeof(UElevatorDestinationComponent) == 0x000230, "Wrong size on UElevatorDestinationComponent");

// Class Zion.ElevatorMovementComponent
// 0x0138 (0x0240 - 0x0108)
class UElevatorMovementComponent final : public UMovementComponent
{
public:
	TMulticastInlineDelegate<void(bool bInstant, bool bWasMoving)> OnStartedMovement;                // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bInstant, bool bWasMoving)> OnFinishedMovement;               // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FComponentReference                    ElevatorComponentRef;                              // 0x0128(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FComponentReference                    DestinationComponentRef;                           // 0x0150(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Speed;                                             // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     MovementCurve;                                     // 0x0180(0x0088)(Edit, NativeAccessSpecifierPrivate)
	float                                         DelayBeforeMove;                                   // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSweep;                                            // 0x020C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETeleportType                                 TeleportType;                                      // 0x020D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20E[0x32];                                     // 0x020E(0x0032)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GoToDestination(bool bInstant);
	void GoToOrigin(bool bInstant);
	void SetAllowOutOfScreenSpeedFactor(bool bAllowed);
	void TeleportToDestination();
	void TeleportToOrigin();

	struct FVector GetCurrentLocation() const;
	bool IsDirectionSetToDestination() const;
	bool IsMoving() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ElevatorMovementComponent">();
	}
	static class UElevatorMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UElevatorMovementComponent>();
	}
};
static_assert(alignof(UElevatorMovementComponent) == 0x000008, "Wrong alignment on UElevatorMovementComponent");
static_assert(sizeof(UElevatorMovementComponent) == 0x000240, "Wrong size on UElevatorMovementComponent");
static_assert(offsetof(UElevatorMovementComponent, OnStartedMovement) == 0x000108, "Member 'UElevatorMovementComponent::OnStartedMovement' has a wrong offset!");
static_assert(offsetof(UElevatorMovementComponent, OnFinishedMovement) == 0x000118, "Member 'UElevatorMovementComponent::OnFinishedMovement' has a wrong offset!");
static_assert(offsetof(UElevatorMovementComponent, ElevatorComponentRef) == 0x000128, "Member 'UElevatorMovementComponent::ElevatorComponentRef' has a wrong offset!");
static_assert(offsetof(UElevatorMovementComponent, DestinationComponentRef) == 0x000150, "Member 'UElevatorMovementComponent::DestinationComponentRef' has a wrong offset!");
static_assert(offsetof(UElevatorMovementComponent, Speed) == 0x000178, "Member 'UElevatorMovementComponent::Speed' has a wrong offset!");
static_assert(offsetof(UElevatorMovementComponent, MovementCurve) == 0x000180, "Member 'UElevatorMovementComponent::MovementCurve' has a wrong offset!");
static_assert(offsetof(UElevatorMovementComponent, DelayBeforeMove) == 0x000208, "Member 'UElevatorMovementComponent::DelayBeforeMove' has a wrong offset!");
static_assert(offsetof(UElevatorMovementComponent, bSweep) == 0x00020C, "Member 'UElevatorMovementComponent::bSweep' has a wrong offset!");
static_assert(offsetof(UElevatorMovementComponent, TeleportType) == 0x00020D, "Member 'UElevatorMovementComponent::TeleportType' has a wrong offset!");

// Class Zion.ElevatorStateManagerComponent
// 0x0058 (0x00F8 - 0x00A0)
class UElevatorStateManagerComponent final : public UActorComponent
{
public:
	TMap<struct FClearActorData, EElevatorState>  ElevatorStates;                                    // 0x00A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UElevatorStateManagerComponent* Get(const class UObject* WorldContextObject);

	void ClearElevatorStates();
	void OnGameMapChangeFinished();
	EElevatorState RegisterElevatorState(const class AMovingPlatform_Elevator* ElevatorActor);

	EElevatorState GetElevatorState(const class AMovingPlatform_Elevator* ElevatorActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ElevatorStateManagerComponent">();
	}
	static class UElevatorStateManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UElevatorStateManagerComponent>();
	}
};
static_assert(alignof(UElevatorStateManagerComponent) == 0x000008, "Wrong alignment on UElevatorStateManagerComponent");
static_assert(sizeof(UElevatorStateManagerComponent) == 0x0000F8, "Wrong size on UElevatorStateManagerComponent");
static_assert(offsetof(UElevatorStateManagerComponent, ElevatorStates) == 0x0000A0, "Member 'UElevatorStateManagerComponent::ElevatorStates' has a wrong offset!");

// Class Zion.EmulatedFogManagerComponent
// 0x0218 (0x02B8 - 0x00A0)
class UEmulatedFogManagerComponent final : public UActorComponent
{
public:
	class UMaterialParameterCollection*           EmulatedFogMPC;                                    // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x210];                                     // 0x00A8(0x0210)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmulatedFogManagerComponent">();
	}
	static class UEmulatedFogManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmulatedFogManagerComponent>();
	}
};
static_assert(alignof(UEmulatedFogManagerComponent) == 0x000008, "Wrong alignment on UEmulatedFogManagerComponent");
static_assert(sizeof(UEmulatedFogManagerComponent) == 0x0002B8, "Wrong size on UEmulatedFogManagerComponent");
static_assert(offsetof(UEmulatedFogManagerComponent, EmulatedFogMPC) == 0x0000A0, "Member 'UEmulatedFogManagerComponent::EmulatedFogMPC' has a wrong offset!");

// Class Zion.EquipmentComponent
// 0x00A0 (0x0140 - 0x00A0)
class UEquipmentComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x38];                                      // 0x00A0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EEquipmentSlot, struct FEquippedItem>    EquippedItems;                                     // 0x00D8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	int32                                         CurrentLoadoutIndex;                               // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerEquipmentLoadoutData>    EquipmentLoadouts;                                 // 0x0130(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Equip(EEquipmentSlot EquipmentSlot, const class FName& EquipmentID, bool bAddToCurrentLoadout);
	void EquipEquipmentLoadout(int32 LoadoutIndex);
	void OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn);
	void UnEquip(EEquipmentSlot EquipmentSlot, bool bRemoveFromCurrentLoadout);
	void UnEquipAll(bool bRemoveFromCurrentLoadout);

	int32 GetCurrentEquipmentLoadoutIndex() const;
	const struct FInventoryItemEquipmentData GetEquipmentDataFromID(const class FName& EquipmentID) const;
	const struct FInventoryItemEquipmentData GetEquipmentDataFromSlot(EEquipmentSlot EquipmentSlot) const;
	class FName GetEquipmentIDFromSlot(EEquipmentSlot EquipmentSlot) const;
	bool IsEquipped(const class FName& EquipmentID) const;
	bool IsEquippedOnSlot(EEquipmentSlot EquipmentSlot, const class FName& EquipmentID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentComponent">();
	}
	static class UEquipmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentComponent>();
	}
};
static_assert(alignof(UEquipmentComponent) == 0x000008, "Wrong alignment on UEquipmentComponent");
static_assert(sizeof(UEquipmentComponent) == 0x000140, "Wrong size on UEquipmentComponent");
static_assert(offsetof(UEquipmentComponent, EquippedItems) == 0x0000D8, "Member 'UEquipmentComponent::EquippedItems' has a wrong offset!");
static_assert(offsetof(UEquipmentComponent, CurrentLoadoutIndex) == 0x000128, "Member 'UEquipmentComponent::CurrentLoadoutIndex' has a wrong offset!");
static_assert(offsetof(UEquipmentComponent, EquipmentLoadouts) == 0x000130, "Member 'UEquipmentComponent::EquipmentLoadouts' has a wrong offset!");

// Class Zion.EventAction_CameraShake
// 0x0020 (0x0070 - 0x0050)
class UEventAction_CameraShake final : public UEventAction
{
public:
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InnerRadius;                                       // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OuterRadius;                                       // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Falloff;                                           // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOrientShakeTowardsEpicenter;                      // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_65[0xB];                                       // 0x0065(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_CameraShake">();
	}
	static class UEventAction_CameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_CameraShake>();
	}
};
static_assert(alignof(UEventAction_CameraShake) == 0x000008, "Wrong alignment on UEventAction_CameraShake");
static_assert(sizeof(UEventAction_CameraShake) == 0x000070, "Wrong size on UEventAction_CameraShake");
static_assert(offsetof(UEventAction_CameraShake, CameraShake) == 0x000050, "Member 'UEventAction_CameraShake::CameraShake' has a wrong offset!");
static_assert(offsetof(UEventAction_CameraShake, InnerRadius) == 0x000058, "Member 'UEventAction_CameraShake::InnerRadius' has a wrong offset!");
static_assert(offsetof(UEventAction_CameraShake, OuterRadius) == 0x00005C, "Member 'UEventAction_CameraShake::OuterRadius' has a wrong offset!");
static_assert(offsetof(UEventAction_CameraShake, Falloff) == 0x000060, "Member 'UEventAction_CameraShake::Falloff' has a wrong offset!");
static_assert(offsetof(UEventAction_CameraShake, bOrientShakeTowardsEpicenter) == 0x000064, "Member 'UEventAction_CameraShake::bOrientShakeTowardsEpicenter' has a wrong offset!");

// Class Zion.EventAction_ClearEventIdleOverride
// 0x0000 (0x0058 - 0x0058)
class UEventAction_ClearEventIdleOverride final : public UEventAction_SubjectBinding
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_ClearEventIdleOverride">();
	}
	static class UEventAction_ClearEventIdleOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_ClearEventIdleOverride>();
	}
};
static_assert(alignof(UEventAction_ClearEventIdleOverride) == 0x000008, "Wrong alignment on UEventAction_ClearEventIdleOverride");
static_assert(sizeof(UEventAction_ClearEventIdleOverride) == 0x000058, "Wrong size on UEventAction_ClearEventIdleOverride");

// Class Zion.EventAction_ConvertToNPC
// 0x0030 (0x00B8 - 0x0088)
class UEventAction_ConvertToNPC final : public UEventAction_Convert
{
public:
	TSoftClassPtr<class UClass>                   NPCClass;                                          // 0x0088(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACharacterZionNPC>          LoadedNPCClass;                                    // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_ConvertToNPC">();
	}
	static class UEventAction_ConvertToNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_ConvertToNPC>();
	}
};
static_assert(alignof(UEventAction_ConvertToNPC) == 0x000008, "Wrong alignment on UEventAction_ConvertToNPC");
static_assert(sizeof(UEventAction_ConvertToNPC) == 0x0000B8, "Wrong size on UEventAction_ConvertToNPC");
static_assert(offsetof(UEventAction_ConvertToNPC, NPCClass) == 0x000088, "Member 'UEventAction_ConvertToNPC::NPCClass' has a wrong offset!");
static_assert(offsetof(UEventAction_ConvertToNPC, LoadedNPCClass) == 0x0000B0, "Member 'UEventAction_ConvertToNPC::LoadedNPCClass' has a wrong offset!");

// Class Zion.EventAction_DismissSpirits
// 0x0008 (0x0058 - 0x0050)
class UEventAction_DismissSpirits final : public UEventAction
{
public:
	bool                                          bInstant;                                          // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_DismissSpirits">();
	}
	static class UEventAction_DismissSpirits* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_DismissSpirits>();
	}
};
static_assert(alignof(UEventAction_DismissSpirits) == 0x000008, "Wrong alignment on UEventAction_DismissSpirits");
static_assert(sizeof(UEventAction_DismissSpirits) == 0x000058, "Wrong size on UEventAction_DismissSpirits");
static_assert(offsetof(UEventAction_DismissSpirits, bInstant) == 0x000050, "Member 'UEventAction_DismissSpirits::bInstant' has a wrong offset!");

// Class Zion.EventAction_EquipSkills
// 0x0058 (0x00A8 - 0x0050)
class UEventAction_EquipSkills final : public UEventAction
{
public:
	bool                                          bOnlyIfSetIsEmpty;                                 // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESkillSlot, struct FDataTableRowHandle>  SkillsToEquip;                                     // 0x0058(0x0050)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_EquipSkills">();
	}
	static class UEventAction_EquipSkills* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_EquipSkills>();
	}
};
static_assert(alignof(UEventAction_EquipSkills) == 0x000008, "Wrong alignment on UEventAction_EquipSkills");
static_assert(sizeof(UEventAction_EquipSkills) == 0x0000A8, "Wrong size on UEventAction_EquipSkills");
static_assert(offsetof(UEventAction_EquipSkills, bOnlyIfSetIsEmpty) == 0x000050, "Member 'UEventAction_EquipSkills::bOnlyIfSetIsEmpty' has a wrong offset!");
static_assert(offsetof(UEventAction_EquipSkills, SkillsToEquip) == 0x000058, "Member 'UEventAction_EquipSkills::SkillsToEquip' has a wrong offset!");

// Class Zion.EventAction_ExecuteRecollectionBossFight
// 0x0010 (0x0060 - 0x0050)
class UEventAction_ExecuteRecollectionBossFight final : public UEventAction
{
public:
	class FName                                   IsBossRushKey;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   RecollectionBossDataKey;                           // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_ExecuteRecollectionBossFight">();
	}
	static class UEventAction_ExecuteRecollectionBossFight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_ExecuteRecollectionBossFight>();
	}
};
static_assert(alignof(UEventAction_ExecuteRecollectionBossFight) == 0x000008, "Wrong alignment on UEventAction_ExecuteRecollectionBossFight");
static_assert(sizeof(UEventAction_ExecuteRecollectionBossFight) == 0x000060, "Wrong size on UEventAction_ExecuteRecollectionBossFight");
static_assert(offsetof(UEventAction_ExecuteRecollectionBossFight, IsBossRushKey) == 0x000050, "Member 'UEventAction_ExecuteRecollectionBossFight::IsBossRushKey' has a wrong offset!");
static_assert(offsetof(UEventAction_ExecuteRecollectionBossFight, RecollectionBossDataKey) == 0x000058, "Member 'UEventAction_ExecuteRecollectionBossFight::RecollectionBossDataKey' has a wrong offset!");

// Class Zion.EventAction_FadeSetup
// 0x0028 (0x0078 - 0x0050)
class UEventAction_FadeSetup final : public UEventAction
{
public:
	struct FFadeDescriptionData                   FadeDescription;                                   // 0x0050(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	EFadeLayer                                    FadeLayer;                                         // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_FadeSetup">();
	}
	static class UEventAction_FadeSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_FadeSetup>();
	}
};
static_assert(alignof(UEventAction_FadeSetup) == 0x000008, "Wrong alignment on UEventAction_FadeSetup");
static_assert(sizeof(UEventAction_FadeSetup) == 0x000078, "Wrong size on UEventAction_FadeSetup");
static_assert(offsetof(UEventAction_FadeSetup, FadeDescription) == 0x000050, "Member 'UEventAction_FadeSetup::FadeDescription' has a wrong offset!");
static_assert(offsetof(UEventAction_FadeSetup, FadeLayer) == 0x000070, "Member 'UEventAction_FadeSetup::FadeLayer' has a wrong offset!");

// Class Zion.EventAction_GrantItemsFromBlackboard
// 0x0020 (0x00A0 - 0x0080)
class UEventAction_GrantItemsFromBlackboard final : public UEventAction_GrantItemsBase
{
public:
	TArray<class FName>                           ItemBlackboardKeys;                                // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_GrantItemsFromBlackboard">();
	}
	static class UEventAction_GrantItemsFromBlackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_GrantItemsFromBlackboard>();
	}
};
static_assert(alignof(UEventAction_GrantItemsFromBlackboard) == 0x000008, "Wrong alignment on UEventAction_GrantItemsFromBlackboard");
static_assert(sizeof(UEventAction_GrantItemsFromBlackboard) == 0x0000A0, "Wrong size on UEventAction_GrantItemsFromBlackboard");
static_assert(offsetof(UEventAction_GrantItemsFromBlackboard, ItemBlackboardKeys) == 0x000080, "Member 'UEventAction_GrantItemsFromBlackboard::ItemBlackboardKeys' has a wrong offset!");

// Class Zion.EventAction_MarkEventAsCleared
// 0x0000 (0x0050 - 0x0050)
class UEventAction_MarkEventAsCleared final : public UEventAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_MarkEventAsCleared">();
	}
	static class UEventAction_MarkEventAsCleared* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_MarkEventAsCleared>();
	}
};
static_assert(alignof(UEventAction_MarkEventAsCleared) == 0x000008, "Wrong alignment on UEventAction_MarkEventAsCleared");
static_assert(sizeof(UEventAction_MarkEventAsCleared) == 0x000050, "Wrong size on UEventAction_MarkEventAsCleared");

// Class Zion.EventAction_Material_SetParameter
// 0x00C0 (0x0118 - 0x0058)
class UEventAction_Material_SetParameter final : public UEventAction_SubjectBinding
{
public:
	TArray<struct FComponentReference>            RenderComponentRefs;                               // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FName                                   ParameterName;                                     // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMaterialParameterMode                        Mode;                                              // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0078(0x0088)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x18];                                     // 0x0100(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_Material_SetParameter">();
	}
	static class UEventAction_Material_SetParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_Material_SetParameter>();
	}
};
static_assert(alignof(UEventAction_Material_SetParameter) == 0x000008, "Wrong alignment on UEventAction_Material_SetParameter");
static_assert(sizeof(UEventAction_Material_SetParameter) == 0x000118, "Wrong size on UEventAction_Material_SetParameter");
static_assert(offsetof(UEventAction_Material_SetParameter, RenderComponentRefs) == 0x000058, "Member 'UEventAction_Material_SetParameter::RenderComponentRefs' has a wrong offset!");
static_assert(offsetof(UEventAction_Material_SetParameter, ParameterName) == 0x000068, "Member 'UEventAction_Material_SetParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(UEventAction_Material_SetParameter, Mode) == 0x000070, "Member 'UEventAction_Material_SetParameter::Mode' has a wrong offset!");
static_assert(offsetof(UEventAction_Material_SetParameter, Value) == 0x000074, "Member 'UEventAction_Material_SetParameter::Value' has a wrong offset!");
static_assert(offsetof(UEventAction_Material_SetParameter, Curve) == 0x000078, "Member 'UEventAction_Material_SetParameter::Curve' has a wrong offset!");

// Class Zion.EventAction_MoveTo_Actor
// 0x0038 (0x0100 - 0x00C8)
class UEventAction_MoveTo_Actor final : public UEventAction_MoveTo
{
public:
	struct FActorBindingKey                       TargetBinding;                                     // 0x00C8(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TargetLocalOffset;                                 // 0x00D0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                WorldOffset;                                       // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_MoveTo_Actor">();
	}
	static class UEventAction_MoveTo_Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_MoveTo_Actor>();
	}
};
static_assert(alignof(UEventAction_MoveTo_Actor) == 0x000008, "Wrong alignment on UEventAction_MoveTo_Actor");
static_assert(sizeof(UEventAction_MoveTo_Actor) == 0x000100, "Wrong size on UEventAction_MoveTo_Actor");
static_assert(offsetof(UEventAction_MoveTo_Actor, TargetBinding) == 0x0000C8, "Member 'UEventAction_MoveTo_Actor::TargetBinding' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_Actor, TargetLocalOffset) == 0x0000D0, "Member 'UEventAction_MoveTo_Actor::TargetLocalOffset' has a wrong offset!");
static_assert(offsetof(UEventAction_MoveTo_Actor, WorldOffset) == 0x0000E8, "Member 'UEventAction_MoveTo_Actor::WorldOffset' has a wrong offset!");

// Class Zion.Passive_ReduceCommandSetCooldown
// 0x0008 (0x0038 - 0x0030)
class UPassive_ReduceCommandSetCooldown final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_ReduceCommandSetCooldown">();
	}
	static class UPassive_ReduceCommandSetCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_ReduceCommandSetCooldown>();
	}
};
static_assert(alignof(UPassive_ReduceCommandSetCooldown) == 0x000008, "Wrong alignment on UPassive_ReduceCommandSetCooldown");
static_assert(sizeof(UPassive_ReduceCommandSetCooldown) == 0x000038, "Wrong size on UPassive_ReduceCommandSetCooldown");
static_assert(offsetof(UPassive_ReduceCommandSetCooldown, PercentageBonus) == 0x000030, "Member 'UPassive_ReduceCommandSetCooldown::PercentageBonus' has a wrong offset!");

// Class Zion.EventAction_OpenUI
// 0x0010 (0x0060 - 0x0050)
class UEventAction_OpenUI final : public UEventAction
{
public:
	TSubclassOf<class UUserWidgetZion>            UserWidgetClass;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWidgetDestruct();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_OpenUI">();
	}
	static class UEventAction_OpenUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_OpenUI>();
	}
};
static_assert(alignof(UEventAction_OpenUI) == 0x000008, "Wrong alignment on UEventAction_OpenUI");
static_assert(sizeof(UEventAction_OpenUI) == 0x000060, "Wrong size on UEventAction_OpenUI");
static_assert(offsetof(UEventAction_OpenUI, UserWidgetClass) == 0x000050, "Member 'UEventAction_OpenUI::UserWidgetClass' has a wrong offset!");

// Class Zion.EventAction_OpenWorld
// 0x0070 (0x00C0 - 0x0050)
class UEventAction_OpenWorld final : public UEventAction
{
public:
	TSoftObjectPtr<class UWorld>                  World;                                             // 0x0050(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PlayerStartTag;                                    // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFadeDescriptionData                   FadeOutDescription;                                // 0x0080(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FFadeDescriptionData                   FadeInDescription;                                 // 0x00A0(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_OpenWorld">();
	}
	static class UEventAction_OpenWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_OpenWorld>();
	}
};
static_assert(alignof(UEventAction_OpenWorld) == 0x000008, "Wrong alignment on UEventAction_OpenWorld");
static_assert(sizeof(UEventAction_OpenWorld) == 0x0000C0, "Wrong size on UEventAction_OpenWorld");
static_assert(offsetof(UEventAction_OpenWorld, World) == 0x000050, "Member 'UEventAction_OpenWorld::World' has a wrong offset!");
static_assert(offsetof(UEventAction_OpenWorld, PlayerStartTag) == 0x000078, "Member 'UEventAction_OpenWorld::PlayerStartTag' has a wrong offset!");
static_assert(offsetof(UEventAction_OpenWorld, FadeOutDescription) == 0x000080, "Member 'UEventAction_OpenWorld::FadeOutDescription' has a wrong offset!");
static_assert(offsetof(UEventAction_OpenWorld, FadeInDescription) == 0x0000A0, "Member 'UEventAction_OpenWorld::FadeInDescription' has a wrong offset!");

// Class Zion.Passive_AttackDamageBack
// 0x0008 (0x0038 - 0x0030)
class UPassive_AttackDamageBack final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AttackDamageBack">();
	}
	static class UPassive_AttackDamageBack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AttackDamageBack>();
	}
};
static_assert(alignof(UPassive_AttackDamageBack) == 0x000008, "Wrong alignment on UPassive_AttackDamageBack");
static_assert(sizeof(UPassive_AttackDamageBack) == 0x000038, "Wrong size on UPassive_AttackDamageBack");
static_assert(offsetof(UPassive_AttackDamageBack, PercentageBonus) == 0x000030, "Member 'UPassive_AttackDamageBack::PercentageBonus' has a wrong offset!");

// Class Zion.EventAction_OpenWorldSpaceWidget
// 0x0040 (0x0098 - 0x0058)
class UEventAction_OpenWorldSpaceWidget final : public UEventAction_SubjectBinding
{
public:
	TSubclassOf<class UUserWidgetWorldSpace>      WidgetClass;                                       // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LocalSpaceOffset;                                  // 0x0060(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAttachToSubject;                                  // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x1F];                                      // 0x0079(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_OpenWorldSpaceWidget">();
	}
	static class UEventAction_OpenWorldSpaceWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_OpenWorldSpaceWidget>();
	}
};
static_assert(alignof(UEventAction_OpenWorldSpaceWidget) == 0x000008, "Wrong alignment on UEventAction_OpenWorldSpaceWidget");
static_assert(sizeof(UEventAction_OpenWorldSpaceWidget) == 0x000098, "Wrong size on UEventAction_OpenWorldSpaceWidget");
static_assert(offsetof(UEventAction_OpenWorldSpaceWidget, WidgetClass) == 0x000058, "Member 'UEventAction_OpenWorldSpaceWidget::WidgetClass' has a wrong offset!");
static_assert(offsetof(UEventAction_OpenWorldSpaceWidget, LocalSpaceOffset) == 0x000060, "Member 'UEventAction_OpenWorldSpaceWidget::LocalSpaceOffset' has a wrong offset!");
static_assert(offsetof(UEventAction_OpenWorldSpaceWidget, bAttachToSubject) == 0x000078, "Member 'UEventAction_OpenWorldSpaceWidget::bAttachToSubject' has a wrong offset!");

// Class Zion.EventAction_PlayAnimations
// 0x0018 (0x0070 - 0x0058)
class UEventAction_PlayAnimations final : public UEventAction_SubjectBinding
{
public:
	TArray<struct FSpineAnimationDefinition>      AnimationDefinitions;                              // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_PlayAnimations">();
	}
	static class UEventAction_PlayAnimations* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_PlayAnimations>();
	}
};
static_assert(alignof(UEventAction_PlayAnimations) == 0x000008, "Wrong alignment on UEventAction_PlayAnimations");
static_assert(sizeof(UEventAction_PlayAnimations) == 0x000070, "Wrong size on UEventAction_PlayAnimations");
static_assert(offsetof(UEventAction_PlayAnimations, AnimationDefinitions) == 0x000058, "Member 'UEventAction_PlayAnimations::AnimationDefinitions' has a wrong offset!");

// Class Zion.EventAction_PlayFX
// 0x0118 (0x0170 - 0x0058)
class UEventAction_PlayFX final : public UEventAction_SubjectBinding
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           FXData;                                            // 0x0060(0x0100)(Edit, NativeAccessSpecifierPrivate)
	class FName                                   BlackboardID;                                      // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSystemCompleted(class UNiagaraComponent* PSystem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_PlayFX">();
	}
	static class UEventAction_PlayFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_PlayFX>();
	}
};
static_assert(alignof(UEventAction_PlayFX) == 0x000010, "Wrong alignment on UEventAction_PlayFX");
static_assert(sizeof(UEventAction_PlayFX) == 0x000170, "Wrong size on UEventAction_PlayFX");
static_assert(offsetof(UEventAction_PlayFX, FXData) == 0x000060, "Member 'UEventAction_PlayFX::FXData' has a wrong offset!");
static_assert(offsetof(UEventAction_PlayFX, BlackboardID) == 0x000160, "Member 'UEventAction_PlayFX::BlackboardID' has a wrong offset!");

// Class Zion.Passive_OnKill_RestoreSP
// 0x0008 (0x0060 - 0x0058)
class UPassive_OnKill_RestoreSP final : public UPassive_OnKill_Restore
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_OnKill_RestoreSP">();
	}
	static class UPassive_OnKill_RestoreSP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_OnKill_RestoreSP>();
	}
};
static_assert(alignof(UPassive_OnKill_RestoreSP) == 0x000008, "Wrong alignment on UPassive_OnKill_RestoreSP");
static_assert(sizeof(UPassive_OnKill_RestoreSP) == 0x000060, "Wrong size on UPassive_OnKill_RestoreSP");

// Class Zion.EventAction_PlayLevelSequence
// 0x0038 (0x0088 - 0x0050)
class UEventAction_PlayLevelSequence final : public UEventAction
{
public:
	class ULevelSequence*                         LevelSequence;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMovieSceneSequencePlaybackSettings    SequenceSettings;                                  // 0x0058(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelSequenceFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_PlayLevelSequence">();
	}
	static class UEventAction_PlayLevelSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_PlayLevelSequence>();
	}
};
static_assert(alignof(UEventAction_PlayLevelSequence) == 0x000008, "Wrong alignment on UEventAction_PlayLevelSequence");
static_assert(sizeof(UEventAction_PlayLevelSequence) == 0x000088, "Wrong size on UEventAction_PlayLevelSequence");
static_assert(offsetof(UEventAction_PlayLevelSequence, LevelSequence) == 0x000050, "Member 'UEventAction_PlayLevelSequence::LevelSequence' has a wrong offset!");
static_assert(offsetof(UEventAction_PlayLevelSequence, SequenceSettings) == 0x000058, "Member 'UEventAction_PlayLevelSequence::SequenceSettings' has a wrong offset!");

// Class Zion.Passive_AttackCommandSetCategory
// 0x0008 (0x0038 - 0x0030)
class UPassive_AttackCommandSetCategory : public UPassive
{
public:
	ECommandSetCategory                           CommandSetCategory;                                // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AttackCommandSetCategory">();
	}
	static class UPassive_AttackCommandSetCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AttackCommandSetCategory>();
	}
};
static_assert(alignof(UPassive_AttackCommandSetCategory) == 0x000008, "Wrong alignment on UPassive_AttackCommandSetCategory");
static_assert(sizeof(UPassive_AttackCommandSetCategory) == 0x000038, "Wrong size on UPassive_AttackCommandSetCategory");
static_assert(offsetof(UPassive_AttackCommandSetCategory, CommandSetCategory) == 0x000030, "Member 'UPassive_AttackCommandSetCategory::CommandSetCategory' has a wrong offset!");
static_assert(offsetof(UPassive_AttackCommandSetCategory, PercentageBonus) == 0x000034, "Member 'UPassive_AttackCommandSetCategory::PercentageBonus' has a wrong offset!");

// Class Zion.EventAction_PlaySE
// 0x0008 (0x0060 - 0x0058)
class UEventAction_PlaySE final : public UEventAction_SubjectBinding
{
public:
	class UFMODEvent*                             SoundEvent;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_PlaySE">();
	}
	static class UEventAction_PlaySE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_PlaySE>();
	}
};
static_assert(alignof(UEventAction_PlaySE) == 0x000008, "Wrong alignment on UEventAction_PlaySE");
static_assert(sizeof(UEventAction_PlaySE) == 0x000060, "Wrong size on UEventAction_PlaySE");
static_assert(offsetof(UEventAction_PlaySE, SoundEvent) == 0x000058, "Member 'UEventAction_PlaySE::SoundEvent' has a wrong offset!");

// Class Zion.EventAction_RemoveItems
// 0x0010 (0x0060 - 0x0050)
class UEventAction_RemoveItems final : public UEventAction
{
public:
	TArray<struct FItemHandleCount>               ItemHandleCounts;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_RemoveItems">();
	}
	static class UEventAction_RemoveItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_RemoveItems>();
	}
};
static_assert(alignof(UEventAction_RemoveItems) == 0x000008, "Wrong alignment on UEventAction_RemoveItems");
static_assert(sizeof(UEventAction_RemoveItems) == 0x000060, "Wrong size on UEventAction_RemoveItems");
static_assert(offsetof(UEventAction_RemoveItems, ItemHandleCounts) == 0x000050, "Member 'UEventAction_RemoveItems::ItemHandleCounts' has a wrong offset!");

// Class Zion.Passive_AttackDamageSPGauge
// 0x0010 (0x0040 - 0x0030)
class UPassive_AttackDamageSPGauge final : public UPassive
{
public:
	int32                                         NoGaugePercentageBonus;                            // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         OneGaugePercentageBonus;                           // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TwoGaugesPercentageBonus;                          // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ThreeGaugesPercentageBonus;                        // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AttackDamageSPGauge">();
	}
	static class UPassive_AttackDamageSPGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AttackDamageSPGauge>();
	}
};
static_assert(alignof(UPassive_AttackDamageSPGauge) == 0x000008, "Wrong alignment on UPassive_AttackDamageSPGauge");
static_assert(sizeof(UPassive_AttackDamageSPGauge) == 0x000040, "Wrong size on UPassive_AttackDamageSPGauge");
static_assert(offsetof(UPassive_AttackDamageSPGauge, NoGaugePercentageBonus) == 0x000030, "Member 'UPassive_AttackDamageSPGauge::NoGaugePercentageBonus' has a wrong offset!");
static_assert(offsetof(UPassive_AttackDamageSPGauge, OneGaugePercentageBonus) == 0x000034, "Member 'UPassive_AttackDamageSPGauge::OneGaugePercentageBonus' has a wrong offset!");
static_assert(offsetof(UPassive_AttackDamageSPGauge, TwoGaugesPercentageBonus) == 0x000038, "Member 'UPassive_AttackDamageSPGauge::TwoGaugesPercentageBonus' has a wrong offset!");
static_assert(offsetof(UPassive_AttackDamageSPGauge, ThreeGaugesPercentageBonus) == 0x00003C, "Member 'UPassive_AttackDamageSPGauge::ThreeGaugesPercentageBonus' has a wrong offset!");

// Class Zion.EventAction_ResetClearedObjects
// 0x0000 (0x0050 - 0x0050)
class UEventAction_ResetClearedObjects final : public UEventAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_ResetClearedObjects">();
	}
	static class UEventAction_ResetClearedObjects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_ResetClearedObjects>();
	}
};
static_assert(alignof(UEventAction_ResetClearedObjects) == 0x000008, "Wrong alignment on UEventAction_ResetClearedObjects");
static_assert(sizeof(UEventAction_ResetClearedObjects) == 0x000050, "Wrong size on UEventAction_ResetClearedObjects");

// Class Zion.EventAction_RestorePlayer
// 0x0000 (0x0050 - 0x0050)
class UEventAction_RestorePlayer final : public UEventAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_RestorePlayer">();
	}
	static class UEventAction_RestorePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_RestorePlayer>();
	}
};
static_assert(alignof(UEventAction_RestorePlayer) == 0x000008, "Wrong alignment on UEventAction_RestorePlayer");
static_assert(sizeof(UEventAction_RestorePlayer) == 0x000050, "Wrong size on UEventAction_RestorePlayer");

// Class Zion.Passive_AttackDamageFront
// 0x0008 (0x0038 - 0x0030)
class UPassive_AttackDamageFront final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AttackDamageFront">();
	}
	static class UPassive_AttackDamageFront* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AttackDamageFront>();
	}
};
static_assert(alignof(UPassive_AttackDamageFront) == 0x000008, "Wrong alignment on UPassive_AttackDamageFront");
static_assert(sizeof(UPassive_AttackDamageFront) == 0x000038, "Wrong size on UPassive_AttackDamageFront");
static_assert(offsetof(UPassive_AttackDamageFront, PercentageBonus) == 0x000030, "Member 'UPassive_AttackDamageFront::PercentageBonus' has a wrong offset!");

// Class Zion.EventAction_SaveGame
// 0x0008 (0x0058 - 0x0050)
class UEventAction_SaveGame final : public UEventAction
{
public:
	bool                                          bUseAsyncSave;                                     // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSaveFinished(bool bResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_SaveGame">();
	}
	static class UEventAction_SaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_SaveGame>();
	}
};
static_assert(alignof(UEventAction_SaveGame) == 0x000008, "Wrong alignment on UEventAction_SaveGame");
static_assert(sizeof(UEventAction_SaveGame) == 0x000058, "Wrong size on UEventAction_SaveGame");
static_assert(offsetof(UEventAction_SaveGame, bUseAsyncSave) == 0x000050, "Member 'UEventAction_SaveGame::bUseAsyncSave' has a wrong offset!");

// Class Zion.EventAction_SetEventIdleOverride
// 0x0028 (0x0080 - 0x0058)
class UEventAction_SetEventIdleOverride final : public UEventAction_SubjectBinding
{
public:
	TArray<struct FSpineAnimationDefinition>      IdleDefinitions;                                   // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bOverrideTurn;                                     // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      TurnDefinitions;                                   // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_SetEventIdleOverride">();
	}
	static class UEventAction_SetEventIdleOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_SetEventIdleOverride>();
	}
};
static_assert(alignof(UEventAction_SetEventIdleOverride) == 0x000008, "Wrong alignment on UEventAction_SetEventIdleOverride");
static_assert(sizeof(UEventAction_SetEventIdleOverride) == 0x000080, "Wrong size on UEventAction_SetEventIdleOverride");
static_assert(offsetof(UEventAction_SetEventIdleOverride, IdleDefinitions) == 0x000058, "Member 'UEventAction_SetEventIdleOverride::IdleDefinitions' has a wrong offset!");
static_assert(offsetof(UEventAction_SetEventIdleOverride, bOverrideTurn) == 0x000068, "Member 'UEventAction_SetEventIdleOverride::bOverrideTurn' has a wrong offset!");
static_assert(offsetof(UEventAction_SetEventIdleOverride, TurnDefinitions) == 0x000070, "Member 'UEventAction_SetEventIdleOverride::TurnDefinitions' has a wrong offset!");

// Class Zion.Passive_AttackDamageMinSP
// 0x0008 (0x0038 - 0x0030)
class UPassive_AttackDamageMinSP final : public UPassive
{
public:
	int32                                         SPPercentage;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AttackDamageMinSP">();
	}
	static class UPassive_AttackDamageMinSP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AttackDamageMinSP>();
	}
};
static_assert(alignof(UPassive_AttackDamageMinSP) == 0x000008, "Wrong alignment on UPassive_AttackDamageMinSP");
static_assert(sizeof(UPassive_AttackDamageMinSP) == 0x000038, "Wrong size on UPassive_AttackDamageMinSP");
static_assert(offsetof(UPassive_AttackDamageMinSP, SPPercentage) == 0x000030, "Member 'UPassive_AttackDamageMinSP::SPPercentage' has a wrong offset!");
static_assert(offsetof(UPassive_AttackDamageMinSP, PercentageBonus) == 0x000034, "Member 'UPassive_AttackDamageMinSP::PercentageBonus' has a wrong offset!");

// Class Zion.EventAction_SetFacing_Actor
// 0x0008 (0x0080 - 0x0078)
class UEventAction_SetFacing_Actor final : public UEventAction_SetFacing
{
public:
	struct FActorBindingKey                       TargetBinding;                                     // 0x0078(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_SetFacing_Actor">();
	}
	static class UEventAction_SetFacing_Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_SetFacing_Actor>();
	}
};
static_assert(alignof(UEventAction_SetFacing_Actor) == 0x000008, "Wrong alignment on UEventAction_SetFacing_Actor");
static_assert(sizeof(UEventAction_SetFacing_Actor) == 0x000080, "Wrong size on UEventAction_SetFacing_Actor");
static_assert(offsetof(UEventAction_SetFacing_Actor, TargetBinding) == 0x000078, "Member 'UEventAction_SetFacing_Actor::TargetBinding' has a wrong offset!");

// Class Zion.Passive_DamageCutAboveDistance
// 0x0008 (0x0038 - 0x0030)
class UPassive_DamageCutAboveDistance final : public UPassive
{
public:
	int32                                         Distance;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DamageCutAboveDistance">();
	}
	static class UPassive_DamageCutAboveDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DamageCutAboveDistance>();
	}
};
static_assert(alignof(UPassive_DamageCutAboveDistance) == 0x000008, "Wrong alignment on UPassive_DamageCutAboveDistance");
static_assert(sizeof(UPassive_DamageCutAboveDistance) == 0x000038, "Wrong size on UPassive_DamageCutAboveDistance");
static_assert(offsetof(UPassive_DamageCutAboveDistance, Distance) == 0x000030, "Member 'UPassive_DamageCutAboveDistance::Distance' has a wrong offset!");
static_assert(offsetof(UPassive_DamageCutAboveDistance, PercentageBonus) == 0x000034, "Member 'UPassive_DamageCutAboveDistance::PercentageBonus' has a wrong offset!");

// Class Zion.EventAction_SetRespawnPointData
// 0x0010 (0x0060 - 0x0050)
class UEventAction_SetRespawnPointData final : public UEventAction
{
public:
	struct FDataTableRowHandle                    RespawnRestPointData;                              // 0x0050(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_SetRespawnPointData">();
	}
	static class UEventAction_SetRespawnPointData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_SetRespawnPointData>();
	}
};
static_assert(alignof(UEventAction_SetRespawnPointData) == 0x000008, "Wrong alignment on UEventAction_SetRespawnPointData");
static_assert(sizeof(UEventAction_SetRespawnPointData) == 0x000060, "Wrong size on UEventAction_SetRespawnPointData");
static_assert(offsetof(UEventAction_SetRespawnPointData, RespawnRestPointData) == 0x000050, "Member 'UEventAction_SetRespawnPointData::RespawnRestPointData' has a wrong offset!");

// Class Zion.EventAction_SetSpineMaterial
// 0x0008 (0x0060 - 0x0058)
class UEventAction_SetSpineMaterial final : public UEventAction_SubjectBinding
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_SetSpineMaterial">();
	}
	static class UEventAction_SetSpineMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_SetSpineMaterial>();
	}
};
static_assert(alignof(UEventAction_SetSpineMaterial) == 0x000008, "Wrong alignment on UEventAction_SetSpineMaterial");
static_assert(sizeof(UEventAction_SetSpineMaterial) == 0x000060, "Wrong size on UEventAction_SetSpineMaterial");
static_assert(offsetof(UEventAction_SetSpineMaterial, Material) == 0x000058, "Member 'UEventAction_SetSpineMaterial::Material' has a wrong offset!");

// Class Zion.Passive_AutoRegenerate
// 0x0020 (0x0050 - 0x0030)
class UPassive_AutoRegenerate : public UPassive
{
public:
	int32                                         ValueToRegenerate;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x10];                                      // 0x0034(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RegenerationTick;                                  // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AutoRegenerate">();
	}
	static class UPassive_AutoRegenerate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AutoRegenerate>();
	}
};
static_assert(alignof(UPassive_AutoRegenerate) == 0x000008, "Wrong alignment on UPassive_AutoRegenerate");
static_assert(sizeof(UPassive_AutoRegenerate) == 0x000050, "Wrong size on UPassive_AutoRegenerate");
static_assert(offsetof(UPassive_AutoRegenerate, ValueToRegenerate) == 0x000030, "Member 'UPassive_AutoRegenerate::ValueToRegenerate' has a wrong offset!");
static_assert(offsetof(UPassive_AutoRegenerate, RegenerationTick) == 0x000044, "Member 'UPassive_AutoRegenerate::RegenerationTick' has a wrong offset!");

// Class Zion.EventAction_SetSpineSkins
// 0x0010 (0x0068 - 0x0058)
class UEventAction_SetSpineSkins final : public UEventAction_SubjectBinding
{
public:
	TArray<class FString>                         Skins;                                             // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_SetSpineSkins">();
	}
	static class UEventAction_SetSpineSkins* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_SetSpineSkins>();
	}
};
static_assert(alignof(UEventAction_SetSpineSkins) == 0x000008, "Wrong alignment on UEventAction_SetSpineSkins");
static_assert(sizeof(UEventAction_SetSpineSkins) == 0x000068, "Wrong size on UEventAction_SetSpineSkins");
static_assert(offsetof(UEventAction_SetSpineSkins, Skins) == 0x000058, "Member 'UEventAction_SetSpineSkins::Skins' has a wrong offset!");

// Class Zion.EventAction_ShowHideActor
// 0x0020 (0x0078 - 0x0058)
class UEventAction_ShowHideActor : public UEventAction_SubjectBinding
{
public:
	float                                         FadeTime;                                          // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Curve;                                             // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FadeParameterName;                                 // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_ShowHideActor">();
	}
	static class UEventAction_ShowHideActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_ShowHideActor>();
	}
};
static_assert(alignof(UEventAction_ShowHideActor) == 0x000008, "Wrong alignment on UEventAction_ShowHideActor");
static_assert(sizeof(UEventAction_ShowHideActor) == 0x000078, "Wrong size on UEventAction_ShowHideActor");
static_assert(offsetof(UEventAction_ShowHideActor, FadeTime) == 0x000058, "Member 'UEventAction_ShowHideActor::FadeTime' has a wrong offset!");
static_assert(offsetof(UEventAction_ShowHideActor, Curve) == 0x000060, "Member 'UEventAction_ShowHideActor::Curve' has a wrong offset!");
static_assert(offsetof(UEventAction_ShowHideActor, FadeParameterName) == 0x000068, "Member 'UEventAction_ShowHideActor::FadeParameterName' has a wrong offset!");

// Class Zion.Passive_AttackDamageMaxSP
// 0x0008 (0x0038 - 0x0030)
class UPassive_AttackDamageMaxSP final : public UPassive
{
public:
	int32                                         SPPercentage;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AttackDamageMaxSP">();
	}
	static class UPassive_AttackDamageMaxSP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AttackDamageMaxSP>();
	}
};
static_assert(alignof(UPassive_AttackDamageMaxSP) == 0x000008, "Wrong alignment on UPassive_AttackDamageMaxSP");
static_assert(sizeof(UPassive_AttackDamageMaxSP) == 0x000038, "Wrong size on UPassive_AttackDamageMaxSP");
static_assert(offsetof(UPassive_AttackDamageMaxSP, SPPercentage) == 0x000030, "Member 'UPassive_AttackDamageMaxSP::SPPercentage' has a wrong offset!");
static_assert(offsetof(UPassive_AttackDamageMaxSP, PercentageBonus) == 0x000034, "Member 'UPassive_AttackDamageMaxSP::PercentageBonus' has a wrong offset!");

// Class Zion.EventAction_ShowActor
// 0x0000 (0x0078 - 0x0078)
class UEventAction_ShowActor final : public UEventAction_ShowHideActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_ShowActor">();
	}
	static class UEventAction_ShowActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_ShowActor>();
	}
};
static_assert(alignof(UEventAction_ShowActor) == 0x000008, "Wrong alignment on UEventAction_ShowActor");
static_assert(sizeof(UEventAction_ShowActor) == 0x000078, "Wrong size on UEventAction_ShowActor");

// Class Zion.EventAction_HideActor
// 0x0000 (0x0078 - 0x0078)
class UEventAction_HideActor final : public UEventAction_ShowHideActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_HideActor">();
	}
	static class UEventAction_HideActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_HideActor>();
	}
};
static_assert(alignof(UEventAction_HideActor) == 0x000008, "Wrong alignment on UEventAction_HideActor");
static_assert(sizeof(UEventAction_HideActor) == 0x000078, "Wrong size on UEventAction_HideActor");

// Class Zion.Passive_CommandSetOverride
// 0x0008 (0x0038 - 0x0030)
class UPassive_CommandSetOverride final : public UPassive
{
public:
	class UCommandSet*                            CommandSet;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_CommandSetOverride">();
	}
	static class UPassive_CommandSetOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_CommandSetOverride>();
	}
};
static_assert(alignof(UPassive_CommandSetOverride) == 0x000008, "Wrong alignment on UPassive_CommandSetOverride");
static_assert(sizeof(UPassive_CommandSetOverride) == 0x000038, "Wrong size on UPassive_CommandSetOverride");
static_assert(offsetof(UPassive_CommandSetOverride, CommandSet) == 0x000030, "Member 'UPassive_CommandSetOverride::CommandSet' has a wrong offset!");

// Class Zion.EventAction_StopAnimation
// 0x0000 (0x0058 - 0x0058)
class UEventAction_StopAnimation final : public UEventAction_SubjectBinding
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_StopAnimation">();
	}
	static class UEventAction_StopAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_StopAnimation>();
	}
};
static_assert(alignof(UEventAction_StopAnimation) == 0x000008, "Wrong alignment on UEventAction_StopAnimation");
static_assert(sizeof(UEventAction_StopAnimation) == 0x000058, "Wrong size on UEventAction_StopAnimation");

// Class Zion.Passive_DamageCutMaxSP
// 0x0008 (0x0038 - 0x0030)
class UPassive_DamageCutMaxSP final : public UPassive
{
public:
	int32                                         SPPercentage;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DamageCutMaxSP">();
	}
	static class UPassive_DamageCutMaxSP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DamageCutMaxSP>();
	}
};
static_assert(alignof(UPassive_DamageCutMaxSP) == 0x000008, "Wrong alignment on UPassive_DamageCutMaxSP");
static_assert(sizeof(UPassive_DamageCutMaxSP) == 0x000038, "Wrong size on UPassive_DamageCutMaxSP");
static_assert(offsetof(UPassive_DamageCutMaxSP, SPPercentage) == 0x000030, "Member 'UPassive_DamageCutMaxSP::SPPercentage' has a wrong offset!");
static_assert(offsetof(UPassive_DamageCutMaxSP, PercentageBonus) == 0x000034, "Member 'UPassive_DamageCutMaxSP::PercentageBonus' has a wrong offset!");

// Class Zion.EventAction_StopFX
// 0x0008 (0x0058 - 0x0050)
class UEventAction_StopFX final : public UEventAction
{
public:
	class FName                                   BlackboardID;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_StopFX">();
	}
	static class UEventAction_StopFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_StopFX>();
	}
};
static_assert(alignof(UEventAction_StopFX) == 0x000008, "Wrong alignment on UEventAction_StopFX");
static_assert(sizeof(UEventAction_StopFX) == 0x000058, "Wrong size on UEventAction_StopFX");
static_assert(offsetof(UEventAction_StopFX, BlackboardID) == 0x000050, "Member 'UEventAction_StopFX::BlackboardID' has a wrong offset!");

// Class Zion.EventAction_SummonEquippedSpirits
// 0x0000 (0x0050 - 0x0050)
class UEventAction_SummonEquippedSpirits final : public UEventAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_SummonEquippedSpirits">();
	}
	static class UEventAction_SummonEquippedSpirits* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_SummonEquippedSpirits>();
	}
};
static_assert(alignof(UEventAction_SummonEquippedSpirits) == 0x000008, "Wrong alignment on UEventAction_SummonEquippedSpirits");
static_assert(sizeof(UEventAction_SummonEquippedSpirits) == 0x000050, "Wrong size on UEventAction_SummonEquippedSpirits");

// Class Zion.Passive_DamageCutBackPercentage
// 0x0008 (0x0038 - 0x0030)
class UPassive_DamageCutBackPercentage final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DamageCutBackPercentage">();
	}
	static class UPassive_DamageCutBackPercentage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DamageCutBackPercentage>();
	}
};
static_assert(alignof(UPassive_DamageCutBackPercentage) == 0x000008, "Wrong alignment on UPassive_DamageCutBackPercentage");
static_assert(sizeof(UPassive_DamageCutBackPercentage) == 0x000038, "Wrong size on UPassive_DamageCutBackPercentage");
static_assert(offsetof(UPassive_DamageCutBackPercentage, PercentageBonus) == 0x000030, "Member 'UPassive_DamageCutBackPercentage::PercentageBonus' has a wrong offset!");

// Class Zion.EventAction_Talk
// 0x0030 (0x0080 - 0x0050)
class UEventAction_Talk final : public UEventAction
{
public:
	class FText                                   Speaker;                                           // 0x0050(0x0010)(Edit, NativeAccessSpecifierPrivate)
	TArray<struct FTalkData>                      TalkData;                                          // 0x0060(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_Talk">();
	}
	static class UEventAction_Talk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_Talk>();
	}
};
static_assert(alignof(UEventAction_Talk) == 0x000008, "Wrong alignment on UEventAction_Talk");
static_assert(sizeof(UEventAction_Talk) == 0x000080, "Wrong size on UEventAction_Talk");
static_assert(offsetof(UEventAction_Talk, Speaker) == 0x000050, "Member 'UEventAction_Talk::Speaker' has a wrong offset!");
static_assert(offsetof(UEventAction_Talk, TalkData) == 0x000060, "Member 'UEventAction_Talk::TalkData' has a wrong offset!");

// Class Zion.EventAction_Talk_Actor
// 0x0098 (0x00F0 - 0x0058)
class UEventAction_Talk_Actor final : public UEventAction_SubjectBinding
{
public:
	TSubclassOf<class UUserWidgetWorldSpaceText_Talk> WidgetWorldSpaceTalk_Class;                    // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EWidgetActorAnchor                            ActorAnchor;                                       // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ActorLocalOffset;                                  // 0x0068(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                WorldOffset;                                       // 0x0080(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAttachToSubject;                                  // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETalkAnimationType                            AnimationType;                                     // 0x0099(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      StartAnimationDefinitions;                         // 0x00A0(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      EndAnimationDefinitions;                           // 0x00B0(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FTalkData>                      TalkData;                                          // 0x00C0(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_Talk_Actor">();
	}
	static class UEventAction_Talk_Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_Talk_Actor>();
	}
};
static_assert(alignof(UEventAction_Talk_Actor) == 0x000008, "Wrong alignment on UEventAction_Talk_Actor");
static_assert(sizeof(UEventAction_Talk_Actor) == 0x0000F0, "Wrong size on UEventAction_Talk_Actor");
static_assert(offsetof(UEventAction_Talk_Actor, WidgetWorldSpaceTalk_Class) == 0x000058, "Member 'UEventAction_Talk_Actor::WidgetWorldSpaceTalk_Class' has a wrong offset!");
static_assert(offsetof(UEventAction_Talk_Actor, ActorAnchor) == 0x000060, "Member 'UEventAction_Talk_Actor::ActorAnchor' has a wrong offset!");
static_assert(offsetof(UEventAction_Talk_Actor, ActorLocalOffset) == 0x000068, "Member 'UEventAction_Talk_Actor::ActorLocalOffset' has a wrong offset!");
static_assert(offsetof(UEventAction_Talk_Actor, WorldOffset) == 0x000080, "Member 'UEventAction_Talk_Actor::WorldOffset' has a wrong offset!");
static_assert(offsetof(UEventAction_Talk_Actor, bAttachToSubject) == 0x000098, "Member 'UEventAction_Talk_Actor::bAttachToSubject' has a wrong offset!");
static_assert(offsetof(UEventAction_Talk_Actor, AnimationType) == 0x000099, "Member 'UEventAction_Talk_Actor::AnimationType' has a wrong offset!");
static_assert(offsetof(UEventAction_Talk_Actor, StartAnimationDefinitions) == 0x0000A0, "Member 'UEventAction_Talk_Actor::StartAnimationDefinitions' has a wrong offset!");
static_assert(offsetof(UEventAction_Talk_Actor, EndAnimationDefinitions) == 0x0000B0, "Member 'UEventAction_Talk_Actor::EndAnimationDefinitions' has a wrong offset!");
static_assert(offsetof(UEventAction_Talk_Actor, TalkData) == 0x0000C0, "Member 'UEventAction_Talk_Actor::TalkData' has a wrong offset!");

// Class Zion.Passive_AutoRegenerateSP
// 0x0008 (0x0058 - 0x0050)
class UPassive_AutoRegenerateSP final : public UPassive_AutoRegenerate
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AutoRegenerateSP">();
	}
	static class UPassive_AutoRegenerateSP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AutoRegenerateSP>();
	}
};
static_assert(alignof(UPassive_AutoRegenerateSP) == 0x000008, "Wrong alignment on UPassive_AutoRegenerateSP");
static_assert(sizeof(UPassive_AutoRegenerateSP) == 0x000058, "Wrong size on UPassive_AutoRegenerateSP");

// Class Zion.EventAction_WaitAnimation
// 0x0008 (0x0060 - 0x0058)
class UEventAction_WaitAnimation final : public UEventAction_SubjectBinding
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_WaitAnimation">();
	}
	static class UEventAction_WaitAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_WaitAnimation>();
	}
};
static_assert(alignof(UEventAction_WaitAnimation) == 0x000008, "Wrong alignment on UEventAction_WaitAnimation");
static_assert(sizeof(UEventAction_WaitAnimation) == 0x000060, "Wrong size on UEventAction_WaitAnimation");

// Class Zion.EventAction_WaitMove
// 0x0010 (0x0068 - 0x0058)
class UEventAction_WaitMove final : public UEventAction_SubjectBinding
{
public:
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAction_WaitMove">();
	}
	static class UEventAction_WaitMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAction_WaitMove>();
	}
};
static_assert(alignof(UEventAction_WaitMove) == 0x000008, "Wrong alignment on UEventAction_WaitMove");
static_assert(sizeof(UEventAction_WaitMove) == 0x000068, "Wrong size on UEventAction_WaitMove");

// Class Zion.EventBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class UEventBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AppendActorBindings(TMap<class FName, class AActor*>& ActorBindings, const TMap<class FName, class AActor*>& AdditionalBindings);
	static TMap<class FName, class AActor*> GenerateActorBindings(const TMap<class FName, class AActor*>& ActorBindings, const TMap<class FName, class ASpawner*>& SpawnerBindings);
	static TMap<class FName, class AActor*> GenerateActorBindingsFromSpawners(const TMap<class FName, class ASpawner*>& SpawnerBindings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventBPFLibrary">();
	}
	static class UEventBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventBPFLibrary>();
	}
};
static_assert(alignof(UEventBPFLibrary) == 0x000008, "Wrong alignment on UEventBPFLibrary");
static_assert(sizeof(UEventBPFLibrary) == 0x000028, "Wrong size on UEventBPFLibrary");

// Class Zion.EventCondition_HasSeenEvent
// 0x0028 (0x0058 - 0x0030)
class UEventCondition_HasSeenEvent final : public UEventCondition
{
public:
	TSoftObjectPtr<class UEventAsset>             Event;                                             // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCondition_HasSeenEvent">();
	}
	static class UEventCondition_HasSeenEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventCondition_HasSeenEvent>();
	}
};
static_assert(alignof(UEventCondition_HasSeenEvent) == 0x000008, "Wrong alignment on UEventCondition_HasSeenEvent");
static_assert(sizeof(UEventCondition_HasSeenEvent) == 0x000058, "Wrong size on UEventCondition_HasSeenEvent");
static_assert(offsetof(UEventCondition_HasSeenEvent, Event) == 0x000030, "Member 'UEventCondition_HasSeenEvent::Event' has a wrong offset!");

// Class Zion.EventSkipActionZion
// 0x0000 (0x0030 - 0x0030)
class UEventSkipActionZion : public UEventSkipAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSkipActionZion">();
	}
	static class UEventSkipActionZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventSkipActionZion>();
	}
};
static_assert(alignof(UEventSkipActionZion) == 0x000008, "Wrong alignment on UEventSkipActionZion");
static_assert(sizeof(UEventSkipActionZion) == 0x000030, "Wrong size on UEventSkipActionZion");

// Class Zion.FadeSubsystem
// 0x0050 (0x0080 - 0x0030)
class UFadeSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<EFadeLayer, struct FFadeRuntimeData>     Fades;                                             // 0x0030(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void LaunchFadeIn(const struct FFadeDescriptionData& FadeDescription, const TDelegate<void()>& OnFadeFinishedDelegate, EFadeLayer FadeLayer);
	void LaunchFadeOut(const struct FFadeDescriptionData& FadeDescription, const TDelegate<void()>& OnFadeFinishedDelegate, EFadeLayer FadeLayer);
	void OnFadeWidgetDestruct();
	void SetupFadeIn(const struct FFadeDescriptionData& FadeDescription, EFadeLayer FadeLayer);

	EFadeState GetFadeState(EFadeLayer FadeLayer) const;
	bool IsAnyFadeVisible() const;
	bool IsFadeVisible(EFadeLayer FadeLayer) const;
	bool IsFading(EFadeLayer FadeLayer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadeSubsystem">();
	}
	static class UFadeSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadeSubsystem>();
	}
};
static_assert(alignof(UFadeSubsystem) == 0x000008, "Wrong alignment on UFadeSubsystem");
static_assert(sizeof(UFadeSubsystem) == 0x000080, "Wrong size on UFadeSubsystem");
static_assert(offsetof(UFadeSubsystem, Fades) == 0x000030, "Member 'UFadeSubsystem::Fades' has a wrong offset!");

// Class Zion.FakeWall
// 0x0058 (0x02E8 - 0x0290)
class AFakeWall : public AActor
{
public:
	bool                                          bAutoManageLinkedVisibilityActors;                 // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequireLinkedVisibilityActorsOnSameLevel;         // 0x0291(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_292[0x6];                                      // 0x0292(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         LinkedVisibilityActors;                            // 0x0298(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FComponentReference>            FogOfWarBlockerReferences;                         // 0x02A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class USceneComponent*                        RootSceneComponent;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClearComponent*                        ClearComponent;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBoxComponent*>                  FogOfWarBlockers;                                  // 0x02C8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void Hide(bool bInstant);
	void OnClearStatusChecked(EClearStatus ClearStatus);

	bool IsCleared() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FakeWall">();
	}
	static class AFakeWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFakeWall>();
	}
};
static_assert(alignof(AFakeWall) == 0x000008, "Wrong alignment on AFakeWall");
static_assert(sizeof(AFakeWall) == 0x0002E8, "Wrong size on AFakeWall");
static_assert(offsetof(AFakeWall, bAutoManageLinkedVisibilityActors) == 0x000290, "Member 'AFakeWall::bAutoManageLinkedVisibilityActors' has a wrong offset!");
static_assert(offsetof(AFakeWall, bRequireLinkedVisibilityActorsOnSameLevel) == 0x000291, "Member 'AFakeWall::bRequireLinkedVisibilityActorsOnSameLevel' has a wrong offset!");
static_assert(offsetof(AFakeWall, LinkedVisibilityActors) == 0x000298, "Member 'AFakeWall::LinkedVisibilityActors' has a wrong offset!");
static_assert(offsetof(AFakeWall, FogOfWarBlockerReferences) == 0x0002A8, "Member 'AFakeWall::FogOfWarBlockerReferences' has a wrong offset!");
static_assert(offsetof(AFakeWall, RootSceneComponent) == 0x0002B8, "Member 'AFakeWall::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AFakeWall, ClearComponent) == 0x0002C0, "Member 'AFakeWall::ClearComponent' has a wrong offset!");
static_assert(offsetof(AFakeWall, FogOfWarBlockers) == 0x0002C8, "Member 'AFakeWall::FogOfWarBlockers' has a wrong offset!");

// Class Zion.FallDamageComponent
// 0x00C0 (0x0160 - 0x00A0)
class UFallDamageComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x28];                                      // 0x00A0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     FallDamageCurve;                                   // 0x00C8(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             NecessaryStatesForFallDamage;                      // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void OnLandedCallback(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallDamageComponent">();
	}
	static class UFallDamageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallDamageComponent>();
	}
};
static_assert(alignof(UFallDamageComponent) == 0x000008, "Wrong alignment on UFallDamageComponent");
static_assert(sizeof(UFallDamageComponent) == 0x000160, "Wrong size on UFallDamageComponent");
static_assert(offsetof(UFallDamageComponent, FallDamageCurve) == 0x0000C8, "Member 'UFallDamageComponent::FallDamageCurve' has a wrong offset!");
static_assert(offsetof(UFallDamageComponent, NecessaryStatesForFallDamage) == 0x000150, "Member 'UFallDamageComponent::NecessaryStatesForFallDamage' has a wrong offset!");

// Class Zion.Passive_DiveDashChargeShort
// 0x0000 (0x0030 - 0x0030)
class UPassive_DiveDashChargeShort final : public UPassive
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DiveDashChargeShort">();
	}
	static class UPassive_DiveDashChargeShort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DiveDashChargeShort>();
	}
};
static_assert(alignof(UPassive_DiveDashChargeShort) == 0x000008, "Wrong alignment on UPassive_DiveDashChargeShort");
static_assert(sizeof(UPassive_DiveDashChargeShort) == 0x000030, "Wrong size on UPassive_DiveDashChargeShort");

// Class Zion.FallThroughComponent
// 0x0020 (0x00C0 - 0x00A0)
class UFallThroughComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FIgnoredPlatformData>           IgnoredPlatforms;                                  // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void ClearAllIgnoredPlatforms();
	void FallThroughOneWayPlatform(class AOneWayPlatform* OneWayPlatform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallThroughComponent">();
	}
	static class UFallThroughComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallThroughComponent>();
	}
};
static_assert(alignof(UFallThroughComponent) == 0x000008, "Wrong alignment on UFallThroughComponent");
static_assert(sizeof(UFallThroughComponent) == 0x0000C0, "Wrong size on UFallThroughComponent");
static_assert(offsetof(UFallThroughComponent, IgnoredPlatforms) == 0x0000B0, "Member 'UFallThroughComponent::IgnoredPlatforms' has a wrong offset!");

// Class Zion.FieldMessageComponent
// 0x0060 (0x06F0 - 0x0690)
class UFieldMessageComponent final : public UWidgetComponent
{
public:
	TMulticastInlineDelegate<void()>              OnFieldMessageFinished;                            // 0x0690(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFieldMessageAsset*                     MessageData;                                       // 0x06A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A8[0x48];                                     // 0x06A8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Abort();
	bool LaunchFieldMessage(class AActor* InTargetActor);
	void OnMessageCompleted();
	void SetMessageData(class UFieldMessageAsset* MessageDataAsset);

	class UFieldMessageAsset* GetFieldMessageAsset() const;
	bool IsProcessingFieldMessage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldMessageComponent">();
	}
	static class UFieldMessageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldMessageComponent>();
	}
};
static_assert(alignof(UFieldMessageComponent) == 0x000010, "Wrong alignment on UFieldMessageComponent");
static_assert(sizeof(UFieldMessageComponent) == 0x0006F0, "Wrong size on UFieldMessageComponent");
static_assert(offsetof(UFieldMessageComponent, OnFieldMessageFinished) == 0x000690, "Member 'UFieldMessageComponent::OnFieldMessageFinished' has a wrong offset!");
static_assert(offsetof(UFieldMessageComponent, MessageData) == 0x0006A0, "Member 'UFieldMessageComponent::MessageData' has a wrong offset!");

// Class Zion.FieldTalkComponent
// 0x0040 (0x00E0 - 0x00A0)
class UFieldTalkComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnFieldTalkFinished;                               // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UFieldTalkAsset*                        CachedFieldTalkAsset;                              // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnDeath();
	void ShowFieldTalkEntry();
	bool StartFieldTalk(class UFieldTalkAsset* FieldTalkAsset, bool bSkipActiveFieldTalkAsset);

	bool CanStartFieldTalk() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldTalkComponent">();
	}
	static class UFieldTalkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldTalkComponent>();
	}
};
static_assert(alignof(UFieldTalkComponent) == 0x000008, "Wrong alignment on UFieldTalkComponent");
static_assert(sizeof(UFieldTalkComponent) == 0x0000E0, "Wrong size on UFieldTalkComponent");
static_assert(offsetof(UFieldTalkComponent, OnFieldTalkFinished) == 0x0000A0, "Member 'UFieldTalkComponent::OnFieldTalkFinished' has a wrong offset!");
static_assert(offsetof(UFieldTalkComponent, CachedFieldTalkAsset) == 0x0000C8, "Member 'UFieldTalkComponent::CachedFieldTalkAsset' has a wrong offset!");

// Class Zion.FindTargetComponent
// 0x0020 (0x00C0 - 0x00A0)
class UFindTargetComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EAITargetDetectionType                        DetectionType;                                     // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistance;                                       // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDistance;                                       // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckFront;                                       // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckLineOfSight;                                 // 0x00B5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             VisibilityCollisionChannel;                        // 0x00B6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B7[0x9];                                       // 0x00B7(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FindTargetComponent">();
	}
	static class UFindTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFindTargetComponent>();
	}
};
static_assert(alignof(UFindTargetComponent) == 0x000008, "Wrong alignment on UFindTargetComponent");
static_assert(sizeof(UFindTargetComponent) == 0x0000C0, "Wrong size on UFindTargetComponent");
static_assert(offsetof(UFindTargetComponent, DetectionType) == 0x0000A8, "Member 'UFindTargetComponent::DetectionType' has a wrong offset!");
static_assert(offsetof(UFindTargetComponent, MinDistance) == 0x0000AC, "Member 'UFindTargetComponent::MinDistance' has a wrong offset!");
static_assert(offsetof(UFindTargetComponent, MaxDistance) == 0x0000B0, "Member 'UFindTargetComponent::MaxDistance' has a wrong offset!");
static_assert(offsetof(UFindTargetComponent, bCheckFront) == 0x0000B4, "Member 'UFindTargetComponent::bCheckFront' has a wrong offset!");
static_assert(offsetof(UFindTargetComponent, bCheckLineOfSight) == 0x0000B5, "Member 'UFindTargetComponent::bCheckLineOfSight' has a wrong offset!");
static_assert(offsetof(UFindTargetComponent, VisibilityCollisionChannel) == 0x0000B6, "Member 'UFindTargetComponent::VisibilityCollisionChannel' has a wrong offset!");

// Class Zion.Passive_DamageCutSPGauge
// 0x0010 (0x0040 - 0x0030)
class UPassive_DamageCutSPGauge final : public UPassive
{
public:
	int32                                         NoGaugePercentageBonus;                            // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         OneGaugePercentageBonus;                           // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TwoGaugesPercentageBonus;                          // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ThreeGaugesPercentageBonus;                        // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DamageCutSPGauge">();
	}
	static class UPassive_DamageCutSPGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DamageCutSPGauge>();
	}
};
static_assert(alignof(UPassive_DamageCutSPGauge) == 0x000008, "Wrong alignment on UPassive_DamageCutSPGauge");
static_assert(sizeof(UPassive_DamageCutSPGauge) == 0x000040, "Wrong size on UPassive_DamageCutSPGauge");
static_assert(offsetof(UPassive_DamageCutSPGauge, NoGaugePercentageBonus) == 0x000030, "Member 'UPassive_DamageCutSPGauge::NoGaugePercentageBonus' has a wrong offset!");
static_assert(offsetof(UPassive_DamageCutSPGauge, OneGaugePercentageBonus) == 0x000034, "Member 'UPassive_DamageCutSPGauge::OneGaugePercentageBonus' has a wrong offset!");
static_assert(offsetof(UPassive_DamageCutSPGauge, TwoGaugesPercentageBonus) == 0x000038, "Member 'UPassive_DamageCutSPGauge::TwoGaugesPercentageBonus' has a wrong offset!");
static_assert(offsetof(UPassive_DamageCutSPGauge, ThreeGaugesPercentageBonus) == 0x00003C, "Member 'UPassive_DamageCutSPGauge::ThreeGaugesPercentageBonus' has a wrong offset!");

// Class Zion.FluidBody
// 0x0310 (0x05A0 - 0x0290)
class AFluidBody : public AActor
{
public:
	TMap<ESplashSize, class UNiagaraSystem*>      EnterSplashFXs;                                    // 0x0290(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<ESplashSize, class UNiagaraSystem*>      ExitSplashFXs;                                     // 0x02E0(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<ESplashSize, class UFMODEvent*>          EnterSplashSEs;                                    // 0x0330(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<ESplashSize, class UFMODEvent*>          ExitSplashSEs;                                     // 0x0380(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<ESplashSize, float>                      SplashSizeToStrengths;                             // 0x03D0(0x0050)(Edit, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     VelocityToSplashStrength;                          // 0x0420(0x0088)(Edit, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     VelocityToSplashSize;                              // 0x04A8(0x0088)(Edit, NativeAccessSpecifierPrivate)
	class USceneComponent*                        SceneRootComponent;                                // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFluidMeshComponent*                    FluidMeshComponent;                                // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFluidSimulationComponent*              FluidSimulationComponent;                          // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          SurfaceCollisionComponent;                         // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AActor*, int32>                    InContactActors;                                   // 0x0550(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void GenerateSplash(const struct FVector& WorldLocation, float Strength, float SizePercent, bool bEntering, bool bLaunchFX);
	void OnBeginOverlapSurface(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bBFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapSurface(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	void RegenerateFluidMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluidBody">();
	}
	static class AFluidBody* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFluidBody>();
	}
};
static_assert(alignof(AFluidBody) == 0x000008, "Wrong alignment on AFluidBody");
static_assert(sizeof(AFluidBody) == 0x0005A0, "Wrong size on AFluidBody");
static_assert(offsetof(AFluidBody, EnterSplashFXs) == 0x000290, "Member 'AFluidBody::EnterSplashFXs' has a wrong offset!");
static_assert(offsetof(AFluidBody, ExitSplashFXs) == 0x0002E0, "Member 'AFluidBody::ExitSplashFXs' has a wrong offset!");
static_assert(offsetof(AFluidBody, EnterSplashSEs) == 0x000330, "Member 'AFluidBody::EnterSplashSEs' has a wrong offset!");
static_assert(offsetof(AFluidBody, ExitSplashSEs) == 0x000380, "Member 'AFluidBody::ExitSplashSEs' has a wrong offset!");
static_assert(offsetof(AFluidBody, SplashSizeToStrengths) == 0x0003D0, "Member 'AFluidBody::SplashSizeToStrengths' has a wrong offset!");
static_assert(offsetof(AFluidBody, VelocityToSplashStrength) == 0x000420, "Member 'AFluidBody::VelocityToSplashStrength' has a wrong offset!");
static_assert(offsetof(AFluidBody, VelocityToSplashSize) == 0x0004A8, "Member 'AFluidBody::VelocityToSplashSize' has a wrong offset!");
static_assert(offsetof(AFluidBody, SceneRootComponent) == 0x000530, "Member 'AFluidBody::SceneRootComponent' has a wrong offset!");
static_assert(offsetof(AFluidBody, FluidMeshComponent) == 0x000538, "Member 'AFluidBody::FluidMeshComponent' has a wrong offset!");
static_assert(offsetof(AFluidBody, FluidSimulationComponent) == 0x000540, "Member 'AFluidBody::FluidSimulationComponent' has a wrong offset!");
static_assert(offsetof(AFluidBody, SurfaceCollisionComponent) == 0x000548, "Member 'AFluidBody::SurfaceCollisionComponent' has a wrong offset!");
static_assert(offsetof(AFluidBody, InContactActors) == 0x000550, "Member 'AFluidBody::InContactActors' has a wrong offset!");

// Class Zion.FluidInteractionComponent
// 0x00A8 (0x0148 - 0x00A0)
class UFluidInteractionComponent final : public UActorComponent
{
public:
	TMap<EMovementSpeedMode, struct FSplashSettings> SplashSettingsForSpeedModes;                    // 0x00A0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x58];                                      // 0x00F0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluidInteractionComponent">();
	}
	static class UFluidInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFluidInteractionComponent>();
	}
};
static_assert(alignof(UFluidInteractionComponent) == 0x000008, "Wrong alignment on UFluidInteractionComponent");
static_assert(sizeof(UFluidInteractionComponent) == 0x000148, "Wrong size on UFluidInteractionComponent");
static_assert(offsetof(UFluidInteractionComponent, SplashSettingsForSpeedModes) == 0x0000A0, "Member 'UFluidInteractionComponent::SplashSettingsForSpeedModes' has a wrong offset!");

// Class Zion.Passive_HealCount
// 0x0008 (0x0038 - 0x0030)
class UPassive_HealCount final : public UPassive
{
public:
	int32                                         HealCountBonus;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_HealCount">();
	}
	static class UPassive_HealCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_HealCount>();
	}
};
static_assert(alignof(UPassive_HealCount) == 0x000008, "Wrong alignment on UPassive_HealCount");
static_assert(sizeof(UPassive_HealCount) == 0x000038, "Wrong size on UPassive_HealCount");
static_assert(offsetof(UPassive_HealCount, HealCountBonus) == 0x000030, "Member 'UPassive_HealCount::HealCountBonus' has a wrong offset!");

// Class Zion.FluidMeshComponent
// 0x0020 (0x05F0 - 0x05D0)
class UFluidMeshComponent final : public UProceduralMeshComponent
{
public:
	class UMaterialInterface*                     Material;                                          // 0x05D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFluidMeshType                                MeshType;                                          // 0x05D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseMeshSubdivision;                               // 0x05D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5DA[0x2];                                      // 0x05DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CellSizeX;                                         // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CellSizeY;                                         // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntVector                             GeneratedCellCounts;                               // 0x05E4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void RegenerateMesh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluidMeshComponent">();
	}
	static class UFluidMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFluidMeshComponent>();
	}
};
static_assert(alignof(UFluidMeshComponent) == 0x000010, "Wrong alignment on UFluidMeshComponent");
static_assert(sizeof(UFluidMeshComponent) == 0x0005F0, "Wrong size on UFluidMeshComponent");
static_assert(offsetof(UFluidMeshComponent, Material) == 0x0005D0, "Member 'UFluidMeshComponent::Material' has a wrong offset!");
static_assert(offsetof(UFluidMeshComponent, MeshType) == 0x0005D8, "Member 'UFluidMeshComponent::MeshType' has a wrong offset!");
static_assert(offsetof(UFluidMeshComponent, bUseMeshSubdivision) == 0x0005D9, "Member 'UFluidMeshComponent::bUseMeshSubdivision' has a wrong offset!");
static_assert(offsetof(UFluidMeshComponent, CellSizeX) == 0x0005DC, "Member 'UFluidMeshComponent::CellSizeX' has a wrong offset!");
static_assert(offsetof(UFluidMeshComponent, CellSizeY) == 0x0005E0, "Member 'UFluidMeshComponent::CellSizeY' has a wrong offset!");
static_assert(offsetof(UFluidMeshComponent, GeneratedCellCounts) == 0x0005E4, "Member 'UFluidMeshComponent::GeneratedCellCounts' has a wrong offset!");

// Class Zion.FluidSimulationComponent
// 0x0178 (0x0218 - 0x00A0)
class UFluidSimulationComponent final : public UActorComponent
{
public:
	class UMaterialInterface*                     SplatMaterial;                                     // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     HeightSimulationMaterial;                          // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bComputeNormal;                                    // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ComputeNormalMaterial;                             // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     VelocityToSplashStrength;                          // 0x00C0(0x0088)(Edit, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     VelocityToSplashSize;                              // 0x0148(0x0088)(Edit, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       FluidMIDs;                                         // 0x01D0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               SplatMID;                                          // 0x01E0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               HeightSimulationMID;                               // 0x01E8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ComputeNormalMID;                                  // 0x01F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTextureRenderTarget2D*>         HeightFieldRTs;                                    // 0x01F8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 NormalRT;                                          // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GenerateSplash(const struct FVector& WorldLocation, float Strength, float SizePercent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluidSimulationComponent">();
	}
	static class UFluidSimulationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFluidSimulationComponent>();
	}
};
static_assert(alignof(UFluidSimulationComponent) == 0x000008, "Wrong alignment on UFluidSimulationComponent");
static_assert(sizeof(UFluidSimulationComponent) == 0x000218, "Wrong size on UFluidSimulationComponent");
static_assert(offsetof(UFluidSimulationComponent, SplatMaterial) == 0x0000A0, "Member 'UFluidSimulationComponent::SplatMaterial' has a wrong offset!");
static_assert(offsetof(UFluidSimulationComponent, HeightSimulationMaterial) == 0x0000A8, "Member 'UFluidSimulationComponent::HeightSimulationMaterial' has a wrong offset!");
static_assert(offsetof(UFluidSimulationComponent, bComputeNormal) == 0x0000B0, "Member 'UFluidSimulationComponent::bComputeNormal' has a wrong offset!");
static_assert(offsetof(UFluidSimulationComponent, ComputeNormalMaterial) == 0x0000B8, "Member 'UFluidSimulationComponent::ComputeNormalMaterial' has a wrong offset!");
static_assert(offsetof(UFluidSimulationComponent, VelocityToSplashStrength) == 0x0000C0, "Member 'UFluidSimulationComponent::VelocityToSplashStrength' has a wrong offset!");
static_assert(offsetof(UFluidSimulationComponent, VelocityToSplashSize) == 0x000148, "Member 'UFluidSimulationComponent::VelocityToSplashSize' has a wrong offset!");
static_assert(offsetof(UFluidSimulationComponent, FluidMIDs) == 0x0001D0, "Member 'UFluidSimulationComponent::FluidMIDs' has a wrong offset!");
static_assert(offsetof(UFluidSimulationComponent, SplatMID) == 0x0001E0, "Member 'UFluidSimulationComponent::SplatMID' has a wrong offset!");
static_assert(offsetof(UFluidSimulationComponent, HeightSimulationMID) == 0x0001E8, "Member 'UFluidSimulationComponent::HeightSimulationMID' has a wrong offset!");
static_assert(offsetof(UFluidSimulationComponent, ComputeNormalMID) == 0x0001F0, "Member 'UFluidSimulationComponent::ComputeNormalMID' has a wrong offset!");
static_assert(offsetof(UFluidSimulationComponent, HeightFieldRTs) == 0x0001F8, "Member 'UFluidSimulationComponent::HeightFieldRTs' has a wrong offset!");
static_assert(offsetof(UFluidSimulationComponent, NormalRT) == 0x000208, "Member 'UFluidSimulationComponent::NormalRT' has a wrong offset!");

// Class Zion.Passive_OnKill_Drop
// 0x0018 (0x0060 - 0x0048)
class UPassive_OnKill_Drop final : public UPassive_OnKill
{
public:
	struct FDataTableRowHandle                    DropHandle;                                        // 0x0048(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         DropPercentage;                                    // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_OnKill_Drop">();
	}
	static class UPassive_OnKill_Drop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_OnKill_Drop>();
	}
};
static_assert(alignof(UPassive_OnKill_Drop) == 0x000008, "Wrong alignment on UPassive_OnKill_Drop");
static_assert(sizeof(UPassive_OnKill_Drop) == 0x000060, "Wrong size on UPassive_OnKill_Drop");
static_assert(offsetof(UPassive_OnKill_Drop, DropHandle) == 0x000048, "Member 'UPassive_OnKill_Drop::DropHandle' has a wrong offset!");
static_assert(offsetof(UPassive_OnKill_Drop, DropPercentage) == 0x000058, "Member 'UPassive_OnKill_Drop::DropPercentage' has a wrong offset!");

// Class Zion.FogOfWarComponent
// 0x02A8 (0x0348 - 0x00A0)
class UFogOfWarComponent final : public UActorComponent
{
public:
	class UMaterialInterface*                     MapAreaMaterial;                                   // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     ClearZoneMaterial;                                 // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              CompleteZoneSizeOffset;                            // 0x00B0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              CompleteZoneBorderSize;                            // 0x00C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              RevealZoneSizeOffset;                              // 0x00D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              RevealZoneBorderSize;                              // 0x00E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ClearZoneMID;                                      // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     ClearFogOfWarMaterial;                             // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              ClearFogOfWarSizeOffset;                           // 0x0100(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ClearFogOfWarMID;                                  // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               FogOfWarBlockerMID;                                // 0x0118(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 FogOfWarMaskRTBuffer;                              // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 ZonesClearedMaskRTBuffer;                          // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x28];                                     // 0x0130(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FRenderTargetData>   RenderTargetDataMap;                               // 0x0158(0x0050)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	TSet<struct FClearActorData>                  CachedZonesCompletedForMask;                       // 0x01A8(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<struct FClearActorData>                  CachedZonesRevealedForMask;                        // 0x01F8(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x100];                                    // 0x0248(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAllMapsFogOfWar();
	void ClearMapFogOfWar(const class FName& MapName);
	void ResetAllMapsFogOfWar();
	void ResetMapFogOfWar(const class FName& MapName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FogOfWarComponent">();
	}
	static class UFogOfWarComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFogOfWarComponent>();
	}
};
static_assert(alignof(UFogOfWarComponent) == 0x000008, "Wrong alignment on UFogOfWarComponent");
static_assert(sizeof(UFogOfWarComponent) == 0x000348, "Wrong size on UFogOfWarComponent");
static_assert(offsetof(UFogOfWarComponent, MapAreaMaterial) == 0x0000A0, "Member 'UFogOfWarComponent::MapAreaMaterial' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, ClearZoneMaterial) == 0x0000A8, "Member 'UFogOfWarComponent::ClearZoneMaterial' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, CompleteZoneSizeOffset) == 0x0000B0, "Member 'UFogOfWarComponent::CompleteZoneSizeOffset' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, CompleteZoneBorderSize) == 0x0000C0, "Member 'UFogOfWarComponent::CompleteZoneBorderSize' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, RevealZoneSizeOffset) == 0x0000D0, "Member 'UFogOfWarComponent::RevealZoneSizeOffset' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, RevealZoneBorderSize) == 0x0000E0, "Member 'UFogOfWarComponent::RevealZoneBorderSize' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, ClearZoneMID) == 0x0000F0, "Member 'UFogOfWarComponent::ClearZoneMID' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, ClearFogOfWarMaterial) == 0x0000F8, "Member 'UFogOfWarComponent::ClearFogOfWarMaterial' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, ClearFogOfWarSizeOffset) == 0x000100, "Member 'UFogOfWarComponent::ClearFogOfWarSizeOffset' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, ClearFogOfWarMID) == 0x000110, "Member 'UFogOfWarComponent::ClearFogOfWarMID' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, FogOfWarBlockerMID) == 0x000118, "Member 'UFogOfWarComponent::FogOfWarBlockerMID' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, FogOfWarMaskRTBuffer) == 0x000120, "Member 'UFogOfWarComponent::FogOfWarMaskRTBuffer' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, ZonesClearedMaskRTBuffer) == 0x000128, "Member 'UFogOfWarComponent::ZonesClearedMaskRTBuffer' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, RenderTargetDataMap) == 0x000158, "Member 'UFogOfWarComponent::RenderTargetDataMap' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, CachedZonesCompletedForMask) == 0x0001A8, "Member 'UFogOfWarComponent::CachedZonesCompletedForMask' has a wrong offset!");
static_assert(offsetof(UFogOfWarComponent, CachedZonesRevealedForMask) == 0x0001F8, "Member 'UFogOfWarComponent::CachedZonesRevealedForMask' has a wrong offset!");

// Class Zion.FollowGeometryMovementComponent
// 0x00A8 (0x01B0 - 0x0108)
class UFollowGeometryMovementComponent final : public UMovementComponent
{
public:
	struct FFollowGeometryMovementData            MovementData;                                      // 0x0108(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bStartMovementAtBeginPlay;                         // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0x77];                                     // 0x0139(0x0077)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Reset();
	void SetSpeedFactor(float NewSpeedFactor);
	void StartMovement();
	void StopMovement();

	float GetSpeedFactor() const;
	bool IsMoving() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FollowGeometryMovementComponent">();
	}
	static class UFollowGeometryMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFollowGeometryMovementComponent>();
	}
};
static_assert(alignof(UFollowGeometryMovementComponent) == 0x000008, "Wrong alignment on UFollowGeometryMovementComponent");
static_assert(sizeof(UFollowGeometryMovementComponent) == 0x0001B0, "Wrong size on UFollowGeometryMovementComponent");
static_assert(offsetof(UFollowGeometryMovementComponent, MovementData) == 0x000108, "Member 'UFollowGeometryMovementComponent::MovementData' has a wrong offset!");
static_assert(offsetof(UFollowGeometryMovementComponent, bStartMovementAtBeginPlay) == 0x000138, "Member 'UFollowGeometryMovementComponent::bStartMovementAtBeginPlay' has a wrong offset!");

// Class Zion.FollowTargetComponent
// 0x0160 (0x0268 - 0x0108)
class UFollowTargetComponent final : public UMovementComponent
{
public:
	bool                                          bUpdateOwnerLocation;                              // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFollowTargetBlendSpeedMode                   BlendSpeedMode;                                    // 0x0109(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x2];                                      // 0x010A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendSpeed;                                        // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     BlendSpeedCurve;                                   // 0x0110(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         OscillationScale;                                  // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVOscillator                           LocOscillation;                                    // 0x019C(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x01C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalSpaceOffset;                                  // 0x01D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x01F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSpringArmBehavior;                                // 0x01F1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             ProbeChannel;                                      // 0x01F2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F3[0x1];                                      // 0x01F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProbeRadius;                                       // 0x01F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 Owner;                                             // 0x01F8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x68];                                     // 0x0200(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearFollowTarget();
	void OnGameMapChanged();
	void SetFollowTarget(class USceneComponent* NewFollowTarget, bool bSnapToTarget);
	void TeleportToTarget();

	class USceneComponent* GetFollowTarget() const;
	struct FVector GetFollowTargetDeltaLocation() const;
	struct FVector GetFollowTargetForward() const;
	struct FVector GetFollowTargetLocation() const;
	struct FVector GetTargetLocation(const class USceneComponent* PinnedTarget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FollowTargetComponent">();
	}
	static class UFollowTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFollowTargetComponent>();
	}
};
static_assert(alignof(UFollowTargetComponent) == 0x000008, "Wrong alignment on UFollowTargetComponent");
static_assert(sizeof(UFollowTargetComponent) == 0x000268, "Wrong size on UFollowTargetComponent");
static_assert(offsetof(UFollowTargetComponent, bUpdateOwnerLocation) == 0x000108, "Member 'UFollowTargetComponent::bUpdateOwnerLocation' has a wrong offset!");
static_assert(offsetof(UFollowTargetComponent, BlendSpeedMode) == 0x000109, "Member 'UFollowTargetComponent::BlendSpeedMode' has a wrong offset!");
static_assert(offsetof(UFollowTargetComponent, BlendSpeed) == 0x00010C, "Member 'UFollowTargetComponent::BlendSpeed' has a wrong offset!");
static_assert(offsetof(UFollowTargetComponent, BlendSpeedCurve) == 0x000110, "Member 'UFollowTargetComponent::BlendSpeedCurve' has a wrong offset!");
static_assert(offsetof(UFollowTargetComponent, OscillationScale) == 0x000198, "Member 'UFollowTargetComponent::OscillationScale' has a wrong offset!");
static_assert(offsetof(UFollowTargetComponent, LocOscillation) == 0x00019C, "Member 'UFollowTargetComponent::LocOscillation' has a wrong offset!");
static_assert(offsetof(UFollowTargetComponent, Offset) == 0x0001C0, "Member 'UFollowTargetComponent::Offset' has a wrong offset!");
static_assert(offsetof(UFollowTargetComponent, LocalSpaceOffset) == 0x0001D8, "Member 'UFollowTargetComponent::LocalSpaceOffset' has a wrong offset!");
static_assert(offsetof(UFollowTargetComponent, bSweep) == 0x0001F0, "Member 'UFollowTargetComponent::bSweep' has a wrong offset!");
static_assert(offsetof(UFollowTargetComponent, bSpringArmBehavior) == 0x0001F1, "Member 'UFollowTargetComponent::bSpringArmBehavior' has a wrong offset!");
static_assert(offsetof(UFollowTargetComponent, ProbeChannel) == 0x0001F2, "Member 'UFollowTargetComponent::ProbeChannel' has a wrong offset!");
static_assert(offsetof(UFollowTargetComponent, ProbeRadius) == 0x0001F4, "Member 'UFollowTargetComponent::ProbeRadius' has a wrong offset!");
static_assert(offsetof(UFollowTargetComponent, Owner) == 0x0001F8, "Member 'UFollowTargetComponent::Owner' has a wrong offset!");

// Class Zion.Passive_FallingGravityFactor_Reduce
// 0x0008 (0x0038 - 0x0030)
class UPassive_FallingGravityFactor_Reduce final : public UPassive
{
public:
	int32                                         FallingGravityReductionPercentage;                 // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_FallingGravityFactor_Reduce">();
	}
	static class UPassive_FallingGravityFactor_Reduce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_FallingGravityFactor_Reduce>();
	}
};
static_assert(alignof(UPassive_FallingGravityFactor_Reduce) == 0x000008, "Wrong alignment on UPassive_FallingGravityFactor_Reduce");
static_assert(sizeof(UPassive_FallingGravityFactor_Reduce) == 0x000038, "Wrong size on UPassive_FallingGravityFactor_Reduce");
static_assert(offsetof(UPassive_FallingGravityFactor_Reduce, FallingGravityReductionPercentage) == 0x000030, "Member 'UPassive_FallingGravityFactor_Reduce::FallingGravityReductionPercentage' has a wrong offset!");

// Class Zion.FootIKComponent
// 0x02A0 (0x0340 - 0x00A0)
class alignas(0x10) UFootIKComponent final : public UActorComponent
{
public:
	struct FFootIKSettings                        Settings_Ground;                                   // 0x00A0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FFootIKSettings                        Settings_Slide;                                    // 0x00B8(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bUseIKLocation;                                    // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseIKRotation;                                    // 0x00D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBlendIKRotation;                                  // 0x00D2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D3[0x1];                                       // 0x00D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IKRotationBlendSpeed;                              // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class FString>                           NegativeScaleAnimations;                           // 0x00D8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     HeightOffsetForSlopeAngle;                         // 0x0128(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bUseHeightOffsetBlend;                             // 0x01B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightOffsetBlendSpeed;                            // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowUpdateLimitation;                            // 0x01B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B9[0x187];                                    // 0x01B9(0x0187)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationStart(class UTrackEntry* TrackEntry);
	void OnBeforeUpdateWorldTransform(class USpineSkeletonComponent* Skeleton);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootIKComponent">();
	}
	static class UFootIKComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootIKComponent>();
	}
};
static_assert(alignof(UFootIKComponent) == 0x000010, "Wrong alignment on UFootIKComponent");
static_assert(sizeof(UFootIKComponent) == 0x000340, "Wrong size on UFootIKComponent");
static_assert(offsetof(UFootIKComponent, Settings_Ground) == 0x0000A0, "Member 'UFootIKComponent::Settings_Ground' has a wrong offset!");
static_assert(offsetof(UFootIKComponent, Settings_Slide) == 0x0000B8, "Member 'UFootIKComponent::Settings_Slide' has a wrong offset!");
static_assert(offsetof(UFootIKComponent, bUseIKLocation) == 0x0000D0, "Member 'UFootIKComponent::bUseIKLocation' has a wrong offset!");
static_assert(offsetof(UFootIKComponent, bUseIKRotation) == 0x0000D1, "Member 'UFootIKComponent::bUseIKRotation' has a wrong offset!");
static_assert(offsetof(UFootIKComponent, bBlendIKRotation) == 0x0000D2, "Member 'UFootIKComponent::bBlendIKRotation' has a wrong offset!");
static_assert(offsetof(UFootIKComponent, IKRotationBlendSpeed) == 0x0000D4, "Member 'UFootIKComponent::IKRotationBlendSpeed' has a wrong offset!");
static_assert(offsetof(UFootIKComponent, NegativeScaleAnimations) == 0x0000D8, "Member 'UFootIKComponent::NegativeScaleAnimations' has a wrong offset!");
static_assert(offsetof(UFootIKComponent, HeightOffsetForSlopeAngle) == 0x000128, "Member 'UFootIKComponent::HeightOffsetForSlopeAngle' has a wrong offset!");
static_assert(offsetof(UFootIKComponent, bUseHeightOffsetBlend) == 0x0001B0, "Member 'UFootIKComponent::bUseHeightOffsetBlend' has a wrong offset!");
static_assert(offsetof(UFootIKComponent, HeightOffsetBlendSpeed) == 0x0001B4, "Member 'UFootIKComponent::HeightOffsetBlendSpeed' has a wrong offset!");
static_assert(offsetof(UFootIKComponent, bAllowUpdateLimitation) == 0x0001B8, "Member 'UFootIKComponent::bAllowUpdateLimitation' has a wrong offset!");

// Class Zion.Passive_OnAttack_Restore
// 0x0010 (0x0058 - 0x0048)
class UPassive_OnAttack_Restore : public UPassive_OnAttack
{
public:
	EPassiveOnAttackRestoreType                   RestoreType;                                       // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FlatAmountToRestore;                               // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DamagePercentageToRestore;                         // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StatPercentageToRestore;                           // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_OnAttack_Restore">();
	}
	static class UPassive_OnAttack_Restore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_OnAttack_Restore>();
	}
};
static_assert(alignof(UPassive_OnAttack_Restore) == 0x000008, "Wrong alignment on UPassive_OnAttack_Restore");
static_assert(sizeof(UPassive_OnAttack_Restore) == 0x000058, "Wrong size on UPassive_OnAttack_Restore");
static_assert(offsetof(UPassive_OnAttack_Restore, RestoreType) == 0x000048, "Member 'UPassive_OnAttack_Restore::RestoreType' has a wrong offset!");
static_assert(offsetof(UPassive_OnAttack_Restore, FlatAmountToRestore) == 0x00004C, "Member 'UPassive_OnAttack_Restore::FlatAmountToRestore' has a wrong offset!");
static_assert(offsetof(UPassive_OnAttack_Restore, DamagePercentageToRestore) == 0x000050, "Member 'UPassive_OnAttack_Restore::DamagePercentageToRestore' has a wrong offset!");
static_assert(offsetof(UPassive_OnAttack_Restore, StatPercentageToRestore) == 0x000054, "Member 'UPassive_OnAttack_Restore::StatPercentageToRestore' has a wrong offset!");

// Class Zion.Passive_OnAttack_RestoreSP
// 0x0008 (0x0060 - 0x0058)
class UPassive_OnAttack_RestoreSP final : public UPassive_OnAttack_Restore
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_OnAttack_RestoreSP">();
	}
	static class UPassive_OnAttack_RestoreSP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_OnAttack_RestoreSP>();
	}
};
static_assert(alignof(UPassive_OnAttack_RestoreSP) == 0x000008, "Wrong alignment on UPassive_OnAttack_RestoreSP");
static_assert(sizeof(UPassive_OnAttack_RestoreSP) == 0x000060, "Wrong size on UPassive_OnAttack_RestoreSP");

// Class Zion.GameEngineZion
// 0x0028 (0x1120 - 0x10F8)
class UGameEngineZion final : public UGameEngine
{
public:
	TMulticastInlineDelegate<void()>              OnApplicationSuspend;                              // 0x10F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnApplicationUnsuspend;                            // 0x1108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1118[0x8];                                     // 0x1118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameEngineZion* Get();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEngineZion">();
	}
	static class UGameEngineZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEngineZion>();
	}
};
static_assert(alignof(UGameEngineZion) == 0x000008, "Wrong alignment on UGameEngineZion");
static_assert(sizeof(UGameEngineZion) == 0x001120, "Wrong size on UGameEngineZion");
static_assert(offsetof(UGameEngineZion, OnApplicationSuspend) == 0x0010F8, "Member 'UGameEngineZion::OnApplicationSuspend' has a wrong offset!");
static_assert(offsetof(UGameEngineZion, OnApplicationUnsuspend) == 0x001108, "Member 'UGameEngineZion::OnApplicationUnsuspend' has a wrong offset!");

// Class Zion.GameInstanceZion
// 0x01D0 (0x0390 - 0x01C0)
class UGameInstanceZion : public UGameInstance
{
public:
	ELaunchGameIntent                             LaunchGameIntent;                                  // 0x01C0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInputMappingContext*>           InputContexts;                                     // 0x01C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UInputMappingContext*>           DebugInputContexts;                                // 0x01D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<ESoundFamily, class UFMODVCA*>           SoundVCAs;                                         // 0x01E8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<ESoundFamily, class UFMODBus*>           SoundBuses;                                        // 0x0238(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class UFMODBank*>                      VoiceBanks;                                        // 0x0288(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UWorld>                  PersistentGameWorld;                               // 0x0298(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   WorldLoadingIconWidgetClass;                       // 0x02C0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   SaveIconWidgetClass;                               // 0x02E8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   AchievementNotificationWidgetClass;                // 0x0310(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x58];                                     // 0x0338(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameInstanceZion* Get(const class UObject* WorldContextObject);

	void ClearLaunchGameIntent();
	void HandleSettingsDelegate(class USentrySettings* Settings);
	void OnAutoUploadCrashReportChanged();
	void SetLaunchGameIntent(ELaunchGameIntent NewLaunchGameIntent);

	ELaunchGameIntent GetLaunchGameIntent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameInstanceZion">();
	}
	static class UGameInstanceZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameInstanceZion>();
	}
};
static_assert(alignof(UGameInstanceZion) == 0x000008, "Wrong alignment on UGameInstanceZion");
static_assert(sizeof(UGameInstanceZion) == 0x000390, "Wrong size on UGameInstanceZion");
static_assert(offsetof(UGameInstanceZion, LaunchGameIntent) == 0x0001C0, "Member 'UGameInstanceZion::LaunchGameIntent' has a wrong offset!");
static_assert(offsetof(UGameInstanceZion, InputContexts) == 0x0001C8, "Member 'UGameInstanceZion::InputContexts' has a wrong offset!");
static_assert(offsetof(UGameInstanceZion, DebugInputContexts) == 0x0001D8, "Member 'UGameInstanceZion::DebugInputContexts' has a wrong offset!");
static_assert(offsetof(UGameInstanceZion, SoundVCAs) == 0x0001E8, "Member 'UGameInstanceZion::SoundVCAs' has a wrong offset!");
static_assert(offsetof(UGameInstanceZion, SoundBuses) == 0x000238, "Member 'UGameInstanceZion::SoundBuses' has a wrong offset!");
static_assert(offsetof(UGameInstanceZion, VoiceBanks) == 0x000288, "Member 'UGameInstanceZion::VoiceBanks' has a wrong offset!");
static_assert(offsetof(UGameInstanceZion, PersistentGameWorld) == 0x000298, "Member 'UGameInstanceZion::PersistentGameWorld' has a wrong offset!");
static_assert(offsetof(UGameInstanceZion, WorldLoadingIconWidgetClass) == 0x0002C0, "Member 'UGameInstanceZion::WorldLoadingIconWidgetClass' has a wrong offset!");
static_assert(offsetof(UGameInstanceZion, SaveIconWidgetClass) == 0x0002E8, "Member 'UGameInstanceZion::SaveIconWidgetClass' has a wrong offset!");
static_assert(offsetof(UGameInstanceZion, AchievementNotificationWidgetClass) == 0x000310, "Member 'UGameInstanceZion::AchievementNotificationWidgetClass' has a wrong offset!");

// Class Zion.Passive_RestoreSPPercentage
// 0x0008 (0x0038 - 0x0030)
class UPassive_RestoreSPPercentage final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_RestoreSPPercentage">();
	}
	static class UPassive_RestoreSPPercentage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_RestoreSPPercentage>();
	}
};
static_assert(alignof(UPassive_RestoreSPPercentage) == 0x000008, "Wrong alignment on UPassive_RestoreSPPercentage");
static_assert(sizeof(UPassive_RestoreSPPercentage) == 0x000038, "Wrong size on UPassive_RestoreSPPercentage");
static_assert(offsetof(UPassive_RestoreSPPercentage, PercentageBonus) == 0x000030, "Member 'UPassive_RestoreSPPercentage::PercentageBonus' has a wrong offset!");

// Class Zion.GameLogicBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameLogicBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CanUnlockAnySkillLevel(const class UInventoryComponent* InventoryComponent);
	static ESkillUnlockResultType CanUnlockSkillLevel(const class UInventoryComponent* InventoryComponent, const struct FDataTableRowHandle& SkillHandle, int32 Level);
	static bool CheckGameplayConditions(class APlayerController* PlayerController, const struct FGameplayConditionChecker& GameplayConditions);
	static bool CheckItemConditions(class APlayerControllerZion* PlayerControllerZion, const struct FItemConditionData& ItemConditionData);
	static int32 GetEquipLoadoutCount();
	static int32 GetNextLevelForSkill(const class UInventoryComponent* InventoryComponent, const struct FDataTableRowHandle& SkillHandle);
	static int32 GetPlayerMaxAttackLimit(const class APlayerControllerZion* PlayerController);
	static int32 GetPlayerMaxDefenseLimit(const class APlayerControllerZion* PlayerController);
	static int32 GetPlayerMaxHealCountLimit(const class APlayerControllerZion* PlayerController);
	static int32 GetPlayerMaxHealPowerLimit(const class APlayerControllerZion* PlayerController);
	static int32 GetPlayerMaxHPLimit(const class APlayerControllerZion* PlayerController);
	static const struct FExtendedStatsData GetPlayerMaxPossibleStats(const class APlayerControllerZion* PlayerController);
	static int32 GetPlayerMaxSPLimit(const class APlayerControllerZion* PlayerController);
	static int32 GetSkillLevelFromHandle(const class UObject* WorldContextObject, const struct FDataTableRowHandle& SkillHandle);
	static int32 GetSkillLevelFromID(const class UObject* WorldContextObject, const class FName& SkillID);
	static int32 GetSPGaugeValue();
	static void LaunchForceFeedback(class APlayerController* PlayerController, class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag, bool bLooping, bool bIgnoreTimeDilation, bool bPlayWhilePaused);
	static void StopForceFeedbackByTag(class APlayerController* PlayerController, class FName Tag);
	static class UUserWidgetTutorial* TryLaunchTutorialWidget(const class UObject* WorldContextObject, const TSubclassOf<class UUserWidgetTutorial> TutorialWidgetClass, const struct FDataTableRowHandle& TutorialHandle, const EUMGLayer UMGLayer);
	static bool UnlockSkillLevel(class UInventoryComponent* InventoryComponent, const struct FDataTableRowHandle& SkillHandle, int32 Level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameLogicBPFLibrary">();
	}
	static class UGameLogicBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameLogicBPFLibrary>();
	}
};
static_assert(alignof(UGameLogicBPFLibrary) == 0x000008, "Wrong alignment on UGameLogicBPFLibrary");
static_assert(sizeof(UGameLogicBPFLibrary) == 0x000028, "Wrong size on UGameLogicBPFLibrary");

// Class Zion.GameMapBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameMapBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetPixelPerMeter();
	static struct FVector WorldToPixelLocation(const struct FVector& WorldLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMapBPFLibrary">();
	}
	static class UGameMapBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMapBPFLibrary>();
	}
};
static_assert(alignof(UGameMapBPFLibrary) == 0x000008, "Wrong alignment on UGameMapBPFLibrary");
static_assert(sizeof(UGameMapBPFLibrary) == 0x000028, "Wrong size on UGameMapBPFLibrary");

// Class Zion.GameModeZionBase
// 0x0010 (0x0338 - 0x0328)
class AGameModeZionBase : public AGameModeBase
{
public:
	class UInputDeviceCheckerComponent*           InputDeviceCheckerComponent;                       // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalizationSwitcherComponent*         LocalizationSwitcherComponent;                     // 0x0330(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeZionBase">();
	}
	static class AGameModeZionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeZionBase>();
	}
};
static_assert(alignof(AGameModeZionBase) == 0x000008, "Wrong alignment on AGameModeZionBase");
static_assert(sizeof(AGameModeZionBase) == 0x000338, "Wrong size on AGameModeZionBase");
static_assert(offsetof(AGameModeZionBase, InputDeviceCheckerComponent) == 0x000328, "Member 'AGameModeZionBase::InputDeviceCheckerComponent' has a wrong offset!");
static_assert(offsetof(AGameModeZionBase, LocalizationSwitcherComponent) == 0x000330, "Member 'AGameModeZionBase::LocalizationSwitcherComponent' has a wrong offset!");

// Class Zion.GameModeZion
// 0x0318 (0x0650 - 0x0338)
class AGameModeZion : public AGameModeZionBase
{
public:
	uint8                                         Pad_338[0x18];                                     // 0x0338(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnGameMapChanged;                                  // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UDataTable*                             DataTableStoryLevels;                              // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableGameMaps;                                 // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableGameMapTransitions;                       // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableRestPoints;                               // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableRestPointEvents;                          // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableEnemies;                                  // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemCurrencies;                           // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemAptitudes;                            // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemSpirits;                              // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemSkills;                               // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemStats;                                // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemPassives;                             // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemEquipments;                           // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemAssists;                              // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemMaterials;                            // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemTips;                                 // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemTutorials;                            // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemKeys;                                 // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemQuests;                               // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemCostumes;                             // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemEnemyInfos;                           // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemNPCInfos;                             // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableItemGallery;                              // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableRecollectionBosses;                       // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableAchievements;                             // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStepMatrixData*                        StepMatrixData;                                    // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialFXMatrixData*                  AbilityFXMatrixData;                               // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialSEMatrixData*                  AbilitySEMatrixData;                               // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFadeDescriptionData                   DefaultFadeDescription;                            // 0x0440(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UWorld>                  TitleMap;                                          // 0x0460(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameStatsComponent*                    GameStatsComponent;                                // 0x0488(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEmulatedFogManagerComponent*           EmulatedFogManager;                                // 0x0490(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimeManagerComponent*                  TimeManager;                                       // 0x0498(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPoolSystemComponent*                   PoolSystemComponent;                               // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDropSystemComponent*                   DropSystemComponent;                               // 0x04A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZoneSystemComponent*                   ZoneSystemComponent;                               // 0x04B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClearManagerComponent*                 ClearManagerComponent;                             // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URenderStateManagerComponent*           RenderStateManagerComponent;                       // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDifficultySystemComponent*             DifficultySystemComponent;                         // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UElevatorStateManagerComponent*         ElevatorStateManagerComponent;                     // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBreakPartStateManagerComponent*        BreakPartStateManagerComponent;                    // 0x04D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URecollectionBossComponent*             RecollectionBossComponent;                         // 0x04E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URecollectionBossRushComponent*         BossRushComponent;                                 // 0x04E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         EnvironmentLevel;                                  // 0x04F0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F4[0x4];                                      // 0x04F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      EnvironmentLevelForGameMaps;                       // 0x04F8(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	int32                                         EnvironmentLevelOverride;                          // 0x0548(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54C[0x4];                                      // 0x054C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGameEndingType, int32>                  ReachedGameEndings;                                // 0x0550(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<EGameEndingType, int32>                  PreviousCumulatedReachedGameEndings;               // 0x05A0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	int32                                         NewGamePlusGeneration;                             // 0x05F0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NewGamePlusGenerationOverride;                     // 0x05F4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x58];                                     // 0x05F8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AGameModeZion* Get(const class UObject* WorldContextObject);
	static int32 GetMaxEnvironmentLevel(int32 NewGamePlusGeneration_0);

	void DBG_SetNewGamePlusGeneration(int32 NewNewGamePlusGeneration);
	void FastTravel(const class FName& RestPointID);
	void NotifyGameEndingReached(EGameEndingType GameEndingType);
	void RegisterBossRushComponent(class URecollectionBossRushComponent* NewBossRushComponent);
	void RegisterRecollectionBossComponent(class URecollectionBossComponent* NewRecollectionBossComponent);
	void ResetEnvironmentLevelOverride();
	void ResetNewGamePlusGenerationOverride();
	void RespawnPlayer(ERespawnReason Reason);
	void SetEnvironmentLevelOverride(int32 LevelOverride);
	void SetNewGamePlusGenerationOverride(int32 GenerationOverride);
	void StartRecollectionBoss(const struct FDataTableRowHandle& RecollectionBossDataHandle);
	void StartRecollectionBossRush();

	bool CanLeaveRecollectionBoss() const;
	bool DidReachGameEnding(EGameEndingType GameEndingType, bool bCheckPreviousGameGeneration) const;
	class UMaterialFXMatrixData* GetAbilityFXMatrixData() const;
	class UMaterialSEMatrixData* GetAbilitySEMatrixData() const;
	ERespawnReason GetCurrentRespawnReason() const;
	class UDataTable* GetDataTableAchievements() const;
	class UDataTable* GetDataTableEnemies() const;
	class UDataTable* GetDataTableGameMaps() const;
	class UDataTable* GetDataTableGameMapTransitions() const;
	class UDataTable* GetDataTableItemAptitudes() const;
	class UDataTable* GetDataTableItemAssists() const;
	class UDataTable* GetDataTableItemCostumes() const;
	class UDataTable* GetDataTableItemCurrencies() const;
	class UDataTable* GetDataTableItemEnemyInfo() const;
	class UDataTable* GetDataTableItemEquipments() const;
	class UDataTable* GetDataTableItemGallery() const;
	class UDataTable* GetDataTableItemKeys() const;
	class UDataTable* GetDataTableItemMaterials() const;
	class UDataTable* GetDataTableItemNPCInfo() const;
	class UDataTable* GetDataTableItemPassives() const;
	class UDataTable* GetDataTableItemQuests() const;
	class UDataTable* GetDataTableItemSkills() const;
	class UDataTable* GetDataTableItemSpirits() const;
	class UDataTable* GetDataTableItemStats() const;
	class UDataTable* GetDataTableItemTips() const;
	class UDataTable* GetDataTableItemTutorials() const;
	class UDataTable* GetDataTableRecollectionBosses() const;
	class UDataTable* GetDataTableRestPointEvents() const;
	class UDataTable* GetDataTableRestPoints() const;
	class UDataTable* GetDataTableStoryLevels() const;
	int32 GetEnvironmentLevel() const;
	int32 GetEnvironmentLevelNewGamePlus() const;
	int32 GetEnvironmentLevelOverride() const;
	int32 GetGameClearCount() const;
	int32 GetGameEndingCountReached() const;
	EGameModeType GetGameModeType() const;
	struct FDataTableRowHandle GetLastBossRecollectionHandle() const;
	int32 GetNewGamePlusGeneration() const;
	int32 GetNewGamePlusGenerationOverride() const;
	class FString GetPlayTimeAsString() const;
	int32 GetRawEnvironmentLevel() const;
	class UStepMatrixData* GetStepMatrixData() const;
	bool IsDeathProcessingAllowed() const;
	bool IsGameCleared() const;
	bool IsGameReady() const;
	bool IsInNewGamePlus() const;
	bool IsInRespawnProcess() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeZion">();
	}
	static class AGameModeZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeZion>();
	}
};
static_assert(alignof(AGameModeZion) == 0x000008, "Wrong alignment on AGameModeZion");
static_assert(sizeof(AGameModeZion) == 0x000650, "Wrong size on AGameModeZion");
static_assert(offsetof(AGameModeZion, OnGameMapChanged) == 0x000350, "Member 'AGameModeZion::OnGameMapChanged' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableStoryLevels) == 0x000360, "Member 'AGameModeZion::DataTableStoryLevels' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableGameMaps) == 0x000368, "Member 'AGameModeZion::DataTableGameMaps' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableGameMapTransitions) == 0x000370, "Member 'AGameModeZion::DataTableGameMapTransitions' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableRestPoints) == 0x000378, "Member 'AGameModeZion::DataTableRestPoints' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableRestPointEvents) == 0x000380, "Member 'AGameModeZion::DataTableRestPointEvents' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableEnemies) == 0x000388, "Member 'AGameModeZion::DataTableEnemies' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemCurrencies) == 0x000390, "Member 'AGameModeZion::DataTableItemCurrencies' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemAptitudes) == 0x000398, "Member 'AGameModeZion::DataTableItemAptitudes' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemSpirits) == 0x0003A0, "Member 'AGameModeZion::DataTableItemSpirits' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemSkills) == 0x0003A8, "Member 'AGameModeZion::DataTableItemSkills' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemStats) == 0x0003B0, "Member 'AGameModeZion::DataTableItemStats' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemPassives) == 0x0003B8, "Member 'AGameModeZion::DataTableItemPassives' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemEquipments) == 0x0003C0, "Member 'AGameModeZion::DataTableItemEquipments' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemAssists) == 0x0003C8, "Member 'AGameModeZion::DataTableItemAssists' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemMaterials) == 0x0003D0, "Member 'AGameModeZion::DataTableItemMaterials' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemTips) == 0x0003D8, "Member 'AGameModeZion::DataTableItemTips' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemTutorials) == 0x0003E0, "Member 'AGameModeZion::DataTableItemTutorials' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemKeys) == 0x0003E8, "Member 'AGameModeZion::DataTableItemKeys' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemQuests) == 0x0003F0, "Member 'AGameModeZion::DataTableItemQuests' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemCostumes) == 0x0003F8, "Member 'AGameModeZion::DataTableItemCostumes' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemEnemyInfos) == 0x000400, "Member 'AGameModeZion::DataTableItemEnemyInfos' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemNPCInfos) == 0x000408, "Member 'AGameModeZion::DataTableItemNPCInfos' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableItemGallery) == 0x000410, "Member 'AGameModeZion::DataTableItemGallery' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableRecollectionBosses) == 0x000418, "Member 'AGameModeZion::DataTableRecollectionBosses' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DataTableAchievements) == 0x000420, "Member 'AGameModeZion::DataTableAchievements' has a wrong offset!");
static_assert(offsetof(AGameModeZion, StepMatrixData) == 0x000428, "Member 'AGameModeZion::StepMatrixData' has a wrong offset!");
static_assert(offsetof(AGameModeZion, AbilityFXMatrixData) == 0x000430, "Member 'AGameModeZion::AbilityFXMatrixData' has a wrong offset!");
static_assert(offsetof(AGameModeZion, AbilitySEMatrixData) == 0x000438, "Member 'AGameModeZion::AbilitySEMatrixData' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DefaultFadeDescription) == 0x000440, "Member 'AGameModeZion::DefaultFadeDescription' has a wrong offset!");
static_assert(offsetof(AGameModeZion, TitleMap) == 0x000460, "Member 'AGameModeZion::TitleMap' has a wrong offset!");
static_assert(offsetof(AGameModeZion, GameStatsComponent) == 0x000488, "Member 'AGameModeZion::GameStatsComponent' has a wrong offset!");
static_assert(offsetof(AGameModeZion, EmulatedFogManager) == 0x000490, "Member 'AGameModeZion::EmulatedFogManager' has a wrong offset!");
static_assert(offsetof(AGameModeZion, TimeManager) == 0x000498, "Member 'AGameModeZion::TimeManager' has a wrong offset!");
static_assert(offsetof(AGameModeZion, PoolSystemComponent) == 0x0004A0, "Member 'AGameModeZion::PoolSystemComponent' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DropSystemComponent) == 0x0004A8, "Member 'AGameModeZion::DropSystemComponent' has a wrong offset!");
static_assert(offsetof(AGameModeZion, ZoneSystemComponent) == 0x0004B0, "Member 'AGameModeZion::ZoneSystemComponent' has a wrong offset!");
static_assert(offsetof(AGameModeZion, ClearManagerComponent) == 0x0004B8, "Member 'AGameModeZion::ClearManagerComponent' has a wrong offset!");
static_assert(offsetof(AGameModeZion, RenderStateManagerComponent) == 0x0004C0, "Member 'AGameModeZion::RenderStateManagerComponent' has a wrong offset!");
static_assert(offsetof(AGameModeZion, DifficultySystemComponent) == 0x0004C8, "Member 'AGameModeZion::DifficultySystemComponent' has a wrong offset!");
static_assert(offsetof(AGameModeZion, ElevatorStateManagerComponent) == 0x0004D0, "Member 'AGameModeZion::ElevatorStateManagerComponent' has a wrong offset!");
static_assert(offsetof(AGameModeZion, BreakPartStateManagerComponent) == 0x0004D8, "Member 'AGameModeZion::BreakPartStateManagerComponent' has a wrong offset!");
static_assert(offsetof(AGameModeZion, RecollectionBossComponent) == 0x0004E0, "Member 'AGameModeZion::RecollectionBossComponent' has a wrong offset!");
static_assert(offsetof(AGameModeZion, BossRushComponent) == 0x0004E8, "Member 'AGameModeZion::BossRushComponent' has a wrong offset!");
static_assert(offsetof(AGameModeZion, EnvironmentLevel) == 0x0004F0, "Member 'AGameModeZion::EnvironmentLevel' has a wrong offset!");
static_assert(offsetof(AGameModeZion, EnvironmentLevelForGameMaps) == 0x0004F8, "Member 'AGameModeZion::EnvironmentLevelForGameMaps' has a wrong offset!");
static_assert(offsetof(AGameModeZion, EnvironmentLevelOverride) == 0x000548, "Member 'AGameModeZion::EnvironmentLevelOverride' has a wrong offset!");
static_assert(offsetof(AGameModeZion, ReachedGameEndings) == 0x000550, "Member 'AGameModeZion::ReachedGameEndings' has a wrong offset!");
static_assert(offsetof(AGameModeZion, PreviousCumulatedReachedGameEndings) == 0x0005A0, "Member 'AGameModeZion::PreviousCumulatedReachedGameEndings' has a wrong offset!");
static_assert(offsetof(AGameModeZion, NewGamePlusGeneration) == 0x0005F0, "Member 'AGameModeZion::NewGamePlusGeneration' has a wrong offset!");
static_assert(offsetof(AGameModeZion, NewGamePlusGenerationOverride) == 0x0005F4, "Member 'AGameModeZion::NewGamePlusGenerationOverride' has a wrong offset!");

// Class Zion.GameplayConditionCheckerAsset
// 0x0018 (0x0040 - 0x0028)
class UGameplayConditionCheckerAsset final : public UObject
{
public:
	struct FGameplayConditionChecker              ConditionChecker;                                  // 0x0028(0x0018)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static bool CheckGameplayConditionAsset(const TSubclassOf<class UGameplayConditionCheckerAsset>& GameplayConditionAssetClass, class APlayerController* PlayerController);

	bool CheckCondition(class APlayerController* PlayerController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayConditionCheckerAsset">();
	}
	static class UGameplayConditionCheckerAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayConditionCheckerAsset>();
	}
};
static_assert(alignof(UGameplayConditionCheckerAsset) == 0x000008, "Wrong alignment on UGameplayConditionCheckerAsset");
static_assert(sizeof(UGameplayConditionCheckerAsset) == 0x000040, "Wrong size on UGameplayConditionCheckerAsset");
static_assert(offsetof(UGameplayConditionCheckerAsset, ConditionChecker) == 0x000028, "Member 'UGameplayConditionCheckerAsset::ConditionChecker' has a wrong offset!");

// Class Zion.GameplayConditionRefreshComponent
// 0x0038 (0x00D8 - 0x00A0)
class UGameplayConditionRefreshComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnRefreshRequestedDynamic;                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnableRefresh;                                    // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0xF];                                       // 0x00C9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayConditionRefreshComponent">();
	}
	static class UGameplayConditionRefreshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayConditionRefreshComponent>();
	}
};
static_assert(alignof(UGameplayConditionRefreshComponent) == 0x000008, "Wrong alignment on UGameplayConditionRefreshComponent");
static_assert(sizeof(UGameplayConditionRefreshComponent) == 0x0000D8, "Wrong size on UGameplayConditionRefreshComponent");
static_assert(offsetof(UGameplayConditionRefreshComponent, OnRefreshRequestedDynamic) == 0x0000B8, "Member 'UGameplayConditionRefreshComponent::OnRefreshRequestedDynamic' has a wrong offset!");
static_assert(offsetof(UGameplayConditionRefreshComponent, bEnableRefresh) == 0x0000C8, "Member 'UGameplayConditionRefreshComponent::bEnableRefresh' has a wrong offset!");

// Class Zion.GameplayCondition_HasClearedEvent
// 0x0028 (0x0058 - 0x0030)
class UGameplayCondition_HasClearedEvent final : public UGameplayCondition
{
public:
	TSoftObjectPtr<class UEventAsset>             Event;                                             // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCondition_HasClearedEvent">();
	}
	static class UGameplayCondition_HasClearedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCondition_HasClearedEvent>();
	}
};
static_assert(alignof(UGameplayCondition_HasClearedEvent) == 0x000008, "Wrong alignment on UGameplayCondition_HasClearedEvent");
static_assert(sizeof(UGameplayCondition_HasClearedEvent) == 0x000058, "Wrong size on UGameplayCondition_HasClearedEvent");
static_assert(offsetof(UGameplayCondition_HasClearedEvent, Event) == 0x000030, "Member 'UGameplayCondition_HasClearedEvent::Event' has a wrong offset!");

// Class Zion.GameplayCondition_HasPassiveEquipped
// 0x0010 (0x0040 - 0x0030)
class UGameplayCondition_HasPassiveEquipped final : public UGameplayCondition
{
public:
	struct FDataTableRowHandle                    Passive;                                           // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCondition_HasPassiveEquipped">();
	}
	static class UGameplayCondition_HasPassiveEquipped* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCondition_HasPassiveEquipped>();
	}
};
static_assert(alignof(UGameplayCondition_HasPassiveEquipped) == 0x000008, "Wrong alignment on UGameplayCondition_HasPassiveEquipped");
static_assert(sizeof(UGameplayCondition_HasPassiveEquipped) == 0x000040, "Wrong size on UGameplayCondition_HasPassiveEquipped");
static_assert(offsetof(UGameplayCondition_HasPassiveEquipped, Passive) == 0x000030, "Member 'UGameplayCondition_HasPassiveEquipped::Passive' has a wrong offset!");

// Class Zion.Passive_TargetDebuffedDamage
// 0x0008 (0x0038 - 0x0030)
class UPassive_TargetDebuffedDamage : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_TargetDebuffedDamage">();
	}
	static class UPassive_TargetDebuffedDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_TargetDebuffedDamage>();
	}
};
static_assert(alignof(UPassive_TargetDebuffedDamage) == 0x000008, "Wrong alignment on UPassive_TargetDebuffedDamage");
static_assert(sizeof(UPassive_TargetDebuffedDamage) == 0x000038, "Wrong size on UPassive_TargetDebuffedDamage");
static_assert(offsetof(UPassive_TargetDebuffedDamage, PercentageBonus) == 0x000030, "Member 'UPassive_TargetDebuffedDamage::PercentageBonus' has a wrong offset!");

// Class Zion.GameplayCondition_StoryLevel
// 0x0018 (0x0048 - 0x0030)
class UGameplayCondition_StoryLevel final : public UGameplayCondition
{
public:
	ECommonOperator                               Operator;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    StoryLevel;                                        // 0x0038(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCondition_StoryLevel">();
	}
	static class UGameplayCondition_StoryLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCondition_StoryLevel>();
	}
};
static_assert(alignof(UGameplayCondition_StoryLevel) == 0x000008, "Wrong alignment on UGameplayCondition_StoryLevel");
static_assert(sizeof(UGameplayCondition_StoryLevel) == 0x000048, "Wrong size on UGameplayCondition_StoryLevel");
static_assert(offsetof(UGameplayCondition_StoryLevel, Operator) == 0x000030, "Member 'UGameplayCondition_StoryLevel::Operator' has a wrong offset!");
static_assert(offsetof(UGameplayCondition_StoryLevel, StoryLevel) == 0x000038, "Member 'UGameplayCondition_StoryLevel::StoryLevel' has a wrong offset!");

// Class Zion.GameplayEffect_HealCount
// 0x0008 (0x0030 - 0x0028)
class UGameplayEffect_HealCount final : public UGameplayEffect
{
public:
	int32                                         HealCount;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEffect_HealCount">();
	}
	static class UGameplayEffect_HealCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffect_HealCount>();
	}
};
static_assert(alignof(UGameplayEffect_HealCount) == 0x000008, "Wrong alignment on UGameplayEffect_HealCount");
static_assert(sizeof(UGameplayEffect_HealCount) == 0x000030, "Wrong size on UGameplayEffect_HealCount");
static_assert(offsetof(UGameplayEffect_HealCount, HealCount) == 0x000028, "Member 'UGameplayEffect_HealCount::HealCount' has a wrong offset!");

// Class Zion.GameplayEffect_HealHP
// 0x0008 (0x0030 - 0x0028)
class UGameplayEffect_HealHP final : public UGameplayEffect
{
public:
	float                                         HealPercentage;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEffect_HealHP">();
	}
	static class UGameplayEffect_HealHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffect_HealHP>();
	}
};
static_assert(alignof(UGameplayEffect_HealHP) == 0x000008, "Wrong alignment on UGameplayEffect_HealHP");
static_assert(sizeof(UGameplayEffect_HealHP) == 0x000030, "Wrong size on UGameplayEffect_HealHP");
static_assert(offsetof(UGameplayEffect_HealHP, HealPercentage) == 0x000028, "Member 'UGameplayEffect_HealHP::HealPercentage' has a wrong offset!");

// Class Zion.GameplayEffect_HealSP
// 0x0008 (0x0030 - 0x0028)
class UGameplayEffect_HealSP final : public UGameplayEffect
{
public:
	float                                         HealPercentage;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEffect_HealSP">();
	}
	static class UGameplayEffect_HealSP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffect_HealSP>();
	}
};
static_assert(alignof(UGameplayEffect_HealSP) == 0x000008, "Wrong alignment on UGameplayEffect_HealSP");
static_assert(sizeof(UGameplayEffect_HealSP) == 0x000030, "Wrong size on UGameplayEffect_HealSP");
static_assert(offsetof(UGameplayEffect_HealSP, HealPercentage) == 0x000028, "Member 'UGameplayEffect_HealSP::HealPercentage' has a wrong offset!");

// Class Zion.Passive_StatsPercentage
// 0x0040 (0x0070 - 0x0030)
class UPassive_StatsPercentage final : public UPassive
{
public:
	struct FStatsLevelData                        PercentageBonus;                                   // 0x0030(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_StatsPercentage">();
	}
	static class UPassive_StatsPercentage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_StatsPercentage>();
	}
};
static_assert(alignof(UPassive_StatsPercentage) == 0x000008, "Wrong alignment on UPassive_StatsPercentage");
static_assert(sizeof(UPassive_StatsPercentage) == 0x000070, "Wrong size on UPassive_StatsPercentage");
static_assert(offsetof(UPassive_StatsPercentage, PercentageBonus) == 0x000030, "Member 'UPassive_StatsPercentage::PercentageBonus' has a wrong offset!");

// Class Zion.GameStatsComponent
// 0x0038 (0x00D8 - 0x00A0)
class UGameStatsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x38];                                      // 0x00A0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 SetPause();
	int32 UnsetPause();

	class FString GetPlayTimeAsString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStatsComponent">();
	}
	static class UGameStatsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStatsComponent>();
	}
};
static_assert(alignof(UGameStatsComponent) == 0x000008, "Wrong alignment on UGameStatsComponent");
static_assert(sizeof(UGameStatsComponent) == 0x0000D8, "Wrong size on UGameStatsComponent");

// Class Zion.GuardComponent
// 0x0028 (0x00C8 - 0x00A0)
class UGuardComponent final : public UActorComponent
{
public:
	TArray<TSubclassOf<class UCommand>>           OnGuardedCommands;                                 // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGuarded(class AAbility* Ability, class AActor* Source);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardComponent">();
	}
	static class UGuardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardComponent>();
	}
};
static_assert(alignof(UGuardComponent) == 0x000008, "Wrong alignment on UGuardComponent");
static_assert(sizeof(UGuardComponent) == 0x0000C8, "Wrong size on UGuardComponent");
static_assert(offsetof(UGuardComponent, OnGuardedCommands) == 0x0000A0, "Member 'UGuardComponent::OnGuardedCommands' has a wrong offset!");

// Class Zion.HealComponent
// 0x0080 (0x0120 - 0x00A0)
class UHealComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnUseHealDelegate;                                 // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 RestoredHealCount)> OnRestoreHealsDelegate;                  // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFullyRestoreHealsDelegate;                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnHealCountChangedDelegate;                        // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         BaseHealPower;                                     // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxBonusHealPower;                                 // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxBonusHealCount;                                 // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BaseHealCount;                                     // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BonusHealCount;                                    // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AdditiveBonusHealCount;                            // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         HealPowerPercentageBonus;                          // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrHealCount;                                     // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BonusHealPower;                                    // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x1C];                                     // 0x0104(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddHealCountBonus(int32 HealCountBonusToAdd);
	int32 AddHealPowerPercentageBonus(int32 HealPercentBonusToAdd);
	bool FullyRestoreHeals();
	int32 RestoreHeals(const int32 RestoreCount);
	int32 SubHealCountBonus(int32 HealCountBonusToSub);
	int32 SubHealPowerPercentageBonus(int32 HealPercentBonusToSub);
	void UseHeal();

	int32 GetHealValue() const;
	int32 GetMaxHealCount() const;
	int32 GetRemainingHealCount() const;
	bool IsHealCountMax() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealComponent">();
	}
	static class UHealComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealComponent>();
	}
};
static_assert(alignof(UHealComponent) == 0x000008, "Wrong alignment on UHealComponent");
static_assert(sizeof(UHealComponent) == 0x000120, "Wrong size on UHealComponent");
static_assert(offsetof(UHealComponent, OnUseHealDelegate) == 0x0000A0, "Member 'UHealComponent::OnUseHealDelegate' has a wrong offset!");
static_assert(offsetof(UHealComponent, OnRestoreHealsDelegate) == 0x0000B0, "Member 'UHealComponent::OnRestoreHealsDelegate' has a wrong offset!");
static_assert(offsetof(UHealComponent, OnFullyRestoreHealsDelegate) == 0x0000C0, "Member 'UHealComponent::OnFullyRestoreHealsDelegate' has a wrong offset!");
static_assert(offsetof(UHealComponent, OnHealCountChangedDelegate) == 0x0000D0, "Member 'UHealComponent::OnHealCountChangedDelegate' has a wrong offset!");
static_assert(offsetof(UHealComponent, BaseHealPower) == 0x0000E0, "Member 'UHealComponent::BaseHealPower' has a wrong offset!");
static_assert(offsetof(UHealComponent, MaxBonusHealPower) == 0x0000E4, "Member 'UHealComponent::MaxBonusHealPower' has a wrong offset!");
static_assert(offsetof(UHealComponent, MaxBonusHealCount) == 0x0000E8, "Member 'UHealComponent::MaxBonusHealCount' has a wrong offset!");
static_assert(offsetof(UHealComponent, BaseHealCount) == 0x0000EC, "Member 'UHealComponent::BaseHealCount' has a wrong offset!");
static_assert(offsetof(UHealComponent, BonusHealCount) == 0x0000F0, "Member 'UHealComponent::BonusHealCount' has a wrong offset!");
static_assert(offsetof(UHealComponent, AdditiveBonusHealCount) == 0x0000F4, "Member 'UHealComponent::AdditiveBonusHealCount' has a wrong offset!");
static_assert(offsetof(UHealComponent, HealPowerPercentageBonus) == 0x0000F8, "Member 'UHealComponent::HealPowerPercentageBonus' has a wrong offset!");
static_assert(offsetof(UHealComponent, CurrHealCount) == 0x0000FC, "Member 'UHealComponent::CurrHealCount' has a wrong offset!");
static_assert(offsetof(UHealComponent, BonusHealPower) == 0x000100, "Member 'UHealComponent::BonusHealPower' has a wrong offset!");

// Class Zion.HitStopComponent
// 0x0058 (0x00F8 - 0x00A0)
class UHitStopComponent final : public UActorComponent
{
public:
	float                                         HitStopFactor;                                     // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             AdditionalHitStopStates;                           // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x40];                                      // 0x00B8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LaunchHitStop(float HitStopDuration);

	bool IsInHitStop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitStopComponent">();
	}
	static class UHitStopComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitStopComponent>();
	}
};
static_assert(alignof(UHitStopComponent) == 0x000008, "Wrong alignment on UHitStopComponent");
static_assert(sizeof(UHitStopComponent) == 0x0000F8, "Wrong size on UHitStopComponent");
static_assert(offsetof(UHitStopComponent, HitStopFactor) == 0x0000A0, "Member 'UHitStopComponent::HitStopFactor' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, AdditionalHitStopStates) == 0x0000A8, "Member 'UHitStopComponent::AdditionalHitStopStates' has a wrong offset!");

// Class Zion.HomingComponent
// 0x00C0 (0x01C8 - 0x0108)
class UHomingComponent final : public UMovementComponent
{
public:
	uint8                                         Pad_108[0x64];                                     // 0x0108(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSweep;                                            // 0x016C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHomingPropertyType                           InitialSpeedType;                                  // 0x016D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16E[0x2];                                      // 0x016E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialSpeed;                                      // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InitialSpeedMin;                                   // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InitialSpeedMax;                                   // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Acceleration;                                      // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bClampMaxSpeed;                                    // 0x0180(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeed;                                          // 0x0184(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHomingPropertyType                           InitialAngularSpeedType;                           // 0x0188(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialAngularSpeed;                               // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InitialAngularSpeedMin;                            // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InitialAngularSpeedMax;                            // 0x0194(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AngularAcceleration;                               // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bClampMaxAngularSpeed;                             // 0x019C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19D[0x3];                                      // 0x019D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAngularSpeed;                                   // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AngularSpeedForStraightToTarget;                   // 0x01A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRotationFollowVelocity;                           // 0x01A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoStopHoming;                                   // 0x01A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AA[0x2];                                      // 0x01AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoStopHomingDelay;                               // 0x01AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RangeForTargetReach;                               // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIncreaseRangeOverTime;                            // 0x01B4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B5[0x3];                                      // 0x01B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IncreaseRangeOverTimeDelay;                        // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ReachMaxRangeTime;                                 // 0x01BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxRangeForTargetReach;                            // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Reset();
	void SetTarget(const class AActor* TargetActor, bool bReset);

	bool DidReachTarget(const class USceneComponent* PinnedTarget) const;
	const class USceneComponent* GetTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HomingComponent">();
	}
	static class UHomingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHomingComponent>();
	}
};
static_assert(alignof(UHomingComponent) == 0x000008, "Wrong alignment on UHomingComponent");
static_assert(sizeof(UHomingComponent) == 0x0001C8, "Wrong size on UHomingComponent");
static_assert(offsetof(UHomingComponent, bSweep) == 0x00016C, "Member 'UHomingComponent::bSweep' has a wrong offset!");
static_assert(offsetof(UHomingComponent, InitialSpeedType) == 0x00016D, "Member 'UHomingComponent::InitialSpeedType' has a wrong offset!");
static_assert(offsetof(UHomingComponent, InitialSpeed) == 0x000170, "Member 'UHomingComponent::InitialSpeed' has a wrong offset!");
static_assert(offsetof(UHomingComponent, InitialSpeedMin) == 0x000174, "Member 'UHomingComponent::InitialSpeedMin' has a wrong offset!");
static_assert(offsetof(UHomingComponent, InitialSpeedMax) == 0x000178, "Member 'UHomingComponent::InitialSpeedMax' has a wrong offset!");
static_assert(offsetof(UHomingComponent, Acceleration) == 0x00017C, "Member 'UHomingComponent::Acceleration' has a wrong offset!");
static_assert(offsetof(UHomingComponent, bClampMaxSpeed) == 0x000180, "Member 'UHomingComponent::bClampMaxSpeed' has a wrong offset!");
static_assert(offsetof(UHomingComponent, MaxSpeed) == 0x000184, "Member 'UHomingComponent::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UHomingComponent, InitialAngularSpeedType) == 0x000188, "Member 'UHomingComponent::InitialAngularSpeedType' has a wrong offset!");
static_assert(offsetof(UHomingComponent, InitialAngularSpeed) == 0x00018C, "Member 'UHomingComponent::InitialAngularSpeed' has a wrong offset!");
static_assert(offsetof(UHomingComponent, InitialAngularSpeedMin) == 0x000190, "Member 'UHomingComponent::InitialAngularSpeedMin' has a wrong offset!");
static_assert(offsetof(UHomingComponent, InitialAngularSpeedMax) == 0x000194, "Member 'UHomingComponent::InitialAngularSpeedMax' has a wrong offset!");
static_assert(offsetof(UHomingComponent, AngularAcceleration) == 0x000198, "Member 'UHomingComponent::AngularAcceleration' has a wrong offset!");
static_assert(offsetof(UHomingComponent, bClampMaxAngularSpeed) == 0x00019C, "Member 'UHomingComponent::bClampMaxAngularSpeed' has a wrong offset!");
static_assert(offsetof(UHomingComponent, MaxAngularSpeed) == 0x0001A0, "Member 'UHomingComponent::MaxAngularSpeed' has a wrong offset!");
static_assert(offsetof(UHomingComponent, AngularSpeedForStraightToTarget) == 0x0001A4, "Member 'UHomingComponent::AngularSpeedForStraightToTarget' has a wrong offset!");
static_assert(offsetof(UHomingComponent, bRotationFollowVelocity) == 0x0001A8, "Member 'UHomingComponent::bRotationFollowVelocity' has a wrong offset!");
static_assert(offsetof(UHomingComponent, bAutoStopHoming) == 0x0001A9, "Member 'UHomingComponent::bAutoStopHoming' has a wrong offset!");
static_assert(offsetof(UHomingComponent, AutoStopHomingDelay) == 0x0001AC, "Member 'UHomingComponent::AutoStopHomingDelay' has a wrong offset!");
static_assert(offsetof(UHomingComponent, RangeForTargetReach) == 0x0001B0, "Member 'UHomingComponent::RangeForTargetReach' has a wrong offset!");
static_assert(offsetof(UHomingComponent, bIncreaseRangeOverTime) == 0x0001B4, "Member 'UHomingComponent::bIncreaseRangeOverTime' has a wrong offset!");
static_assert(offsetof(UHomingComponent, IncreaseRangeOverTimeDelay) == 0x0001B8, "Member 'UHomingComponent::IncreaseRangeOverTimeDelay' has a wrong offset!");
static_assert(offsetof(UHomingComponent, ReachMaxRangeTime) == 0x0001BC, "Member 'UHomingComponent::ReachMaxRangeTime' has a wrong offset!");
static_assert(offsetof(UHomingComponent, MaxRangeForTargetReach) == 0x0001C0, "Member 'UHomingComponent::MaxRangeForTargetReach' has a wrong offset!");

// Class Zion.EnemyHookPointSceneComponent
// 0x0000 (0x0230 - 0x0230)
class UEnemyHookPointSceneComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyHookPointSceneComponent">();
	}
	static class UEnemyHookPointSceneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyHookPointSceneComponent>();
	}
};
static_assert(alignof(UEnemyHookPointSceneComponent) == 0x000010, "Wrong alignment on UEnemyHookPointSceneComponent");
static_assert(sizeof(UEnemyHookPointSceneComponent) == 0x000230, "Wrong size on UEnemyHookPointSceneComponent");

// Class Zion.IKBonesComponent
// 0x00A0 (0x0140 - 0x00A0)
class UIKBonesComponent final : public UActorComponent
{
public:
	TMap<EIKBoneDriver, class USceneComponent*>   CachedBoneDrivers;                                 // 0x00A0(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x50];                                      // 0x00F0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USceneComponent* GetIKBone(EIKBoneDriver IKBoneDriver);
	void ResetIKBone(EIKBoneDriver IKBoneDriver, bool bResetIKConstraint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKBonesComponent">();
	}
	static class UIKBonesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKBonesComponent>();
	}
};
static_assert(alignof(UIKBonesComponent) == 0x000008, "Wrong alignment on UIKBonesComponent");
static_assert(sizeof(UIKBonesComponent) == 0x000140, "Wrong size on UIKBonesComponent");
static_assert(offsetof(UIKBonesComponent, CachedBoneDrivers) == 0x0000A0, "Member 'UIKBonesComponent::CachedBoneDrivers' has a wrong offset!");

// Class Zion.ImageZion
// 0x0020 (0x0300 - 0x02E0)
class UImageZion final : public UImage
{
public:
	TMulticastInlineDelegate<void(TSoftObjectPtr<class UObject> SoftImageObject)> OnImageStreamingStart; // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(TSoftObjectPtr<class UObject> SoftImageObject)> OnImageStreamingFinish; // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageZion">();
	}
	static class UImageZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageZion>();
	}
};
static_assert(alignof(UImageZion) == 0x000010, "Wrong alignment on UImageZion");
static_assert(sizeof(UImageZion) == 0x000300, "Wrong size on UImageZion");
static_assert(offsetof(UImageZion, OnImageStreamingStart) == 0x0002D8, "Member 'UImageZion::OnImageStreamingStart' has a wrong offset!");
static_assert(offsetof(UImageZion, OnImageStreamingFinish) == 0x0002E8, "Member 'UImageZion::OnImageStreamingFinish' has a wrong offset!");

// Class Zion.InputBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class UInputBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsEqual(const struct FInputSnapshot& A, const struct FInputSnapshot& B);
	static bool IsInputActionJustTriggered(const struct FInputSnapshot& InputSnapshot, const class UInputAction* InputAction);
	static bool IsInputActionTriggering(const struct FInputSnapshot& InputSnapshot, const class UInputAction* InputAction);
	static bool IsSameHorizontalDirection(EInputDirection DirectionA, EInputDirection DirectionB, bool bConsiderNeutralAsSame);
	static bool IsSameVerticalDirection(EInputDirection DirectionA, EInputDirection DirectionB, bool bConsiderNeutralAsSame);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputBPFLibrary">();
	}
	static class UInputBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputBPFLibrary>();
	}
};
static_assert(alignof(UInputBPFLibrary) == 0x000008, "Wrong alignment on UInputBPFLibrary");
static_assert(sizeof(UInputBPFLibrary) == 0x000028, "Wrong size on UInputBPFLibrary");

// Class Zion.InputBufferComponent
// 0x0030 (0x00D0 - 0x00A0)
class UInputBufferComponent final : public UActorComponent
{
public:
	float                                         MaxBufferTime;                                     // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x2C];                                      // 0x00A4(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FTimedInputSnapshot GetInputSnapshotAtIndex(int32 Index_0) const;
	int32 GetInputSnapshotCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputBufferComponent">();
	}
	static class UInputBufferComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputBufferComponent>();
	}
};
static_assert(alignof(UInputBufferComponent) == 0x000008, "Wrong alignment on UInputBufferComponent");
static_assert(sizeof(UInputBufferComponent) == 0x0000D0, "Wrong size on UInputBufferComponent");
static_assert(offsetof(UInputBufferComponent, MaxBufferTime) == 0x0000A0, "Member 'UInputBufferComponent::MaxBufferTime' has a wrong offset!");

// Class Zion.InputDeviceCheckerComponent
// 0x0038 (0x00D8 - 0x00A0)
class UInputDeviceCheckerComponent final : public UActorComponent
{
public:
	TSoftClassPtr<class UClass>                   UserWidgetClass;                                   // 0x00A0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActiveControllerDisconnected();
	void OnWidgetClosed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputDeviceCheckerComponent">();
	}
	static class UInputDeviceCheckerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputDeviceCheckerComponent>();
	}
};
static_assert(alignof(UInputDeviceCheckerComponent) == 0x000008, "Wrong alignment on UInputDeviceCheckerComponent");
static_assert(sizeof(UInputDeviceCheckerComponent) == 0x0000D8, "Wrong size on UInputDeviceCheckerComponent");
static_assert(offsetof(UInputDeviceCheckerComponent, UserWidgetClass) == 0x0000A0, "Member 'UInputDeviceCheckerComponent::UserWidgetClass' has a wrong offset!");

// Class Zion.InputModifier_SettingsDrivenDeadZone
// 0x0010 (0x0038 - 0x0028)
class UInputModifier_SettingsDrivenDeadZone final : public UInputModifier
{
public:
	EDeadZoneType                                 Type;                                              // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowerThreshold;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperThreshold;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputStick                                   DeadZoneStick;                                     // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputModifier_SettingsDrivenDeadZone">();
	}
	static class UInputModifier_SettingsDrivenDeadZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputModifier_SettingsDrivenDeadZone>();
	}
};
static_assert(alignof(UInputModifier_SettingsDrivenDeadZone) == 0x000008, "Wrong alignment on UInputModifier_SettingsDrivenDeadZone");
static_assert(sizeof(UInputModifier_SettingsDrivenDeadZone) == 0x000038, "Wrong size on UInputModifier_SettingsDrivenDeadZone");
static_assert(offsetof(UInputModifier_SettingsDrivenDeadZone, Type) == 0x000028, "Member 'UInputModifier_SettingsDrivenDeadZone::Type' has a wrong offset!");
static_assert(offsetof(UInputModifier_SettingsDrivenDeadZone, LowerThreshold) == 0x00002C, "Member 'UInputModifier_SettingsDrivenDeadZone::LowerThreshold' has a wrong offset!");
static_assert(offsetof(UInputModifier_SettingsDrivenDeadZone, UpperThreshold) == 0x000030, "Member 'UInputModifier_SettingsDrivenDeadZone::UpperThreshold' has a wrong offset!");
static_assert(offsetof(UInputModifier_SettingsDrivenDeadZone, DeadZoneStick) == 0x000034, "Member 'UInputModifier_SettingsDrivenDeadZone::DeadZoneStick' has a wrong offset!");

// Class Zion.Passive_DamageCutFrontPercentage
// 0x0008 (0x0038 - 0x0030)
class UPassive_DamageCutFrontPercentage final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DamageCutFrontPercentage">();
	}
	static class UPassive_DamageCutFrontPercentage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DamageCutFrontPercentage>();
	}
};
static_assert(alignof(UPassive_DamageCutFrontPercentage) == 0x000008, "Wrong alignment on UPassive_DamageCutFrontPercentage");
static_assert(sizeof(UPassive_DamageCutFrontPercentage) == 0x000038, "Wrong size on UPassive_DamageCutFrontPercentage");
static_assert(offsetof(UPassive_DamageCutFrontPercentage, PercentageBonus) == 0x000030, "Member 'UPassive_DamageCutFrontPercentage::PercentageBonus' has a wrong offset!");

// Class Zion.InputRichTextBlockImageDecorator
// 0x0138 (0x0160 - 0x0028)
class UInputRichTextBlockImageDecorator : public URichTextBlockDecorator
{
public:
	TMap<EInputStyle, class UDataTable*>          IconSets;                                          // 0x0028(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            FallbackBrush;                                     // 0x0080(0x00D0)(Edit, NativeAccessSpecifierPrivate)
	struct FMargin                                FallbackPadding;                                   // 0x0150(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputRichTextBlockImageDecorator">();
	}
	static class UInputRichTextBlockImageDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputRichTextBlockImageDecorator>();
	}
};
static_assert(alignof(UInputRichTextBlockImageDecorator) == 0x000010, "Wrong alignment on UInputRichTextBlockImageDecorator");
static_assert(sizeof(UInputRichTextBlockImageDecorator) == 0x000160, "Wrong size on UInputRichTextBlockImageDecorator");
static_assert(offsetof(UInputRichTextBlockImageDecorator, IconSets) == 0x000028, "Member 'UInputRichTextBlockImageDecorator::IconSets' has a wrong offset!");
static_assert(offsetof(UInputRichTextBlockImageDecorator, FallbackBrush) == 0x000080, "Member 'UInputRichTextBlockImageDecorator::FallbackBrush' has a wrong offset!");
static_assert(offsetof(UInputRichTextBlockImageDecorator, FallbackPadding) == 0x000150, "Member 'UInputRichTextBlockImageDecorator::FallbackPadding' has a wrong offset!");

// Class Zion.Interactable
// 0x0088 (0x0318 - 0x0290)
class AInteractable : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InteractionText;                                   // 0x0298(0x0010)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayConditionChecker              ConditionChecker;                                  // 0x02A8(0x0018)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCommand>                   OnSuccessCommand;                                  // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCommand>                   OnFailureCommand;                                  // 0x02C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             OnSuccessFMODEvent;                                // 0x02D0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             OnFailureFMODEvent;                                // 0x02D8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        RootSceneComponent;                                // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBillboardComponent*                    BillboardComponent;                                // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetComponent*                       WidgetComponent;                                   // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x20];                                     // 0x02F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivateInteractable(class APlayerController* Controller);
	void OnCanBeInteractedChanged();
	void OnDeactivateInteractable(class APlayerController* Controller);
	void OnInteract(class APlayerController* Controller);
	void OnInteract_ConditionCheckFailed(class APlayerController* Controller);
	void SetCanBeInteracted(bool bCanInteract);

	bool CanBeInteracted() const;
	bool ConditionsChecked() const;
	class APlayerController* GetInteractingController() const;
	class FText GetInteractionText() const;
	void PlaySoundEvent(class UFMODEvent* SoundEffect) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interactable">();
	}
	static class AInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractable>();
	}
};
static_assert(alignof(AInteractable) == 0x000008, "Wrong alignment on AInteractable");
static_assert(sizeof(AInteractable) == 0x000318, "Wrong size on AInteractable");
static_assert(offsetof(AInteractable, InteractionText) == 0x000298, "Member 'AInteractable::InteractionText' has a wrong offset!");
static_assert(offsetof(AInteractable, ConditionChecker) == 0x0002A8, "Member 'AInteractable::ConditionChecker' has a wrong offset!");
static_assert(offsetof(AInteractable, OnSuccessCommand) == 0x0002C0, "Member 'AInteractable::OnSuccessCommand' has a wrong offset!");
static_assert(offsetof(AInteractable, OnFailureCommand) == 0x0002C8, "Member 'AInteractable::OnFailureCommand' has a wrong offset!");
static_assert(offsetof(AInteractable, OnSuccessFMODEvent) == 0x0002D0, "Member 'AInteractable::OnSuccessFMODEvent' has a wrong offset!");
static_assert(offsetof(AInteractable, OnFailureFMODEvent) == 0x0002D8, "Member 'AInteractable::OnFailureFMODEvent' has a wrong offset!");
static_assert(offsetof(AInteractable, RootSceneComponent) == 0x0002E0, "Member 'AInteractable::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AInteractable, BillboardComponent) == 0x0002E8, "Member 'AInteractable::BillboardComponent' has a wrong offset!");
static_assert(offsetof(AInteractable, WidgetComponent) == 0x0002F0, "Member 'AInteractable::WidgetComponent' has a wrong offset!");

// Class Zion.Interactable_Event
// 0x02B0 (0x05C8 - 0x0318)
class AInteractable_Event : public AInteractable
{
public:
	class UClearComponent*                        ClearComponent;                                    // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoMarkAsClear;                                  // 0x0320(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMarkAsClearOnSpecificEvent;                       // 0x0321(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_322[0x6];                                      // 0x0322(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UEventAsset>             MarkAsClearEvent;                                  // 0x0328(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisableWhenCleared;                               // 0x0350(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UEventAsset>             EventAsset;                                        // 0x0358(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UEventAsset>             FailureEventAsset;                                 // 0x0380(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class AActor*>              ActorBindings;                                     // 0x03A8(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<class FName, class ASpawner*>            SpawnerBindings;                                   // 0x03F8(0x0050)(Edit, NativeAccessSpecifierPrivate)
	struct FEventBlackboardInit                   DefaultEventValues;                                // 0x0448(0x0140)(Edit, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             PostEventStates;                                   // 0x0588(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         PostEventStatesDuration;                           // 0x0598(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59C[0x4];                                      // 0x059C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEventAsset*                            LoadedEventAsset;                                  // 0x05A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEventAsset*                            LoadedFailureEventAsset;                           // 0x05A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEventPlayer*                           EventPlayer;                                       // 0x05B0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x10];                                     // 0x05B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClearStatusChecked(EClearStatus ClearStatus);
	void OnEventFinished(class UEventPlayer* InEventPlayer, bool bCompletedEvent, EEventPlayerResult EventResult);
	void OnPostEventProcess();
	void SetupAdditionalBindings(TMap<class FName, class AActor*>* AdditionalBindings);
	void SetupAdditionalBlackboardValues(struct FEventBlackboardInit& EventBlackboardInit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interactable_Event">();
	}
	static class AInteractable_Event* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractable_Event>();
	}
};
static_assert(alignof(AInteractable_Event) == 0x000008, "Wrong alignment on AInteractable_Event");
static_assert(sizeof(AInteractable_Event) == 0x0005C8, "Wrong size on AInteractable_Event");
static_assert(offsetof(AInteractable_Event, ClearComponent) == 0x000318, "Member 'AInteractable_Event::ClearComponent' has a wrong offset!");
static_assert(offsetof(AInteractable_Event, bAutoMarkAsClear) == 0x000320, "Member 'AInteractable_Event::bAutoMarkAsClear' has a wrong offset!");
static_assert(offsetof(AInteractable_Event, bMarkAsClearOnSpecificEvent) == 0x000321, "Member 'AInteractable_Event::bMarkAsClearOnSpecificEvent' has a wrong offset!");
static_assert(offsetof(AInteractable_Event, MarkAsClearEvent) == 0x000328, "Member 'AInteractable_Event::MarkAsClearEvent' has a wrong offset!");
static_assert(offsetof(AInteractable_Event, bDisableWhenCleared) == 0x000350, "Member 'AInteractable_Event::bDisableWhenCleared' has a wrong offset!");
static_assert(offsetof(AInteractable_Event, EventAsset) == 0x000358, "Member 'AInteractable_Event::EventAsset' has a wrong offset!");
static_assert(offsetof(AInteractable_Event, FailureEventAsset) == 0x000380, "Member 'AInteractable_Event::FailureEventAsset' has a wrong offset!");
static_assert(offsetof(AInteractable_Event, ActorBindings) == 0x0003A8, "Member 'AInteractable_Event::ActorBindings' has a wrong offset!");
static_assert(offsetof(AInteractable_Event, SpawnerBindings) == 0x0003F8, "Member 'AInteractable_Event::SpawnerBindings' has a wrong offset!");
static_assert(offsetof(AInteractable_Event, DefaultEventValues) == 0x000448, "Member 'AInteractable_Event::DefaultEventValues' has a wrong offset!");
static_assert(offsetof(AInteractable_Event, PostEventStates) == 0x000588, "Member 'AInteractable_Event::PostEventStates' has a wrong offset!");
static_assert(offsetof(AInteractable_Event, PostEventStatesDuration) == 0x000598, "Member 'AInteractable_Event::PostEventStatesDuration' has a wrong offset!");
static_assert(offsetof(AInteractable_Event, LoadedEventAsset) == 0x0005A0, "Member 'AInteractable_Event::LoadedEventAsset' has a wrong offset!");
static_assert(offsetof(AInteractable_Event, LoadedFailureEventAsset) == 0x0005A8, "Member 'AInteractable_Event::LoadedFailureEventAsset' has a wrong offset!");
static_assert(offsetof(AInteractable_Event, EventPlayer) == 0x0005B0, "Member 'AInteractable_Event::EventPlayer' has a wrong offset!");

// Class Zion.Passive_DamageCutMinSP
// 0x0008 (0x0038 - 0x0030)
class UPassive_DamageCutMinSP final : public UPassive
{
public:
	int32                                         SPPercentage;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DamageCutMinSP">();
	}
	static class UPassive_DamageCutMinSP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DamageCutMinSP>();
	}
};
static_assert(alignof(UPassive_DamageCutMinSP) == 0x000008, "Wrong alignment on UPassive_DamageCutMinSP");
static_assert(sizeof(UPassive_DamageCutMinSP) == 0x000038, "Wrong size on UPassive_DamageCutMinSP");
static_assert(offsetof(UPassive_DamageCutMinSP, SPPercentage) == 0x000030, "Member 'UPassive_DamageCutMinSP::SPPercentage' has a wrong offset!");
static_assert(offsetof(UPassive_DamageCutMinSP, PercentageBonus) == 0x000034, "Member 'UPassive_DamageCutMinSP::PercentageBonus' has a wrong offset!");

// Class Zion.Interactable_EventNPC
// 0x0060 (0x0628 - 0x05C8)
class AInteractable_EventNPC : public AInteractable_Event
{
public:
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UChildActorComponent*                   ChildActorComponent;                               // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayConditionRefreshComponent*     ConditionRefreshComponent;                         // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   NPCClass;                                          // 0x05E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FInteractableNPCData>           NPCDataList;                                       // 0x0608(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, ExposeOnSpawn, NativeAccessSpecifierPrivate)
	uint8                                         Pad_618[0x10];                                     // 0x0618(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACharacterZionNPC* GetNPC() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interactable_EventNPC">();
	}
	static class AInteractable_EventNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractable_EventNPC>();
	}
};
static_assert(alignof(AInteractable_EventNPC) == 0x000008, "Wrong alignment on AInteractable_EventNPC");
static_assert(sizeof(AInteractable_EventNPC) == 0x000628, "Wrong size on AInteractable_EventNPC");
static_assert(offsetof(AInteractable_EventNPC, ChildActorComponent) == 0x0005D0, "Member 'AInteractable_EventNPC::ChildActorComponent' has a wrong offset!");
static_assert(offsetof(AInteractable_EventNPC, ConditionRefreshComponent) == 0x0005D8, "Member 'AInteractable_EventNPC::ConditionRefreshComponent' has a wrong offset!");
static_assert(offsetof(AInteractable_EventNPC, NPCClass) == 0x0005E0, "Member 'AInteractable_EventNPC::NPCClass' has a wrong offset!");
static_assert(offsetof(AInteractable_EventNPC, NPCDataList) == 0x000608, "Member 'AInteractable_EventNPC::NPCDataList' has a wrong offset!");

// Class Zion.Interactable_RestPoint
// 0x0038 (0x0350 - 0x0318)
class AInteractable_RestPoint : public AInteractable
{
public:
	class UChildActorComponent*                   PlayerStartChildActor;                             // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    RestPointDataHandle;                               // 0x0320(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x20];                                     // 0x0330(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearNextEventDataHandle();
	void SetNextEventDataHandle(const struct FDataTableRowHandle& InNextEventDataHandle);

	const struct FDataTableRowHandle GetNextEventDataHandle() const;
	const struct FDataTableRowHandle GetRestPointDataHandle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interactable_RestPoint">();
	}
	static class AInteractable_RestPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractable_RestPoint>();
	}
};
static_assert(alignof(AInteractable_RestPoint) == 0x000008, "Wrong alignment on AInteractable_RestPoint");
static_assert(sizeof(AInteractable_RestPoint) == 0x000350, "Wrong size on AInteractable_RestPoint");
static_assert(offsetof(AInteractable_RestPoint, PlayerStartChildActor) == 0x000318, "Member 'AInteractable_RestPoint::PlayerStartChildActor' has a wrong offset!");
static_assert(offsetof(AInteractable_RestPoint, RestPointDataHandle) == 0x000320, "Member 'AInteractable_RestPoint::RestPointDataHandle' has a wrong offset!");

// Class Zion.Passive_DamageCutDebuffedPercentage
// 0x0008 (0x0038 - 0x0030)
class UPassive_DamageCutDebuffedPercentage final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DamageCutDebuffedPercentage">();
	}
	static class UPassive_DamageCutDebuffedPercentage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DamageCutDebuffedPercentage>();
	}
};
static_assert(alignof(UPassive_DamageCutDebuffedPercentage) == 0x000008, "Wrong alignment on UPassive_DamageCutDebuffedPercentage");
static_assert(sizeof(UPassive_DamageCutDebuffedPercentage) == 0x000038, "Wrong size on UPassive_DamageCutDebuffedPercentage");
static_assert(offsetof(UPassive_DamageCutDebuffedPercentage, PercentageBonus) == 0x000030, "Member 'UPassive_DamageCutDebuffedPercentage::PercentageBonus' has a wrong offset!");

// Class Zion.InteractComponent
// 0x0090 (0x0130 - 0x00A0)
class UInteractComponent final : public UActorComponent
{
public:
	class UInputMappingContext*                   InteractMappingContext;                            // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InteractInputAction;                               // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             NoDisplayStates;                                   // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FMovementModeData>              AllowedMovementModes;                              // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class FName>                           IgnoredTags;                                       // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class APawn*                                  PawnOwner;                                         // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZionInputComponent*                    InputComponent;                                    // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZionCharacterMovementComponent*        MovementComponent;                                 // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStateComponent*                        StateComponent;                                    // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandComponent*                      CommandComponent;                                  // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x28];                                     // 0x0108(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractComponent">();
	}
	static class UInteractComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractComponent>();
	}
};
static_assert(alignof(UInteractComponent) == 0x000008, "Wrong alignment on UInteractComponent");
static_assert(sizeof(UInteractComponent) == 0x000130, "Wrong size on UInteractComponent");
static_assert(offsetof(UInteractComponent, InteractMappingContext) == 0x0000A0, "Member 'UInteractComponent::InteractMappingContext' has a wrong offset!");
static_assert(offsetof(UInteractComponent, InteractInputAction) == 0x0000A8, "Member 'UInteractComponent::InteractInputAction' has a wrong offset!");
static_assert(offsetof(UInteractComponent, NoDisplayStates) == 0x0000B0, "Member 'UInteractComponent::NoDisplayStates' has a wrong offset!");
static_assert(offsetof(UInteractComponent, AllowedMovementModes) == 0x0000C0, "Member 'UInteractComponent::AllowedMovementModes' has a wrong offset!");
static_assert(offsetof(UInteractComponent, IgnoredTags) == 0x0000D0, "Member 'UInteractComponent::IgnoredTags' has a wrong offset!");
static_assert(offsetof(UInteractComponent, PawnOwner) == 0x0000E0, "Member 'UInteractComponent::PawnOwner' has a wrong offset!");
static_assert(offsetof(UInteractComponent, InputComponent) == 0x0000E8, "Member 'UInteractComponent::InputComponent' has a wrong offset!");
static_assert(offsetof(UInteractComponent, MovementComponent) == 0x0000F0, "Member 'UInteractComponent::MovementComponent' has a wrong offset!");
static_assert(offsetof(UInteractComponent, StateComponent) == 0x0000F8, "Member 'UInteractComponent::StateComponent' has a wrong offset!");
static_assert(offsetof(UInteractComponent, CommandComponent) == 0x000100, "Member 'UInteractComponent::CommandComponent' has a wrong offset!");

// Class Zion.Inventory
// 0x00E0 (0x0108 - 0x0028)
class UInventory : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      Items;                                             // 0x0058(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<class FName>                             CheckedItems;                                      // 0x00A8(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTable;                                         // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TMap<class FName, int32> GetAllItemsAvailable();
	void MarkItemAsChecked(const class FName& ItemRowName);

	const TMap<class FName, int32> GetAllItems() const;
	int32 GetCountOfItem(const class FName& ItemId) const;
	const class UDataTable* GetDataTable() const;
	int32 GetItemCount() const;
	bool HasItem(const class FName& ItemRowName, int32 Count) const;
	bool HasNonCheckedItem() const;
	bool IsItemChecked(const class FName& ItemRowName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Inventory">();
	}
	static class UInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventory>();
	}
};
static_assert(alignof(UInventory) == 0x000008, "Wrong alignment on UInventory");
static_assert(sizeof(UInventory) == 0x000108, "Wrong size on UInventory");
static_assert(offsetof(UInventory, Items) == 0x000058, "Member 'UInventory::Items' has a wrong offset!");
static_assert(offsetof(UInventory, CheckedItems) == 0x0000A8, "Member 'UInventory::CheckedItems' has a wrong offset!");
static_assert(offsetof(UInventory, DataTable) == 0x0000F8, "Member 'UInventory::DataTable' has a wrong offset!");

// Class Zion.InventoryAptitude
// 0x0040 (0x0148 - 0x0108)
class UInventoryAptitude final : public UInventory
{
public:
	uint8                                         Pad_108[0x40];                                     // 0x0108(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryAptitude">();
	}
	static class UInventoryAptitude* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryAptitude>();
	}
};
static_assert(alignof(UInventoryAptitude) == 0x000008, "Wrong alignment on UInventoryAptitude");
static_assert(sizeof(UInventoryAptitude) == 0x000148, "Wrong size on UInventoryAptitude");

// Class Zion.InventorySkill
// 0x0068 (0x0170 - 0x0108)
class UInventorySkill final : public UInventory
{
public:
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      SkillLevels;                                       // 0x0120(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static int32 GetMaxSkillLevel();
	static int32 GetMinSkillLevel();

	int32 SetSkillLevel(const class FName& SkillID, int32 NewLevel);

	int32 GetInitialSkillLevel(const class FName& SkillID) const;
	int32 GetSkillLevel(const class FName& SkillID, bool bFallbackInitialLevel) const;
	bool IsMaxSkillLevel(const class FName& SkillID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventorySkill">();
	}
	static class UInventorySkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventorySkill>();
	}
};
static_assert(alignof(UInventorySkill) == 0x000008, "Wrong alignment on UInventorySkill");
static_assert(sizeof(UInventorySkill) == 0x000170, "Wrong size on UInventorySkill");
static_assert(offsetof(UInventorySkill, SkillLevels) == 0x000120, "Member 'UInventorySkill::SkillLevels' has a wrong offset!");

// Class Zion.KnockbackComponent
// 0x0158 (0x01F8 - 0x00A0)
class UKnockbackComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x30];                                      // 0x00A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             GlobalStates;                                      // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             StatePhase_Launch;                                 // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             StatePhase_WaitForLanding;                         // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             StatePhase_Stagger;                                // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             StatePhase_Recovery;                               // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             PostKnockbackStates;                               // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         PostKnockbackStatesDuration;                       // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             UpdateBlockingStates;                              // 0x0138(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bSetFacing;                                        // 0x0148(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreKnockbackDuringKnockback;                   // 0x0149(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14A[0x2];                                      // 0x014A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseForceFactor;                                // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinImpulseForLaunch;                               // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRestoreDefaultMovementMode;                       // 0x0154(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_155[0xA3];                                     // 0x0155(0x00A3)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLandingAnimationFinished();
	void OnPreStartCommand(const class UCommand* Command);
	void OnRecoveryAnimationFinished();
	void StartKnockback(const struct FKnockbackData& KnockbackData, const struct FVector& KnockbackDirection);

	bool IsInKnockback() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnockbackComponent">();
	}
	static class UKnockbackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnockbackComponent>();
	}
};
static_assert(alignof(UKnockbackComponent) == 0x000008, "Wrong alignment on UKnockbackComponent");
static_assert(sizeof(UKnockbackComponent) == 0x0001F8, "Wrong size on UKnockbackComponent");
static_assert(offsetof(UKnockbackComponent, GlobalStates) == 0x0000D0, "Member 'UKnockbackComponent::GlobalStates' has a wrong offset!");
static_assert(offsetof(UKnockbackComponent, StatePhase_Launch) == 0x0000E0, "Member 'UKnockbackComponent::StatePhase_Launch' has a wrong offset!");
static_assert(offsetof(UKnockbackComponent, StatePhase_WaitForLanding) == 0x0000F0, "Member 'UKnockbackComponent::StatePhase_WaitForLanding' has a wrong offset!");
static_assert(offsetof(UKnockbackComponent, StatePhase_Stagger) == 0x000100, "Member 'UKnockbackComponent::StatePhase_Stagger' has a wrong offset!");
static_assert(offsetof(UKnockbackComponent, StatePhase_Recovery) == 0x000110, "Member 'UKnockbackComponent::StatePhase_Recovery' has a wrong offset!");
static_assert(offsetof(UKnockbackComponent, PostKnockbackStates) == 0x000120, "Member 'UKnockbackComponent::PostKnockbackStates' has a wrong offset!");
static_assert(offsetof(UKnockbackComponent, PostKnockbackStatesDuration) == 0x000130, "Member 'UKnockbackComponent::PostKnockbackStatesDuration' has a wrong offset!");
static_assert(offsetof(UKnockbackComponent, UpdateBlockingStates) == 0x000138, "Member 'UKnockbackComponent::UpdateBlockingStates' has a wrong offset!");
static_assert(offsetof(UKnockbackComponent, bSetFacing) == 0x000148, "Member 'UKnockbackComponent::bSetFacing' has a wrong offset!");
static_assert(offsetof(UKnockbackComponent, bIgnoreKnockbackDuringKnockback) == 0x000149, "Member 'UKnockbackComponent::bIgnoreKnockbackDuringKnockback' has a wrong offset!");
static_assert(offsetof(UKnockbackComponent, ImpulseForceFactor) == 0x00014C, "Member 'UKnockbackComponent::ImpulseForceFactor' has a wrong offset!");
static_assert(offsetof(UKnockbackComponent, MinImpulseForLaunch) == 0x000150, "Member 'UKnockbackComponent::MinImpulseForLaunch' has a wrong offset!");
static_assert(offsetof(UKnockbackComponent, bRestoreDefaultMovementMode) == 0x000154, "Member 'UKnockbackComponent::bRestoreDefaultMovementMode' has a wrong offset!");

// Class Zion.LocalizationBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class ULocalizationBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FString> GetAvailableLanguages();
	static class FString GetLanguage();
	static void SetLanguage(const class FString& Language);
	static void SetLanguageToSystemLanguage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalizationBPFLibrary">();
	}
	static class ULocalizationBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalizationBPFLibrary>();
	}
};
static_assert(alignof(ULocalizationBPFLibrary) == 0x000008, "Wrong alignment on ULocalizationBPFLibrary");
static_assert(sizeof(ULocalizationBPFLibrary) == 0x000028, "Wrong size on ULocalizationBPFLibrary");

// Class Zion.LocalizationSwitcherComponent
// 0x0018 (0x00B8 - 0x00A0)
class ULocalizationSwitcherComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalizationSwitcherComponent">();
	}
	static class ULocalizationSwitcherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalizationSwitcherComponent>();
	}
};
static_assert(alignof(ULocalizationSwitcherComponent) == 0x000008, "Wrong alignment on ULocalizationSwitcherComponent");
static_assert(sizeof(ULocalizationSwitcherComponent) == 0x0000B8, "Wrong size on ULocalizationSwitcherComponent");

// Class Zion.MapAreaTransitionMarker
// 0x0040 (0x02D0 - 0x0290)
class AMapAreaTransitionMarker final : public AActor
{
public:
	class USceneComponent*                        SceneRootComponent;                                // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UElevatorDestinationComponent*          StartPosition;                                     // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UElevatorDestinationComponent*          EndPosition;                                       // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        VisualLinkParent;                                  // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    MapAreaTransitionHandle;                           // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         LinkDepthScale;                                    // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LinkWidthScale;                                    // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LinkMinLength;                                     // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapAreaTransitionMarker">();
	}
	static class AMapAreaTransitionMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapAreaTransitionMarker>();
	}
};
static_assert(alignof(AMapAreaTransitionMarker) == 0x000008, "Wrong alignment on AMapAreaTransitionMarker");
static_assert(sizeof(AMapAreaTransitionMarker) == 0x0002D0, "Wrong size on AMapAreaTransitionMarker");
static_assert(offsetof(AMapAreaTransitionMarker, SceneRootComponent) == 0x000290, "Member 'AMapAreaTransitionMarker::SceneRootComponent' has a wrong offset!");
static_assert(offsetof(AMapAreaTransitionMarker, StartPosition) == 0x000298, "Member 'AMapAreaTransitionMarker::StartPosition' has a wrong offset!");
static_assert(offsetof(AMapAreaTransitionMarker, EndPosition) == 0x0002A0, "Member 'AMapAreaTransitionMarker::EndPosition' has a wrong offset!");
static_assert(offsetof(AMapAreaTransitionMarker, VisualLinkParent) == 0x0002A8, "Member 'AMapAreaTransitionMarker::VisualLinkParent' has a wrong offset!");
static_assert(offsetof(AMapAreaTransitionMarker, MapAreaTransitionHandle) == 0x0002B0, "Member 'AMapAreaTransitionMarker::MapAreaTransitionHandle' has a wrong offset!");
static_assert(offsetof(AMapAreaTransitionMarker, LinkDepthScale) == 0x0002C0, "Member 'AMapAreaTransitionMarker::LinkDepthScale' has a wrong offset!");
static_assert(offsetof(AMapAreaTransitionMarker, LinkWidthScale) == 0x0002C4, "Member 'AMapAreaTransitionMarker::LinkWidthScale' has a wrong offset!");
static_assert(offsetof(AMapAreaTransitionMarker, LinkMinLength) == 0x0002C8, "Member 'AMapAreaTransitionMarker::LinkMinLength' has a wrong offset!");

// Class Zion.MapIconProviderInterface
// 0x0000 (0x0000 - 0x0000)
class IMapIconProviderInterface final
{
public:
	void GetMapIconActorWithDependencies(struct FMapIconProviderData* OutMapIconProviderData);
	bool GetMapIconGameplayConditions(struct FGameplayConditionChecker* OutConditionChecker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapIconProviderInterface">();
	}
	static class IMapIconProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMapIconProviderInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMapIconProviderInterface) == 0x000001, "Wrong alignment on IMapIconProviderInterface");
static_assert(sizeof(IMapIconProviderInterface) == 0x000001, "Wrong size on IMapIconProviderInterface");

// Class Zion.MathBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class UMathBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float AngleBetweenAsDegree(const struct FVector& VectorA, const struct FVector& VectorB);
	static float AngleBetweenAsRad(const struct FVector& VectorA, const struct FVector& VectorB);
	static float Evaluate(const struct FRuntimeFloatCurve& Curve, float Time);
	static float GetMaxTime(const struct FRuntimeFloatCurve& Curve);
	static float GetMinTime(const struct FRuntimeFloatCurve& Curve);
	static int32 LoopAround(int32 Value, int32 Min, int32 Max);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MathBPFLibrary">();
	}
	static class UMathBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMathBPFLibrary>();
	}
};
static_assert(alignof(UMathBPFLibrary) == 0x000008, "Wrong alignment on UMathBPFLibrary");
static_assert(sizeof(UMathBPFLibrary) == 0x000028, "Wrong size on UMathBPFLibrary");

// Class Zion.MovingBlock_Elevator
// 0x0038 (0x02C8 - 0x0290)
class AMovingBlock_Elevator final : public AActor
{
public:
	class USceneComponent*                        SceneRootComponent;                                // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        MovingComponent;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        Destination;                                       // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        RopeAttachPoint;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UElevatorDestinationComponent*          RopeDestinationPoint;                              // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UElevatorMovementComponent*             ElevatorMovementComponent;                         // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URopeComponent*                         RopeComponent;                                     // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CallToDestination(bool bInstant);
	void CallToOrigin(bool bInstant);
	void OnFinishMovement(bool bInstant, bool bWasMoving);
	void OnStartMovement(bool bInstant, bool bWasMoving);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovingBlock_Elevator">();
	}
	static class AMovingBlock_Elevator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMovingBlock_Elevator>();
	}
};
static_assert(alignof(AMovingBlock_Elevator) == 0x000008, "Wrong alignment on AMovingBlock_Elevator");
static_assert(sizeof(AMovingBlock_Elevator) == 0x0002C8, "Wrong size on AMovingBlock_Elevator");
static_assert(offsetof(AMovingBlock_Elevator, SceneRootComponent) == 0x000290, "Member 'AMovingBlock_Elevator::SceneRootComponent' has a wrong offset!");
static_assert(offsetof(AMovingBlock_Elevator, MovingComponent) == 0x000298, "Member 'AMovingBlock_Elevator::MovingComponent' has a wrong offset!");
static_assert(offsetof(AMovingBlock_Elevator, Destination) == 0x0002A0, "Member 'AMovingBlock_Elevator::Destination' has a wrong offset!");
static_assert(offsetof(AMovingBlock_Elevator, RopeAttachPoint) == 0x0002A8, "Member 'AMovingBlock_Elevator::RopeAttachPoint' has a wrong offset!");
static_assert(offsetof(AMovingBlock_Elevator, RopeDestinationPoint) == 0x0002B0, "Member 'AMovingBlock_Elevator::RopeDestinationPoint' has a wrong offset!");
static_assert(offsetof(AMovingBlock_Elevator, ElevatorMovementComponent) == 0x0002B8, "Member 'AMovingBlock_Elevator::ElevatorMovementComponent' has a wrong offset!");
static_assert(offsetof(AMovingBlock_Elevator, RopeComponent) == 0x0002C0, "Member 'AMovingBlock_Elevator::RopeComponent' has a wrong offset!");

// Class Zion.MovingPlatform_Elevator
// 0x0088 (0x03E8 - 0x0360)
class AMovingPlatform_Elevator : public AOneWayPlatform
{
public:
	class USphereComponent*                       PlayerDetector;                                    // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UElevatorDestinationComponent*          ElevatorDestination;                               // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RopeAttachPoint;                                   // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UElevatorDestinationComponent*          RopeDestinationPoint;                              // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UElevatorMovementComponent*             ElevatorMovementComponent;                         // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URopeComponent*                         RopeComponent;                                     // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCacheElevatorState;                               // 0x0390(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerDetectionRange;                              // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseRope;                                          // 0x0398(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RopeWidthScale;                                    // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RopeMinLength;                                     // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FComponentReference>            RopeMeshesRef;                                     // 0x03A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0x10];                                     // 0x03B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InnerRadius;                                       // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OuterRadius;                                       // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Falloff;                                           // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOrientShakeTowardsEpicenter;                      // 0x03DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DD[0x3];                                      // 0x03DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CallToDestination();
	void CallToOrigin();
	void OnFinishMovement(bool bInstant, bool bWasMoving);
	void OnPlayerDetectorOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPlayerDetectorOverlapEnd(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnStartMovement(bool bInstant, bool bWasMoving);
	void TriggerElevator();

	float GetPlayerDetectionRange() const;
	bool IsMoving() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovingPlatform_Elevator">();
	}
	static class AMovingPlatform_Elevator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMovingPlatform_Elevator>();
	}
};
static_assert(alignof(AMovingPlatform_Elevator) == 0x000008, "Wrong alignment on AMovingPlatform_Elevator");
static_assert(sizeof(AMovingPlatform_Elevator) == 0x0003E8, "Wrong size on AMovingPlatform_Elevator");
static_assert(offsetof(AMovingPlatform_Elevator, PlayerDetector) == 0x000360, "Member 'AMovingPlatform_Elevator::PlayerDetector' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, ElevatorDestination) == 0x000368, "Member 'AMovingPlatform_Elevator::ElevatorDestination' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, RopeAttachPoint) == 0x000370, "Member 'AMovingPlatform_Elevator::RopeAttachPoint' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, RopeDestinationPoint) == 0x000378, "Member 'AMovingPlatform_Elevator::RopeDestinationPoint' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, ElevatorMovementComponent) == 0x000380, "Member 'AMovingPlatform_Elevator::ElevatorMovementComponent' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, RopeComponent) == 0x000388, "Member 'AMovingPlatform_Elevator::RopeComponent' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, bCacheElevatorState) == 0x000390, "Member 'AMovingPlatform_Elevator::bCacheElevatorState' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, PlayerDetectionRange) == 0x000394, "Member 'AMovingPlatform_Elevator::PlayerDetectionRange' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, bUseRope) == 0x000398, "Member 'AMovingPlatform_Elevator::bUseRope' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, RopeWidthScale) == 0x00039C, "Member 'AMovingPlatform_Elevator::RopeWidthScale' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, RopeMinLength) == 0x0003A0, "Member 'AMovingPlatform_Elevator::RopeMinLength' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, RopeMeshesRef) == 0x0003A8, "Member 'AMovingPlatform_Elevator::RopeMeshesRef' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, CameraShake) == 0x0003C8, "Member 'AMovingPlatform_Elevator::CameraShake' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, InnerRadius) == 0x0003D0, "Member 'AMovingPlatform_Elevator::InnerRadius' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, OuterRadius) == 0x0003D4, "Member 'AMovingPlatform_Elevator::OuterRadius' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, Falloff) == 0x0003D8, "Member 'AMovingPlatform_Elevator::Falloff' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, bOrientShakeTowardsEpicenter) == 0x0003DC, "Member 'AMovingPlatform_Elevator::bOrientShakeTowardsEpicenter' has a wrong offset!");
static_assert(offsetof(AMovingPlatform_Elevator, ForceFeedbackEffect) == 0x0003E0, "Member 'AMovingPlatform_Elevator::ForceFeedbackEffect' has a wrong offset!");

// Class Zion.niagaraBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class UniagaraBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsValid(const struct FSpineFXData& FXData);
	static void TryReleaseToPool(class UNiagaraComponent* NiagaraComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"niagaraBPFLibrary">();
	}
	static class UniagaraBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UniagaraBPFLibrary>();
	}
};
static_assert(alignof(UniagaraBPFLibrary) == 0x000008, "Wrong alignment on UniagaraBPFLibrary");
static_assert(sizeof(UniagaraBPFLibrary) == 0x000028, "Wrong size on UniagaraBPFLibrary");

// Class Zion.NotificationComponent
// 0x0068 (0x0108 - 0x00A0)
class UNotificationComponent final : public UActorComponent
{
public:
	float                                         DelayBetweenNotifications;                         // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NotificationDuration;                              // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EInventoryItemType>                    UnnotifiedItems;                                   // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UNotificationMapAsset*                  NotificationMap;                                   // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x48];                                      // 0x00C0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnItemAdded(const class UInventory* Inventory, const class FName& ItemId, int32 AddedCount);
	void OnNotificationDelayFinished();
	void OnNotificationDurationFinished();
	void OnPawnDeath();

	bool CanStartNotification() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotificationComponent">();
	}
	static class UNotificationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotificationComponent>();
	}
};
static_assert(alignof(UNotificationComponent) == 0x000008, "Wrong alignment on UNotificationComponent");
static_assert(sizeof(UNotificationComponent) == 0x000108, "Wrong size on UNotificationComponent");
static_assert(offsetof(UNotificationComponent, DelayBetweenNotifications) == 0x0000A0, "Member 'UNotificationComponent::DelayBetweenNotifications' has a wrong offset!");
static_assert(offsetof(UNotificationComponent, NotificationDuration) == 0x0000A4, "Member 'UNotificationComponent::NotificationDuration' has a wrong offset!");
static_assert(offsetof(UNotificationComponent, UnnotifiedItems) == 0x0000A8, "Member 'UNotificationComponent::UnnotifiedItems' has a wrong offset!");
static_assert(offsetof(UNotificationComponent, NotificationMap) == 0x0000B8, "Member 'UNotificationComponent::NotificationMap' has a wrong offset!");

// Class Zion.NotificationMapAsset
// 0x0050 (0x0080 - 0x0030)
class UNotificationMapAsset final : public UDataAsset
{
public:
	TMap<ENotificationTypes, struct FNotificationData> Notifications;                                // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotificationMapAsset">();
	}
	static class UNotificationMapAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotificationMapAsset>();
	}
};
static_assert(alignof(UNotificationMapAsset) == 0x000008, "Wrong alignment on UNotificationMapAsset");
static_assert(sizeof(UNotificationMapAsset) == 0x000080, "Wrong size on UNotificationMapAsset");
static_assert(offsetof(UNotificationMapAsset, Notifications) == 0x000030, "Member 'UNotificationMapAsset::Notifications' has a wrong offset!");

// Class Zion.OrientFromFloorComponent
// 0x0068 (0x0108 - 0x00A0)
class UOrientFromFloorComponent final : public UActorComponent
{
public:
	EOrientTargetType                             OrientTargetType;                                  // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentReference                    ComponentToOrient;                                 // 0x00A8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseBlend;                                         // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendSpeed;                                        // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bClampAngle;                                       // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampAngle;                                        // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSkipOnLowPerfPlatforms;                           // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x27];                                      // 0x00E1(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFacingChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrientFromFloorComponent">();
	}
	static class UOrientFromFloorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrientFromFloorComponent>();
	}
};
static_assert(alignof(UOrientFromFloorComponent) == 0x000008, "Wrong alignment on UOrientFromFloorComponent");
static_assert(sizeof(UOrientFromFloorComponent) == 0x000108, "Wrong size on UOrientFromFloorComponent");
static_assert(offsetof(UOrientFromFloorComponent, OrientTargetType) == 0x0000A0, "Member 'UOrientFromFloorComponent::OrientTargetType' has a wrong offset!");
static_assert(offsetof(UOrientFromFloorComponent, ComponentToOrient) == 0x0000A8, "Member 'UOrientFromFloorComponent::ComponentToOrient' has a wrong offset!");
static_assert(offsetof(UOrientFromFloorComponent, bUseBlend) == 0x0000D0, "Member 'UOrientFromFloorComponent::bUseBlend' has a wrong offset!");
static_assert(offsetof(UOrientFromFloorComponent, BlendSpeed) == 0x0000D4, "Member 'UOrientFromFloorComponent::BlendSpeed' has a wrong offset!");
static_assert(offsetof(UOrientFromFloorComponent, bClampAngle) == 0x0000D8, "Member 'UOrientFromFloorComponent::bClampAngle' has a wrong offset!");
static_assert(offsetof(UOrientFromFloorComponent, ClampAngle) == 0x0000DC, "Member 'UOrientFromFloorComponent::ClampAngle' has a wrong offset!");
static_assert(offsetof(UOrientFromFloorComponent, bSkipOnLowPerfPlatforms) == 0x0000E0, "Member 'UOrientFromFloorComponent::bSkipOnLowPerfPlatforms' has a wrong offset!");

// Class Zion.OrientToTargetComponent
// 0x0020 (0x00C0 - 0x00A0)
class UOrientToTargetComponent final : public UActorComponent
{
public:
	EOrientToTargetBlendMode                      BlendMode;                                         // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInjectionSpeed;                               // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationSpeed;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoDeactivate;                                   // 0x00AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoDeactivateTime;                                // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0xC];                                       // 0x00B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrientToTargetComponent">();
	}
	static class UOrientToTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrientToTargetComponent>();
	}
};
static_assert(alignof(UOrientToTargetComponent) == 0x000008, "Wrong alignment on UOrientToTargetComponent");
static_assert(sizeof(UOrientToTargetComponent) == 0x0000C0, "Wrong size on UOrientToTargetComponent");
static_assert(offsetof(UOrientToTargetComponent, BlendMode) == 0x0000A0, "Member 'UOrientToTargetComponent::BlendMode' has a wrong offset!");
static_assert(offsetof(UOrientToTargetComponent, BlendInjectionSpeed) == 0x0000A4, "Member 'UOrientToTargetComponent::BlendInjectionSpeed' has a wrong offset!");
static_assert(offsetof(UOrientToTargetComponent, RotationSpeed) == 0x0000A8, "Member 'UOrientToTargetComponent::RotationSpeed' has a wrong offset!");
static_assert(offsetof(UOrientToTargetComponent, bAutoDeactivate) == 0x0000AC, "Member 'UOrientToTargetComponent::bAutoDeactivate' has a wrong offset!");
static_assert(offsetof(UOrientToTargetComponent, AutoDeactivateTime) == 0x0000B0, "Member 'UOrientToTargetComponent::AutoDeactivateTime' has a wrong offset!");

// Class Zion.PassiveComponent
// 0x0070 (0x0110 - 0x00A0)
class UPassiveComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnPassiveEquipped;                                 // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPassiveUnequipped;                               // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         MaxPassiveCount;                                   // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DefaultSlotCount;                                  // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AdditionalSlotCount;                               // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         UsedSlotCount;                                     // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentLoadoutIndex;                               // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPassiveRuntimeData>            Passives;                                          // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPassiveRuntimeData>            PassivesToUpdate;                                  // 0x00E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPlayerPassiveLoadoutData>      PassiveLoadouts;                                   // 0x00F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EPassiveEquipResult EquipPassive(const class FName& PassiveID, bool bAddToCurrentLoadout, int32 InsertIndex);
	void EquipPassiveLoadout(int32 LoadoutIndex);
	void OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn);
	void ReplacePassiveInAllLoadouts(const class FName& PassiveToRemove, const class FName& PassiveToAdd);
	bool UnequipPassive(const class FName& PassiveID, int32* OutPassiveIndex, bool bRemoveFromCurrentLoadout);

	EPassiveEquipResult CanEquipPassive(const struct FInventoryItemPassiveData& ItemPassiveData) const;
	int32 GetAvailableSlotCount() const;
	int32 GetCurrentPassiveLoadoutIndex() const;
	const TArray<struct FPassiveRuntimeData> GetEquippedPassives() const;
	int32 GetSlotCount() const;
	int32 GetUsedSlotCount() const;
	bool IsPassiveEquipped(const class FName& PassiveID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PassiveComponent">();
	}
	static class UPassiveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassiveComponent>();
	}
};
static_assert(alignof(UPassiveComponent) == 0x000008, "Wrong alignment on UPassiveComponent");
static_assert(sizeof(UPassiveComponent) == 0x000110, "Wrong size on UPassiveComponent");
static_assert(offsetof(UPassiveComponent, OnPassiveEquipped) == 0x0000A0, "Member 'UPassiveComponent::OnPassiveEquipped' has a wrong offset!");
static_assert(offsetof(UPassiveComponent, OnPassiveUnequipped) == 0x0000B0, "Member 'UPassiveComponent::OnPassiveUnequipped' has a wrong offset!");
static_assert(offsetof(UPassiveComponent, MaxPassiveCount) == 0x0000C0, "Member 'UPassiveComponent::MaxPassiveCount' has a wrong offset!");
static_assert(offsetof(UPassiveComponent, DefaultSlotCount) == 0x0000C4, "Member 'UPassiveComponent::DefaultSlotCount' has a wrong offset!");
static_assert(offsetof(UPassiveComponent, AdditionalSlotCount) == 0x0000C8, "Member 'UPassiveComponent::AdditionalSlotCount' has a wrong offset!");
static_assert(offsetof(UPassiveComponent, UsedSlotCount) == 0x0000CC, "Member 'UPassiveComponent::UsedSlotCount' has a wrong offset!");
static_assert(offsetof(UPassiveComponent, CurrentLoadoutIndex) == 0x0000D0, "Member 'UPassiveComponent::CurrentLoadoutIndex' has a wrong offset!");
static_assert(offsetof(UPassiveComponent, Passives) == 0x0000D8, "Member 'UPassiveComponent::Passives' has a wrong offset!");
static_assert(offsetof(UPassiveComponent, PassivesToUpdate) == 0x0000E8, "Member 'UPassiveComponent::PassivesToUpdate' has a wrong offset!");
static_assert(offsetof(UPassiveComponent, PassiveLoadouts) == 0x0000F8, "Member 'UPassiveComponent::PassiveLoadouts' has a wrong offset!");

// Class Zion.Passive_AttackDamageAboveDistance
// 0x0008 (0x0038 - 0x0030)
class UPassive_AttackDamageAboveDistance final : public UPassive
{
public:
	int32                                         Distance;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AttackDamageAboveDistance">();
	}
	static class UPassive_AttackDamageAboveDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AttackDamageAboveDistance>();
	}
};
static_assert(alignof(UPassive_AttackDamageAboveDistance) == 0x000008, "Wrong alignment on UPassive_AttackDamageAboveDistance");
static_assert(sizeof(UPassive_AttackDamageAboveDistance) == 0x000038, "Wrong size on UPassive_AttackDamageAboveDistance");
static_assert(offsetof(UPassive_AttackDamageAboveDistance, Distance) == 0x000030, "Member 'UPassive_AttackDamageAboveDistance::Distance' has a wrong offset!");
static_assert(offsetof(UPassive_AttackDamageAboveDistance, PercentageBonus) == 0x000034, "Member 'UPassive_AttackDamageAboveDistance::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_AttackDamageBelowDistance
// 0x0008 (0x0038 - 0x0030)
class UPassive_AttackDamageBelowDistance final : public UPassive
{
public:
	int32                                         Distance;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AttackDamageBelowDistance">();
	}
	static class UPassive_AttackDamageBelowDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AttackDamageBelowDistance>();
	}
};
static_assert(alignof(UPassive_AttackDamageBelowDistance) == 0x000008, "Wrong alignment on UPassive_AttackDamageBelowDistance");
static_assert(sizeof(UPassive_AttackDamageBelowDistance) == 0x000038, "Wrong size on UPassive_AttackDamageBelowDistance");
static_assert(offsetof(UPassive_AttackDamageBelowDistance, Distance) == 0x000030, "Member 'UPassive_AttackDamageBelowDistance::Distance' has a wrong offset!");
static_assert(offsetof(UPassive_AttackDamageBelowDistance, PercentageBonus) == 0x000034, "Member 'UPassive_AttackDamageBelowDistance::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_AttackDamageMaxHP
// 0x0008 (0x0038 - 0x0030)
class UPassive_AttackDamageMaxHP final : public UPassive
{
public:
	int32                                         HPPercentage;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AttackDamageMaxHP">();
	}
	static class UPassive_AttackDamageMaxHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AttackDamageMaxHP>();
	}
};
static_assert(alignof(UPassive_AttackDamageMaxHP) == 0x000008, "Wrong alignment on UPassive_AttackDamageMaxHP");
static_assert(sizeof(UPassive_AttackDamageMaxHP) == 0x000038, "Wrong size on UPassive_AttackDamageMaxHP");
static_assert(offsetof(UPassive_AttackDamageMaxHP, HPPercentage) == 0x000030, "Member 'UPassive_AttackDamageMaxHP::HPPercentage' has a wrong offset!");
static_assert(offsetof(UPassive_AttackDamageMaxHP, PercentageBonus) == 0x000034, "Member 'UPassive_AttackDamageMaxHP::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_AttackDamageMinHP
// 0x0008 (0x0038 - 0x0030)
class UPassive_AttackDamageMinHP final : public UPassive
{
public:
	int32                                         HPPercentage;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AttackDamageMinHP">();
	}
	static class UPassive_AttackDamageMinHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AttackDamageMinHP>();
	}
};
static_assert(alignof(UPassive_AttackDamageMinHP) == 0x000008, "Wrong alignment on UPassive_AttackDamageMinHP");
static_assert(sizeof(UPassive_AttackDamageMinHP) == 0x000038, "Wrong size on UPassive_AttackDamageMinHP");
static_assert(offsetof(UPassive_AttackDamageMinHP, HPPercentage) == 0x000030, "Member 'UPassive_AttackDamageMinHP::HPPercentage' has a wrong offset!");
static_assert(offsetof(UPassive_AttackDamageMinHP, PercentageBonus) == 0x000034, "Member 'UPassive_AttackDamageMinHP::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_AttackDamageMovementMode
// 0x0008 (0x0038 - 0x0030)
class UPassive_AttackDamageMovementMode final : public UPassive
{
public:
	EMovementMode                                 MovementMode;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AttackDamageMovementMode">();
	}
	static class UPassive_AttackDamageMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AttackDamageMovementMode>();
	}
};
static_assert(alignof(UPassive_AttackDamageMovementMode) == 0x000008, "Wrong alignment on UPassive_AttackDamageMovementMode");
static_assert(sizeof(UPassive_AttackDamageMovementMode) == 0x000038, "Wrong size on UPassive_AttackDamageMovementMode");
static_assert(offsetof(UPassive_AttackDamageMovementMode, MovementMode) == 0x000030, "Member 'UPassive_AttackDamageMovementMode::MovementMode' has a wrong offset!");
static_assert(offsetof(UPassive_AttackDamageMovementMode, PercentageBonus) == 0x000034, "Member 'UPassive_AttackDamageMovementMode::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_AttackTypeBonus
// 0x0008 (0x0038 - 0x0030)
class UPassive_AttackTypeBonus final : public UPassive
{
public:
	EAttackType                                   AttackType;                                        // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AttackTypeBonus">();
	}
	static class UPassive_AttackTypeBonus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AttackTypeBonus>();
	}
};
static_assert(alignof(UPassive_AttackTypeBonus) == 0x000008, "Wrong alignment on UPassive_AttackTypeBonus");
static_assert(sizeof(UPassive_AttackTypeBonus) == 0x000038, "Wrong size on UPassive_AttackTypeBonus");
static_assert(offsetof(UPassive_AttackTypeBonus, AttackType) == 0x000030, "Member 'UPassive_AttackTypeBonus::AttackType' has a wrong offset!");
static_assert(offsetof(UPassive_AttackTypeBonus, PercentageBonus) == 0x000034, "Member 'UPassive_AttackTypeBonus::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_AutoRegenerateHP
// 0x0008 (0x0058 - 0x0050)
class UPassive_AutoRegenerateHP final : public UPassive_AutoRegenerate
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_AutoRegenerateHP">();
	}
	static class UPassive_AutoRegenerateHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_AutoRegenerateHP>();
	}
};
static_assert(alignof(UPassive_AutoRegenerateHP) == 0x000008, "Wrong alignment on UPassive_AutoRegenerateHP");
static_assert(sizeof(UPassive_AutoRegenerateHP) == 0x000058, "Wrong size on UPassive_AutoRegenerateHP");

// Class Zion.Passive_BurnDamage
// 0x0008 (0x0038 - 0x0030)
class UPassive_BurnDamage final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_BurnDamage">();
	}
	static class UPassive_BurnDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_BurnDamage>();
	}
};
static_assert(alignof(UPassive_BurnDamage) == 0x000008, "Wrong alignment on UPassive_BurnDamage");
static_assert(sizeof(UPassive_BurnDamage) == 0x000038, "Wrong size on UPassive_BurnDamage");
static_assert(offsetof(UPassive_BurnDamage, PercentageBonus) == 0x000030, "Member 'UPassive_BurnDamage::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_CurrencyPercentage
// 0x0008 (0x0038 - 0x0030)
class UPassive_CurrencyPercentage final : public UPassive
{
public:
	ECurrencyType                                 CurrencyType;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_CurrencyPercentage">();
	}
	static class UPassive_CurrencyPercentage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_CurrencyPercentage>();
	}
};
static_assert(alignof(UPassive_CurrencyPercentage) == 0x000008, "Wrong alignment on UPassive_CurrencyPercentage");
static_assert(sizeof(UPassive_CurrencyPercentage) == 0x000038, "Wrong size on UPassive_CurrencyPercentage");
static_assert(offsetof(UPassive_CurrencyPercentage, CurrencyType) == 0x000030, "Member 'UPassive_CurrencyPercentage::CurrencyType' has a wrong offset!");
static_assert(offsetof(UPassive_CurrencyPercentage, PercentageBonus) == 0x000034, "Member 'UPassive_CurrencyPercentage::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_DamageCutAttackType
// 0x0008 (0x0038 - 0x0030)
class UPassive_DamageCutAttackType final : public UPassive
{
public:
	EAttackType                                   AttackType;                                        // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DamageCutAttackType">();
	}
	static class UPassive_DamageCutAttackType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DamageCutAttackType>();
	}
};
static_assert(alignof(UPassive_DamageCutAttackType) == 0x000008, "Wrong alignment on UPassive_DamageCutAttackType");
static_assert(sizeof(UPassive_DamageCutAttackType) == 0x000038, "Wrong size on UPassive_DamageCutAttackType");
static_assert(offsetof(UPassive_DamageCutAttackType, AttackType) == 0x000030, "Member 'UPassive_DamageCutAttackType::AttackType' has a wrong offset!");
static_assert(offsetof(UPassive_DamageCutAttackType, PercentageBonus) == 0x000034, "Member 'UPassive_DamageCutAttackType::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_DamageCutBelowDistance
// 0x0008 (0x0038 - 0x0030)
class UPassive_DamageCutBelowDistance final : public UPassive
{
public:
	int32                                         Distance;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DamageCutBelowDistance">();
	}
	static class UPassive_DamageCutBelowDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DamageCutBelowDistance>();
	}
};
static_assert(alignof(UPassive_DamageCutBelowDistance) == 0x000008, "Wrong alignment on UPassive_DamageCutBelowDistance");
static_assert(sizeof(UPassive_DamageCutBelowDistance) == 0x000038, "Wrong size on UPassive_DamageCutBelowDistance");
static_assert(offsetof(UPassive_DamageCutBelowDistance, Distance) == 0x000030, "Member 'UPassive_DamageCutBelowDistance::Distance' has a wrong offset!");
static_assert(offsetof(UPassive_DamageCutBelowDistance, PercentageBonus) == 0x000034, "Member 'UPassive_DamageCutBelowDistance::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_DamageCutElementType
// 0x0020 (0x0050 - 0x0030)
class UPassive_DamageCutElementType final : public UPassive
{
public:
	bool                                          bImmuneToStatusEffect;                             // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAttackElement>                        ElementTypes;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int32                                         PercentageBonus;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DamageCutElementType">();
	}
	static class UPassive_DamageCutElementType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DamageCutElementType>();
	}
};
static_assert(alignof(UPassive_DamageCutElementType) == 0x000008, "Wrong alignment on UPassive_DamageCutElementType");
static_assert(sizeof(UPassive_DamageCutElementType) == 0x000050, "Wrong size on UPassive_DamageCutElementType");
static_assert(offsetof(UPassive_DamageCutElementType, bImmuneToStatusEffect) == 0x000030, "Member 'UPassive_DamageCutElementType::bImmuneToStatusEffect' has a wrong offset!");
static_assert(offsetof(UPassive_DamageCutElementType, ElementTypes) == 0x000038, "Member 'UPassive_DamageCutElementType::ElementTypes' has a wrong offset!");
static_assert(offsetof(UPassive_DamageCutElementType, PercentageBonus) == 0x000048, "Member 'UPassive_DamageCutElementType::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_DamageCutMaxHP
// 0x0008 (0x0038 - 0x0030)
class UPassive_DamageCutMaxHP final : public UPassive
{
public:
	int32                                         HPPercentage;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DamageCutMaxHP">();
	}
	static class UPassive_DamageCutMaxHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DamageCutMaxHP>();
	}
};
static_assert(alignof(UPassive_DamageCutMaxHP) == 0x000008, "Wrong alignment on UPassive_DamageCutMaxHP");
static_assert(sizeof(UPassive_DamageCutMaxHP) == 0x000038, "Wrong size on UPassive_DamageCutMaxHP");
static_assert(offsetof(UPassive_DamageCutMaxHP, HPPercentage) == 0x000030, "Member 'UPassive_DamageCutMaxHP::HPPercentage' has a wrong offset!");
static_assert(offsetof(UPassive_DamageCutMaxHP, PercentageBonus) == 0x000034, "Member 'UPassive_DamageCutMaxHP::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_DamageCutMinHP
// 0x0008 (0x0038 - 0x0030)
class UPassive_DamageCutMinHP final : public UPassive
{
public:
	int32                                         HPPercentage;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PercentageBonus;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DamageCutMinHP">();
	}
	static class UPassive_DamageCutMinHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DamageCutMinHP>();
	}
};
static_assert(alignof(UPassive_DamageCutMinHP) == 0x000008, "Wrong alignment on UPassive_DamageCutMinHP");
static_assert(sizeof(UPassive_DamageCutMinHP) == 0x000038, "Wrong size on UPassive_DamageCutMinHP");
static_assert(offsetof(UPassive_DamageCutMinHP, HPPercentage) == 0x000030, "Member 'UPassive_DamageCutMinHP::HPPercentage' has a wrong offset!");
static_assert(offsetof(UPassive_DamageCutMinHP, PercentageBonus) == 0x000034, "Member 'UPassive_DamageCutMinHP::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_DamageCutPercentage
// 0x0008 (0x0038 - 0x0030)
class UPassive_DamageCutPercentage final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DamageCutPercentage">();
	}
	static class UPassive_DamageCutPercentage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DamageCutPercentage>();
	}
};
static_assert(alignof(UPassive_DamageCutPercentage) == 0x000008, "Wrong alignment on UPassive_DamageCutPercentage");
static_assert(sizeof(UPassive_DamageCutPercentage) == 0x000038, "Wrong size on UPassive_DamageCutPercentage");
static_assert(offsetof(UPassive_DamageCutPercentage, PercentageBonus) == 0x000030, "Member 'UPassive_DamageCutPercentage::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_DashChargeShort
// 0x0000 (0x0030 - 0x0030)
class UPassive_DashChargeShort final : public UPassive
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_DashChargeShort">();
	}
	static class UPassive_DashChargeShort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_DashChargeShort>();
	}
};
static_assert(alignof(UPassive_DashChargeShort) == 0x000008, "Wrong alignment on UPassive_DashChargeShort");
static_assert(sizeof(UPassive_DashChargeShort) == 0x000030, "Wrong size on UPassive_DashChargeShort");

// Class Zion.Passive_FallingGravityFactor_Increase
// 0x0008 (0x0038 - 0x0030)
class UPassive_FallingGravityFactor_Increase final : public UPassive
{
public:
	int32                                         FallingGravityIncreasePercentage;                  // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_FallingGravityFactor_Increase">();
	}
	static class UPassive_FallingGravityFactor_Increase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_FallingGravityFactor_Increase>();
	}
};
static_assert(alignof(UPassive_FallingGravityFactor_Increase) == 0x000008, "Wrong alignment on UPassive_FallingGravityFactor_Increase");
static_assert(sizeof(UPassive_FallingGravityFactor_Increase) == 0x000038, "Wrong size on UPassive_FallingGravityFactor_Increase");
static_assert(offsetof(UPassive_FallingGravityFactor_Increase, FallingGravityIncreasePercentage) == 0x000030, "Member 'UPassive_FallingGravityFactor_Increase::FallingGravityIncreasePercentage' has a wrong offset!");

// Class Zion.Passive_FreezeDamage
// 0x0008 (0x0038 - 0x0030)
class UPassive_FreezeDamage final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_FreezeDamage">();
	}
	static class UPassive_FreezeDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_FreezeDamage>();
	}
};
static_assert(alignof(UPassive_FreezeDamage) == 0x000008, "Wrong alignment on UPassive_FreezeDamage");
static_assert(sizeof(UPassive_FreezeDamage) == 0x000038, "Wrong size on UPassive_FreezeDamage");
static_assert(offsetof(UPassive_FreezeDamage, PercentageBonus) == 0x000030, "Member 'UPassive_FreezeDamage::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_HealPower
// 0x0008 (0x0038 - 0x0030)
class UPassive_HealPower final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_HealPower">();
	}
	static class UPassive_HealPower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_HealPower>();
	}
};
static_assert(alignof(UPassive_HealPower) == 0x000008, "Wrong alignment on UPassive_HealPower");
static_assert(sizeof(UPassive_HealPower) == 0x000038, "Wrong size on UPassive_HealPower");
static_assert(offsetof(UPassive_HealPower, PercentageBonus) == 0x000030, "Member 'UPassive_HealPower::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_OnAttack_InstantKillTarget
// 0x00A0 (0x00E8 - 0x0048)
class UPassive_OnAttack_InstantKillTarget final : public UPassive_OnAttack
{
public:
	float                                         Cooldown;                                          // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     TriggerChanceCurve;                                // 0x0050(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_OnAttack_InstantKillTarget">();
	}
	static class UPassive_OnAttack_InstantKillTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_OnAttack_InstantKillTarget>();
	}
};
static_assert(alignof(UPassive_OnAttack_InstantKillTarget) == 0x000008, "Wrong alignment on UPassive_OnAttack_InstantKillTarget");
static_assert(sizeof(UPassive_OnAttack_InstantKillTarget) == 0x0000E8, "Wrong size on UPassive_OnAttack_InstantKillTarget");
static_assert(offsetof(UPassive_OnAttack_InstantKillTarget, Cooldown) == 0x000048, "Member 'UPassive_OnAttack_InstantKillTarget::Cooldown' has a wrong offset!");
static_assert(offsetof(UPassive_OnAttack_InstantKillTarget, TriggerChanceCurve) == 0x000050, "Member 'UPassive_OnAttack_InstantKillTarget::TriggerChanceCurve' has a wrong offset!");

// Class Zion.Passive_OnAttack_RestoreHP
// 0x0008 (0x0060 - 0x0058)
class UPassive_OnAttack_RestoreHP final : public UPassive_OnAttack_Restore
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_OnAttack_RestoreHP">();
	}
	static class UPassive_OnAttack_RestoreHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_OnAttack_RestoreHP>();
	}
};
static_assert(alignof(UPassive_OnAttack_RestoreHP) == 0x000008, "Wrong alignment on UPassive_OnAttack_RestoreHP");
static_assert(sizeof(UPassive_OnAttack_RestoreHP) == 0x000060, "Wrong size on UPassive_OnAttack_RestoreHP");

// Class Zion.Passive_OnKill_RestoreHP
// 0x0008 (0x0060 - 0x0058)
class UPassive_OnKill_RestoreHP final : public UPassive_OnKill_Restore
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_OnKill_RestoreHP">();
	}
	static class UPassive_OnKill_RestoreHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_OnKill_RestoreHP>();
	}
};
static_assert(alignof(UPassive_OnKill_RestoreHP) == 0x000008, "Wrong alignment on UPassive_OnKill_RestoreHP");
static_assert(sizeof(UPassive_OnKill_RestoreHP) == 0x000060, "Wrong size on UPassive_OnKill_RestoreHP");

// Class Zion.Passive_PlayerDebuffedDamage
// 0x0008 (0x0038 - 0x0030)
class UPassive_PlayerDebuffedDamage final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_PlayerDebuffedDamage">();
	}
	static class UPassive_PlayerDebuffedDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_PlayerDebuffedDamage>();
	}
};
static_assert(alignof(UPassive_PlayerDebuffedDamage) == 0x000008, "Wrong alignment on UPassive_PlayerDebuffedDamage");
static_assert(sizeof(UPassive_PlayerDebuffedDamage) == 0x000038, "Wrong size on UPassive_PlayerDebuffedDamage");
static_assert(offsetof(UPassive_PlayerDebuffedDamage, PercentageBonus) == 0x000030, "Member 'UPassive_PlayerDebuffedDamage::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_ReduceKnockbackImpulseForce
// 0x0008 (0x0038 - 0x0030)
class UPassive_ReduceKnockbackImpulseForce final : public UPassive
{
public:
	int32                                         ImpulseForceReductionPercentage;                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_ReduceKnockbackImpulseForce">();
	}
	static class UPassive_ReduceKnockbackImpulseForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_ReduceKnockbackImpulseForce>();
	}
};
static_assert(alignof(UPassive_ReduceKnockbackImpulseForce) == 0x000008, "Wrong alignment on UPassive_ReduceKnockbackImpulseForce");
static_assert(sizeof(UPassive_ReduceKnockbackImpulseForce) == 0x000038, "Wrong size on UPassive_ReduceKnockbackImpulseForce");
static_assert(offsetof(UPassive_ReduceKnockbackImpulseForce, ImpulseForceReductionPercentage) == 0x000030, "Member 'UPassive_ReduceKnockbackImpulseForce::ImpulseForceReductionPercentage' has a wrong offset!");

// Class Zion.Passive_StaminaDamage
// 0x0008 (0x0038 - 0x0030)
class UPassive_StaminaDamage final : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_StaminaDamage">();
	}
	static class UPassive_StaminaDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_StaminaDamage>();
	}
};
static_assert(alignof(UPassive_StaminaDamage) == 0x000008, "Wrong alignment on UPassive_StaminaDamage");
static_assert(sizeof(UPassive_StaminaDamage) == 0x000038, "Wrong size on UPassive_StaminaDamage");
static_assert(offsetof(UPassive_StaminaDamage, PercentageBonus) == 0x000030, "Member 'UPassive_StaminaDamage::PercentageBonus' has a wrong offset!");

// Class Zion.Passive_SwimFaster
// 0x0008 (0x0038 - 0x0030)
class UPassive_SwimFaster final : public UPassive
{
public:
	float                                         FactorBonus;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_SwimFaster">();
	}
	static class UPassive_SwimFaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_SwimFaster>();
	}
};
static_assert(alignof(UPassive_SwimFaster) == 0x000008, "Wrong alignment on UPassive_SwimFaster");
static_assert(sizeof(UPassive_SwimFaster) == 0x000038, "Wrong size on UPassive_SwimFaster");
static_assert(offsetof(UPassive_SwimFaster, FactorBonus) == 0x000030, "Member 'UPassive_SwimFaster::FactorBonus' has a wrong offset!");

// Class Zion.Passive_TargetStunnedDamage
// 0x0008 (0x0038 - 0x0030)
class UPassive_TargetStunnedDamage : public UPassive
{
public:
	int32                                         PercentageBonus;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passive_TargetStunnedDamage">();
	}
	static class UPassive_TargetStunnedDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassive_TargetStunnedDamage>();
	}
};
static_assert(alignof(UPassive_TargetStunnedDamage) == 0x000008, "Wrong alignment on UPassive_TargetStunnedDamage");
static_assert(sizeof(UPassive_TargetStunnedDamage) == 0x000038, "Wrong size on UPassive_TargetStunnedDamage");
static_assert(offsetof(UPassive_TargetStunnedDamage, PercentageBonus) == 0x000030, "Member 'UPassive_TargetStunnedDamage::PercentageBonus' has a wrong offset!");

// Class Zion.PhysicsReactionComponent
// 0x0090 (0x0130 - 0x00A0)
class UPhysicsReactionComponent final : public UActorComponent
{
public:
	bool                                          bEnabled;                                          // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentReference                    PhysicsComponentRef;                               // 0x00A8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLimitVelocity;                                    // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VelocityLimit;                                     // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EAbilityWeightCategory, float>           ImpulseForWeightCategories;                        // 0x00D8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    PhysicsComponent;                                  // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnGotAbilityApplied(class AAbility* Ability, class AActor* Source, const struct FHitData& HitData);
	void SetEnabled(bool bNewEnabled);

	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsReactionComponent">();
	}
	static class UPhysicsReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsReactionComponent>();
	}
};
static_assert(alignof(UPhysicsReactionComponent) == 0x000008, "Wrong alignment on UPhysicsReactionComponent");
static_assert(sizeof(UPhysicsReactionComponent) == 0x000130, "Wrong size on UPhysicsReactionComponent");
static_assert(offsetof(UPhysicsReactionComponent, bEnabled) == 0x0000A0, "Member 'UPhysicsReactionComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UPhysicsReactionComponent, PhysicsComponentRef) == 0x0000A8, "Member 'UPhysicsReactionComponent::PhysicsComponentRef' has a wrong offset!");
static_assert(offsetof(UPhysicsReactionComponent, bLimitVelocity) == 0x0000D0, "Member 'UPhysicsReactionComponent::bLimitVelocity' has a wrong offset!");
static_assert(offsetof(UPhysicsReactionComponent, VelocityLimit) == 0x0000D4, "Member 'UPhysicsReactionComponent::VelocityLimit' has a wrong offset!");
static_assert(offsetof(UPhysicsReactionComponent, ImpulseForWeightCategories) == 0x0000D8, "Member 'UPhysicsReactionComponent::ImpulseForWeightCategories' has a wrong offset!");
static_assert(offsetof(UPhysicsReactionComponent, PhysicsComponent) == 0x000128, "Member 'UPhysicsReactionComponent::PhysicsComponent' has a wrong offset!");

// Class Zion.PlayerCameraManagerZion
// 0x0100 (0x25C0 - 0x24C0)
class APlayerCameraManagerZion : public APlayerCameraManager
{
public:
	uint8                                         Pad_24C0[0x30];                                    // 0x24C0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGameplayCamera>            GameplayCameraClass;                               // 0x24F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           MainMPC;                                           // 0x24F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           BlackBordersMPC;                                   // 0x2500(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     BlackBorderPostProcessMaterial;                    // 0x2508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSimulateAspectRatioLock;                          // 0x2510(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2511[0xAF];                                    // 0x2511(0x00AF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class APlayerCameraManagerZion* Get(const class UObject* WorldContextObject, int32 PlayerControllerIndex);

	void ResetCameraLocation();
	void SetViewTargetToGameplayCamera(const struct FViewTargetTransitionParams& ViewTargetTransitionParams, bool bInterruptOnGoingBlend);

	struct FBox GetActiveCameraClampBox() const;
	class AGameplayCamera* GetGameplayCamera() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCameraManagerZion">();
	}
	static class APlayerCameraManagerZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerCameraManagerZion>();
	}
};
static_assert(alignof(APlayerCameraManagerZion) == 0x000010, "Wrong alignment on APlayerCameraManagerZion");
static_assert(sizeof(APlayerCameraManagerZion) == 0x0025C0, "Wrong size on APlayerCameraManagerZion");
static_assert(offsetof(APlayerCameraManagerZion, GameplayCameraClass) == 0x0024F0, "Member 'APlayerCameraManagerZion::GameplayCameraClass' has a wrong offset!");
static_assert(offsetof(APlayerCameraManagerZion, MainMPC) == 0x0024F8, "Member 'APlayerCameraManagerZion::MainMPC' has a wrong offset!");
static_assert(offsetof(APlayerCameraManagerZion, BlackBordersMPC) == 0x002500, "Member 'APlayerCameraManagerZion::BlackBordersMPC' has a wrong offset!");
static_assert(offsetof(APlayerCameraManagerZion, BlackBorderPostProcessMaterial) == 0x002508, "Member 'APlayerCameraManagerZion::BlackBorderPostProcessMaterial' has a wrong offset!");
static_assert(offsetof(APlayerCameraManagerZion, bSimulateAspectRatioLock) == 0x002510, "Member 'APlayerCameraManagerZion::bSimulateAspectRatioLock' has a wrong offset!");

// Class Zion.PlayerCostumeComponent
// 0x0088 (0x0128 - 0x00A0)
class UPlayerCostumeComponent final : public UActorComponent
{
public:
	class FName                                   DefaultCostumeID;                                  // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USpineAtlasAsset*                       SpineAtlasAsset;                                   // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineSkeletonDataAsset*                SpineSkeletonDataAsset;                            // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineNotifyAsset*                      SpineNotifyAsset;                                  // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EPlayerCostumeFX, class UNiagaraSystem*> CostumeFXs;                                        // 0x00D8(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void ApplyPendingCostume();
	void EquipCostume(const class FName& InCostumeID);
	void SetPendingCostumeID(const class FName& InCostumeID);

	class FName GetEquippedCostumeID() const;
	class FName GetPendingOrEquippedCostumeID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCostumeComponent">();
	}
	static class UPlayerCostumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCostumeComponent>();
	}
};
static_assert(alignof(UPlayerCostumeComponent) == 0x000008, "Wrong alignment on UPlayerCostumeComponent");
static_assert(sizeof(UPlayerCostumeComponent) == 0x000128, "Wrong size on UPlayerCostumeComponent");
static_assert(offsetof(UPlayerCostumeComponent, DefaultCostumeID) == 0x0000A0, "Member 'UPlayerCostumeComponent::DefaultCostumeID' has a wrong offset!");
static_assert(offsetof(UPlayerCostumeComponent, SpineAtlasAsset) == 0x0000C0, "Member 'UPlayerCostumeComponent::SpineAtlasAsset' has a wrong offset!");
static_assert(offsetof(UPlayerCostumeComponent, SpineSkeletonDataAsset) == 0x0000C8, "Member 'UPlayerCostumeComponent::SpineSkeletonDataAsset' has a wrong offset!");
static_assert(offsetof(UPlayerCostumeComponent, SpineNotifyAsset) == 0x0000D0, "Member 'UPlayerCostumeComponent::SpineNotifyAsset' has a wrong offset!");
static_assert(offsetof(UPlayerCostumeComponent, CostumeFXs) == 0x0000D8, "Member 'UPlayerCostumeComponent::CostumeFXs' has a wrong offset!");

// Class Zion.PlayerStartZion
// 0x0000 (0x02C0 - 0x02C0)
class APlayerStartZion : public APlayerStart
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStartZion">();
	}
	static class APlayerStartZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStartZion>();
	}
};
static_assert(alignof(APlayerStartZion) == 0x000008, "Wrong alignment on APlayerStartZion");
static_assert(sizeof(APlayerStartZion) == 0x0002C0, "Wrong size on APlayerStartZion");

// Class Zion.PlayerStartZionMovable
// 0x0000 (0x02C0 - 0x02C0)
class APlayerStartZionMovable : public APlayerStartZion
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStartZionMovable">();
	}
	static class APlayerStartZionMovable* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStartZionMovable>();
	}
};
static_assert(alignof(APlayerStartZionMovable) == 0x000008, "Wrong alignment on APlayerStartZionMovable");
static_assert(sizeof(APlayerStartZionMovable) == 0x0002C0, "Wrong size on APlayerStartZionMovable");

// Class Zion.PlayUMGAnimationAsyncAction
// 0x0030 (0x0060 - 0x0030)
class UPlayUMGAnimationAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPlayUMGAnimationAsyncAction* PlayUMGAnimation(class UUserWidget* Widget, class UWidgetAnimation* InAnimation, bool bLockNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayUMGAnimationAsyncAction">();
	}
	static class UPlayUMGAnimationAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayUMGAnimationAsyncAction>();
	}
};
static_assert(alignof(UPlayUMGAnimationAsyncAction) == 0x000008, "Wrong alignment on UPlayUMGAnimationAsyncAction");
static_assert(sizeof(UPlayUMGAnimationAsyncAction) == 0x000060, "Wrong size on UPlayUMGAnimationAsyncAction");
static_assert(offsetof(UPlayUMGAnimationAsyncAction, OnFinish) == 0x000030, "Member 'UPlayUMGAnimationAsyncAction::OnFinish' has a wrong offset!");

// Class Zion.PoolSystemComponent
// 0x0050 (0x00F0 - 0x00A0)
class UPoolSystemComponent final : public UActorComponent
{
public:
	TMap<TSubclassOf<class UObject>, struct FObjectArray> CachedInstances;                           // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UPoolSystemComponent* Get(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolSystemComponent">();
	}
	static class UPoolSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoolSystemComponent>();
	}
};
static_assert(alignof(UPoolSystemComponent) == 0x000008, "Wrong alignment on UPoolSystemComponent");
static_assert(sizeof(UPoolSystemComponent) == 0x0000F0, "Wrong size on UPoolSystemComponent");
static_assert(offsetof(UPoolSystemComponent, CachedInstances) == 0x0000A0, "Member 'UPoolSystemComponent::CachedInstances' has a wrong offset!");

// Class Zion.ProfileSubsystem
// 0x0018 (0x0048 - 0x0030)
class UProfileSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetCurrentProfileName() const;
	bool IsUsingProfileSystem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfileSubsystem">();
	}
	static class UProfileSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProfileSubsystem>();
	}
};
static_assert(alignof(UProfileSubsystem) == 0x000008, "Wrong alignment on UProfileSubsystem");
static_assert(sizeof(UProfileSubsystem) == 0x000048, "Wrong size on UProfileSubsystem");

// Class Zion.PSOCacheDataAsset
// 0x0020 (0x0050 - 0x0030)
class UPSOCacheDataAsset final : public UDataAsset
{
public:
	TArray<class UNiagaraSystem*>                 VFXs;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             Characters;                                        // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PSOCacheDataAsset">();
	}
	static class UPSOCacheDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPSOCacheDataAsset>();
	}
};
static_assert(alignof(UPSOCacheDataAsset) == 0x000008, "Wrong alignment on UPSOCacheDataAsset");
static_assert(sizeof(UPSOCacheDataAsset) == 0x000050, "Wrong size on UPSOCacheDataAsset");
static_assert(offsetof(UPSOCacheDataAsset, VFXs) == 0x000030, "Member 'UPSOCacheDataAsset::VFXs' has a wrong offset!");
static_assert(offsetof(UPSOCacheDataAsset, Characters) == 0x000040, "Member 'UPSOCacheDataAsset::Characters' has a wrong offset!");

// Class Zion.RadialSliderZion
// 0x0010 (0x0810 - 0x0800)
class URadialSliderZion final : public URadialSlider
{
public:
	uint8                                         Pad_800[0x10];                                     // 0x0800(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadialSliderZion">();
	}
	static class URadialSliderZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadialSliderZion>();
	}
};
static_assert(alignof(URadialSliderZion) == 0x000010, "Wrong alignment on URadialSliderZion");
static_assert(sizeof(URadialSliderZion) == 0x000810, "Wrong size on URadialSliderZion");

// Class Zion.CameraOverrideModule_CameraSpeed
// 0x0008 (0x0030 - 0x0028)
class UCameraOverrideModule_CameraSpeed final : public UCameraOverrideModule
{
public:
	float                                         CameraSpeed;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_CameraSpeed">();
	}
	static class UCameraOverrideModule_CameraSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_CameraSpeed>();
	}
};
static_assert(alignof(UCameraOverrideModule_CameraSpeed) == 0x000008, "Wrong alignment on UCameraOverrideModule_CameraSpeed");
static_assert(sizeof(UCameraOverrideModule_CameraSpeed) == 0x000030, "Wrong size on UCameraOverrideModule_CameraSpeed");
static_assert(offsetof(UCameraOverrideModule_CameraSpeed, CameraSpeed) == 0x000028, "Member 'UCameraOverrideModule_CameraSpeed::CameraSpeed' has a wrong offset!");

// Class Zion.RecollectionBossRushComponent
// 0x0110 (0x0260 - 0x0150)
class URecollectionBossRushComponent : public URecollectionBossBaseComponent
{
public:
	int32                                         CurrentBossRushIndex;                              // 0x0150(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreNextBossDelay;                                  // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreClearProcessDelay;                              // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnemyHPFactor;                                     // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowEnemyDrop;                                   // 0x0160(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDataTableRowHandle>            BossList;                                          // 0x0168(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    BossDeathRecoveryDrop;                             // 0x0178(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    BossRushClearedDrop;                               // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0xC8];                                     // 0x0198(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearBossRush();
	void GameMapChangePostFade();
	int32 GetMaxBossesDefeatedCount();
	struct FRecollectionBossRushRecordData GetRecordData(const int32 RecordIndex);
	void GoToNextBoss();
	void OnClearBossRush();
	void OnEndBossRush();
	void OnGameMapChanged();
	void OnGameMapChangedPostFade();
	void OnSetTimerPaused(bool bIsPaused);
	void OnStartBossRush();
	void ResetCurrentRecords();
	bool SetTimerPaused(bool bIsPaused);
	int32 TryAddNewRecord(const struct FRecollectionBossRushRecordData& NewRecordData);

	bool CanUpdateTime() const;
	EDifficultyPreset GetBossRushDifficultyPreset() const;
	float GetBossRushTime() const;
	int32 GetCurrentBossIndex() const;
	bool IsTimerPaused() const;
	bool ShouldDisplayRecollectionBossRush() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecollectionBossRushComponent">();
	}
	static class URecollectionBossRushComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecollectionBossRushComponent>();
	}
};
static_assert(alignof(URecollectionBossRushComponent) == 0x000008, "Wrong alignment on URecollectionBossRushComponent");
static_assert(sizeof(URecollectionBossRushComponent) == 0x000260, "Wrong size on URecollectionBossRushComponent");
static_assert(offsetof(URecollectionBossRushComponent, CurrentBossRushIndex) == 0x000150, "Member 'URecollectionBossRushComponent::CurrentBossRushIndex' has a wrong offset!");
static_assert(offsetof(URecollectionBossRushComponent, PreNextBossDelay) == 0x000154, "Member 'URecollectionBossRushComponent::PreNextBossDelay' has a wrong offset!");
static_assert(offsetof(URecollectionBossRushComponent, PreClearProcessDelay) == 0x000158, "Member 'URecollectionBossRushComponent::PreClearProcessDelay' has a wrong offset!");
static_assert(offsetof(URecollectionBossRushComponent, EnemyHPFactor) == 0x00015C, "Member 'URecollectionBossRushComponent::EnemyHPFactor' has a wrong offset!");
static_assert(offsetof(URecollectionBossRushComponent, bAllowEnemyDrop) == 0x000160, "Member 'URecollectionBossRushComponent::bAllowEnemyDrop' has a wrong offset!");
static_assert(offsetof(URecollectionBossRushComponent, BossList) == 0x000168, "Member 'URecollectionBossRushComponent::BossList' has a wrong offset!");
static_assert(offsetof(URecollectionBossRushComponent, BossDeathRecoveryDrop) == 0x000178, "Member 'URecollectionBossRushComponent::BossDeathRecoveryDrop' has a wrong offset!");
static_assert(offsetof(URecollectionBossRushComponent, BossRushClearedDrop) == 0x000188, "Member 'URecollectionBossRushComponent::BossRushClearedDrop' has a wrong offset!");

// Class Zion.RenderStateComponent
// 0x00E8 (0x0188 - 0x00A0)
class URenderStateComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnMarkedAsSeen;                                    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisible;                                          // 0x00B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequireRecentlyRendered;                          // 0x00B2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoMarkAsSeenOnZoneComplete;                     // 0x00B3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UWorld>                  ZoneLevel;                                         // 0x00B8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideBounds;                                   // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGetOnlyCollidingComponentsBounds;                 // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OverrideBoundsOriginOffset;                        // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                OverrideBoundsBoxExtent;                           // 0x0100(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideCameraBounds;                             // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OverrideCameraBoxExtent;                           // 0x0120(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckDistanceToPlayerLocation;                    // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlayerDistanceBoxExtent;                           // 0x0140(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x30];                                     // 0x0158(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetNewBounds(const class AActor* Actor);
	bool SetVisible(bool bIsVisible);

	bool IsVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenderStateComponent">();
	}
	static class URenderStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URenderStateComponent>();
	}
};
static_assert(alignof(URenderStateComponent) == 0x000008, "Wrong alignment on URenderStateComponent");
static_assert(sizeof(URenderStateComponent) == 0x000188, "Wrong size on URenderStateComponent");
static_assert(offsetof(URenderStateComponent, OnMarkedAsSeen) == 0x0000A0, "Member 'URenderStateComponent::OnMarkedAsSeen' has a wrong offset!");
static_assert(offsetof(URenderStateComponent, bEnabled) == 0x0000B0, "Member 'URenderStateComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(URenderStateComponent, bVisible) == 0x0000B1, "Member 'URenderStateComponent::bVisible' has a wrong offset!");
static_assert(offsetof(URenderStateComponent, bRequireRecentlyRendered) == 0x0000B2, "Member 'URenderStateComponent::bRequireRecentlyRendered' has a wrong offset!");
static_assert(offsetof(URenderStateComponent, bAutoMarkAsSeenOnZoneComplete) == 0x0000B3, "Member 'URenderStateComponent::bAutoMarkAsSeenOnZoneComplete' has a wrong offset!");
static_assert(offsetof(URenderStateComponent, ZoneLevel) == 0x0000B8, "Member 'URenderStateComponent::ZoneLevel' has a wrong offset!");
static_assert(offsetof(URenderStateComponent, bOverrideBounds) == 0x0000E0, "Member 'URenderStateComponent::bOverrideBounds' has a wrong offset!");
static_assert(offsetof(URenderStateComponent, bGetOnlyCollidingComponentsBounds) == 0x0000E1, "Member 'URenderStateComponent::bGetOnlyCollidingComponentsBounds' has a wrong offset!");
static_assert(offsetof(URenderStateComponent, OverrideBoundsOriginOffset) == 0x0000E8, "Member 'URenderStateComponent::OverrideBoundsOriginOffset' has a wrong offset!");
static_assert(offsetof(URenderStateComponent, OverrideBoundsBoxExtent) == 0x000100, "Member 'URenderStateComponent::OverrideBoundsBoxExtent' has a wrong offset!");
static_assert(offsetof(URenderStateComponent, bOverrideCameraBounds) == 0x000118, "Member 'URenderStateComponent::bOverrideCameraBounds' has a wrong offset!");
static_assert(offsetof(URenderStateComponent, OverrideCameraBoxExtent) == 0x000120, "Member 'URenderStateComponent::OverrideCameraBoxExtent' has a wrong offset!");
static_assert(offsetof(URenderStateComponent, bCheckDistanceToPlayerLocation) == 0x000138, "Member 'URenderStateComponent::bCheckDistanceToPlayerLocation' has a wrong offset!");
static_assert(offsetof(URenderStateComponent, PlayerDistanceBoxExtent) == 0x000140, "Member 'URenderStateComponent::PlayerDistanceBoxExtent' has a wrong offset!");

// Class Zion.RenderStateManagerComponent
// 0x00E0 (0x0180 - 0x00A0)
class URenderStateManagerComponent final : public UActorComponent
{
public:
	TMap<class FName, struct FNameSet>            SeenActors;                                        // 0x00A0(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class URenderStateComponent>> RenderStateComponents;                       // 0x00F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x80];                                     // 0x0100(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URenderStateManagerComponent* Get(const class UObject* WorldContextObject);

	void OnGameMapChangeFinished();
	void OnGameMapChangeStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenderStateManagerComponent">();
	}
	static class URenderStateManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URenderStateManagerComponent>();
	}
};
static_assert(alignof(URenderStateManagerComponent) == 0x000008, "Wrong alignment on URenderStateManagerComponent");
static_assert(sizeof(URenderStateManagerComponent) == 0x000180, "Wrong size on URenderStateManagerComponent");
static_assert(offsetof(URenderStateManagerComponent, SeenActors) == 0x0000A0, "Member 'URenderStateManagerComponent::SeenActors' has a wrong offset!");
static_assert(offsetof(URenderStateManagerComponent, RenderStateComponents) == 0x0000F0, "Member 'URenderStateManagerComponent::RenderStateComponents' has a wrong offset!");

// Class Zion.CameraOverrideModule_LocalOffsetEaseExp
// 0x0008 (0x0030 - 0x0028)
class UCameraOverrideModule_LocalOffsetEaseExp final : public UCameraOverrideModule
{
public:
	ECameraLocalOffsetBlendType                   LocalOffsetBlendType;                              // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocalOffsetEaseExp;                                // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_LocalOffsetEaseExp">();
	}
	static class UCameraOverrideModule_LocalOffsetEaseExp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_LocalOffsetEaseExp>();
	}
};
static_assert(alignof(UCameraOverrideModule_LocalOffsetEaseExp) == 0x000008, "Wrong alignment on UCameraOverrideModule_LocalOffsetEaseExp");
static_assert(sizeof(UCameraOverrideModule_LocalOffsetEaseExp) == 0x000030, "Wrong size on UCameraOverrideModule_LocalOffsetEaseExp");
static_assert(offsetof(UCameraOverrideModule_LocalOffsetEaseExp, LocalOffsetBlendType) == 0x000028, "Member 'UCameraOverrideModule_LocalOffsetEaseExp::LocalOffsetBlendType' has a wrong offset!");
static_assert(offsetof(UCameraOverrideModule_LocalOffsetEaseExp, LocalOffsetEaseExp) == 0x00002C, "Member 'UCameraOverrideModule_LocalOffsetEaseExp::LocalOffsetEaseExp' has a wrong offset!");

// Class Zion.RepulsionEnemyComponent
// 0x0140 (0x01E0 - 0x00A0)
class URepulsionEnemyComponent final : public UActorComponent
{
public:
	TArray<TSubclassOf<class UState>>             IgnoreRepulsionStates;                             // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bDisableRepulsion;                                 // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEnemyRepulsionOrigin                         RepulsionOriginType;                               // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEnemyRepulsionData                    DefaultRepulsionData;                              // 0x00B8(0x0098)(Edit, NativeAccessSpecifierPrivate)
	TArray<struct FEnemyRepulsionSetupData>       RepulsionSetupDatas;                               // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FMovementModeData>              IgnoreRepulsionMovementModes;                      // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x50];                                     // 0x0170(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             CharacterOwner;                                    // 0x01C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x18];                                     // 0x01C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentOverlapEnd(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepulsionEnemyComponent">();
	}
	static class URepulsionEnemyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URepulsionEnemyComponent>();
	}
};
static_assert(alignof(URepulsionEnemyComponent) == 0x000008, "Wrong alignment on URepulsionEnemyComponent");
static_assert(sizeof(URepulsionEnemyComponent) == 0x0001E0, "Wrong size on URepulsionEnemyComponent");
static_assert(offsetof(URepulsionEnemyComponent, IgnoreRepulsionStates) == 0x0000A0, "Member 'URepulsionEnemyComponent::IgnoreRepulsionStates' has a wrong offset!");
static_assert(offsetof(URepulsionEnemyComponent, bDisableRepulsion) == 0x0000B0, "Member 'URepulsionEnemyComponent::bDisableRepulsion' has a wrong offset!");
static_assert(offsetof(URepulsionEnemyComponent, RepulsionOriginType) == 0x0000B1, "Member 'URepulsionEnemyComponent::RepulsionOriginType' has a wrong offset!");
static_assert(offsetof(URepulsionEnemyComponent, DefaultRepulsionData) == 0x0000B8, "Member 'URepulsionEnemyComponent::DefaultRepulsionData' has a wrong offset!");
static_assert(offsetof(URepulsionEnemyComponent, RepulsionSetupDatas) == 0x000150, "Member 'URepulsionEnemyComponent::RepulsionSetupDatas' has a wrong offset!");
static_assert(offsetof(URepulsionEnemyComponent, IgnoreRepulsionMovementModes) == 0x000160, "Member 'URepulsionEnemyComponent::IgnoreRepulsionMovementModes' has a wrong offset!");
static_assert(offsetof(URepulsionEnemyComponent, CharacterOwner) == 0x0001C0, "Member 'URepulsionEnemyComponent::CharacterOwner' has a wrong offset!");

// Class Zion.RepulsionPlayerComponent
// 0x0078 (0x0118 - 0x00A0)
class URepulsionPlayerComponent final : public UActorComponent
{
public:
	float                                         DisableForceTime;                                  // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoEnemyTime;                                       // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallingForceFactor;                                // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SwimmingForceFactor;                               // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             IgnoreRepulsionStates;                             // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FMovementModeData>              IgnoreMovementModes;                               // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x18];                                      // 0x00D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UZionInputComponent*                    InputComponent;                                    // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZionCharacterMovementComponent*        ZionMovementComponent;                             // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStateComponent*                        StateComponent;                                    // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCollisionComponent*                    CollisionComponent;                                // 0x0108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddRepulsionEnemyComponent(class URepulsionEnemyComponent* RepulsionEnemyComponent, class UPrimitiveComponent* Collider);
	void RemoveRepulsionEnemyComponent(class URepulsionEnemyComponent* RepulsionEnemyComponent, class UPrimitiveComponent* Collider);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepulsionPlayerComponent">();
	}
	static class URepulsionPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URepulsionPlayerComponent>();
	}
};
static_assert(alignof(URepulsionPlayerComponent) == 0x000008, "Wrong alignment on URepulsionPlayerComponent");
static_assert(sizeof(URepulsionPlayerComponent) == 0x000118, "Wrong size on URepulsionPlayerComponent");
static_assert(offsetof(URepulsionPlayerComponent, DisableForceTime) == 0x0000A0, "Member 'URepulsionPlayerComponent::DisableForceTime' has a wrong offset!");
static_assert(offsetof(URepulsionPlayerComponent, NoEnemyTime) == 0x0000A8, "Member 'URepulsionPlayerComponent::NoEnemyTime' has a wrong offset!");
static_assert(offsetof(URepulsionPlayerComponent, FallingForceFactor) == 0x0000B0, "Member 'URepulsionPlayerComponent::FallingForceFactor' has a wrong offset!");
static_assert(offsetof(URepulsionPlayerComponent, SwimmingForceFactor) == 0x0000B4, "Member 'URepulsionPlayerComponent::SwimmingForceFactor' has a wrong offset!");
static_assert(offsetof(URepulsionPlayerComponent, IgnoreRepulsionStates) == 0x0000B8, "Member 'URepulsionPlayerComponent::IgnoreRepulsionStates' has a wrong offset!");
static_assert(offsetof(URepulsionPlayerComponent, IgnoreMovementModes) == 0x0000C8, "Member 'URepulsionPlayerComponent::IgnoreMovementModes' has a wrong offset!");
static_assert(offsetof(URepulsionPlayerComponent, InputComponent) == 0x0000F0, "Member 'URepulsionPlayerComponent::InputComponent' has a wrong offset!");
static_assert(offsetof(URepulsionPlayerComponent, ZionMovementComponent) == 0x0000F8, "Member 'URepulsionPlayerComponent::ZionMovementComponent' has a wrong offset!");
static_assert(offsetof(URepulsionPlayerComponent, StateComponent) == 0x000100, "Member 'URepulsionPlayerComponent::StateComponent' has a wrong offset!");
static_assert(offsetof(URepulsionPlayerComponent, CollisionComponent) == 0x000108, "Member 'URepulsionPlayerComponent::CollisionComponent' has a wrong offset!");

// Class Zion.RichPresenceSubsystem
// 0x0050 (0x0080 - 0x0030)
class URichPresenceSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RefreshPresence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichPresenceSubsystem">();
	}
	static class URichPresenceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichPresenceSubsystem>();
	}
};
static_assert(alignof(URichPresenceSubsystem) == 0x000008, "Wrong alignment on URichPresenceSubsystem");
static_assert(sizeof(URichPresenceSubsystem) == 0x000080, "Wrong size on URichPresenceSubsystem");

// Class Zion.RopeComponent
// 0x0090 (0x0130 - 0x00A0)
class URopeComponent final : public UActorComponent
{
public:
	bool                                          bUseRope;                                          // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RopeDepthScale;                                    // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RopeWidthScale;                                    // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RopeMinLength;                                     // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FComponentReference>            RopeMeshesRef;                                     // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentReference                    RopeDestinationPointRef;                           // 0x00D0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FComponentReference                    RopeAttachPointRef;                                // 0x00F8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        RopeDestinationPoint;                              // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        RopeAttachPoint;                                   // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RopeComponent">();
	}
	static class URopeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URopeComponent>();
	}
};
static_assert(alignof(URopeComponent) == 0x000008, "Wrong alignment on URopeComponent");
static_assert(sizeof(URopeComponent) == 0x000130, "Wrong size on URopeComponent");
static_assert(offsetof(URopeComponent, bUseRope) == 0x0000A0, "Member 'URopeComponent::bUseRope' has a wrong offset!");
static_assert(offsetof(URopeComponent, RopeDepthScale) == 0x0000A4, "Member 'URopeComponent::RopeDepthScale' has a wrong offset!");
static_assert(offsetof(URopeComponent, RopeWidthScale) == 0x0000A8, "Member 'URopeComponent::RopeWidthScale' has a wrong offset!");
static_assert(offsetof(URopeComponent, RopeMinLength) == 0x0000AC, "Member 'URopeComponent::RopeMinLength' has a wrong offset!");
static_assert(offsetof(URopeComponent, RopeMeshesRef) == 0x0000B0, "Member 'URopeComponent::RopeMeshesRef' has a wrong offset!");
static_assert(offsetof(URopeComponent, RopeDestinationPointRef) == 0x0000D0, "Member 'URopeComponent::RopeDestinationPointRef' has a wrong offset!");
static_assert(offsetof(URopeComponent, RopeAttachPointRef) == 0x0000F8, "Member 'URopeComponent::RopeAttachPointRef' has a wrong offset!");
static_assert(offsetof(URopeComponent, RopeDestinationPoint) == 0x000120, "Member 'URopeComponent::RopeDestinationPoint' has a wrong offset!");
static_assert(offsetof(URopeComponent, RopeAttachPoint) == 0x000128, "Member 'URopeComponent::RopeAttachPoint' has a wrong offset!");

// Class Zion.CameraOverrideModule_PlayerBoundsFactor
// 0x0008 (0x0030 - 0x0028)
class UCameraOverrideModule_PlayerBoundsFactor final : public UCameraOverrideModule
{
public:
	float                                         PlayerBoundsFactor;                                // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_PlayerBoundsFactor">();
	}
	static class UCameraOverrideModule_PlayerBoundsFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_PlayerBoundsFactor>();
	}
};
static_assert(alignof(UCameraOverrideModule_PlayerBoundsFactor) == 0x000008, "Wrong alignment on UCameraOverrideModule_PlayerBoundsFactor");
static_assert(sizeof(UCameraOverrideModule_PlayerBoundsFactor) == 0x000030, "Wrong size on UCameraOverrideModule_PlayerBoundsFactor");
static_assert(offsetof(UCameraOverrideModule_PlayerBoundsFactor, PlayerBoundsFactor) == 0x000028, "Member 'UCameraOverrideModule_PlayerBoundsFactor::PlayerBoundsFactor' has a wrong offset!");

// Class Zion.SaveSubsystem
// 0x0080 (0x00B0 - 0x0030)
class USaveSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class USaveSettings*                          CurrentSettings;                                   // 0x0068(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveGameZion*                          SavingGameData;                                    // 0x0070(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x38];                                      // 0x0078(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESaveExistsType CheckCurrentSlotExistence();
	ESaveExistsType CheckSlotExistence(int32 SlotIndex);
	ESaveCopyResult CopyGameDataToEmptySlot(int32 SlotToCopy, int32* out_TargetSlot);
	void DeleteSaveDataAtSlotIndex(int32 SlotIndex);
	void DeleteSettings();
	ESaveExistsType LoadGameFromCurrentSlot(class USaveGameZion** out_GameData);
	void LoadGameFromCurrentSlotAsync(TDelegate<void(ESaveExistsType Result, class USaveGameZion* LoadedData)> OnLoadFinished);
	void LoadGameFromSlotAsync(int32 SlotIndex, TDelegate<void(ESaveExistsType Result, class USaveGameZion* LoadedData)> OnLoadFinished);
	ESaveExistsType LoadSettings(bool bForceReload);
	void ResetTimeSinceLastGameSave();
	bool SaveGameInCurrentSlot();
	void SaveGameInCurrentSlotAsync(TDelegate<void(bool Result)> OnSaveFinished);
	bool SaveSettings();
	void SetCurrentSlotIndex(int32 NewSlotIndex);

	float GetTimeSinceLastGameSave() const;
	bool IsLoadingGameData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveSubsystem">();
	}
	static class USaveSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveSubsystem>();
	}
};
static_assert(alignof(USaveSubsystem) == 0x000008, "Wrong alignment on USaveSubsystem");
static_assert(sizeof(USaveSubsystem) == 0x0000B0, "Wrong size on USaveSubsystem");
static_assert(offsetof(USaveSubsystem, CurrentSettings) == 0x000068, "Member 'USaveSubsystem::CurrentSettings' has a wrong offset!");
static_assert(offsetof(USaveSubsystem, SavingGameData) == 0x000070, "Member 'USaveSubsystem::SavingGameData' has a wrong offset!");

// Class Zion.SaveGameZion
// 0x1338 (0x1360 - 0x0028)
class USaveGameZion final : public USaveGame
{
public:
	int32                                         Version;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubVersion;                                        // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ValidGameVersion;                                  // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValidBuildVersion;                                 // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BackupIndex;                                       // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameModeSaveData                      GameMode;                                          // 0x0048(0x0300)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPlayerSaveData                        Player;                                            // 0x0348(0x1008)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameAchievementsData                  GameAchievements;                                  // 0x1350(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveGameZion">();
	}
	static class USaveGameZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveGameZion>();
	}
};
static_assert(alignof(USaveGameZion) == 0x000008, "Wrong alignment on USaveGameZion");
static_assert(sizeof(USaveGameZion) == 0x001360, "Wrong size on USaveGameZion");
static_assert(offsetof(USaveGameZion, Version) == 0x000028, "Member 'USaveGameZion::Version' has a wrong offset!");
static_assert(offsetof(USaveGameZion, SubVersion) == 0x00002C, "Member 'USaveGameZion::SubVersion' has a wrong offset!");
static_assert(offsetof(USaveGameZion, ValidGameVersion) == 0x000030, "Member 'USaveGameZion::ValidGameVersion' has a wrong offset!");
static_assert(offsetof(USaveGameZion, ValidBuildVersion) == 0x000040, "Member 'USaveGameZion::ValidBuildVersion' has a wrong offset!");
static_assert(offsetof(USaveGameZion, BackupIndex) == 0x000044, "Member 'USaveGameZion::BackupIndex' has a wrong offset!");
static_assert(offsetof(USaveGameZion, GameMode) == 0x000048, "Member 'USaveGameZion::GameMode' has a wrong offset!");
static_assert(offsetof(USaveGameZion, Player) == 0x000348, "Member 'USaveGameZion::Player' has a wrong offset!");
static_assert(offsetof(USaveGameZion, GameAchievements) == 0x001350, "Member 'USaveGameZion::GameAchievements' has a wrong offset!");

// Class Zion.SaveSettings
// 0x01A8 (0x01D0 - 0x0028)
class USaveSettings final : public USaveGame
{
public:
	int32                                         Version;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubVersion;                                        // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ValidGameVersion;                                  // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValidBuildVersion;                                 // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastGameSlotIndex;                                 // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputSettingsData                     InputSettingsData;                                 // 0x0048(0x0078)(NativeAccessSpecifierPublic)
	struct FUIInputSettingsData                   UIInputSettingsData;                               // 0x00C0(0x0058)(NativeAccessSpecifierPublic)
	struct FGameSettingsData                      GameSettingsData;                                  // 0x0118(0x0058)(NativeAccessSpecifierPublic)
	struct FSoundSettingsData                     SoundSettingsData;                                 // 0x0170(0x0060)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveSettings">();
	}
	static class USaveSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveSettings>();
	}
};
static_assert(alignof(USaveSettings) == 0x000008, "Wrong alignment on USaveSettings");
static_assert(sizeof(USaveSettings) == 0x0001D0, "Wrong size on USaveSettings");
static_assert(offsetof(USaveSettings, Version) == 0x000028, "Member 'USaveSettings::Version' has a wrong offset!");
static_assert(offsetof(USaveSettings, SubVersion) == 0x00002C, "Member 'USaveSettings::SubVersion' has a wrong offset!");
static_assert(offsetof(USaveSettings, ValidGameVersion) == 0x000030, "Member 'USaveSettings::ValidGameVersion' has a wrong offset!");
static_assert(offsetof(USaveSettings, ValidBuildVersion) == 0x000040, "Member 'USaveSettings::ValidBuildVersion' has a wrong offset!");
static_assert(offsetof(USaveSettings, LastGameSlotIndex) == 0x000044, "Member 'USaveSettings::LastGameSlotIndex' has a wrong offset!");
static_assert(offsetof(USaveSettings, InputSettingsData) == 0x000048, "Member 'USaveSettings::InputSettingsData' has a wrong offset!");
static_assert(offsetof(USaveSettings, UIInputSettingsData) == 0x0000C0, "Member 'USaveSettings::UIInputSettingsData' has a wrong offset!");
static_assert(offsetof(USaveSettings, GameSettingsData) == 0x000118, "Member 'USaveSettings::GameSettingsData' has a wrong offset!");
static_assert(offsetof(USaveSettings, SoundSettingsData) == 0x000170, "Member 'USaveSettings::SoundSettingsData' has a wrong offset!");

// Class Zion.SaveAchievements
// 0x0010 (0x0038 - 0x0028)
class USaveAchievements final : public USaveGame
{
public:
	TArray<class FName>                           Achievements;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveAchievements">();
	}
	static class USaveAchievements* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveAchievements>();
	}
};
static_assert(alignof(USaveAchievements) == 0x000008, "Wrong alignment on USaveAchievements");
static_assert(sizeof(USaveAchievements) == 0x000038, "Wrong size on USaveAchievements");
static_assert(offsetof(USaveAchievements, Achievements) == 0x000028, "Member 'USaveAchievements::Achievements' has a wrong offset!");

// Class Zion.ZionCharacterMovementComponent
// 0x0190 (0x1110 - 0x0F80)
class UZionCharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	TMulticastInlineDelegate<void(const struct FHitResult& Hit)> OnMoveBlockedDelegate;              // 0x0F78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F88[0x18];                                     // 0x0F88(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideDefaultMovementMode;                      // 0x0FA0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMovementModeData                      DefaultMovementModeData;                           // 0x0FA1(0x0002)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisableUpdateBasedMovementWhenAttached;           // 0x0FA3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckForCollidersWhenNotMoving;                   // 0x0FA4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnsureCapsuleFullyGrounded;                       // 0x0FA5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FA6[0x2];                                      // 0x0FA6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedFactor_Slow;                                  // 0x0FA8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpeedFactor_Default;                               // 0x0FAC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpeedFactor_Fast;                                  // 0x0FB0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpeedFactor_Fastest;                               // 0x0FB4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             FastSpeedModePreservingStates;                     // 0x0FB8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreInputVector;                                // 0x0FC8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUpdatePhysicsWhenInactive;                        // 0x0FC9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseMaxFallVelocity;                               // 0x0FCA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FCB[0x1];                                      // 0x0FCB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxFallVelocity;                                   // 0x0FCC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReleaseWallOnLateralInput;                        // 0x0FD0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReleaseWallOnDownInput;                           // 0x0FD1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReleaseWallOnAnyDownwardInput;                    // 0x0FD2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FD3[0x5];                                      // 0x0FD3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             WallGrabPostCollisionStates;                       // 0x0FD8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         WallGrabPostCollisionStatesDuration;               // 0x0FE8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BrakingDecelerationWallScaling;                    // 0x0FEC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SwimmingMaxAcceleration;                           // 0x0FF0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultBuoyancy;                                   // 0x0FF4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DiveBuoyancy;                                      // 0x0FF8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreDiveAptitude;                               // 0x0FFC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FFD[0x3];                                      // 0x0FFD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FloatingImmersionDepth;                            // 0x1000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SnapToFloatingDepthSpeed;                          // 0x1004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ToFloatingDepthAcceleration;                       // 0x1008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxSlideFloorAngle;                                // 0x100C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlidingAcceleration;                               // 0x1010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxSlidingSpeed;                                   // 0x1014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JumpHigherZVelocity;                               // 0x1018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101C[0xF4];                                    // 0x101C(0x00F4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMovementModeCustom(EMovementModeCustom NewMovementModeCustom);
	void SetMovementSpeedMode(EMovementSpeedMode NewMovementSpeedMode);

	struct FVector ComputeLaunchVelocityToDestination(const struct FVector& DestinationLocation, float Duration) const;
	struct FVector GetLastNonFallingLocation() const;
	EMovementSpeedMode GetMovementSpeedMode() const;
	float GetTimeSinceLastGrounded() const;
	float GetTimeSinceLastHookAttach() const;
	float GetTimeSinceLastWallGrab() const;
	bool IsAirborne() const;
	bool IsHookAttached() const;
	bool IsSliding() const;
	bool IsWallGrabbing() const;
	bool IsWallScaling() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZionCharacterMovementComponent">();
	}
	static class UZionCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZionCharacterMovementComponent>();
	}
};
static_assert(alignof(UZionCharacterMovementComponent) == 0x000010, "Wrong alignment on UZionCharacterMovementComponent");
static_assert(sizeof(UZionCharacterMovementComponent) == 0x001110, "Wrong size on UZionCharacterMovementComponent");
static_assert(offsetof(UZionCharacterMovementComponent, OnMoveBlockedDelegate) == 0x000F78, "Member 'UZionCharacterMovementComponent::OnMoveBlockedDelegate' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, bOverrideDefaultMovementMode) == 0x000FA0, "Member 'UZionCharacterMovementComponent::bOverrideDefaultMovementMode' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, DefaultMovementModeData) == 0x000FA1, "Member 'UZionCharacterMovementComponent::DefaultMovementModeData' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, bDisableUpdateBasedMovementWhenAttached) == 0x000FA3, "Member 'UZionCharacterMovementComponent::bDisableUpdateBasedMovementWhenAttached' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, bCheckForCollidersWhenNotMoving) == 0x000FA4, "Member 'UZionCharacterMovementComponent::bCheckForCollidersWhenNotMoving' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, bEnsureCapsuleFullyGrounded) == 0x000FA5, "Member 'UZionCharacterMovementComponent::bEnsureCapsuleFullyGrounded' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, SpeedFactor_Slow) == 0x000FA8, "Member 'UZionCharacterMovementComponent::SpeedFactor_Slow' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, SpeedFactor_Default) == 0x000FAC, "Member 'UZionCharacterMovementComponent::SpeedFactor_Default' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, SpeedFactor_Fast) == 0x000FB0, "Member 'UZionCharacterMovementComponent::SpeedFactor_Fast' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, SpeedFactor_Fastest) == 0x000FB4, "Member 'UZionCharacterMovementComponent::SpeedFactor_Fastest' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, FastSpeedModePreservingStates) == 0x000FB8, "Member 'UZionCharacterMovementComponent::FastSpeedModePreservingStates' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, bIgnoreInputVector) == 0x000FC8, "Member 'UZionCharacterMovementComponent::bIgnoreInputVector' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, bUpdatePhysicsWhenInactive) == 0x000FC9, "Member 'UZionCharacterMovementComponent::bUpdatePhysicsWhenInactive' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, bUseMaxFallVelocity) == 0x000FCA, "Member 'UZionCharacterMovementComponent::bUseMaxFallVelocity' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, MaxFallVelocity) == 0x000FCC, "Member 'UZionCharacterMovementComponent::MaxFallVelocity' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, bReleaseWallOnLateralInput) == 0x000FD0, "Member 'UZionCharacterMovementComponent::bReleaseWallOnLateralInput' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, bReleaseWallOnDownInput) == 0x000FD1, "Member 'UZionCharacterMovementComponent::bReleaseWallOnDownInput' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, bReleaseWallOnAnyDownwardInput) == 0x000FD2, "Member 'UZionCharacterMovementComponent::bReleaseWallOnAnyDownwardInput' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, WallGrabPostCollisionStates) == 0x000FD8, "Member 'UZionCharacterMovementComponent::WallGrabPostCollisionStates' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, WallGrabPostCollisionStatesDuration) == 0x000FE8, "Member 'UZionCharacterMovementComponent::WallGrabPostCollisionStatesDuration' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, BrakingDecelerationWallScaling) == 0x000FEC, "Member 'UZionCharacterMovementComponent::BrakingDecelerationWallScaling' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, SwimmingMaxAcceleration) == 0x000FF0, "Member 'UZionCharacterMovementComponent::SwimmingMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, DefaultBuoyancy) == 0x000FF4, "Member 'UZionCharacterMovementComponent::DefaultBuoyancy' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, DiveBuoyancy) == 0x000FF8, "Member 'UZionCharacterMovementComponent::DiveBuoyancy' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, bIgnoreDiveAptitude) == 0x000FFC, "Member 'UZionCharacterMovementComponent::bIgnoreDiveAptitude' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, FloatingImmersionDepth) == 0x001000, "Member 'UZionCharacterMovementComponent::FloatingImmersionDepth' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, SnapToFloatingDepthSpeed) == 0x001004, "Member 'UZionCharacterMovementComponent::SnapToFloatingDepthSpeed' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, ToFloatingDepthAcceleration) == 0x001008, "Member 'UZionCharacterMovementComponent::ToFloatingDepthAcceleration' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, MaxSlideFloorAngle) == 0x00100C, "Member 'UZionCharacterMovementComponent::MaxSlideFloorAngle' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, SlidingAcceleration) == 0x001010, "Member 'UZionCharacterMovementComponent::SlidingAcceleration' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, MaxSlidingSpeed) == 0x001014, "Member 'UZionCharacterMovementComponent::MaxSlidingSpeed' has a wrong offset!");
static_assert(offsetof(UZionCharacterMovementComponent, JumpHigherZVelocity) == 0x001018, "Member 'UZionCharacterMovementComponent::JumpHigherZVelocity' has a wrong offset!");

// Class Zion.ScrollBoxZion
// 0x0010 (0x0D00 - 0x0CF0)
class UScrollBoxZion final : public UScrollBox
{
public:
	int32                                         ElementCountsPerLine;                              // 0x0CE8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrientation                                  NavigationOrientation;                             // 0x0CEC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAnimateScrollOnNavigation;                        // 0x0CED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CEE[0x12];                                     // 0x0CEE(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CopyWidgetNavigation(class UWidgetNavigation* WidgetNavigation);
	void ScrollWidgetHostIntoView(class UNativeWidgetHost* NativeWidgetHost, bool InAnimateScroll, EDescendantScrollDestination InDestination, float InScrollPadding);
	void SetElementCountPerLine(int32 NewElementCountsPerLine);
	void SetNavigationOrientation(EOrientation NewNavigationOrientation);
	void SimulateNavigation(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrollBoxZion">();
	}
	static class UScrollBoxZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScrollBoxZion>();
	}
};
static_assert(alignof(UScrollBoxZion) == 0x000010, "Wrong alignment on UScrollBoxZion");
static_assert(sizeof(UScrollBoxZion) == 0x000D00, "Wrong size on UScrollBoxZion");
static_assert(offsetof(UScrollBoxZion, ElementCountsPerLine) == 0x000CE8, "Member 'UScrollBoxZion::ElementCountsPerLine' has a wrong offset!");
static_assert(offsetof(UScrollBoxZion, NavigationOrientation) == 0x000CEC, "Member 'UScrollBoxZion::NavigationOrientation' has a wrong offset!");
static_assert(offsetof(UScrollBoxZion, bAnimateScrollOnNavigation) == 0x000CED, "Member 'UScrollBoxZion::bAnimateScrollOnNavigation' has a wrong offset!");

// Class Zion.ShakeComponent
// 0x0088 (0x0128 - 0x00A0)
class UShakeComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x88];                                      // 0x00A0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LaunchShake(const struct FShakeData& ShakeData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShakeComponent">();
	}
	static class UShakeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShakeComponent>();
	}
};
static_assert(alignof(UShakeComponent) == 0x000008, "Wrong alignment on UShakeComponent");
static_assert(sizeof(UShakeComponent) == 0x000128, "Wrong size on UShakeComponent");

// Class Zion.ShopInfoComponent
// 0x00B8 (0x0158 - 0x00A0)
class UShopInfoComponent final : public UActorComponent
{
public:
	TArray<TSoftObjectPtr<class UDataTable>>      DatatableDisplayOrder;                             // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0xA8];                                      // 0x00B0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddShopHistory(EShopType ShopType, const struct FDataTableRowHandle& BoughtItem);
	TArray<struct FShopItemData> GetItemsForShop(EShopType ShopType, const class UDataTable* ShopDataTable);
	void MarkSeen(EShopType ShopType, struct FShopItemData& ShopItemData);
	int32 SetLevel(int32 NewLevel);

	struct FCurrencyValue GetItemCost(EShopType ShopType, const struct FDataTableRowHandle& Item) const;
	int32 GetLevel() const;
	int32 GetMaxLevel() const;
	int32 GetMinLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopInfoComponent">();
	}
	static class UShopInfoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopInfoComponent>();
	}
};
static_assert(alignof(UShopInfoComponent) == 0x000008, "Wrong alignment on UShopInfoComponent");
static_assert(sizeof(UShopInfoComponent) == 0x000158, "Wrong size on UShopInfoComponent");
static_assert(offsetof(UShopInfoComponent, DatatableDisplayOrder) == 0x0000A0, "Member 'UShopInfoComponent::DatatableDisplayOrder' has a wrong offset!");

// Class Zion.SleepActivatorComponent
// 0x0040 (0x00E0 - 0x00A0)
class USleepActivatorComponent final : public UActorComponent
{
public:
	struct FComponentReference                    WakeTriggerReference;                              // 0x00A0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WakeTriggerMinRadius;                              // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WakeTriggerMaxRadius;                              // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWakeTriggerOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnWakeTriggerOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SleepActivatorComponent">();
	}
	static class USleepActivatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USleepActivatorComponent>();
	}
};
static_assert(alignof(USleepActivatorComponent) == 0x000008, "Wrong alignment on USleepActivatorComponent");
static_assert(sizeof(USleepActivatorComponent) == 0x0000E0, "Wrong size on USleepActivatorComponent");
static_assert(offsetof(USleepActivatorComponent, WakeTriggerReference) == 0x0000A0, "Member 'USleepActivatorComponent::WakeTriggerReference' has a wrong offset!");
static_assert(offsetof(USleepActivatorComponent, WakeTriggerMinRadius) == 0x0000C8, "Member 'USleepActivatorComponent::WakeTriggerMinRadius' has a wrong offset!");
static_assert(offsetof(USleepActivatorComponent, WakeTriggerMaxRadius) == 0x0000CC, "Member 'USleepActivatorComponent::WakeTriggerMaxRadius' has a wrong offset!");

// Class Zion.SleepTargetComponent
// 0x00B8 (0x0158 - 0x00A0)
class USleepTargetComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanBePutToSleep;                                  // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UActorComponent*, bool>            SavedComponentTickStates;                          // 0x00C0(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AActor*                                 Owner;                                             // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterMovementComponent*            MovementComponent;                                 // 0x0118(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStateComponent*                        StateComponent;                                    // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffectComponent*                 StatusEffectComponent;                             // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandComponent*                      CommandComponent;                                  // 0x0130(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineSkeletonRendererComponent*        SpineRendererComponent;                            // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineColorComponent*                   SpineColorComponent;                               // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDeathComponent*                        DeathComponent;                                    // 0x0148(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKnockbackComponent*                    KnockbackComponent;                                // 0x0150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SleepTargetComponent">();
	}
	static class USleepTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USleepTargetComponent>();
	}
};
static_assert(alignof(USleepTargetComponent) == 0x000008, "Wrong alignment on USleepTargetComponent");
static_assert(sizeof(USleepTargetComponent) == 0x000158, "Wrong size on USleepTargetComponent");
static_assert(offsetof(USleepTargetComponent, bCanBePutToSleep) == 0x0000B8, "Member 'USleepTargetComponent::bCanBePutToSleep' has a wrong offset!");
static_assert(offsetof(USleepTargetComponent, SavedComponentTickStates) == 0x0000C0, "Member 'USleepTargetComponent::SavedComponentTickStates' has a wrong offset!");
static_assert(offsetof(USleepTargetComponent, Owner) == 0x000110, "Member 'USleepTargetComponent::Owner' has a wrong offset!");
static_assert(offsetof(USleepTargetComponent, MovementComponent) == 0x000118, "Member 'USleepTargetComponent::MovementComponent' has a wrong offset!");
static_assert(offsetof(USleepTargetComponent, StateComponent) == 0x000120, "Member 'USleepTargetComponent::StateComponent' has a wrong offset!");
static_assert(offsetof(USleepTargetComponent, StatusEffectComponent) == 0x000128, "Member 'USleepTargetComponent::StatusEffectComponent' has a wrong offset!");
static_assert(offsetof(USleepTargetComponent, CommandComponent) == 0x000130, "Member 'USleepTargetComponent::CommandComponent' has a wrong offset!");
static_assert(offsetof(USleepTargetComponent, SpineRendererComponent) == 0x000138, "Member 'USleepTargetComponent::SpineRendererComponent' has a wrong offset!");
static_assert(offsetof(USleepTargetComponent, SpineColorComponent) == 0x000140, "Member 'USleepTargetComponent::SpineColorComponent' has a wrong offset!");
static_assert(offsetof(USleepTargetComponent, DeathComponent) == 0x000148, "Member 'USleepTargetComponent::DeathComponent' has a wrong offset!");
static_assert(offsetof(USleepTargetComponent, KnockbackComponent) == 0x000150, "Member 'USleepTargetComponent::KnockbackComponent' has a wrong offset!");

// Class Zion.SoundComponent
// 0x0078 (0x0118 - 0x00A0)
class USoundComponent final : public UActorComponent
{
public:
	EEffectMaterialType                           Material;                                          // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEffectGuardMaterialType                      GuardMaterial;                                     // 0x00A1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FMovementModeData, class UFMODEvent*> LoopSoundForMovementModes;                     // 0x00A8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UFMODAudioComponent*                    VoiceAudioComponent;                               // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x18];                                     // 0x0100(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundComponent">();
	}
	static class USoundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundComponent>();
	}
};
static_assert(alignof(USoundComponent) == 0x000008, "Wrong alignment on USoundComponent");
static_assert(sizeof(USoundComponent) == 0x000118, "Wrong size on USoundComponent");
static_assert(offsetof(USoundComponent, Material) == 0x0000A0, "Member 'USoundComponent::Material' has a wrong offset!");
static_assert(offsetof(USoundComponent, GuardMaterial) == 0x0000A1, "Member 'USoundComponent::GuardMaterial' has a wrong offset!");
static_assert(offsetof(USoundComponent, LoopSoundForMovementModes) == 0x0000A8, "Member 'USoundComponent::LoopSoundForMovementModes' has a wrong offset!");
static_assert(offsetof(USoundComponent, VoiceAudioComponent) == 0x0000F8, "Member 'USoundComponent::VoiceAudioComponent' has a wrong offset!");

// Class Zion.SoundSubsystem
// 0x00F8 (0x0128 - 0x0030)
class USoundSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<ESoundFamily, float>                     VolumeForSoundFamilies;                            // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FFMODEventInstance>  SnapshotInstances;                                 // 0x0080(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             CurrentBGM;                                        // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFMODEventInstance                     CurrentBGMInstance;                                // 0x00D8(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             CurrentAmbience;                                   // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFMODEventInstance                     CurrentAmbienceInstance;                           // 0x00E8(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             VoiceEvent;                                        // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x30];                                      // 0x00F8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableAllSnapshots();
	void DisableSnapshot(class FName Tag);
	void EnableSnapshot(class UFMODEvent* Snapshot, class FName Tag);
	void PauseBGM();
	void PauseFamily(ESoundFamily SoundFamily);
	void PlayAmbience(class UFMODEvent* SoundEvent);
	void PlayBGM(class UFMODEvent* SoundEvent);
	struct FFMODEventInstance PlaySoundEvent(class UFMODEvent* SoundEvent);
	class UFMODAudioComponent* PlaySoundEventAttached(class UFMODEvent* SoundEvent, class USceneComponent* AttachToComponent);
	struct FFMODEventInstance PlaySoundEventAtWorldLocation(class UFMODEvent* SoundEvent, const struct FVector& WorldLocation);
	class UFMODAudioComponent* PlayVoice(const class FString& VoiceID);
	class UFMODAudioComponent* PlayVoiceFromText(const class FText& Text, class AActor* Speaker);
	class UFMODAudioComponent* PlayVoiceOnActor(class AActor* Actor, const class FString& VoiceID);
	void RefreshAudioVolumes();
	void ResetVolumes();
	void ResumeBGM();
	void ResumeFamily(ESoundFamily SoundFamily);
	void SetParameter(class FName Parameter, float Value);
	void SetPauseGameFamilies(bool bPause);
	void SetVoiceLanguage(const class FString& Locale);
	void SetVolume(ESoundFamily SoundFamily, float NewVolume);
	void StopAll();
	void StopAmbience();
	void StopBGM(float FadeOutTime);
	void StopSoundEventInstance(const struct FFMODEventInstance& SoundInstance);

	class UFMODEvent* GetCurrentAmbience() const;
	class UFMODEvent* GetCurrentBGM() const;
	class FString GetVoiceLanguage() const;
	float GetVolume(ESoundFamily SoundFamily) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundSubsystem">();
	}
	static class USoundSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundSubsystem>();
	}
};
static_assert(alignof(USoundSubsystem) == 0x000008, "Wrong alignment on USoundSubsystem");
static_assert(sizeof(USoundSubsystem) == 0x000128, "Wrong size on USoundSubsystem");
static_assert(offsetof(USoundSubsystem, VolumeForSoundFamilies) == 0x000030, "Member 'USoundSubsystem::VolumeForSoundFamilies' has a wrong offset!");
static_assert(offsetof(USoundSubsystem, SnapshotInstances) == 0x000080, "Member 'USoundSubsystem::SnapshotInstances' has a wrong offset!");
static_assert(offsetof(USoundSubsystem, CurrentBGM) == 0x0000D0, "Member 'USoundSubsystem::CurrentBGM' has a wrong offset!");
static_assert(offsetof(USoundSubsystem, CurrentBGMInstance) == 0x0000D8, "Member 'USoundSubsystem::CurrentBGMInstance' has a wrong offset!");
static_assert(offsetof(USoundSubsystem, CurrentAmbience) == 0x0000E0, "Member 'USoundSubsystem::CurrentAmbience' has a wrong offset!");
static_assert(offsetof(USoundSubsystem, CurrentAmbienceInstance) == 0x0000E8, "Member 'USoundSubsystem::CurrentAmbienceInstance' has a wrong offset!");
static_assert(offsetof(USoundSubsystem, VoiceEvent) == 0x0000F0, "Member 'USoundSubsystem::VoiceEvent' has a wrong offset!");

// Class Zion.SpawnerComponent
// 0x0028 (0x00C8 - 0x00A0)
class USpawnerComponent final : public UActorComponent
{
public:
	bool                                          bKillAllSpawnedEntitiesOnDeath;                    // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x27];                                      // 0x00A1(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void KillAllSpawnedEntities();
	void OnDeathProcessStart();
	void OnEntityDestroyed(class AActor* EntityActor);
	void Spawn(const struct FSpawnData& SpawnData);

	int32 GetSpawnedEntityCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerComponent">();
	}
	static class USpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerComponent>();
	}
};
static_assert(alignof(USpawnerComponent) == 0x000008, "Wrong alignment on USpawnerComponent");
static_assert(sizeof(USpawnerComponent) == 0x0000C8, "Wrong size on USpawnerComponent");
static_assert(offsetof(USpawnerComponent, bKillAllSpawnedEntitiesOnDeath) == 0x0000A0, "Member 'USpawnerComponent::bKillAllSpawnedEntitiesOnDeath' has a wrong offset!");

// Class Zion.SpineActor
// 0x0028 (0x02B8 - 0x0290)
class ASpineActor final : public AActor
{
public:
	class USceneComponent*                        RootSceneComponent;                                // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineSkeletonAnimationExComponent*     SpineAnimationComponent;                           // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineSkeletonRendererComponent*        SpineRendererComponent;                            // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TrackIndex;                                        // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFlushAnimationsOnActivate;                        // 0x02AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoDeactivate;                                   // 0x02AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AE[0xA];                                      // 0x02AE(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Activate(const TArray<struct FSpineSimpleAnimationDefinition>& AnimationDefinitions);
	void Deactivate();
	void OnActivate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineActor">();
	}
	static class ASpineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpineActor>();
	}
};
static_assert(alignof(ASpineActor) == 0x000008, "Wrong alignment on ASpineActor");
static_assert(sizeof(ASpineActor) == 0x0002B8, "Wrong size on ASpineActor");
static_assert(offsetof(ASpineActor, RootSceneComponent) == 0x000290, "Member 'ASpineActor::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(ASpineActor, SpineAnimationComponent) == 0x000298, "Member 'ASpineActor::SpineAnimationComponent' has a wrong offset!");
static_assert(offsetof(ASpineActor, SpineRendererComponent) == 0x0002A0, "Member 'ASpineActor::SpineRendererComponent' has a wrong offset!");
static_assert(offsetof(ASpineActor, TrackIndex) == 0x0002A8, "Member 'ASpineActor::TrackIndex' has a wrong offset!");
static_assert(offsetof(ASpineActor, bFlushAnimationsOnActivate) == 0x0002AC, "Member 'ASpineActor::bFlushAnimationsOnActivate' has a wrong offset!");
static_assert(offsetof(ASpineActor, bAutoDeactivate) == 0x0002AD, "Member 'ASpineActor::bAutoDeactivate' has a wrong offset!");

// Class Zion.SpineAdditiveAccessoryComponent
// 0x0038 (0x00D8 - 0x00A0)
class USpineAdditiveAccessoryComponent final : public UActorComponent
{
public:
	TArray<struct FSpineAdditiveAccessorySettings> AnimationSettings;                                // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationStart(class UTrackEntry* Entry);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAdditiveAccessoryComponent">();
	}
	static class USpineAdditiveAccessoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAdditiveAccessoryComponent>();
	}
};
static_assert(alignof(USpineAdditiveAccessoryComponent) == 0x000008, "Wrong alignment on USpineAdditiveAccessoryComponent");
static_assert(sizeof(USpineAdditiveAccessoryComponent) == 0x0000D8, "Wrong size on USpineAdditiveAccessoryComponent");
static_assert(offsetof(USpineAdditiveAccessoryComponent, AnimationSettings) == 0x0000A0, "Member 'USpineAdditiveAccessoryComponent::AnimationSettings' has a wrong offset!");

// Class Zion.SpineAdditiveComponent
// 0x0028 (0x00C8 - 0x00A0)
class USpineAdditiveComponent final : public UActorComponent
{
public:
	TArray<struct FSpineAdditiveSettings>         AdditiveSettings;                                  // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationStart(class UTrackEntry* TrackEntry);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAdditiveComponent">();
	}
	static class USpineAdditiveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAdditiveComponent>();
	}
};
static_assert(alignof(USpineAdditiveComponent) == 0x000008, "Wrong alignment on USpineAdditiveComponent");
static_assert(sizeof(USpineAdditiveComponent) == 0x0000C8, "Wrong size on USpineAdditiveComponent");
static_assert(offsetof(USpineAdditiveComponent, AdditiveSettings) == 0x0000A0, "Member 'USpineAdditiveComponent::AdditiveSettings' has a wrong offset!");

// Class Zion.SpineAnimationTransitionCondition
// 0x0000 (0x0028 - 0x0028)
class USpineAnimationTransitionCondition : public UObject
{
public:
	bool Evaluate(const class USpineAnimatorComponent* Animator, const class FString& CurrAnimationName, const class FString& NextAnimationName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimationTransitionCondition">();
	}
	static class USpineAnimationTransitionCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimationTransitionCondition>();
	}
};
static_assert(alignof(USpineAnimationTransitionCondition) == 0x000008, "Wrong alignment on USpineAnimationTransitionCondition");
static_assert(sizeof(USpineAnimationTransitionCondition) == 0x000028, "Wrong size on USpineAnimationTransitionCondition");

// Class Zion.SpineAnimatorComponent
// 0x06A8 (0x0748 - 0x00A0)
class USpineAnimatorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUpdateLocomotion;                                 // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinVerticalVelocityForFallingUp;                   // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinVerticalVelocityForFallingDown;                 // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinVerticalVelocityForDashFallingUp;               // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinVerticalVelocityForDashFallingDown;             // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinVerticalVelocityForRideFallingUp;               // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinVerticalVelocityForRideFallingDown;             // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELocomotionMoveSource                         LocomotionVectorSource;                            // 0x00D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VelocityZForUp;                                    // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VelocityZForDown;                                  // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VelocityYForForward;                               // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMovementModeData                      FallbackMovementModeData;                          // 0x00E4(0x0002)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFallbackMovementModeUse                      FallbackMovementModeUse;                           // 0x00E6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSyncLocomotionTrackTime;                          // 0x00E7(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoManageTurnAnimations;                         // 0x00E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDamageAdditiveType                           DamageAdditiveType;                                // 0x00E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DamageAdditiveAnimation;                           // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             DamageAdditiveForbiddenStates;                     // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bFlushOnStagger;                                   // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      EventIdle;                                         // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      EventTurn;                                         // 0x0128(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x28];                                     // 0x0138(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      LocomotionIdle;                                    // 0x0160(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionWalk;                                    // 0x0170(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionRun;                                     // 0x0180(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionDash;                                    // 0x0190(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionRide;                                    // 0x01A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionFallingUp;                               // 0x01B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionFallingNeutral;                          // 0x01C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionFallingDown;                             // 0x01D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionDashFallingUp;                           // 0x01E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionDashFallingNeutral;                      // 0x01F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionDashFallingDown;                         // 0x0200(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionRideFallingUp;                           // 0x0210(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionRideFallingNeutral;                      // 0x0220(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionRideFallingDown;                         // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionFallingKnockbackUp_Forward;              // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionFallingKnockbackUp_Backward;             // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionFallingKnockbackNeutral_Forward;         // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionFallingKnockbackNeutral_Backward;        // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionFallingKnockbackDown_Forward;            // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionFallingKnockbackDown_Backward;           // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionWallGrab;                                // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionSlide;                                   // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionHookAttach;                              // 0x02C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionSwimIdle;                                // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionSwimLateral;                             // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterIdle;                          // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterUp;                            // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterUpLateral;                     // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterDown;                          // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterDownLateral;                   // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterLateral;                       // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterDashUp;                        // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterDashUpLateral;                 // 0x0360(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterDashDown;                      // 0x0370(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterDashDownLateral;               // 0x0380(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterDashLateral;                   // 0x0390(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterRideUp;                        // 0x03A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterRideUpLateral;                 // 0x03B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterRideDown;                      // 0x03C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterRideDownLateral;               // 0x03D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionUnderwaterRideLateral;                   // 0x03E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionFlyIdle;                                 // 0x03F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionFly;                                     // 0x0400(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionFlyUp;                                   // 0x0410(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionFlyDown;                                 // 0x0420(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionWallScalingIdle;                         // 0x0430(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionWallScalingForward;                      // 0x0440(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      LocomotionWallScalingBackward;                     // 0x0450(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationStaggerDefinitions> KnockbackStaggers;                              // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationStaggerDefinitions> KnockbackStaggersSwimming;                      // 0x0470(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      KnockbackLaunchLand;                               // 0x0480(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      KnockbackLaunchLandBack;                           // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      KnockbackLaunchStagger;                            // 0x04A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      KnockbackLaunchRecovery;                           // 0x04B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      Stun;                                              // 0x04C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      StunRecovery;                                      // 0x04D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      TurnGrounded_Slow;                                 // 0x04E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      TurnGrounded_Default;                              // 0x04F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      TurnGrounded_Fast;                                 // 0x0500(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      TurnSwim_Slow;                                     // 0x0510(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      TurnSwim_Default;                                  // 0x0520(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      TurnUnderwater_Default;                            // 0x0530(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      TurnUnderwater_Dash_Up;                            // 0x0540(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      TurnUnderwater_Dash_Down;                          // 0x0550(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      TurnUnderwater_Ride_Up;                            // 0x0560(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      TurnUnderwater_Ride_Down;                          // 0x0570(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationDefinition>      TurnFlying_Default;                                // 0x0580(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpineAnimationTransitionDefinition> TransitionDefinitions;                        // 0x0590(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A0[0x158];                                    // 0x05A0(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	class USpineSkeletonAnimationComponent*       SpineAnimation;                                    // 0x06F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineRootMotionComponent*              RootMotionComponent;                               // 0x0700(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacter*                             Character;                                         // 0x0708(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZionCharacterMovementComponent*        ZionMovementComponent;                             // 0x0710(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKnockbackComponent*                    KnockbackComponent;                                // 0x0718(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStunComponent*                         StunComponent;                                     // 0x0720(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocomotionComponent*                   LocomotionComponent;                               // 0x0728(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStateComponent*                        StateComponent;                                    // 0x0730(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDeathComponent*                        DeathComponent;                                    // 0x0738(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDashChargeComponent*                   DashChargeComponent;                               // 0x0740(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAnimationComplete(class UTrackEntry* TrackEntry);
	void OnAnimationInterrupt(class UTrackEntry* TrackEntry);
	void OnAnyAnimationComplete(class UTrackEntry* TrackEntry);
	void OnAnyAnimationInterrupt(class UTrackEntry* TrackEntry);
	void OnFacingChanged();
	void OnLayerComplete(class UTrackEntry* TrackEntry);
	void OnLayerInterrupt(class UTrackEntry* TrackEntry);
	void PlayActionAnimation(const struct FSpineAnimationDefinition& AnimationDefinition);
	void PlayActionAnimations(const TArray<struct FSpineAnimationDefinition>& AnimationDefinitions);
	void PlayActionAnimationsWithDelegate(const TArray<struct FSpineAnimationDefinition>& AnimationDefinitions, const TDelegate<void()>& OnLayerEnd);
	void PlayActionAnimationWithDelegate(const struct FSpineAnimationDefinition& AnimationDefinition, const TDelegate<void()>& OnLayerEnd);
	void PlayAnimations(ESpineAnimatorLayer AnimatorLayer, const TArray<struct FSpineAnimationDefinition>& AnimationDefinitions);
	void PlayAnimationsWithDelegate(ESpineAnimatorLayer AnimatorLayer, const TArray<struct FSpineAnimationDefinition>& AnimationDefinitions, const TDelegate<void()>& OnLayerEnd);
	void PlayTurnAnimations(const TArray<struct FSpineAnimationDefinition>& AnimationDefinitions);
	void ResetAnimations();
	void ResetLocomotionCycle();
	void StopActionAnimations();
	void StopAnimationAtLayer(ESpineAnimatorLayer Layer);

	class FString GetCurrentAnimationName() const;
	float GetCurrentAnimationPlayTime() const;
	ESpineAnimatorLayer GetCurrentLayer() const;
	class UTrackEntry* GetCurrentTrackEntry() const;
	bool GetHistoryDataAtIndex(int32 Index_0, struct FSpineAnimatorHistoryData* out_Result) const;
	struct FVector GetLastVelocity() const;
	bool IsPlayingAnimationOnLayer(ESpineAnimatorLayer Layer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimatorComponent">();
	}
	static class USpineAnimatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimatorComponent>();
	}
};
static_assert(alignof(USpineAnimatorComponent) == 0x000008, "Wrong alignment on USpineAnimatorComponent");
static_assert(sizeof(USpineAnimatorComponent) == 0x000748, "Wrong size on USpineAnimatorComponent");
static_assert(offsetof(USpineAnimatorComponent, bUpdateLocomotion) == 0x0000B8, "Member 'USpineAnimatorComponent::bUpdateLocomotion' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, MinVerticalVelocityForFallingUp) == 0x0000BC, "Member 'USpineAnimatorComponent::MinVerticalVelocityForFallingUp' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, MinVerticalVelocityForFallingDown) == 0x0000C0, "Member 'USpineAnimatorComponent::MinVerticalVelocityForFallingDown' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, MinVerticalVelocityForDashFallingUp) == 0x0000C4, "Member 'USpineAnimatorComponent::MinVerticalVelocityForDashFallingUp' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, MinVerticalVelocityForDashFallingDown) == 0x0000C8, "Member 'USpineAnimatorComponent::MinVerticalVelocityForDashFallingDown' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, MinVerticalVelocityForRideFallingUp) == 0x0000CC, "Member 'USpineAnimatorComponent::MinVerticalVelocityForRideFallingUp' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, MinVerticalVelocityForRideFallingDown) == 0x0000D0, "Member 'USpineAnimatorComponent::MinVerticalVelocityForRideFallingDown' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionVectorSource) == 0x0000D4, "Member 'USpineAnimatorComponent::LocomotionVectorSource' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, VelocityZForUp) == 0x0000D8, "Member 'USpineAnimatorComponent::VelocityZForUp' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, VelocityZForDown) == 0x0000DC, "Member 'USpineAnimatorComponent::VelocityZForDown' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, VelocityYForForward) == 0x0000E0, "Member 'USpineAnimatorComponent::VelocityYForForward' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, FallbackMovementModeData) == 0x0000E4, "Member 'USpineAnimatorComponent::FallbackMovementModeData' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, FallbackMovementModeUse) == 0x0000E6, "Member 'USpineAnimatorComponent::FallbackMovementModeUse' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, bSyncLocomotionTrackTime) == 0x0000E7, "Member 'USpineAnimatorComponent::bSyncLocomotionTrackTime' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, bAutoManageTurnAnimations) == 0x0000E8, "Member 'USpineAnimatorComponent::bAutoManageTurnAnimations' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, DamageAdditiveType) == 0x0000E9, "Member 'USpineAnimatorComponent::DamageAdditiveType' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, DamageAdditiveAnimation) == 0x0000F0, "Member 'USpineAnimatorComponent::DamageAdditiveAnimation' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, DamageAdditiveForbiddenStates) == 0x000100, "Member 'USpineAnimatorComponent::DamageAdditiveForbiddenStates' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, bFlushOnStagger) == 0x000110, "Member 'USpineAnimatorComponent::bFlushOnStagger' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, EventIdle) == 0x000118, "Member 'USpineAnimatorComponent::EventIdle' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, EventTurn) == 0x000128, "Member 'USpineAnimatorComponent::EventTurn' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionIdle) == 0x000160, "Member 'USpineAnimatorComponent::LocomotionIdle' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionWalk) == 0x000170, "Member 'USpineAnimatorComponent::LocomotionWalk' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionRun) == 0x000180, "Member 'USpineAnimatorComponent::LocomotionRun' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionDash) == 0x000190, "Member 'USpineAnimatorComponent::LocomotionDash' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionRide) == 0x0001A0, "Member 'USpineAnimatorComponent::LocomotionRide' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionFallingUp) == 0x0001B0, "Member 'USpineAnimatorComponent::LocomotionFallingUp' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionFallingNeutral) == 0x0001C0, "Member 'USpineAnimatorComponent::LocomotionFallingNeutral' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionFallingDown) == 0x0001D0, "Member 'USpineAnimatorComponent::LocomotionFallingDown' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionDashFallingUp) == 0x0001E0, "Member 'USpineAnimatorComponent::LocomotionDashFallingUp' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionDashFallingNeutral) == 0x0001F0, "Member 'USpineAnimatorComponent::LocomotionDashFallingNeutral' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionDashFallingDown) == 0x000200, "Member 'USpineAnimatorComponent::LocomotionDashFallingDown' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionRideFallingUp) == 0x000210, "Member 'USpineAnimatorComponent::LocomotionRideFallingUp' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionRideFallingNeutral) == 0x000220, "Member 'USpineAnimatorComponent::LocomotionRideFallingNeutral' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionRideFallingDown) == 0x000230, "Member 'USpineAnimatorComponent::LocomotionRideFallingDown' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionFallingKnockbackUp_Forward) == 0x000240, "Member 'USpineAnimatorComponent::LocomotionFallingKnockbackUp_Forward' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionFallingKnockbackUp_Backward) == 0x000250, "Member 'USpineAnimatorComponent::LocomotionFallingKnockbackUp_Backward' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionFallingKnockbackNeutral_Forward) == 0x000260, "Member 'USpineAnimatorComponent::LocomotionFallingKnockbackNeutral_Forward' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionFallingKnockbackNeutral_Backward) == 0x000270, "Member 'USpineAnimatorComponent::LocomotionFallingKnockbackNeutral_Backward' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionFallingKnockbackDown_Forward) == 0x000280, "Member 'USpineAnimatorComponent::LocomotionFallingKnockbackDown_Forward' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionFallingKnockbackDown_Backward) == 0x000290, "Member 'USpineAnimatorComponent::LocomotionFallingKnockbackDown_Backward' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionWallGrab) == 0x0002A0, "Member 'USpineAnimatorComponent::LocomotionWallGrab' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionSlide) == 0x0002B0, "Member 'USpineAnimatorComponent::LocomotionSlide' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionHookAttach) == 0x0002C0, "Member 'USpineAnimatorComponent::LocomotionHookAttach' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionSwimIdle) == 0x0002D0, "Member 'USpineAnimatorComponent::LocomotionSwimIdle' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionSwimLateral) == 0x0002E0, "Member 'USpineAnimatorComponent::LocomotionSwimLateral' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterIdle) == 0x0002F0, "Member 'USpineAnimatorComponent::LocomotionUnderwaterIdle' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterUp) == 0x000300, "Member 'USpineAnimatorComponent::LocomotionUnderwaterUp' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterUpLateral) == 0x000310, "Member 'USpineAnimatorComponent::LocomotionUnderwaterUpLateral' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterDown) == 0x000320, "Member 'USpineAnimatorComponent::LocomotionUnderwaterDown' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterDownLateral) == 0x000330, "Member 'USpineAnimatorComponent::LocomotionUnderwaterDownLateral' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterLateral) == 0x000340, "Member 'USpineAnimatorComponent::LocomotionUnderwaterLateral' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterDashUp) == 0x000350, "Member 'USpineAnimatorComponent::LocomotionUnderwaterDashUp' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterDashUpLateral) == 0x000360, "Member 'USpineAnimatorComponent::LocomotionUnderwaterDashUpLateral' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterDashDown) == 0x000370, "Member 'USpineAnimatorComponent::LocomotionUnderwaterDashDown' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterDashDownLateral) == 0x000380, "Member 'USpineAnimatorComponent::LocomotionUnderwaterDashDownLateral' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterDashLateral) == 0x000390, "Member 'USpineAnimatorComponent::LocomotionUnderwaterDashLateral' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterRideUp) == 0x0003A0, "Member 'USpineAnimatorComponent::LocomotionUnderwaterRideUp' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterRideUpLateral) == 0x0003B0, "Member 'USpineAnimatorComponent::LocomotionUnderwaterRideUpLateral' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterRideDown) == 0x0003C0, "Member 'USpineAnimatorComponent::LocomotionUnderwaterRideDown' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterRideDownLateral) == 0x0003D0, "Member 'USpineAnimatorComponent::LocomotionUnderwaterRideDownLateral' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionUnderwaterRideLateral) == 0x0003E0, "Member 'USpineAnimatorComponent::LocomotionUnderwaterRideLateral' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionFlyIdle) == 0x0003F0, "Member 'USpineAnimatorComponent::LocomotionFlyIdle' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionFly) == 0x000400, "Member 'USpineAnimatorComponent::LocomotionFly' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionFlyUp) == 0x000410, "Member 'USpineAnimatorComponent::LocomotionFlyUp' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionFlyDown) == 0x000420, "Member 'USpineAnimatorComponent::LocomotionFlyDown' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionWallScalingIdle) == 0x000430, "Member 'USpineAnimatorComponent::LocomotionWallScalingIdle' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionWallScalingForward) == 0x000440, "Member 'USpineAnimatorComponent::LocomotionWallScalingForward' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionWallScalingBackward) == 0x000450, "Member 'USpineAnimatorComponent::LocomotionWallScalingBackward' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, KnockbackStaggers) == 0x000460, "Member 'USpineAnimatorComponent::KnockbackStaggers' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, KnockbackStaggersSwimming) == 0x000470, "Member 'USpineAnimatorComponent::KnockbackStaggersSwimming' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, KnockbackLaunchLand) == 0x000480, "Member 'USpineAnimatorComponent::KnockbackLaunchLand' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, KnockbackLaunchLandBack) == 0x000490, "Member 'USpineAnimatorComponent::KnockbackLaunchLandBack' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, KnockbackLaunchStagger) == 0x0004A0, "Member 'USpineAnimatorComponent::KnockbackLaunchStagger' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, KnockbackLaunchRecovery) == 0x0004B0, "Member 'USpineAnimatorComponent::KnockbackLaunchRecovery' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, Stun) == 0x0004C0, "Member 'USpineAnimatorComponent::Stun' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, StunRecovery) == 0x0004D0, "Member 'USpineAnimatorComponent::StunRecovery' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, TurnGrounded_Slow) == 0x0004E0, "Member 'USpineAnimatorComponent::TurnGrounded_Slow' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, TurnGrounded_Default) == 0x0004F0, "Member 'USpineAnimatorComponent::TurnGrounded_Default' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, TurnGrounded_Fast) == 0x000500, "Member 'USpineAnimatorComponent::TurnGrounded_Fast' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, TurnSwim_Slow) == 0x000510, "Member 'USpineAnimatorComponent::TurnSwim_Slow' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, TurnSwim_Default) == 0x000520, "Member 'USpineAnimatorComponent::TurnSwim_Default' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, TurnUnderwater_Default) == 0x000530, "Member 'USpineAnimatorComponent::TurnUnderwater_Default' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, TurnUnderwater_Dash_Up) == 0x000540, "Member 'USpineAnimatorComponent::TurnUnderwater_Dash_Up' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, TurnUnderwater_Dash_Down) == 0x000550, "Member 'USpineAnimatorComponent::TurnUnderwater_Dash_Down' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, TurnUnderwater_Ride_Up) == 0x000560, "Member 'USpineAnimatorComponent::TurnUnderwater_Ride_Up' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, TurnUnderwater_Ride_Down) == 0x000570, "Member 'USpineAnimatorComponent::TurnUnderwater_Ride_Down' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, TurnFlying_Default) == 0x000580, "Member 'USpineAnimatorComponent::TurnFlying_Default' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, TransitionDefinitions) == 0x000590, "Member 'USpineAnimatorComponent::TransitionDefinitions' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, SpineAnimation) == 0x0006F8, "Member 'USpineAnimatorComponent::SpineAnimation' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, RootMotionComponent) == 0x000700, "Member 'USpineAnimatorComponent::RootMotionComponent' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, Character) == 0x000708, "Member 'USpineAnimatorComponent::Character' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, ZionMovementComponent) == 0x000710, "Member 'USpineAnimatorComponent::ZionMovementComponent' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, KnockbackComponent) == 0x000718, "Member 'USpineAnimatorComponent::KnockbackComponent' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, StunComponent) == 0x000720, "Member 'USpineAnimatorComponent::StunComponent' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, LocomotionComponent) == 0x000728, "Member 'USpineAnimatorComponent::LocomotionComponent' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, StateComponent) == 0x000730, "Member 'USpineAnimatorComponent::StateComponent' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, DeathComponent) == 0x000738, "Member 'USpineAnimatorComponent::DeathComponent' has a wrong offset!");
static_assert(offsetof(USpineAnimatorComponent, DashChargeComponent) == 0x000740, "Member 'USpineAnimatorComponent::DashChargeComponent' has a wrong offset!");

// Class Zion.SpineAnimNotifyState_AfterImage
// 0x0008 (0x0048 - 0x0040)
class USpineAnimNotifyState_AfterImage final : public USpineAnimNotifyState
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotifyState_AfterImage">();
	}
	static class USpineAnimNotifyState_AfterImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotifyState_AfterImage>();
	}
};
static_assert(alignof(USpineAnimNotifyState_AfterImage) == 0x000008, "Wrong alignment on USpineAnimNotifyState_AfterImage");
static_assert(sizeof(USpineAnimNotifyState_AfterImage) == 0x000048, "Wrong size on USpineAnimNotifyState_AfterImage");

// Class Zion.SpineAnimNotifyState_Camera
// 0x0070 (0x00B0 - 0x0040)
class USpineAnimNotifyState_Camera final : public USpineAnimNotifyState
{
public:
	TSubclassOf<class ACameraActor>               CameraClass;                                       // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                WorldSpaceOffset;                                  // 0x0048(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LocalSpaceOffset;                                  // 0x0060(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAttach;                                           // 0x0078(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FViewTargetTransitionParams            TransitionInParams;                                // 0x007C(0x0010)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	struct FViewTargetTransitionParams            TransitionOutParams;                               // 0x008C(0x0010)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C[0x14];                                      // 0x009C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotifyState_Camera">();
	}
	static class USpineAnimNotifyState_Camera* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotifyState_Camera>();
	}
};
static_assert(alignof(USpineAnimNotifyState_Camera) == 0x000008, "Wrong alignment on USpineAnimNotifyState_Camera");
static_assert(sizeof(USpineAnimNotifyState_Camera) == 0x0000B0, "Wrong size on USpineAnimNotifyState_Camera");
static_assert(offsetof(USpineAnimNotifyState_Camera, CameraClass) == 0x000040, "Member 'USpineAnimNotifyState_Camera::CameraClass' has a wrong offset!");
static_assert(offsetof(USpineAnimNotifyState_Camera, WorldSpaceOffset) == 0x000048, "Member 'USpineAnimNotifyState_Camera::WorldSpaceOffset' has a wrong offset!");
static_assert(offsetof(USpineAnimNotifyState_Camera, LocalSpaceOffset) == 0x000060, "Member 'USpineAnimNotifyState_Camera::LocalSpaceOffset' has a wrong offset!");
static_assert(offsetof(USpineAnimNotifyState_Camera, bAttach) == 0x000078, "Member 'USpineAnimNotifyState_Camera::bAttach' has a wrong offset!");
static_assert(offsetof(USpineAnimNotifyState_Camera, TransitionInParams) == 0x00007C, "Member 'USpineAnimNotifyState_Camera::TransitionInParams' has a wrong offset!");
static_assert(offsetof(USpineAnimNotifyState_Camera, TransitionOutParams) == 0x00008C, "Member 'USpineAnimNotifyState_Camera::TransitionOutParams' has a wrong offset!");

// Class Zion.SpineAnimNotifyState_RenderLayerOverride
// 0x0010 (0x0050 - 0x0040)
class USpineAnimNotifyState_RenderLayerOverride final : public USpineAnimNotifyState
{
public:
	ERenderLayerTypes                             RenderLayer;                                       // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotifyState_RenderLayerOverride">();
	}
	static class USpineAnimNotifyState_RenderLayerOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotifyState_RenderLayerOverride>();
	}
};
static_assert(alignof(USpineAnimNotifyState_RenderLayerOverride) == 0x000008, "Wrong alignment on USpineAnimNotifyState_RenderLayerOverride");
static_assert(sizeof(USpineAnimNotifyState_RenderLayerOverride) == 0x000050, "Wrong size on USpineAnimNotifyState_RenderLayerOverride");
static_assert(offsetof(USpineAnimNotifyState_RenderLayerOverride, RenderLayer) == 0x000040, "Member 'USpineAnimNotifyState_RenderLayerOverride::RenderLayer' has a wrong offset!");

// Class Zion.SpineAnimNotifyState_SetMaterialParameter
// 0x00B8 (0x00F8 - 0x0040)
class USpineAnimNotifyState_SetMaterialParameter final : public USpineAnimNotifyState
{
public:
	class FName                                   ParameterName;                                     // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0048(0x0088)(Edit, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	TArray<struct FComponentReference>            RenderComponentRefs;                               // 0x00D0(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotifyState_SetMaterialParameter">();
	}
	static class USpineAnimNotifyState_SetMaterialParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotifyState_SetMaterialParameter>();
	}
};
static_assert(alignof(USpineAnimNotifyState_SetMaterialParameter) == 0x000008, "Wrong alignment on USpineAnimNotifyState_SetMaterialParameter");
static_assert(sizeof(USpineAnimNotifyState_SetMaterialParameter) == 0x0000F8, "Wrong size on USpineAnimNotifyState_SetMaterialParameter");
static_assert(offsetof(USpineAnimNotifyState_SetMaterialParameter, ParameterName) == 0x000040, "Member 'USpineAnimNotifyState_SetMaterialParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(USpineAnimNotifyState_SetMaterialParameter, Curve) == 0x000048, "Member 'USpineAnimNotifyState_SetMaterialParameter::Curve' has a wrong offset!");
static_assert(offsetof(USpineAnimNotifyState_SetMaterialParameter, RenderComponentRefs) == 0x0000D0, "Member 'USpineAnimNotifyState_SetMaterialParameter::RenderComponentRefs' has a wrong offset!");

// Class Zion.SpineAnimNotifyState_States
// 0x0018 (0x0058 - 0x0040)
class USpineAnimNotifyState_States final : public USpineAnimNotifyState
{
public:
	TArray<TSubclassOf<class UState>>             States;                                            // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotifyState_States">();
	}
	static class USpineAnimNotifyState_States* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotifyState_States>();
	}
};
static_assert(alignof(USpineAnimNotifyState_States) == 0x000008, "Wrong alignment on USpineAnimNotifyState_States");
static_assert(sizeof(USpineAnimNotifyState_States) == 0x000058, "Wrong size on USpineAnimNotifyState_States");
static_assert(offsetof(USpineAnimNotifyState_States, States) == 0x000040, "Member 'USpineAnimNotifyState_States::States' has a wrong offset!");

// Class Zion.SpineAnimNotifyState_TimedSE
// 0x0038 (0x0078 - 0x0040)
class USpineAnimNotifyState_TimedSE final : public USpineAnimNotifyState
{
public:
	struct FSoundData                             SoundData;                                         // 0x0040(0x0028)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotifyState_TimedSE">();
	}
	static class USpineAnimNotifyState_TimedSE* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotifyState_TimedSE>();
	}
};
static_assert(alignof(USpineAnimNotifyState_TimedSE) == 0x000008, "Wrong alignment on USpineAnimNotifyState_TimedSE");
static_assert(sizeof(USpineAnimNotifyState_TimedSE) == 0x000078, "Wrong size on USpineAnimNotifyState_TimedSE");
static_assert(offsetof(USpineAnimNotifyState_TimedSE, SoundData) == 0x000040, "Member 'USpineAnimNotifyState_TimedSE::SoundData' has a wrong offset!");

// Class Zion.SpineAnimNotify_ActivateAuraFXs
// 0x0008 (0x0048 - 0x0040)
class USpineAnimNotify_ActivateAuraFXs final : public USpineAnimNotify
{
public:
	class FName                                   AuraFXTag;                                         // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotify_ActivateAuraFXs">();
	}
	static class USpineAnimNotify_ActivateAuraFXs* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotify_ActivateAuraFXs>();
	}
};
static_assert(alignof(USpineAnimNotify_ActivateAuraFXs) == 0x000008, "Wrong alignment on USpineAnimNotify_ActivateAuraFXs");
static_assert(sizeof(USpineAnimNotify_ActivateAuraFXs) == 0x000048, "Wrong size on USpineAnimNotify_ActivateAuraFXs");
static_assert(offsetof(USpineAnimNotify_ActivateAuraFXs, AuraFXTag) == 0x000040, "Member 'USpineAnimNotify_ActivateAuraFXs::AuraFXTag' has a wrong offset!");

// Class Zion.SpineAnimNotify_CameraShake
// 0x0018 (0x0058 - 0x0040)
class USpineAnimNotify_CameraShake final : public USpineAnimNotify
{
public:
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InnerRadius;                                       // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OuterRadius;                                       // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Falloff;                                           // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOrientShakeTowardsEpicenter;                      // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotify_CameraShake">();
	}
	static class USpineAnimNotify_CameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotify_CameraShake>();
	}
};
static_assert(alignof(USpineAnimNotify_CameraShake) == 0x000008, "Wrong alignment on USpineAnimNotify_CameraShake");
static_assert(sizeof(USpineAnimNotify_CameraShake) == 0x000058, "Wrong size on USpineAnimNotify_CameraShake");
static_assert(offsetof(USpineAnimNotify_CameraShake, CameraShake) == 0x000040, "Member 'USpineAnimNotify_CameraShake::CameraShake' has a wrong offset!");
static_assert(offsetof(USpineAnimNotify_CameraShake, InnerRadius) == 0x000048, "Member 'USpineAnimNotify_CameraShake::InnerRadius' has a wrong offset!");
static_assert(offsetof(USpineAnimNotify_CameraShake, OuterRadius) == 0x00004C, "Member 'USpineAnimNotify_CameraShake::OuterRadius' has a wrong offset!");
static_assert(offsetof(USpineAnimNotify_CameraShake, Falloff) == 0x000050, "Member 'USpineAnimNotify_CameraShake::Falloff' has a wrong offset!");
static_assert(offsetof(USpineAnimNotify_CameraShake, bOrientShakeTowardsEpicenter) == 0x000054, "Member 'USpineAnimNotify_CameraShake::bOrientShakeTowardsEpicenter' has a wrong offset!");

// Class Zion.SpineAnimNotify_CostumeFX
// 0x0220 (0x0260 - 0x0040)
class USpineAnimNotify_CostumeFX final : public USpineAnimNotify
{
public:
	EPlayerCostumeFX                              CostumeFX;                                         // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           FXData;                                            // 0x0050(0x0100)(Edit, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSpineFXData                           RuntimeFXData;                                     // 0x0150(0x0100)(BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotify_CostumeFX">();
	}
	static class USpineAnimNotify_CostumeFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotify_CostumeFX>();
	}
};
static_assert(alignof(USpineAnimNotify_CostumeFX) == 0x000010, "Wrong alignment on USpineAnimNotify_CostumeFX");
static_assert(sizeof(USpineAnimNotify_CostumeFX) == 0x000260, "Wrong size on USpineAnimNotify_CostumeFX");
static_assert(offsetof(USpineAnimNotify_CostumeFX, CostumeFX) == 0x000040, "Member 'USpineAnimNotify_CostumeFX::CostumeFX' has a wrong offset!");
static_assert(offsetof(USpineAnimNotify_CostumeFX, FXData) == 0x000050, "Member 'USpineAnimNotify_CostumeFX::FXData' has a wrong offset!");
static_assert(offsetof(USpineAnimNotify_CostumeFX, RuntimeFXData) == 0x000150, "Member 'USpineAnimNotify_CostumeFX::RuntimeFXData' has a wrong offset!");

// Class Zion.SpineAnimNotify_DeactivateAuraFXs
// 0x0008 (0x0048 - 0x0040)
class USpineAnimNotify_DeactivateAuraFXs final : public USpineAnimNotify
{
public:
	class FName                                   AuraFXTag;                                         // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotify_DeactivateAuraFXs">();
	}
	static class USpineAnimNotify_DeactivateAuraFXs* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotify_DeactivateAuraFXs>();
	}
};
static_assert(alignof(USpineAnimNotify_DeactivateAuraFXs) == 0x000008, "Wrong alignment on USpineAnimNotify_DeactivateAuraFXs");
static_assert(sizeof(USpineAnimNotify_DeactivateAuraFXs) == 0x000048, "Wrong size on USpineAnimNotify_DeactivateAuraFXs");
static_assert(offsetof(USpineAnimNotify_DeactivateAuraFXs, AuraFXTag) == 0x000040, "Member 'USpineAnimNotify_DeactivateAuraFXs::AuraFXTag' has a wrong offset!");

// Class Zion.SpineAnimNotify_ForceFeedback
// 0x0008 (0x0048 - 0x0040)
class USpineAnimNotify_ForceFeedback final : public USpineAnimNotify
{
public:
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotify_ForceFeedback">();
	}
	static class USpineAnimNotify_ForceFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotify_ForceFeedback>();
	}
};
static_assert(alignof(USpineAnimNotify_ForceFeedback) == 0x000008, "Wrong alignment on USpineAnimNotify_ForceFeedback");
static_assert(sizeof(USpineAnimNotify_ForceFeedback) == 0x000048, "Wrong size on USpineAnimNotify_ForceFeedback");
static_assert(offsetof(USpineAnimNotify_ForceFeedback, ForceFeedbackEffect) == 0x000040, "Member 'USpineAnimNotify_ForceFeedback::ForceFeedbackEffect' has a wrong offset!");

// Class Zion.SpineAnimNotify_PlayBGM
// 0x0008 (0x0048 - 0x0040)
class USpineAnimNotify_PlayBGM final : public USpineAnimNotify
{
public:
	class UFMODEvent*                             BGM;                                               // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotify_PlayBGM">();
	}
	static class USpineAnimNotify_PlayBGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotify_PlayBGM>();
	}
};
static_assert(alignof(USpineAnimNotify_PlayBGM) == 0x000008, "Wrong alignment on USpineAnimNotify_PlayBGM");
static_assert(sizeof(USpineAnimNotify_PlayBGM) == 0x000048, "Wrong size on USpineAnimNotify_PlayBGM");
static_assert(offsetof(USpineAnimNotify_PlayBGM, BGM) == 0x000040, "Member 'USpineAnimNotify_PlayBGM::BGM' has a wrong offset!");

// Class Zion.SpineAnimNotify_PlaySE
// 0x0028 (0x0068 - 0x0040)
class USpineAnimNotify_PlaySE final : public USpineAnimNotify
{
public:
	struct FSoundData                             SoundData;                                         // 0x0040(0x0028)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotify_PlaySE">();
	}
	static class USpineAnimNotify_PlaySE* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotify_PlaySE>();
	}
};
static_assert(alignof(USpineAnimNotify_PlaySE) == 0x000008, "Wrong alignment on USpineAnimNotify_PlaySE");
static_assert(sizeof(USpineAnimNotify_PlaySE) == 0x000068, "Wrong size on USpineAnimNotify_PlaySE");
static_assert(offsetof(USpineAnimNotify_PlaySE, SoundData) == 0x000040, "Member 'USpineAnimNotify_PlaySE::SoundData' has a wrong offset!");

// Class Zion.SpineAnimNotify_SetSkins
// 0x0010 (0x0050 - 0x0040)
class USpineAnimNotify_SetSkins final : public USpineAnimNotify
{
public:
	TArray<class FString>                         Skins;                                             // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotify_SetSkins">();
	}
	static class USpineAnimNotify_SetSkins* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotify_SetSkins>();
	}
};
static_assert(alignof(USpineAnimNotify_SetSkins) == 0x000008, "Wrong alignment on USpineAnimNotify_SetSkins");
static_assert(sizeof(USpineAnimNotify_SetSkins) == 0x000050, "Wrong size on USpineAnimNotify_SetSkins");
static_assert(offsetof(USpineAnimNotify_SetSkins, Skins) == 0x000040, "Member 'USpineAnimNotify_SetSkins::Skins' has a wrong offset!");

// Class Zion.SpineAnimNotify_Step
// 0x0020 (0x0060 - 0x0040)
class USpineAnimNotify_Step : public USpineAnimNotify
{
public:
	EStepHeavinessCategory                        StepHeaviness;                                     // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNotifyFluidInteraction;                           // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalSpaceOffset;                                  // 0x0048(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotify_Step">();
	}
	static class USpineAnimNotify_Step* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotify_Step>();
	}
};
static_assert(alignof(USpineAnimNotify_Step) == 0x000008, "Wrong alignment on USpineAnimNotify_Step");
static_assert(sizeof(USpineAnimNotify_Step) == 0x000060, "Wrong size on USpineAnimNotify_Step");
static_assert(offsetof(USpineAnimNotify_Step, StepHeaviness) == 0x000040, "Member 'USpineAnimNotify_Step::StepHeaviness' has a wrong offset!");
static_assert(offsetof(USpineAnimNotify_Step, bNotifyFluidInteraction) == 0x000041, "Member 'USpineAnimNotify_Step::bNotifyFluidInteraction' has a wrong offset!");
static_assert(offsetof(USpineAnimNotify_Step, LocalSpaceOffset) == 0x000048, "Member 'USpineAnimNotify_Step::LocalSpaceOffset' has a wrong offset!");

// Class Zion.SpineAnimNotify_Step_Wall
// 0x0000 (0x0060 - 0x0060)
class USpineAnimNotify_Step_Wall final : public USpineAnimNotify_Step
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotify_Step_Wall">();
	}
	static class USpineAnimNotify_Step_Wall* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotify_Step_Wall>();
	}
};
static_assert(alignof(USpineAnimNotify_Step_Wall) == 0x000008, "Wrong alignment on USpineAnimNotify_Step_Wall");
static_assert(sizeof(USpineAnimNotify_Step_Wall) == 0x000060, "Wrong size on USpineAnimNotify_Step_Wall");

// Class Zion.SpineAnimNotify_Step_Ceiling
// 0x0000 (0x0060 - 0x0060)
class USpineAnimNotify_Step_Ceiling final : public USpineAnimNotify_Step
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotify_Step_Ceiling">();
	}
	static class USpineAnimNotify_Step_Ceiling* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotify_Step_Ceiling>();
	}
};
static_assert(alignof(USpineAnimNotify_Step_Ceiling) == 0x000008, "Wrong alignment on USpineAnimNotify_Step_Ceiling");
static_assert(sizeof(USpineAnimNotify_Step_Ceiling) == 0x000060, "Wrong size on USpineAnimNotify_Step_Ceiling");

// Class Zion.SpineAnimNotify_StopBGM
// 0x0008 (0x0048 - 0x0040)
class USpineAnimNotify_StopBGM final : public USpineAnimNotify
{
public:
	float                                         FadeOut;                                           // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotify_StopBGM">();
	}
	static class USpineAnimNotify_StopBGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotify_StopBGM>();
	}
};
static_assert(alignof(USpineAnimNotify_StopBGM) == 0x000008, "Wrong alignment on USpineAnimNotify_StopBGM");
static_assert(sizeof(USpineAnimNotify_StopBGM) == 0x000048, "Wrong size on USpineAnimNotify_StopBGM");
static_assert(offsetof(USpineAnimNotify_StopBGM, FadeOut) == 0x000040, "Member 'USpineAnimNotify_StopBGM::FadeOut' has a wrong offset!");

// Class Zion.SpineAnimNotify_ToggleFacing
// 0x0000 (0x0040 - 0x0040)
class USpineAnimNotify_ToggleFacing final : public USpineAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotify_ToggleFacing">();
	}
	static class USpineAnimNotify_ToggleFacing* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotify_ToggleFacing>();
	}
};
static_assert(alignof(USpineAnimNotify_ToggleFacing) == 0x000008, "Wrong alignment on USpineAnimNotify_ToggleFacing");
static_assert(sizeof(USpineAnimNotify_ToggleFacing) == 0x000040, "Wrong size on USpineAnimNotify_ToggleFacing");

// Class Zion.SpineAnimNotify_TriggerLeadAbilityFX
// 0x0110 (0x0150 - 0x0040)
class USpineAnimNotify_TriggerLeadAbilityFX final : public USpineAnimNotify
{
public:
	bool                                          bOverrideLeadAbilityFX;                            // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           LeadAbilityFXDataOverride;                         // 0x0050(0x0100)(Edit, BlueprintReadOnly, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineAnimNotify_TriggerLeadAbilityFX">();
	}
	static class USpineAnimNotify_TriggerLeadAbilityFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineAnimNotify_TriggerLeadAbilityFX>();
	}
};
static_assert(alignof(USpineAnimNotify_TriggerLeadAbilityFX) == 0x000010, "Wrong alignment on USpineAnimNotify_TriggerLeadAbilityFX");
static_assert(sizeof(USpineAnimNotify_TriggerLeadAbilityFX) == 0x000150, "Wrong size on USpineAnimNotify_TriggerLeadAbilityFX");
static_assert(offsetof(USpineAnimNotify_TriggerLeadAbilityFX, bOverrideLeadAbilityFX) == 0x000040, "Member 'USpineAnimNotify_TriggerLeadAbilityFX::bOverrideLeadAbilityFX' has a wrong offset!");
static_assert(offsetof(USpineAnimNotify_TriggerLeadAbilityFX, LeadAbilityFXDataOverride) == 0x000050, "Member 'USpineAnimNotify_TriggerLeadAbilityFX::LeadAbilityFXDataOverride' has a wrong offset!");

// Class Zion.SpineColorComponent
// 0x00F8 (0x0198 - 0x00A0)
class USpineColorComponent final : public UActorComponent
{
public:
	struct FSpineFlashColorData                   DefaultDamageFlash;                                // 0x00A0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TMap<EAbilityWeightCategory, struct FSpineFlashColorData> DamageColorForWeights;                 // 0x00B8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class FString>                         AffectedSkins;                                     // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     SkinMaterial;                                      // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x78];                                     // 0x0120(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearColor(float LerpDuration);
	void FlashColor(const struct FLinearColor& Color, float Alpha, float FlashDuration);
	void OnGotAbilityApplied(class AAbility* Ability, class AActor* Source, const struct FHitData& HitData);
	void SetColor(const struct FLinearColor& Color, float Alpha, float LerpDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineColorComponent">();
	}
	static class USpineColorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineColorComponent>();
	}
};
static_assert(alignof(USpineColorComponent) == 0x000008, "Wrong alignment on USpineColorComponent");
static_assert(sizeof(USpineColorComponent) == 0x000198, "Wrong size on USpineColorComponent");
static_assert(offsetof(USpineColorComponent, DefaultDamageFlash) == 0x0000A0, "Member 'USpineColorComponent::DefaultDamageFlash' has a wrong offset!");
static_assert(offsetof(USpineColorComponent, DamageColorForWeights) == 0x0000B8, "Member 'USpineColorComponent::DamageColorForWeights' has a wrong offset!");
static_assert(offsetof(USpineColorComponent, AffectedSkins) == 0x000108, "Member 'USpineColorComponent::AffectedSkins' has a wrong offset!");
static_assert(offsetof(USpineColorComponent, SkinMaterial) == 0x000118, "Member 'USpineColorComponent::SkinMaterial' has a wrong offset!");

// Class Zion.SpineHighlightComponent
// 0x0038 (0x00D8 - 0x00A0)
class USpineHighlightComponent final : public UActorComponent
{
public:
	EStencilCategory                              StencilCategory;                                   // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         AlternatePivotComputationAnimations;               // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationStart(class UTrackEntry* Entry);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineHighlightComponent">();
	}
	static class USpineHighlightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineHighlightComponent>();
	}
};
static_assert(alignof(USpineHighlightComponent) == 0x000008, "Wrong alignment on USpineHighlightComponent");
static_assert(sizeof(USpineHighlightComponent) == 0x0000D8, "Wrong size on USpineHighlightComponent");
static_assert(offsetof(USpineHighlightComponent, StencilCategory) == 0x0000A0, "Member 'USpineHighlightComponent::StencilCategory' has a wrong offset!");
static_assert(offsetof(USpineHighlightComponent, AlternatePivotComputationAnimations) == 0x0000A8, "Member 'USpineHighlightComponent::AlternatePivotComputationAnimations' has a wrong offset!");

// Class Zion.UserWidgetWorldSpaceText_Talk
// 0x0020 (0x0338 - 0x0318)
class UUserWidgetWorldSpaceText_Talk : public UUserWidgetWorldSpaceText
{
public:
	uint8                                         Pad_318[0x20];                                     // 0x0318(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CompleteTalk();
	void FinishTalk();
	void OnPressConfirm();
	void OnTalk(const struct FTalkParameters& TalkParameters);
	void SetSpeakerName(const class FText& SpeakerName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetWorldSpaceText_Talk">();
	}
	static class UUserWidgetWorldSpaceText_Talk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetWorldSpaceText_Talk>();
	}
};
static_assert(alignof(UUserWidgetWorldSpaceText_Talk) == 0x000008, "Wrong alignment on UUserWidgetWorldSpaceText_Talk");
static_assert(sizeof(UUserWidgetWorldSpaceText_Talk) == 0x000338, "Wrong size on UUserWidgetWorldSpaceText_Talk");

// Class Zion.SpineSkinFromFacing
// 0x0058 (0x00F8 - 0x00A0)
class USpineSkinFromFacing final : public UActorComponent
{
public:
	TArray<class FString>                         FacingRightSkins;                                  // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FString>                         FacingRightBrokenSkins;                            // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FString>                         FacingLeftSkins;                                   // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FString>                         FacingLeftBrokenSkins;                             // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFacingChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineSkinFromFacing">();
	}
	static class USpineSkinFromFacing* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineSkinFromFacing>();
	}
};
static_assert(alignof(USpineSkinFromFacing) == 0x000008, "Wrong alignment on USpineSkinFromFacing");
static_assert(sizeof(USpineSkinFromFacing) == 0x0000F8, "Wrong size on USpineSkinFromFacing");
static_assert(offsetof(USpineSkinFromFacing, FacingRightSkins) == 0x0000A0, "Member 'USpineSkinFromFacing::FacingRightSkins' has a wrong offset!");
static_assert(offsetof(USpineSkinFromFacing, FacingRightBrokenSkins) == 0x0000B0, "Member 'USpineSkinFromFacing::FacingRightBrokenSkins' has a wrong offset!");
static_assert(offsetof(USpineSkinFromFacing, FacingLeftSkins) == 0x0000C0, "Member 'USpineSkinFromFacing::FacingLeftSkins' has a wrong offset!");
static_assert(offsetof(USpineSkinFromFacing, FacingLeftBrokenSkins) == 0x0000D0, "Member 'USpineSkinFromFacing::FacingLeftBrokenSkins' has a wrong offset!");

// Class Zion.StepMatrixData
// 0x00F0 (0x0120 - 0x0030)
class UStepMatrixData final : public UDataAsset
{
public:
	TMap<EStepHeavinessCategory, struct FSpeedModeToSurfaceMap> StepMatrix;                          // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EStepHeavinessCategory, struct FSurfaceToStepMap> WallMatrix;                               // 0x0080(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EStepHeavinessCategory, struct FSurfaceToStepMap> CeilingMatrix;                            // 0x00D0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StepMatrixData">();
	}
	static class UStepMatrixData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStepMatrixData>();
	}
};
static_assert(alignof(UStepMatrixData) == 0x000008, "Wrong alignment on UStepMatrixData");
static_assert(sizeof(UStepMatrixData) == 0x000120, "Wrong size on UStepMatrixData");
static_assert(offsetof(UStepMatrixData, StepMatrix) == 0x000030, "Member 'UStepMatrixData::StepMatrix' has a wrong offset!");
static_assert(offsetof(UStepMatrixData, WallMatrix) == 0x000080, "Member 'UStepMatrixData::WallMatrix' has a wrong offset!");
static_assert(offsetof(UStepMatrixData, CeilingMatrix) == 0x0000D0, "Member 'UStepMatrixData::CeilingMatrix' has a wrong offset!");

// Class Zion.SpiritAutoComponent
// 0x0240 (0x02E0 - 0x00A0)
class USpiritAutoComponent final : public UActorComponent
{
public:
	class ACharacterZionSpirit*                   SpiritOwner;                                       // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFollowTargetComponent*                 FollowTargetComponent;                             // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocomotionComponent*                   LocomotionComponent;                               // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineAnimatorComponent*                AnimatorComponent;                                 // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandComponent*                      CommandComponent;                                  // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandSet*                            AutoCommandSet;                                    // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x210];                                     // 0x00D0(0x0210)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCommandQueueCleared();
	void OnGameMapChanged();
	void OnSummonerDodge();
	void OnSummonerFacingChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpiritAutoComponent">();
	}
	static class USpiritAutoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpiritAutoComponent>();
	}
};
static_assert(alignof(USpiritAutoComponent) == 0x000008, "Wrong alignment on USpiritAutoComponent");
static_assert(sizeof(USpiritAutoComponent) == 0x0002E0, "Wrong size on USpiritAutoComponent");
static_assert(offsetof(USpiritAutoComponent, SpiritOwner) == 0x0000A0, "Member 'USpiritAutoComponent::SpiritOwner' has a wrong offset!");
static_assert(offsetof(USpiritAutoComponent, FollowTargetComponent) == 0x0000A8, "Member 'USpiritAutoComponent::FollowTargetComponent' has a wrong offset!");
static_assert(offsetof(USpiritAutoComponent, LocomotionComponent) == 0x0000B0, "Member 'USpiritAutoComponent::LocomotionComponent' has a wrong offset!");
static_assert(offsetof(USpiritAutoComponent, AnimatorComponent) == 0x0000B8, "Member 'USpiritAutoComponent::AnimatorComponent' has a wrong offset!");
static_assert(offsetof(USpiritAutoComponent, CommandComponent) == 0x0000C0, "Member 'USpiritAutoComponent::CommandComponent' has a wrong offset!");
static_assert(offsetof(USpiritAutoComponent, AutoCommandSet) == 0x0000C8, "Member 'USpiritAutoComponent::AutoCommandSet' has a wrong offset!");

// Class Zion.SpiritCooldown
// 0x0048 (0x02D8 - 0x0290)
class ASpiritCooldown : public AActor
{
public:
	class USceneComponent*                        SceneRootComponent;                                // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFollowTargetComponent*                 FollowTargetComponent;                             // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPaperSpriteComponent*                  SpriteComponent;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerControllerZion*                  PlayerControllerZion;                              // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               MID_Sprite;                                        // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x18];                                     // 0x02C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCommandFinishCooldown(const class UCommandSet* CommandSetFinished, bool bReset);
	void OnCooldownCompleted();
	void OnEventStarted();
	void OnEventStopped();
	void OnFinished();
	void OnLaunch();
	void OnNiagaraSystemFinished(class UNiagaraComponent* PSystem);
	void OnUnPossessPlayer(class APawn* Pawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpiritCooldown">();
	}
	static class ASpiritCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpiritCooldown>();
	}
};
static_assert(alignof(ASpiritCooldown) == 0x000008, "Wrong alignment on ASpiritCooldown");
static_assert(sizeof(ASpiritCooldown) == 0x0002D8, "Wrong size on ASpiritCooldown");
static_assert(offsetof(ASpiritCooldown, SceneRootComponent) == 0x000290, "Member 'ASpiritCooldown::SceneRootComponent' has a wrong offset!");
static_assert(offsetof(ASpiritCooldown, FollowTargetComponent) == 0x000298, "Member 'ASpiritCooldown::FollowTargetComponent' has a wrong offset!");
static_assert(offsetof(ASpiritCooldown, SpriteComponent) == 0x0002A0, "Member 'ASpiritCooldown::SpriteComponent' has a wrong offset!");
static_assert(offsetof(ASpiritCooldown, NiagaraComponent) == 0x0002A8, "Member 'ASpiritCooldown::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(ASpiritCooldown, PlayerControllerZion) == 0x0002B0, "Member 'ASpiritCooldown::PlayerControllerZion' has a wrong offset!");
static_assert(offsetof(ASpiritCooldown, MID_Sprite) == 0x0002B8, "Member 'ASpiritCooldown::MID_Sprite' has a wrong offset!");

// Class Zion.VisualPivotModifierComponent
// 0x0110 (0x01B0 - 0x00A0)
class UVisualPivotModifierComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x110];                                     // 0x00A0(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualPivotModifierComponent">();
	}
	static class UVisualPivotModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisualPivotModifierComponent>();
	}
};
static_assert(alignof(UVisualPivotModifierComponent) == 0x000008, "Wrong alignment on UVisualPivotModifierComponent");
static_assert(sizeof(UVisualPivotModifierComponent) == 0x0001B0, "Wrong size on UVisualPivotModifierComponent");

// Class Zion.SpiritRepeatComponent
// 0x0170 (0x0210 - 0x00A0)
class alignas(0x10) USpiritRepeatComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnRepeatEnable;                                    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRepeatDisable;                                   // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterZionSpirit*                   SpiritOwner;                                       // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFollowTargetComponent*                 FollowTargetComponent;                             // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocomotionComponent*                   LocomotionComponent;                               // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineAnimatorComponent*                AnimatorComponent;                                 // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityComponent*                      AbilityComponent;                                  // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x118];                                     // 0x00F0(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	class AAbility*                               ManualAbility;                                     // 0x0208(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnSummonerFacingChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpiritRepeatComponent">();
	}
	static class USpiritRepeatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpiritRepeatComponent>();
	}
};
static_assert(alignof(USpiritRepeatComponent) == 0x000010, "Wrong alignment on USpiritRepeatComponent");
static_assert(sizeof(USpiritRepeatComponent) == 0x000210, "Wrong size on USpiritRepeatComponent");
static_assert(offsetof(USpiritRepeatComponent, OnRepeatEnable) == 0x0000A0, "Member 'USpiritRepeatComponent::OnRepeatEnable' has a wrong offset!");
static_assert(offsetof(USpiritRepeatComponent, OnRepeatDisable) == 0x0000B0, "Member 'USpiritRepeatComponent::OnRepeatDisable' has a wrong offset!");
static_assert(offsetof(USpiritRepeatComponent, SpiritOwner) == 0x0000C8, "Member 'USpiritRepeatComponent::SpiritOwner' has a wrong offset!");
static_assert(offsetof(USpiritRepeatComponent, FollowTargetComponent) == 0x0000D0, "Member 'USpiritRepeatComponent::FollowTargetComponent' has a wrong offset!");
static_assert(offsetof(USpiritRepeatComponent, LocomotionComponent) == 0x0000D8, "Member 'USpiritRepeatComponent::LocomotionComponent' has a wrong offset!");
static_assert(offsetof(USpiritRepeatComponent, AnimatorComponent) == 0x0000E0, "Member 'USpiritRepeatComponent::AnimatorComponent' has a wrong offset!");
static_assert(offsetof(USpiritRepeatComponent, AbilityComponent) == 0x0000E8, "Member 'USpiritRepeatComponent::AbilityComponent' has a wrong offset!");
static_assert(offsetof(USpiritRepeatComponent, ManualAbility) == 0x000208, "Member 'USpiritRepeatComponent::ManualAbility' has a wrong offset!");

// Class Zion.SpiritSkinUpdaterComponent
// 0x0028 (0x00C8 - 0x00A0)
class USpiritSkinUpdaterComponent final : public UActorComponent
{
public:
	EAptitudeType                                 NecessaryAptitude;                                 // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Skins;                                             // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class USpineSkeletonAnimationComponent*       AnimationComponent;                                // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpiritSkinUpdaterComponent">();
	}
	static class USpiritSkinUpdaterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpiritSkinUpdaterComponent>();
	}
};
static_assert(alignof(USpiritSkinUpdaterComponent) == 0x000008, "Wrong alignment on USpiritSkinUpdaterComponent");
static_assert(sizeof(USpiritSkinUpdaterComponent) == 0x0000C8, "Wrong size on USpiritSkinUpdaterComponent");
static_assert(offsetof(USpiritSkinUpdaterComponent, NecessaryAptitude) == 0x0000A0, "Member 'USpiritSkinUpdaterComponent::NecessaryAptitude' has a wrong offset!");
static_assert(offsetof(USpiritSkinUpdaterComponent, Skins) == 0x0000A8, "Member 'USpiritSkinUpdaterComponent::Skins' has a wrong offset!");
static_assert(offsetof(USpiritSkinUpdaterComponent, AnimationComponent) == 0x0000B8, "Member 'USpiritSkinUpdaterComponent::AnimationComponent' has a wrong offset!");

// Class Zion.SpiritStatsSnapshotComponent
// 0x0018 (0x00B8 - 0x00A0)
class USpiritStatsSnapshotComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpiritStatsSnapshotComponent">();
	}
	static class USpiritStatsSnapshotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpiritStatsSnapshotComponent>();
	}
};
static_assert(alignof(USpiritStatsSnapshotComponent) == 0x000008, "Wrong alignment on USpiritStatsSnapshotComponent");
static_assert(sizeof(USpiritStatsSnapshotComponent) == 0x0000B8, "Wrong size on USpiritStatsSnapshotComponent");

// Class Zion.SpiritTurretComponent
// 0x01A0 (0x0240 - 0x00A0)
class USpiritTurretComponent final : public UActorComponent
{
public:
	bool                                          bDismissOnZoneSwitch;                              // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0xF];                                       // 0x00A1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineFXData                           SummonerLinkFXData;                                // 0x00B0(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      SummonerLinkFX;                                    // 0x01B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacterZionSpirit*                   SpiritOwner;                                       // 0x01B8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandComponent*                      CommandComponent;                                  // 0x01C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineBoneComponent*                    BoneComponent;                                     // 0x01C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommandSet*                            AutoCommandSet;                                    // 0x01D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x68];                                     // 0x01D8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpiritTurretComponent">();
	}
	static class USpiritTurretComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpiritTurretComponent>();
	}
};
static_assert(alignof(USpiritTurretComponent) == 0x000010, "Wrong alignment on USpiritTurretComponent");
static_assert(sizeof(USpiritTurretComponent) == 0x000240, "Wrong size on USpiritTurretComponent");
static_assert(offsetof(USpiritTurretComponent, bDismissOnZoneSwitch) == 0x0000A0, "Member 'USpiritTurretComponent::bDismissOnZoneSwitch' has a wrong offset!");
static_assert(offsetof(USpiritTurretComponent, SummonerLinkFXData) == 0x0000B0, "Member 'USpiritTurretComponent::SummonerLinkFXData' has a wrong offset!");
static_assert(offsetof(USpiritTurretComponent, SummonerLinkFX) == 0x0001B0, "Member 'USpiritTurretComponent::SummonerLinkFX' has a wrong offset!");
static_assert(offsetof(USpiritTurretComponent, SpiritOwner) == 0x0001B8, "Member 'USpiritTurretComponent::SpiritOwner' has a wrong offset!");
static_assert(offsetof(USpiritTurretComponent, CommandComponent) == 0x0001C0, "Member 'USpiritTurretComponent::CommandComponent' has a wrong offset!");
static_assert(offsetof(USpiritTurretComponent, BoneComponent) == 0x0001C8, "Member 'USpiritTurretComponent::BoneComponent' has a wrong offset!");
static_assert(offsetof(USpiritTurretComponent, AutoCommandSet) == 0x0001D0, "Member 'USpiritTurretComponent::AutoCommandSet' has a wrong offset!");

// Class Zion.WallAttachComponent
// 0x0040 (0x00E0 - 0x00A0)
class UWallAttachComponent final : public UActorComponent
{
public:
	bool                                          bUpdateUpVector;                                   // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckLateral;                                     // 0x00A1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckAbove;                                       // 0x00A2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A3[0x1];                                       // 0x00A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallLinecastRange;                                 // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x38];                                      // 0x00A8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMovementModeChanged(class ACharacter* InCharacter, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WallAttachComponent">();
	}
	static class UWallAttachComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWallAttachComponent>();
	}
};
static_assert(alignof(UWallAttachComponent) == 0x000008, "Wrong alignment on UWallAttachComponent");
static_assert(sizeof(UWallAttachComponent) == 0x0000E0, "Wrong size on UWallAttachComponent");
static_assert(offsetof(UWallAttachComponent, bUpdateUpVector) == 0x0000A0, "Member 'UWallAttachComponent::bUpdateUpVector' has a wrong offset!");
static_assert(offsetof(UWallAttachComponent, bCheckLateral) == 0x0000A1, "Member 'UWallAttachComponent::bCheckLateral' has a wrong offset!");
static_assert(offsetof(UWallAttachComponent, bCheckAbove) == 0x0000A2, "Member 'UWallAttachComponent::bCheckAbove' has a wrong offset!");
static_assert(offsetof(UWallAttachComponent, WallLinecastRange) == 0x0000A4, "Member 'UWallAttachComponent::WallLinecastRange' has a wrong offset!");

// Class Zion.StatComponent
// 0x00A8 (0x0148 - 0x00A0)
class UStatComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnCurrValueChangedDelegate;                        // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMaxValueChangedDelegate;                         // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCurrValueReachedZeroDelegate;                    // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCurrValueReachedMaxDelegate;                     // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x30];                                      // 0x00E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFullyRestoreOnBeginPlay;                          // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             SubtractBlockingStates;                            // 0x0118(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             AddBlockingStates;                                 // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         MaxValue;                                          // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrValue;                                         // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 Add(int32 ValueToAdd);
	void FullyRestore();
	void SetMaxValue(int32 NewMaxValue);
	int32 Subtract(int32 ValueToSubtract);

	float GetCurrRatio() const;
	int32 GetCurrValue() const;
	int32 GetMaxValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatComponent">();
	}
	static class UStatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatComponent>();
	}
};
static_assert(alignof(UStatComponent) == 0x000008, "Wrong alignment on UStatComponent");
static_assert(sizeof(UStatComponent) == 0x000148, "Wrong size on UStatComponent");
static_assert(offsetof(UStatComponent, OnCurrValueChangedDelegate) == 0x0000A0, "Member 'UStatComponent::OnCurrValueChangedDelegate' has a wrong offset!");
static_assert(offsetof(UStatComponent, OnMaxValueChangedDelegate) == 0x0000B0, "Member 'UStatComponent::OnMaxValueChangedDelegate' has a wrong offset!");
static_assert(offsetof(UStatComponent, OnCurrValueReachedZeroDelegate) == 0x0000C0, "Member 'UStatComponent::OnCurrValueReachedZeroDelegate' has a wrong offset!");
static_assert(offsetof(UStatComponent, OnCurrValueReachedMaxDelegate) == 0x0000D0, "Member 'UStatComponent::OnCurrValueReachedMaxDelegate' has a wrong offset!");
static_assert(offsetof(UStatComponent, bFullyRestoreOnBeginPlay) == 0x000110, "Member 'UStatComponent::bFullyRestoreOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UStatComponent, SubtractBlockingStates) == 0x000118, "Member 'UStatComponent::SubtractBlockingStates' has a wrong offset!");
static_assert(offsetof(UStatComponent, AddBlockingStates) == 0x000128, "Member 'UStatComponent::AddBlockingStates' has a wrong offset!");
static_assert(offsetof(UStatComponent, MaxValue) == 0x000138, "Member 'UStatComponent::MaxValue' has a wrong offset!");
static_assert(offsetof(UStatComponent, CurrValue) == 0x00013C, "Member 'UStatComponent::CurrValue' has a wrong offset!");

// Class Zion.StatBreakableComponent
// 0x0130 (0x0278 - 0x0148)
class UStatBreakableComponent : public UStatComponent
{
public:
	TMulticastInlineDelegate<void()>              OnBreakDelegate;                                   // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInvincibilityStart;                              // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInvincibilityEnd;                                // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UState>>             RegenerationBlockingStates;                        // 0x0178(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UState>>             BreakBlockingStates;                               // 0x0188(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UState>>             BreakRecoveryBlockingStates;                       // 0x0198(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UState>>             CompleteBlockingStates;                            // 0x01A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bEnabled;                                          // 0x01B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatBreakableData                     DefaultParameters;                                 // 0x01BC(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bUseMultiplicativeParameters;                      // 0x01D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatBreakableMultiplicativeData       MultiplicativeParameters;                          // 0x01D4(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bUseAdditiveParameters;                            // 0x01E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E9[0x3];                                      // 0x01E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatBreakableData                     AdditiveParameters;                                // 0x01EC(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bClampMinParameters;                               // 0x0200(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatBreakableData                     MinParameters;                                     // 0x0204(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bClampMaxParameters;                               // 0x0218(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatBreakableData                     MaxParameters;                                     // 0x021C(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FStatBreakableData                     CurrParameters;                                    // 0x0230(0x0014)(Edit, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_244[0x34];                                     // 0x0244(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBreak();
	bool SetIsImmune(bool bImmune);

	bool IsBroken() const;
	bool IsEnabled() const;
	bool IsInvincible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatBreakableComponent">();
	}
	static class UStatBreakableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatBreakableComponent>();
	}
};
static_assert(alignof(UStatBreakableComponent) == 0x000008, "Wrong alignment on UStatBreakableComponent");
static_assert(sizeof(UStatBreakableComponent) == 0x000278, "Wrong size on UStatBreakableComponent");
static_assert(offsetof(UStatBreakableComponent, OnBreakDelegate) == 0x000148, "Member 'UStatBreakableComponent::OnBreakDelegate' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, OnInvincibilityStart) == 0x000158, "Member 'UStatBreakableComponent::OnInvincibilityStart' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, OnInvincibilityEnd) == 0x000168, "Member 'UStatBreakableComponent::OnInvincibilityEnd' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, RegenerationBlockingStates) == 0x000178, "Member 'UStatBreakableComponent::RegenerationBlockingStates' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, BreakBlockingStates) == 0x000188, "Member 'UStatBreakableComponent::BreakBlockingStates' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, BreakRecoveryBlockingStates) == 0x000198, "Member 'UStatBreakableComponent::BreakRecoveryBlockingStates' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, CompleteBlockingStates) == 0x0001A8, "Member 'UStatBreakableComponent::CompleteBlockingStates' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, bEnabled) == 0x0001B8, "Member 'UStatBreakableComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, DefaultParameters) == 0x0001BC, "Member 'UStatBreakableComponent::DefaultParameters' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, bUseMultiplicativeParameters) == 0x0001D0, "Member 'UStatBreakableComponent::bUseMultiplicativeParameters' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, MultiplicativeParameters) == 0x0001D4, "Member 'UStatBreakableComponent::MultiplicativeParameters' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, bUseAdditiveParameters) == 0x0001E8, "Member 'UStatBreakableComponent::bUseAdditiveParameters' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, AdditiveParameters) == 0x0001EC, "Member 'UStatBreakableComponent::AdditiveParameters' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, bClampMinParameters) == 0x000200, "Member 'UStatBreakableComponent::bClampMinParameters' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, MinParameters) == 0x000204, "Member 'UStatBreakableComponent::MinParameters' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, bClampMaxParameters) == 0x000218, "Member 'UStatBreakableComponent::bClampMaxParameters' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, MaxParameters) == 0x00021C, "Member 'UStatBreakableComponent::MaxParameters' has a wrong offset!");
static_assert(offsetof(UStatBreakableComponent, CurrParameters) == 0x000230, "Member 'UStatBreakableComponent::CurrParameters' has a wrong offset!");

// Class Zion.StatBurnComponent
// 0x0000 (0x0278 - 0x0278)
class UStatBurnComponent final : public UStatBreakableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatBurnComponent">();
	}
	static class UStatBurnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatBurnComponent>();
	}
};
static_assert(alignof(UStatBurnComponent) == 0x000008, "Wrong alignment on UStatBurnComponent");
static_assert(sizeof(UStatBurnComponent) == 0x000278, "Wrong size on UStatBurnComponent");

// Class Zion.StateComponent
// 0x00A8 (0x0148 - 0x00A0)
class UStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x60];                                      // 0x00A0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UState>>             DefaultStates;                                     // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             ActiveStates;                                      // 0x0110(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FTimedStateData_Time>           TimedStates;                                       // 0x0120(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FTimedStateData_Frame>          FrameTimedStates;                                  // 0x0130(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddState(const TSubclassOf<class UState> State);
	void AddStates(const TArray<TSubclassOf<class UState>>& States);
	void AddStatesForDuration(const TArray<TSubclassOf<class UState>>& States, float Duration);
	void AddStatesForFrameCount(const TArray<TSubclassOf<class UState>>& States, int32 FrameCount);
	void RemoveAllStates();
	void RemoveState(const TSubclassOf<class UState> State);
	void RemoveStates(const TArray<TSubclassOf<class UState>>& States);

	bool HasAllStates(const TArray<TSubclassOf<class UState>>& States) const;
	bool HasAnyState(const TArray<TSubclassOf<class UState>>& States) const;
	bool HasBusyState() const;
	bool HasState(const TSubclassOf<class UState>& State) const;
	bool IsDebuffed() const;
	bool IsFacingLocked() const;
	bool IsFreeCommandLayerLocked() const;
	bool IsInFreezeCritical() const;
	bool IsInputActionLocked(const class UInputAction* InputAction) const;
	bool IsMovementLocked() const;
	bool IsStunned() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateComponent">();
	}
	static class UStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateComponent>();
	}
};
static_assert(alignof(UStateComponent) == 0x000008, "Wrong alignment on UStateComponent");
static_assert(sizeof(UStateComponent) == 0x000148, "Wrong size on UStateComponent");
static_assert(offsetof(UStateComponent, DefaultStates) == 0x000100, "Member 'UStateComponent::DefaultStates' has a wrong offset!");
static_assert(offsetof(UStateComponent, ActiveStates) == 0x000110, "Member 'UStateComponent::ActiveStates' has a wrong offset!");
static_assert(offsetof(UStateComponent, TimedStates) == 0x000120, "Member 'UStateComponent::TimedStates' has a wrong offset!");
static_assert(offsetof(UStateComponent, FrameTimedStates) == 0x000130, "Member 'UStateComponent::FrameTimedStates' has a wrong offset!");

// Class Zion.StateDead
// 0x0000 (0x0028 - 0x0028)
class UStateDead final : public UStateBusy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateDead">();
	}
	static class UStateDead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateDead>();
	}
};
static_assert(alignof(UStateDead) == 0x000008, "Wrong alignment on UStateDead");
static_assert(sizeof(UStateDead) == 0x000028, "Wrong size on UStateDead");

// Class Zion.StateBlockFreezeBreak
// 0x0000 (0x0028 - 0x0028)
class UStateBlockFreezeBreak final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateBlockFreezeBreak">();
	}
	static class UStateBlockFreezeBreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateBlockFreezeBreak>();
	}
};
static_assert(alignof(UStateBlockFreezeBreak) == 0x000008, "Wrong alignment on UStateBlockFreezeBreak");
static_assert(sizeof(UStateBlockFreezeBreak) == 0x000028, "Wrong size on UStateBlockFreezeBreak");

// Class Zion.StateDodge
// 0x0000 (0x0028 - 0x0028)
class UStateDodge final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateDodge">();
	}
	static class UStateDodge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateDodge>();
	}
};
static_assert(alignof(UStateDodge) == 0x000008, "Wrong alignment on UStateDodge");
static_assert(sizeof(UStateDodge) == 0x000028, "Wrong size on UStateDodge");

// Class Zion.StateDisableGuardResponse
// 0x0000 (0x0028 - 0x0028)
class UStateDisableGuardResponse final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateDisableGuardResponse">();
	}
	static class UStateDisableGuardResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateDisableGuardResponse>();
	}
};
static_assert(alignof(UStateDisableGuardResponse) == 0x000008, "Wrong alignment on UStateDisableGuardResponse");
static_assert(sizeof(UStateDisableGuardResponse) == 0x000028, "Wrong size on UStateDisableGuardResponse");

// Class Zion.StateParry
// 0x0000 (0x0028 - 0x0028)
class UStateParry final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateParry">();
	}
	static class UStateParry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateParry>();
	}
};
static_assert(alignof(UStateParry) == 0x000008, "Wrong alignment on UStateParry");
static_assert(sizeof(UStateParry) == 0x000028, "Wrong size on UStateParry");

// Class Zion.StateLookUp
// 0x0000 (0x0028 - 0x0028)
class UStateLookUp final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateLookUp">();
	}
	static class UStateLookUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateLookUp>();
	}
};
static_assert(alignof(UStateLookUp) == 0x000008, "Wrong alignment on UStateLookUp");
static_assert(sizeof(UStateLookUp) == 0x000028, "Wrong size on UStateLookUp");

// Class Zion.StateLockLookup
// 0x0000 (0x0028 - 0x0028)
class UStateLockLookup final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateLockLookup">();
	}
	static class UStateLockLookup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateLockLookup>();
	}
};
static_assert(alignof(UStateLockLookup) == 0x000008, "Wrong alignment on UStateLockLookup");
static_assert(sizeof(UStateLockLookup) == 0x000028, "Wrong size on UStateLockLookup");

// Class Zion.StateCrouch
// 0x0000 (0x0028 - 0x0028)
class UStateCrouch final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateCrouch">();
	}
	static class UStateCrouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateCrouch>();
	}
};
static_assert(alignof(UStateCrouch) == 0x000008, "Wrong alignment on UStateCrouch");
static_assert(sizeof(UStateCrouch) == 0x000028, "Wrong size on UStateCrouch");

// Class Zion.StateLockCrouch
// 0x0000 (0x0028 - 0x0028)
class UStateLockCrouch final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateLockCrouch">();
	}
	static class UStateLockCrouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateLockCrouch>();
	}
};
static_assert(alignof(UStateLockCrouch) == 0x000008, "Wrong alignment on UStateLockCrouch");
static_assert(sizeof(UStateLockCrouch) == 0x000028, "Wrong size on UStateLockCrouch");

// Class Zion.StateHitStop
// 0x0000 (0x0028 - 0x0028)
class UStateHitStop final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateHitStop">();
	}
	static class UStateHitStop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateHitStop>();
	}
};
static_assert(alignof(UStateHitStop) == 0x000008, "Wrong alignment on UStateHitStop");
static_assert(sizeof(UStateHitStop) == 0x000028, "Wrong size on UStateHitStop");

// Class Zion.StateIgnoreGravity
// 0x0000 (0x0028 - 0x0028)
class UStateIgnoreGravity final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateIgnoreGravity">();
	}
	static class UStateIgnoreGravity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateIgnoreGravity>();
	}
};
static_assert(alignof(UStateIgnoreGravity) == 0x000008, "Wrong alignment on UStateIgnoreGravity");
static_assert(sizeof(UStateIgnoreGravity) == 0x000028, "Wrong size on UStateIgnoreGravity");

// Class Zion.StateIgnoreBrakingDeceleration
// 0x0000 (0x0028 - 0x0028)
class UStateIgnoreBrakingDeceleration final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateIgnoreBrakingDeceleration">();
	}
	static class UStateIgnoreBrakingDeceleration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateIgnoreBrakingDeceleration>();
	}
};
static_assert(alignof(UStateIgnoreBrakingDeceleration) == 0x000008, "Wrong alignment on UStateIgnoreBrakingDeceleration");
static_assert(sizeof(UStateIgnoreBrakingDeceleration) == 0x000028, "Wrong size on UStateIgnoreBrakingDeceleration");

// Class Zion.StateIgnoreKnockback
// 0x0000 (0x0028 - 0x0028)
class UStateIgnoreKnockback final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateIgnoreKnockback">();
	}
	static class UStateIgnoreKnockback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateIgnoreKnockback>();
	}
};
static_assert(alignof(UStateIgnoreKnockback) == 0x000008, "Wrong alignment on UStateIgnoreKnockback");
static_assert(sizeof(UStateIgnoreKnockback) == 0x000028, "Wrong size on UStateIgnoreKnockback");

// Class Zion.StateIgnoreStaminaDamage
// 0x0000 (0x0028 - 0x0028)
class UStateIgnoreStaminaDamage final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateIgnoreStaminaDamage">();
	}
	static class UStateIgnoreStaminaDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateIgnoreStaminaDamage>();
	}
};
static_assert(alignof(UStateIgnoreStaminaDamage) == 0x000008, "Wrong alignment on UStateIgnoreStaminaDamage");
static_assert(sizeof(UStateIgnoreStaminaDamage) == 0x000028, "Wrong size on UStateIgnoreStaminaDamage");

// Class Zion.StateDisableWalkOffLedges
// 0x0000 (0x0028 - 0x0028)
class UStateDisableWalkOffLedges final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateDisableWalkOffLedges">();
	}
	static class UStateDisableWalkOffLedges* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateDisableWalkOffLedges>();
	}
};
static_assert(alignof(UStateDisableWalkOffLedges) == 0x000008, "Wrong alignment on UStateDisableWalkOffLedges");
static_assert(sizeof(UStateDisableWalkOffLedges) == 0x000028, "Wrong size on UStateDisableWalkOffLedges");

// Class Zion.StateDisableMaxFallVelocity
// 0x0000 (0x0028 - 0x0028)
class UStateDisableMaxFallVelocity final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateDisableMaxFallVelocity">();
	}
	static class UStateDisableMaxFallVelocity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateDisableMaxFallVelocity>();
	}
};
static_assert(alignof(UStateDisableMaxFallVelocity) == 0x000008, "Wrong alignment on UStateDisableMaxFallVelocity");
static_assert(sizeof(UStateDisableMaxFallVelocity) == 0x000028, "Wrong size on UStateDisableMaxFallVelocity");

// Class Zion.StateLockInputActions
// 0x0010 (0x0038 - 0x0028)
class UStateLockInputActions : public UState
{
public:
	TArray<class UInputAction*>                   InputActions;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateLockInputActions">();
	}
	static class UStateLockInputActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateLockInputActions>();
	}
};
static_assert(alignof(UStateLockInputActions) == 0x000008, "Wrong alignment on UStateLockInputActions");
static_assert(sizeof(UStateLockInputActions) == 0x000038, "Wrong size on UStateLockInputActions");
static_assert(offsetof(UStateLockInputActions, InputActions) == 0x000028, "Member 'UStateLockInputActions::InputActions' has a wrong offset!");

// Class Zion.StateLockAllInputActions
// 0x0000 (0x0028 - 0x0028)
class UStateLockAllInputActions final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateLockAllInputActions">();
	}
	static class UStateLockAllInputActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateLockAllInputActions>();
	}
};
static_assert(alignof(UStateLockAllInputActions) == 0x000008, "Wrong alignment on UStateLockAllInputActions");
static_assert(sizeof(UStateLockAllInputActions) == 0x000028, "Wrong size on UStateLockAllInputActions");

// Class Zion.ZionProjectileMovementComponent
// 0x0070 (0x02D0 - 0x0260)
class UZionProjectileMovementComponent final : public UProjectileMovementComponent
{
public:
	struct FVector                                InitialLocalSpaceVelocity;                         // 0x0258(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasInitialLocalSpaceAcceleration;                 // 0x0270(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InitialLocalSpaceAcceleration;                     // 0x0278(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasInitialVelocitySpaceAcceleration;              // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InitialVelocitySpaceAcceleration;                  // 0x0298(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasInitialMaxSpeed;                               // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialMaxSpeed;                                   // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInitialRotationFollowsVelocity;                   // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialGravityFactor;                              // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZionProjectileMovementComponent">();
	}
	static class UZionProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZionProjectileMovementComponent>();
	}
};
static_assert(alignof(UZionProjectileMovementComponent) == 0x000010, "Wrong alignment on UZionProjectileMovementComponent");
static_assert(sizeof(UZionProjectileMovementComponent) == 0x0002D0, "Wrong size on UZionProjectileMovementComponent");
static_assert(offsetof(UZionProjectileMovementComponent, InitialLocalSpaceVelocity) == 0x000258, "Member 'UZionProjectileMovementComponent::InitialLocalSpaceVelocity' has a wrong offset!");
static_assert(offsetof(UZionProjectileMovementComponent, bHasInitialLocalSpaceAcceleration) == 0x000270, "Member 'UZionProjectileMovementComponent::bHasInitialLocalSpaceAcceleration' has a wrong offset!");
static_assert(offsetof(UZionProjectileMovementComponent, InitialLocalSpaceAcceleration) == 0x000278, "Member 'UZionProjectileMovementComponent::InitialLocalSpaceAcceleration' has a wrong offset!");
static_assert(offsetof(UZionProjectileMovementComponent, bHasInitialVelocitySpaceAcceleration) == 0x000290, "Member 'UZionProjectileMovementComponent::bHasInitialVelocitySpaceAcceleration' has a wrong offset!");
static_assert(offsetof(UZionProjectileMovementComponent, InitialVelocitySpaceAcceleration) == 0x000298, "Member 'UZionProjectileMovementComponent::InitialVelocitySpaceAcceleration' has a wrong offset!");
static_assert(offsetof(UZionProjectileMovementComponent, bHasInitialMaxSpeed) == 0x0002B0, "Member 'UZionProjectileMovementComponent::bHasInitialMaxSpeed' has a wrong offset!");
static_assert(offsetof(UZionProjectileMovementComponent, InitialMaxSpeed) == 0x0002B4, "Member 'UZionProjectileMovementComponent::InitialMaxSpeed' has a wrong offset!");
static_assert(offsetof(UZionProjectileMovementComponent, bInitialRotationFollowsVelocity) == 0x0002B8, "Member 'UZionProjectileMovementComponent::bInitialRotationFollowsVelocity' has a wrong offset!");
static_assert(offsetof(UZionProjectileMovementComponent, InitialGravityFactor) == 0x0002BC, "Member 'UZionProjectileMovementComponent::InitialGravityFactor' has a wrong offset!");

// Class Zion.StateAutoClimb
// 0x0000 (0x0028 - 0x0028)
class UStateAutoClimb final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateAutoClimb">();
	}
	static class UStateAutoClimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateAutoClimb>();
	}
};
static_assert(alignof(UStateAutoClimb) == 0x000008, "Wrong alignment on UStateAutoClimb");
static_assert(sizeof(UStateAutoClimb) == 0x000028, "Wrong size on UStateAutoClimb");

// Class Zion.StateIgnoreAutoClimb
// 0x0000 (0x0028 - 0x0028)
class UStateIgnoreAutoClimb final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateIgnoreAutoClimb">();
	}
	static class UStateIgnoreAutoClimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateIgnoreAutoClimb>();
	}
};
static_assert(alignof(UStateIgnoreAutoClimb) == 0x000008, "Wrong alignment on UStateIgnoreAutoClimb");
static_assert(sizeof(UStateIgnoreAutoClimb) == 0x000028, "Wrong size on UStateIgnoreAutoClimb");

// Class Zion.StateIgnoreWallGrab
// 0x0000 (0x0028 - 0x0028)
class UStateIgnoreWallGrab final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateIgnoreWallGrab">();
	}
	static class UStateIgnoreWallGrab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateIgnoreWallGrab>();
	}
};
static_assert(alignof(UStateIgnoreWallGrab) == 0x000008, "Wrong alignment on UStateIgnoreWallGrab");
static_assert(sizeof(UStateIgnoreWallGrab) == 0x000028, "Wrong size on UStateIgnoreWallGrab");

// Class Zion.StateIgnoreEnemyRepulsion
// 0x0000 (0x0028 - 0x0028)
class UStateIgnoreEnemyRepulsion final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateIgnoreEnemyRepulsion">();
	}
	static class UStateIgnoreEnemyRepulsion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateIgnoreEnemyRepulsion>();
	}
};
static_assert(alignof(UStateIgnoreEnemyRepulsion) == 0x000008, "Wrong alignment on UStateIgnoreEnemyRepulsion");
static_assert(sizeof(UStateIgnoreEnemyRepulsion) == 0x000028, "Wrong size on UStateIgnoreEnemyRepulsion");

// Class Zion.StateDisableRegisteredHitboxes
// 0x0000 (0x0028 - 0x0028)
class UStateDisableRegisteredHitboxes final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateDisableRegisteredHitboxes">();
	}
	static class UStateDisableRegisteredHitboxes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateDisableRegisteredHitboxes>();
	}
};
static_assert(alignof(UStateDisableRegisteredHitboxes) == 0x000008, "Wrong alignment on UStateDisableRegisteredHitboxes");
static_assert(sizeof(UStateDisableRegisteredHitboxes) == 0x000028, "Wrong size on UStateDisableRegisteredHitboxes");

// Class Zion.StateWallDash
// 0x0000 (0x0028 - 0x0028)
class UStateWallDash final : public UState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateWallDash">();
	}
	static class UStateWallDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateWallDash>();
	}
};
static_assert(alignof(UStateWallDash) == 0x000008, "Wrong alignment on UStateWallDash");
static_assert(sizeof(UStateWallDash) == 0x000028, "Wrong size on UStateWallDash");

// Class Zion.StatFreezeComponent
// 0x0000 (0x0278 - 0x0278)
class UStatFreezeComponent final : public UStatBreakableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatFreezeComponent">();
	}
	static class UStatFreezeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatFreezeComponent>();
	}
};
static_assert(alignof(UStatFreezeComponent) == 0x000008, "Wrong alignment on UStatFreezeComponent");
static_assert(sizeof(UStatFreezeComponent) == 0x000278, "Wrong size on UStatFreezeComponent");

// Class Zion.StatHPComponent
// 0x0058 (0x01A0 - 0x0148)
class UStatHPComponent final : public UStatComponent
{
public:
	TMulticastInlineDelegate<void(class AActor* Source, const struct FDamageData& DamageData)> OnReceivedDamageDataDelegate; // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Source, int32 Value)> OnReceivedDamageDelegate;      // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Source, int32 Value)> OnReceivedHealDelegate;        // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bCanBeInstantKilled;                               // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_179[0x27];                                     // 0x0179(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DoDamage(class AActor* Source, const struct FDamageData& DamageData);
	bool DoHeal(class AActor* Source, int32 Value);

	class AActor* GetLastDamageSource() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatHPComponent">();
	}
	static class UStatHPComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatHPComponent>();
	}
};
static_assert(alignof(UStatHPComponent) == 0x000008, "Wrong alignment on UStatHPComponent");
static_assert(sizeof(UStatHPComponent) == 0x0001A0, "Wrong size on UStatHPComponent");
static_assert(offsetof(UStatHPComponent, OnReceivedDamageDataDelegate) == 0x000148, "Member 'UStatHPComponent::OnReceivedDamageDataDelegate' has a wrong offset!");
static_assert(offsetof(UStatHPComponent, OnReceivedDamageDelegate) == 0x000158, "Member 'UStatHPComponent::OnReceivedDamageDelegate' has a wrong offset!");
static_assert(offsetof(UStatHPComponent, OnReceivedHealDelegate) == 0x000168, "Member 'UStatHPComponent::OnReceivedHealDelegate' has a wrong offset!");
static_assert(offsetof(UStatHPComponent, bCanBeInstantKilled) == 0x000178, "Member 'UStatHPComponent::bCanBeInstantKilled' has a wrong offset!");

// Class Zion.StaticVolume
// 0x0010 (0x02A0 - 0x0290)
class AStaticVolume : public AActor
{
public:
	class USceneComponent*                        RootSceneComponent;                                // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBillboardComponent*                    BillboardComponent;                                // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticVolume">();
	}
	static class AStaticVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticVolume>();
	}
};
static_assert(alignof(AStaticVolume) == 0x000008, "Wrong alignment on AStaticVolume");
static_assert(sizeof(AStaticVolume) == 0x0002A0, "Wrong size on AStaticVolume");
static_assert(offsetof(AStaticVolume, RootSceneComponent) == 0x000290, "Member 'AStaticVolume::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AStaticVolume, BillboardComponent) == 0x000298, "Member 'AStaticVolume::BillboardComponent' has a wrong offset!");

// Class Zion.StaticVolume_Ability
// 0x0110 (0x03B0 - 0x02A0)
class AStaticVolume_Ability final : public AStaticVolume
{
public:
	class UAbilityComponent*                      AbilityComponent;                                  // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityData                           AbilityData;                                       // 0x02B0(0x00E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         AbilityTriggerDelay;                               // 0x0390(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         Targets;                                           // 0x0398(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticVolume_Ability">();
	}
	static class AStaticVolume_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticVolume_Ability>();
	}
};
static_assert(alignof(AStaticVolume_Ability) == 0x000010, "Wrong alignment on AStaticVolume_Ability");
static_assert(sizeof(AStaticVolume_Ability) == 0x0003B0, "Wrong size on AStaticVolume_Ability");
static_assert(offsetof(AStaticVolume_Ability, AbilityComponent) == 0x0002A0, "Member 'AStaticVolume_Ability::AbilityComponent' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Ability, AbilityData) == 0x0002B0, "Member 'AStaticVolume_Ability::AbilityData' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Ability, AbilityTriggerDelay) == 0x000390, "Member 'AStaticVolume_Ability::AbilityTriggerDelay' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Ability, Targets) == 0x000398, "Member 'AStaticVolume_Ability::Targets' has a wrong offset!");

// Class Zion.StaticVolume_AddForce
// 0x0160 (0x0400 - 0x02A0)
class AStaticVolume_AddForce final : public AStaticVolume
{
public:
	struct FVector                                MoveForce;                                         // 0x02A0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            MoveFactorCurve;                                   // 0x02B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERootMotionAccumulateMode                     AccumulateMode;                                    // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLocalSpace;                                       // 0x02C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C2[0x6];                                      // 0x02C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRootMotionFinishVelocitySettingsBP    FinishVelocitySettings;                            // 0x02C8(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FMovementModeData>              ValidMovementModes;                                // 0x02F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpineFXData>                   LoopFXs;                                           // 0x0300(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FNiagaraComponentList> LoopFXInstances;                               // 0x0310(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           InContactActors;                                   // 0x0360(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class ACharacter*, uint16>               RootMotionsIDs;                                    // 0x03B0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnCharacterMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticVolume_AddForce">();
	}
	static class AStaticVolume_AddForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticVolume_AddForce>();
	}
};
static_assert(alignof(AStaticVolume_AddForce) == 0x000008, "Wrong alignment on AStaticVolume_AddForce");
static_assert(sizeof(AStaticVolume_AddForce) == 0x000400, "Wrong size on AStaticVolume_AddForce");
static_assert(offsetof(AStaticVolume_AddForce, MoveForce) == 0x0002A0, "Member 'AStaticVolume_AddForce::MoveForce' has a wrong offset!");
static_assert(offsetof(AStaticVolume_AddForce, MoveFactorCurve) == 0x0002B8, "Member 'AStaticVolume_AddForce::MoveFactorCurve' has a wrong offset!");
static_assert(offsetof(AStaticVolume_AddForce, AccumulateMode) == 0x0002C0, "Member 'AStaticVolume_AddForce::AccumulateMode' has a wrong offset!");
static_assert(offsetof(AStaticVolume_AddForce, bLocalSpace) == 0x0002C1, "Member 'AStaticVolume_AddForce::bLocalSpace' has a wrong offset!");
static_assert(offsetof(AStaticVolume_AddForce, FinishVelocitySettings) == 0x0002C8, "Member 'AStaticVolume_AddForce::FinishVelocitySettings' has a wrong offset!");
static_assert(offsetof(AStaticVolume_AddForce, ValidMovementModes) == 0x0002F0, "Member 'AStaticVolume_AddForce::ValidMovementModes' has a wrong offset!");
static_assert(offsetof(AStaticVolume_AddForce, LoopFXs) == 0x000300, "Member 'AStaticVolume_AddForce::LoopFXs' has a wrong offset!");
static_assert(offsetof(AStaticVolume_AddForce, LoopFXInstances) == 0x000310, "Member 'AStaticVolume_AddForce::LoopFXInstances' has a wrong offset!");
static_assert(offsetof(AStaticVolume_AddForce, InContactActors) == 0x000360, "Member 'AStaticVolume_AddForce::InContactActors' has a wrong offset!");
static_assert(offsetof(AStaticVolume_AddForce, RootMotionsIDs) == 0x0003B0, "Member 'AStaticVolume_AddForce::RootMotionsIDs' has a wrong offset!");

// Class Zion.StaticVolume_Audio
// 0x0090 (0x0330 - 0x02A0)
class AStaticVolume_Audio : public AStaticVolume
{
public:
	struct FGameplayConditionChecker              ConditionChecker;                                  // 0x02A0(0x0018)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bInfiniteExtent;                                   // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAudioVolumeSettings                   Settings;                                          // 0x02C0(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAudioVolumeSettings                   ConditionsFailedSettings;                          // 0x02E8(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<class AFMODAmbientSound*>              AdditionalSounds;                                  // 0x0310(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsInfiniteExtent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticVolume_Audio">();
	}
	static class AStaticVolume_Audio* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticVolume_Audio>();
	}
};
static_assert(alignof(AStaticVolume_Audio) == 0x000008, "Wrong alignment on AStaticVolume_Audio");
static_assert(sizeof(AStaticVolume_Audio) == 0x000330, "Wrong size on AStaticVolume_Audio");
static_assert(offsetof(AStaticVolume_Audio, ConditionChecker) == 0x0002A0, "Member 'AStaticVolume_Audio::ConditionChecker' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Audio, bInfiniteExtent) == 0x0002B8, "Member 'AStaticVolume_Audio::bInfiniteExtent' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Audio, Priority) == 0x0002BC, "Member 'AStaticVolume_Audio::Priority' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Audio, Settings) == 0x0002C0, "Member 'AStaticVolume_Audio::Settings' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Audio, ConditionsFailedSettings) == 0x0002E8, "Member 'AStaticVolume_Audio::ConditionsFailedSettings' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Audio, AdditionalSounds) == 0x000310, "Member 'AStaticVolume_Audio::AdditionalSounds' has a wrong offset!");

// Class Zion.StaticVolume_CameraModifier
// 0x00C8 (0x0368 - 0x02A0)
class AStaticVolume_CameraModifier : public AStaticVolume
{
public:
	ECameraModifierActivationType                 ActivationType;                                    // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendTimeIn;                                       // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendTimeOut;                                      // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasOverrideSettings;                              // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCameraOverrideSettings        CameraOverrideSettings;                            // 0x02B8(0x0010)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasCameraClamp;                                   // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECameraClampLocation>                  CameraClampLocations;                              // 0x02D0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasBlocker;                                       // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBlockerUp_Active;                               // 0x02E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBlockerDown_Active;                             // 0x02E2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBlockerLeft_Active;                             // 0x02E3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBlockerRight_Active;                            // 0x02E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlockerSize;                                       // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         WallFX;                                            // 0x02F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasFixedCamera;                                   // 0x02F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFixedCameraMatch                             FixedCameraMatch;                                  // 0x02F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFixedCameraType                              FixedCameraType;                                   // 0x02FA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasBlackBorders;                                  // 0x02FB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneRootComponent;                                // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          ActivationBoxComponent;                            // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          ClampComponent;                                    // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          Blocker_Up;                                        // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          Blocker_Down;                                      // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          Blocker_Left;                                      // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          Blocker_Right;                                     // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNiagaraComponent*>              WallFXInstances;                                   // 0x0340(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UCameraOverrideModule_FOV*              CameraOverrideModule_FOV;                          // 0x0350(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraOverrideModule_ZoomOffset*       CameraOverrideModule_ZoomOffset;                   // 0x0358(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Activate();
	void Deactivate();
	void OnActivationBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnActivationEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticVolume_CameraModifier">();
	}
	static class AStaticVolume_CameraModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticVolume_CameraModifier>();
	}
};
static_assert(alignof(AStaticVolume_CameraModifier) == 0x000008, "Wrong alignment on AStaticVolume_CameraModifier");
static_assert(sizeof(AStaticVolume_CameraModifier) == 0x000368, "Wrong size on AStaticVolume_CameraModifier");
static_assert(offsetof(AStaticVolume_CameraModifier, ActivationType) == 0x0002A0, "Member 'AStaticVolume_CameraModifier::ActivationType' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, Priority) == 0x0002A4, "Member 'AStaticVolume_CameraModifier::Priority' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, BlendTimeIn) == 0x0002A8, "Member 'AStaticVolume_CameraModifier::BlendTimeIn' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, BlendTimeOut) == 0x0002AC, "Member 'AStaticVolume_CameraModifier::BlendTimeOut' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, bHasOverrideSettings) == 0x0002B0, "Member 'AStaticVolume_CameraModifier::bHasOverrideSettings' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, CameraOverrideSettings) == 0x0002B8, "Member 'AStaticVolume_CameraModifier::CameraOverrideSettings' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, bHasCameraClamp) == 0x0002C8, "Member 'AStaticVolume_CameraModifier::bHasCameraClamp' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, CameraClampLocations) == 0x0002D0, "Member 'AStaticVolume_CameraModifier::CameraClampLocations' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, bHasBlocker) == 0x0002E0, "Member 'AStaticVolume_CameraModifier::bHasBlocker' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, bIsBlockerUp_Active) == 0x0002E1, "Member 'AStaticVolume_CameraModifier::bIsBlockerUp_Active' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, bIsBlockerDown_Active) == 0x0002E2, "Member 'AStaticVolume_CameraModifier::bIsBlockerDown_Active' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, bIsBlockerLeft_Active) == 0x0002E3, "Member 'AStaticVolume_CameraModifier::bIsBlockerLeft_Active' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, bIsBlockerRight_Active) == 0x0002E4, "Member 'AStaticVolume_CameraModifier::bIsBlockerRight_Active' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, BlockerSize) == 0x0002E8, "Member 'AStaticVolume_CameraModifier::BlockerSize' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, WallFX) == 0x0002F0, "Member 'AStaticVolume_CameraModifier::WallFX' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, bHasFixedCamera) == 0x0002F8, "Member 'AStaticVolume_CameraModifier::bHasFixedCamera' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, FixedCameraMatch) == 0x0002F9, "Member 'AStaticVolume_CameraModifier::FixedCameraMatch' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, FixedCameraType) == 0x0002FA, "Member 'AStaticVolume_CameraModifier::FixedCameraType' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, bHasBlackBorders) == 0x0002FB, "Member 'AStaticVolume_CameraModifier::bHasBlackBorders' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, SceneRootComponent) == 0x000300, "Member 'AStaticVolume_CameraModifier::SceneRootComponent' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, ActivationBoxComponent) == 0x000308, "Member 'AStaticVolume_CameraModifier::ActivationBoxComponent' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, ClampComponent) == 0x000310, "Member 'AStaticVolume_CameraModifier::ClampComponent' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, Blocker_Up) == 0x000318, "Member 'AStaticVolume_CameraModifier::Blocker_Up' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, Blocker_Down) == 0x000320, "Member 'AStaticVolume_CameraModifier::Blocker_Down' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, Blocker_Left) == 0x000328, "Member 'AStaticVolume_CameraModifier::Blocker_Left' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, Blocker_Right) == 0x000330, "Member 'AStaticVolume_CameraModifier::Blocker_Right' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, WallFXInstances) == 0x000340, "Member 'AStaticVolume_CameraModifier::WallFXInstances' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, CameraOverrideModule_FOV) == 0x000350, "Member 'AStaticVolume_CameraModifier::CameraOverrideModule_FOV' has a wrong offset!");
static_assert(offsetof(AStaticVolume_CameraModifier, CameraOverrideModule_ZoomOffset) == 0x000358, "Member 'AStaticVolume_CameraModifier::CameraOverrideModule_ZoomOffset' has a wrong offset!");

// Class Zion.StaticVolume_EmulatedFog
// 0x00B8 (0x0358 - 0x02A0)
class AStaticVolume_EmulatedFog : public AStaticVolume
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          FogArea;                                           // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FEmulatedFogSettings                   Settings;                                          // 0x02B0(0x00A0)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         BlendIn;                                           // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendOut;                                          // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticVolume_EmulatedFog">();
	}
	static class AStaticVolume_EmulatedFog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticVolume_EmulatedFog>();
	}
};
static_assert(alignof(AStaticVolume_EmulatedFog) == 0x000008, "Wrong alignment on AStaticVolume_EmulatedFog");
static_assert(sizeof(AStaticVolume_EmulatedFog) == 0x000358, "Wrong size on AStaticVolume_EmulatedFog");
static_assert(offsetof(AStaticVolume_EmulatedFog, FogArea) == 0x0002A8, "Member 'AStaticVolume_EmulatedFog::FogArea' has a wrong offset!");
static_assert(offsetof(AStaticVolume_EmulatedFog, Settings) == 0x0002B0, "Member 'AStaticVolume_EmulatedFog::Settings' has a wrong offset!");
static_assert(offsetof(AStaticVolume_EmulatedFog, BlendIn) == 0x000350, "Member 'AStaticVolume_EmulatedFog::BlendIn' has a wrong offset!");
static_assert(offsetof(AStaticVolume_EmulatedFog, BlendOut) == 0x000354, "Member 'AStaticVolume_EmulatedFog::BlendOut' has a wrong offset!");

// Class Zion.StaticVolume_Physics
// 0x0018 (0x02B8 - 0x02A0)
class AStaticVolume_Physics : public AStaticVolume
{
public:
	struct FMovementModeData                      MovementMode;                                      // 0x02A0(0x0002)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A2[0x2];                                      // 0x02A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FluidFriction;                                     // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TerminalVelocity;                                  // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APhysicsVolume*                         VirtualPhysicsVolume;                              // 0x02B0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticVolume_Physics">();
	}
	static class AStaticVolume_Physics* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticVolume_Physics>();
	}
};
static_assert(alignof(AStaticVolume_Physics) == 0x000008, "Wrong alignment on AStaticVolume_Physics");
static_assert(sizeof(AStaticVolume_Physics) == 0x0002B8, "Wrong size on AStaticVolume_Physics");
static_assert(offsetof(AStaticVolume_Physics, MovementMode) == 0x0002A0, "Member 'AStaticVolume_Physics::MovementMode' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Physics, Priority) == 0x0002A4, "Member 'AStaticVolume_Physics::Priority' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Physics, FluidFriction) == 0x0002A8, "Member 'AStaticVolume_Physics::FluidFriction' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Physics, TerminalVelocity) == 0x0002AC, "Member 'AStaticVolume_Physics::TerminalVelocity' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Physics, VirtualPhysicsVolume) == 0x0002B0, "Member 'AStaticVolume_Physics::VirtualPhysicsVolume' has a wrong offset!");

// Class Zion.StaticVolume_Physics_Fluid
// 0x0000 (0x02B8 - 0x02B8)
class AStaticVolume_Physics_Fluid : public AStaticVolume_Physics
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticVolume_Physics_Fluid">();
	}
	static class AStaticVolume_Physics_Fluid* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticVolume_Physics_Fluid>();
	}
};
static_assert(alignof(AStaticVolume_Physics_Fluid) == 0x000008, "Wrong alignment on AStaticVolume_Physics_Fluid");
static_assert(sizeof(AStaticVolume_Physics_Fluid) == 0x0002B8, "Wrong size on AStaticVolume_Physics_Fluid");

// Class Zion.UserWidgetMapLegend
// 0x0050 (0x04B0 - 0x0460)
class UUserWidgetMapLegend : public UUserWidgetZionShowHide
{
public:
	TSet<EMapIconType>                            IgnoreVisibilityCheckIconTypes;                    // 0x0460(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void OnLegendInitialized(const TSet<EMapIconType>& VisibleIconTypes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapLegend">();
	}
	static class UUserWidgetMapLegend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapLegend>();
	}
};
static_assert(alignof(UUserWidgetMapLegend) == 0x000008, "Wrong alignment on UUserWidgetMapLegend");
static_assert(sizeof(UUserWidgetMapLegend) == 0x0004B0, "Wrong size on UUserWidgetMapLegend");
static_assert(offsetof(UUserWidgetMapLegend, IgnoreVisibilityCheckIconTypes) == 0x000460, "Member 'UUserWidgetMapLegend::IgnoreVisibilityCheckIconTypes' has a wrong offset!");

// Class Zion.StaticVolume_Zone
// 0x00F0 (0x0458 - 0x0368)
class AStaticVolume_Zone : public AStaticVolume_CameraModifier
{
public:
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPostProcessComponent*                  PostProcessComponent;                              // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UWorld>                  ZoneLevel;                                         // 0x0378(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUsePostProcess;                                   // 0x03A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseFog;                                           // 0x03A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A2[0x6];                                      // 0x03A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEmulatedFogSettings                   FogSettings;                                       // 0x03A8(0x00A0)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         FogDepthMin;                                       // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FogDepthMax;                                       // 0x044C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FogHeightMin;                                      // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FogHeightMax;                                      // 0x0454(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetZoneLevel(class UWorld* InZoneLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticVolume_Zone">();
	}
	static class AStaticVolume_Zone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticVolume_Zone>();
	}
};
static_assert(alignof(AStaticVolume_Zone) == 0x000008, "Wrong alignment on AStaticVolume_Zone");
static_assert(sizeof(AStaticVolume_Zone) == 0x000458, "Wrong size on AStaticVolume_Zone");
static_assert(offsetof(AStaticVolume_Zone, PostProcessComponent) == 0x000370, "Member 'AStaticVolume_Zone::PostProcessComponent' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Zone, ZoneLevel) == 0x000378, "Member 'AStaticVolume_Zone::ZoneLevel' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Zone, bUsePostProcess) == 0x0003A0, "Member 'AStaticVolume_Zone::bUsePostProcess' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Zone, bUseFog) == 0x0003A1, "Member 'AStaticVolume_Zone::bUseFog' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Zone, FogSettings) == 0x0003A8, "Member 'AStaticVolume_Zone::FogSettings' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Zone, FogDepthMin) == 0x000448, "Member 'AStaticVolume_Zone::FogDepthMin' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Zone, FogDepthMax) == 0x00044C, "Member 'AStaticVolume_Zone::FogDepthMax' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Zone, FogHeightMin) == 0x000450, "Member 'AStaticVolume_Zone::FogHeightMin' has a wrong offset!");
static_assert(offsetof(AStaticVolume_Zone, FogHeightMax) == 0x000454, "Member 'AStaticVolume_Zone::FogHeightMax' has a wrong offset!");

// Class Zion.StatsControllerComponent
// 0x0028 (0x00C8 - 0x00A0)
class UStatsControllerComponent : public UActorComponent
{
public:
	class UDataTable*                             DefaultLevelTable;                                 // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             LevelTable;                                        // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetAppliedLevel() const;
	int32 GetLevel() const;
	struct FStatsLevelData GetStatsLevelData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatsControllerComponent">();
	}
	static class UStatsControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatsControllerComponent>();
	}
};
static_assert(alignof(UStatsControllerComponent) == 0x000008, "Wrong alignment on UStatsControllerComponent");
static_assert(sizeof(UStatsControllerComponent) == 0x0000C8, "Wrong size on UStatsControllerComponent");
static_assert(offsetof(UStatsControllerComponent, DefaultLevelTable) == 0x0000A0, "Member 'UStatsControllerComponent::DefaultLevelTable' has a wrong offset!");
static_assert(offsetof(UStatsControllerComponent, LevelTable) == 0x0000A8, "Member 'UStatsControllerComponent::LevelTable' has a wrong offset!");

// Class Zion.StatsControllerAIComponent
// 0x0018 (0x00E0 - 0x00C8)
class UStatsControllerAIComponent final : public UStatsControllerComponent
{
public:
	TMulticastInlineDelegate<void(int32 PhaseLevel)> OnPhaseLevelChangeDelegate;                     // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         PhaseLevel;                                        // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 IncrementPhaseLevel();

	int32 GetPhaseLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatsControllerAIComponent">();
	}
	static class UStatsControllerAIComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatsControllerAIComponent>();
	}
};
static_assert(alignof(UStatsControllerAIComponent) == 0x000008, "Wrong alignment on UStatsControllerAIComponent");
static_assert(sizeof(UStatsControllerAIComponent) == 0x0000E0, "Wrong size on UStatsControllerAIComponent");
static_assert(offsetof(UStatsControllerAIComponent, OnPhaseLevelChangeDelegate) == 0x0000C8, "Member 'UStatsControllerAIComponent::OnPhaseLevelChangeDelegate' has a wrong offset!");
static_assert(offsetof(UStatsControllerAIComponent, PhaseLevel) == 0x0000D8, "Member 'UStatsControllerAIComponent::PhaseLevel' has a wrong offset!");

// Class Zion.StatsControllerPlayerComponent
// 0x00F8 (0x01C0 - 0x00C8)
class UStatsControllerPlayerComponent final : public UStatsControllerComponent
{
public:
	TMulticastInlineDelegate<void()>              OnExperienceValueChanged;                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLevelValueChanged;                               // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FExtendedStatsData                     MaxPossibleStatsData;                              // 0x00E8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FExtendedStatsData                     AdditiveBonusStats;                                // 0x0138(0x0050)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x38];                                     // 0x0188(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetLevel(int32 NewLevel);

	int32 GetExperiencePoints() const;
	float GetExperiencePointsRatio() const;
	struct FExtendedStatsData GetExtendedStatsLevelDataWithBonuses() const;
	int32 GetNecessaryExperiencePointsForLevelUp() const;
	struct FStatsLevelData GetStatsLevelDataWithBonuses() const;
	bool IsMaxLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatsControllerPlayerComponent">();
	}
	static class UStatsControllerPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatsControllerPlayerComponent>();
	}
};
static_assert(alignof(UStatsControllerPlayerComponent) == 0x000008, "Wrong alignment on UStatsControllerPlayerComponent");
static_assert(sizeof(UStatsControllerPlayerComponent) == 0x0001C0, "Wrong size on UStatsControllerPlayerComponent");
static_assert(offsetof(UStatsControllerPlayerComponent, OnExperienceValueChanged) == 0x0000C8, "Member 'UStatsControllerPlayerComponent::OnExperienceValueChanged' has a wrong offset!");
static_assert(offsetof(UStatsControllerPlayerComponent, OnLevelValueChanged) == 0x0000D8, "Member 'UStatsControllerPlayerComponent::OnLevelValueChanged' has a wrong offset!");
static_assert(offsetof(UStatsControllerPlayerComponent, MaxPossibleStatsData) == 0x0000E8, "Member 'UStatsControllerPlayerComponent::MaxPossibleStatsData' has a wrong offset!");
static_assert(offsetof(UStatsControllerPlayerComponent, AdditiveBonusStats) == 0x000138, "Member 'UStatsControllerPlayerComponent::AdditiveBonusStats' has a wrong offset!");

// Class Zion.UserWidgetPlayerTrail
// 0x0068 (0x04C8 - 0x0460)
class UUserWidgetPlayerTrail : public UUserWidgetZion
{
public:
	class UCanvasPanel*                           PlayerTrailIconsHolder;                            // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x10];                                     // 0x0468(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisplayPlayerTrailIcon;                           // 0x0478(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRegisterEvents;                                   // 0x0479(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47A[0x2];                                      // 0x047A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPlayerTrailIconCount;                           // 0x047C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PlayerTrailIconOpacityChangeCount;                 // 0x0480(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerTrailIconMinOpacity;                         // 0x0484(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerTrailIconMaxOpacity;                         // 0x0488(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerTrailIconMinScale;                           // 0x048C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerTrailIconMaxScale;                           // 0x0490(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidgetMapIcon_PlayerTrail> WidgetPlayerTrailIconClass;                    // 0x0498(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUserWidgetMapIcon_PlayerTrail*> CachedPlayerTrailIcons;                            // 0x04A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x18];                                     // 0x04B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetPlayerTrail">();
	}
	static class UUserWidgetPlayerTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetPlayerTrail>();
	}
};
static_assert(alignof(UUserWidgetPlayerTrail) == 0x000008, "Wrong alignment on UUserWidgetPlayerTrail");
static_assert(sizeof(UUserWidgetPlayerTrail) == 0x0004C8, "Wrong size on UUserWidgetPlayerTrail");
static_assert(offsetof(UUserWidgetPlayerTrail, PlayerTrailIconsHolder) == 0x000460, "Member 'UUserWidgetPlayerTrail::PlayerTrailIconsHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetPlayerTrail, bDisplayPlayerTrailIcon) == 0x000478, "Member 'UUserWidgetPlayerTrail::bDisplayPlayerTrailIcon' has a wrong offset!");
static_assert(offsetof(UUserWidgetPlayerTrail, bRegisterEvents) == 0x000479, "Member 'UUserWidgetPlayerTrail::bRegisterEvents' has a wrong offset!");
static_assert(offsetof(UUserWidgetPlayerTrail, MaxPlayerTrailIconCount) == 0x00047C, "Member 'UUserWidgetPlayerTrail::MaxPlayerTrailIconCount' has a wrong offset!");
static_assert(offsetof(UUserWidgetPlayerTrail, PlayerTrailIconOpacityChangeCount) == 0x000480, "Member 'UUserWidgetPlayerTrail::PlayerTrailIconOpacityChangeCount' has a wrong offset!");
static_assert(offsetof(UUserWidgetPlayerTrail, PlayerTrailIconMinOpacity) == 0x000484, "Member 'UUserWidgetPlayerTrail::PlayerTrailIconMinOpacity' has a wrong offset!");
static_assert(offsetof(UUserWidgetPlayerTrail, PlayerTrailIconMaxOpacity) == 0x000488, "Member 'UUserWidgetPlayerTrail::PlayerTrailIconMaxOpacity' has a wrong offset!");
static_assert(offsetof(UUserWidgetPlayerTrail, PlayerTrailIconMinScale) == 0x00048C, "Member 'UUserWidgetPlayerTrail::PlayerTrailIconMinScale' has a wrong offset!");
static_assert(offsetof(UUserWidgetPlayerTrail, PlayerTrailIconMaxScale) == 0x000490, "Member 'UUserWidgetPlayerTrail::PlayerTrailIconMaxScale' has a wrong offset!");
static_assert(offsetof(UUserWidgetPlayerTrail, WidgetPlayerTrailIconClass) == 0x000498, "Member 'UUserWidgetPlayerTrail::WidgetPlayerTrailIconClass' has a wrong offset!");
static_assert(offsetof(UUserWidgetPlayerTrail, CachedPlayerTrailIcons) == 0x0004A0, "Member 'UUserWidgetPlayerTrail::CachedPlayerTrailIcons' has a wrong offset!");

// Class Zion.StatsEnemyComponent
// 0x0008 (0x07B8 - 0x07B0)
class UStatsEnemyComponent final : public UStatsComponent
{
public:
	uint8                                         Pad_7B0[0x8];                                      // 0x07B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatsEnemyComponent">();
	}
	static class UStatsEnemyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatsEnemyComponent>();
	}
};
static_assert(alignof(UStatsEnemyComponent) == 0x000008, "Wrong alignment on UStatsEnemyComponent");
static_assert(sizeof(UStatsEnemyComponent) == 0x0007B8, "Wrong size on UStatsEnemyComponent");

// Class Zion.StatShockComponent
// 0x0000 (0x0278 - 0x0278)
class UStatShockComponent final : public UStatBreakableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatShockComponent">();
	}
	static class UStatShockComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatShockComponent>();
	}
};
static_assert(alignof(UStatShockComponent) == 0x000008, "Wrong alignment on UStatShockComponent");
static_assert(sizeof(UStatShockComponent) == 0x000278, "Wrong size on UStatShockComponent");

// Class Zion.StatSPComponent
// 0x0010 (0x0158 - 0x0148)
class UStatSPComponent final : public UStatComponent
{
public:
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SPRegenPercentageBonus;                            // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddSPRegenPercentageBonus(int32 SPRegenPercentBonusToAdd);
	int32 SubSPRegenPercentageBonus(int32 SPRegenPercentBonusToSub);

	int32 GetFilledGaugeCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatSPComponent">();
	}
	static class UStatSPComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatSPComponent>();
	}
};
static_assert(alignof(UStatSPComponent) == 0x000008, "Wrong alignment on UStatSPComponent");
static_assert(sizeof(UStatSPComponent) == 0x000158, "Wrong size on UStatSPComponent");
static_assert(offsetof(UStatSPComponent, SPRegenPercentageBonus) == 0x000150, "Member 'UStatSPComponent::SPRegenPercentageBonus' has a wrong offset!");

// Class Zion.StatsPlayerComponent
// 0x0000 (0x07B0 - 0x07B0)
class UStatsPlayerComponent final : public UStatsComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatsPlayerComponent">();
	}
	static class UStatsPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatsPlayerComponent>();
	}
};
static_assert(alignof(UStatsPlayerComponent) == 0x000008, "Wrong alignment on UStatsPlayerComponent");
static_assert(sizeof(UStatsPlayerComponent) == 0x0007B0, "Wrong size on UStatsPlayerComponent");

// Class Zion.UserWidgetRestPointListEntry
// 0x0028 (0x0488 - 0x0460)
class UUserWidgetRestPointListEntry : public UUserWidgetZion
{
public:
	TMulticastInlineDelegate<void(class UUserWidgetMapIcon_RestPoint* RestPointIcon)> OnFocused;     // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FMapRestPointData& RestPointData)> OnPressed;         // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UUserWidgetMapIcon_RestPoint> CachedRestPointIcon;                          // 0x0480(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeEntry(class UUserWidgetMapIcon_RestPoint* RestPointIcon);
	void OnInitializeEntry();

	bool IsRestPointIcon(class UUserWidgetMapIcon_RestPoint* RestPointIcon) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetRestPointListEntry">();
	}
	static class UUserWidgetRestPointListEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetRestPointListEntry>();
	}
};
static_assert(alignof(UUserWidgetRestPointListEntry) == 0x000008, "Wrong alignment on UUserWidgetRestPointListEntry");
static_assert(sizeof(UUserWidgetRestPointListEntry) == 0x000488, "Wrong size on UUserWidgetRestPointListEntry");
static_assert(offsetof(UUserWidgetRestPointListEntry, OnFocused) == 0x000460, "Member 'UUserWidgetRestPointListEntry::OnFocused' has a wrong offset!");
static_assert(offsetof(UUserWidgetRestPointListEntry, OnPressed) == 0x000470, "Member 'UUserWidgetRestPointListEntry::OnPressed' has a wrong offset!");
static_assert(offsetof(UUserWidgetRestPointListEntry, CachedRestPointIcon) == 0x000480, "Member 'UUserWidgetRestPointListEntry::CachedRestPointIcon' has a wrong offset!");

// Class Zion.StatStaminaComponent
// 0x0000 (0x0278 - 0x0278)
class UStatStaminaComponent final : public UStatBreakableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatStaminaComponent">();
	}
	static class UStatStaminaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatStaminaComponent>();
	}
};
static_assert(alignof(UStatStaminaComponent) == 0x000008, "Wrong alignment on UStatStaminaComponent");
static_assert(sizeof(UStatStaminaComponent) == 0x000278, "Wrong size on UStatStaminaComponent");

// Class Zion.StatsSnapshotProviderInterface
// 0x0000 (0x0000 - 0x0000)
class IStatsSnapshotProviderInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatsSnapshotProviderInterface">();
	}
	static class IStatsSnapshotProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStatsSnapshotProviderInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStatsSnapshotProviderInterface) == 0x000001, "Wrong alignment on IStatsSnapshotProviderInterface");
static_assert(sizeof(IStatsSnapshotProviderInterface) == 0x000001, "Wrong size on IStatsSnapshotProviderInterface");

// Class Zion.StatusEffect
// 0x0070 (0x0098 - 0x0028)
class UStatusEffect : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanEditStatusEffectType;                          // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStatusEffectType                             StatusEffectType;                                  // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDifficultySettings;                            // 0x0042(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43[0x1];                                       // 0x0043(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             OnLaunchSound;                                     // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             LoopSound;                                         // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x40];                                      // 0x0058(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDuration() const;
	EStatusEffectType GetStatusEffectType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffect">();
	}
	static class UStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffect>();
	}
};
static_assert(alignof(UStatusEffect) == 0x000008, "Wrong alignment on UStatusEffect");
static_assert(sizeof(UStatusEffect) == 0x000098, "Wrong size on UStatusEffect");
static_assert(offsetof(UStatusEffect, bCanEditStatusEffectType) == 0x000040, "Member 'UStatusEffect::bCanEditStatusEffectType' has a wrong offset!");
static_assert(offsetof(UStatusEffect, StatusEffectType) == 0x000041, "Member 'UStatusEffect::StatusEffectType' has a wrong offset!");
static_assert(offsetof(UStatusEffect, bUseDifficultySettings) == 0x000042, "Member 'UStatusEffect::bUseDifficultySettings' has a wrong offset!");
static_assert(offsetof(UStatusEffect, Duration) == 0x000044, "Member 'UStatusEffect::Duration' has a wrong offset!");
static_assert(offsetof(UStatusEffect, OnLaunchSound) == 0x000048, "Member 'UStatusEffect::OnLaunchSound' has a wrong offset!");
static_assert(offsetof(UStatusEffect, LoopSound) == 0x000050, "Member 'UStatusEffect::LoopSound' has a wrong offset!");

// Class Zion.StatusEffect_Burn
// 0x00F8 (0x0190 - 0x0098)
class UStatusEffect_Burn : public UStatusEffect
{
public:
	float                                         AbilityTick;                                       // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityData                           AbilityData;                                       // 0x00A0(0x00E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffect_Burn">();
	}
	static class UStatusEffect_Burn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffect_Burn>();
	}
};
static_assert(alignof(UStatusEffect_Burn) == 0x000010, "Wrong alignment on UStatusEffect_Burn");
static_assert(sizeof(UStatusEffect_Burn) == 0x000190, "Wrong size on UStatusEffect_Burn");
static_assert(offsetof(UStatusEffect_Burn, AbilityTick) == 0x000098, "Member 'UStatusEffect_Burn::AbilityTick' has a wrong offset!");
static_assert(offsetof(UStatusEffect_Burn, AbilityData) == 0x0000A0, "Member 'UStatusEffect_Burn::AbilityData' has a wrong offset!");

// Class Zion.StatusEffect_BurnPlayer
// 0x0010 (0x01A0 - 0x0190)
class UStatusEffect_BurnPlayer : public UStatusEffect_Burn
{
public:
	float                                         DodgeDurationReduction;                            // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_194[0xC];                                      // 0x0194(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDodged();
	void OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffect_BurnPlayer">();
	}
	static class UStatusEffect_BurnPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffect_BurnPlayer>();
	}
};
static_assert(alignof(UStatusEffect_BurnPlayer) == 0x000010, "Wrong alignment on UStatusEffect_BurnPlayer");
static_assert(sizeof(UStatusEffect_BurnPlayer) == 0x0001A0, "Wrong size on UStatusEffect_BurnPlayer");
static_assert(offsetof(UStatusEffect_BurnPlayer, DodgeDurationReduction) == 0x000190, "Member 'UStatusEffect_BurnPlayer::DodgeDurationReduction' has a wrong offset!");

// Class Zion.StatusEffect_DamageCut
// 0x0010 (0x00A8 - 0x0098)
class UStatusEffect_DamageCut final : public UStatusEffect
{
public:
	int32                                         PercentageBonus;                                   // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C[0xC];                                       // 0x009C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffect_DamageCut">();
	}
	static class UStatusEffect_DamageCut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffect_DamageCut>();
	}
};
static_assert(alignof(UStatusEffect_DamageCut) == 0x000008, "Wrong alignment on UStatusEffect_DamageCut");
static_assert(sizeof(UStatusEffect_DamageCut) == 0x0000A8, "Wrong size on UStatusEffect_DamageCut");
static_assert(offsetof(UStatusEffect_DamageCut, PercentageBonus) == 0x000098, "Member 'UStatusEffect_DamageCut::PercentageBonus' has a wrong offset!");

// Class Zion.StatusEffect_Freeze
// 0x0138 (0x01D0 - 0x0098)
class UStatusEffect_Freeze : public UStatusEffect
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityData                           AbilityData;                                       // 0x00A0(0x00E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UState>>             AdditionalStates;                                  // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x40];                                     // 0x0190(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffect_Freeze">();
	}
	static class UStatusEffect_Freeze* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffect_Freeze>();
	}
};
static_assert(alignof(UStatusEffect_Freeze) == 0x000010, "Wrong alignment on UStatusEffect_Freeze");
static_assert(sizeof(UStatusEffect_Freeze) == 0x0001D0, "Wrong size on UStatusEffect_Freeze");
static_assert(offsetof(UStatusEffect_Freeze, AbilityData) == 0x0000A0, "Member 'UStatusEffect_Freeze::AbilityData' has a wrong offset!");
static_assert(offsetof(UStatusEffect_Freeze, AdditionalStates) == 0x000180, "Member 'UStatusEffect_Freeze::AdditionalStates' has a wrong offset!");

// Class Zion.StatusEffect_FreezeCritical
// 0x0020 (0x01F0 - 0x01D0)
class UStatusEffect_FreezeCritical : public UStatusEffect_Freeze
{
public:
	float                                         ActivationTimeThreshold;                           // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D4[0x1C];                                     // 0x01D4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffect_FreezeCritical">();
	}
	static class UStatusEffect_FreezeCritical* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffect_FreezeCritical>();
	}
};
static_assert(alignof(UStatusEffect_FreezeCritical) == 0x000010, "Wrong alignment on UStatusEffect_FreezeCritical");
static_assert(sizeof(UStatusEffect_FreezeCritical) == 0x0001F0, "Wrong size on UStatusEffect_FreezeCritical");
static_assert(offsetof(UStatusEffect_FreezeCritical, ActivationTimeThreshold) == 0x0001D0, "Member 'UStatusEffect_FreezeCritical::ActivationTimeThreshold' has a wrong offset!");

// Class Zion.StatusEffect_FreezePlayer
// 0x0018 (0x00B0 - 0x0098)
class UStatusEffect_FreezePlayer : public UStatusEffect
{
public:
	float                                         MovementSpeedRatio;                                // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C[0x14];                                      // 0x009C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffect_FreezePlayer">();
	}
	static class UStatusEffect_FreezePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffect_FreezePlayer>();
	}
};
static_assert(alignof(UStatusEffect_FreezePlayer) == 0x000008, "Wrong alignment on UStatusEffect_FreezePlayer");
static_assert(sizeof(UStatusEffect_FreezePlayer) == 0x0000B0, "Wrong size on UStatusEffect_FreezePlayer");
static_assert(offsetof(UStatusEffect_FreezePlayer, MovementSpeedRatio) == 0x000098, "Member 'UStatusEffect_FreezePlayer::MovementSpeedRatio' has a wrong offset!");

// Class Zion.StatusEffect_Stats
// 0x0048 (0x00E0 - 0x0098)
class UStatusEffect_Stats : public UStatusEffect
{
public:
	struct FStatsLevelData                        BonusStatsPercentage;                              // 0x0098(0x0040)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffect_Stats">();
	}
	static class UStatusEffect_Stats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffect_Stats>();
	}
};
static_assert(alignof(UStatusEffect_Stats) == 0x000008, "Wrong alignment on UStatusEffect_Stats");
static_assert(sizeof(UStatusEffect_Stats) == 0x0000E0, "Wrong size on UStatusEffect_Stats");
static_assert(offsetof(UStatusEffect_Stats, BonusStatsPercentage) == 0x000098, "Member 'UStatusEffect_Stats::BonusStatsPercentage' has a wrong offset!");

// Class Zion.StatusEffect_Shock
// 0x0008 (0x00E8 - 0x00E0)
class UStatusEffect_Shock : public UStatusEffect_Stats
{
public:
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffect_Shock">();
	}
	static class UStatusEffect_Shock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffect_Shock>();
	}
};
static_assert(alignof(UStatusEffect_Shock) == 0x000008, "Wrong alignment on UStatusEffect_Shock");
static_assert(sizeof(UStatusEffect_Shock) == 0x0000E8, "Wrong size on UStatusEffect_Shock");

// Class Zion.StoryEventMarkerLocation
// 0x0010 (0x02A0 - 0x0290)
class AStoryEventMarkerLocation final : public AActor
{
public:
	TArray<int32>                                 ActiveStoryLevels;                                 // 0x0290(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoryEventMarkerLocation">();
	}
	static class AStoryEventMarkerLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStoryEventMarkerLocation>();
	}
};
static_assert(alignof(AStoryEventMarkerLocation) == 0x000008, "Wrong alignment on AStoryEventMarkerLocation");
static_assert(sizeof(AStoryEventMarkerLocation) == 0x0002A0, "Wrong size on AStoryEventMarkerLocation");
static_assert(offsetof(AStoryEventMarkerLocation, ActiveStoryLevels) == 0x000290, "Member 'AStoryEventMarkerLocation::ActiveStoryLevels' has a wrong offset!");

// Class Zion.StoryLevelComponent
// 0x0028 (0x00C8 - 0x00A0)
class UStoryLevelComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StoryLevel;                                        // 0x00B8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0xC];                                       // 0x00BC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetStoryLevel() const;
	const struct FStoryLevelData GetStoryLevelData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoryLevelComponent">();
	}
	static class UStoryLevelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoryLevelComponent>();
	}
};
static_assert(alignof(UStoryLevelComponent) == 0x000008, "Wrong alignment on UStoryLevelComponent");
static_assert(sizeof(UStoryLevelComponent) == 0x0000C8, "Wrong size on UStoryLevelComponent");
static_assert(offsetof(UStoryLevelComponent, StoryLevel) == 0x0000B8, "Member 'UStoryLevelComponent::StoryLevel' has a wrong offset!");

// Class Zion.StringBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class UStringBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString BossRushRecordTimeSecondsToString(float TimeInSeconds);
	static void ProcessSubtitle(const class FText& Text, class FText* Name_0, class FText* Message);
	static TArray<class FString> Sort(TArray<class FString>& Array);
	static class FString TimeSecondsToString(float TimeInSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StringBPFLibrary">();
	}
	static class UStringBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStringBPFLibrary>();
	}
};
static_assert(alignof(UStringBPFLibrary) == 0x000008, "Wrong alignment on UStringBPFLibrary");
static_assert(sizeof(UStringBPFLibrary) == 0x000028, "Wrong size on UStringBPFLibrary");

// Class Zion.StructBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class UStructBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FExtendedStatsData ExtendedStatsData_Add(const struct FExtendedStatsData& A, const struct FExtendedStatsData& B);
	static void ExtendedStatsData_ClampToZero(struct FExtendedStatsData& ExtendedStatsData);
	static struct FExtendedStatsData ExtendedStatsData_Subtract(const struct FExtendedStatsData& A, const struct FExtendedStatsData& B);
	static class UPlatformMediaSource* GetTutorialVideo(const struct FInventoryItemTutorialData& ItemTutorialData, class APlayerControllerZion* PlayerControllerZion);
	static bool IsAbilityDataValid(const struct FAbilityData& AbilityData);
	static bool IsItemSkillDataValid(const struct FInventoryItemSkillData& ItemData);
	static bool MovementModeMatch(const class UCharacterMovementComponent* CharacterMovementComponent, const struct FMovementModeData& MovementModeData);
	static bool MovementModeMatchAny(const class UCharacterMovementComponent* CharacterMovementComponent, const TArray<struct FMovementModeData>& MovementModeDataList);
	static struct FStatsLevelData StatsLevelData_Add(const struct FStatsLevelData& A, const struct FStatsLevelData& B);
	static struct FStatsLevelData StatsLevelData_Subtract(const struct FStatsLevelData& A, const struct FStatsLevelData& B);
	static struct FCurrencyValue ToCurrencyValue(const struct FCurrencyTransactionInfos& Info, int32 AlreadyBoughtCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StructBPFLibrary">();
	}
	static class UStructBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStructBPFLibrary>();
	}
};
static_assert(alignof(UStructBPFLibrary) == 0x000008, "Wrong alignment on UStructBPFLibrary");
static_assert(sizeof(UStructBPFLibrary) == 0x000028, "Wrong size on UStructBPFLibrary");

// Class Zion.StunComponent
// 0x00B0 (0x0150 - 0x00A0)
class UStunComponent final : public UActorComponent
{
public:
	TArray<TSubclassOf<class UState>>             StunStates;                                        // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bUseKnockback;                                     // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKnockbackData                         KnockbackData;                                     // 0x00B8(0x0058)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             OnStunSoundEvent;                                  // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x38];                                     // 0x0118(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBreakRecovery();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StunComponent">();
	}
	static class UStunComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStunComponent>();
	}
};
static_assert(alignof(UStunComponent) == 0x000008, "Wrong alignment on UStunComponent");
static_assert(sizeof(UStunComponent) == 0x000150, "Wrong size on UStunComponent");
static_assert(offsetof(UStunComponent, StunStates) == 0x0000A0, "Member 'UStunComponent::StunStates' has a wrong offset!");
static_assert(offsetof(UStunComponent, bUseKnockback) == 0x0000B0, "Member 'UStunComponent::bUseKnockback' has a wrong offset!");
static_assert(offsetof(UStunComponent, KnockbackData) == 0x0000B8, "Member 'UStunComponent::KnockbackData' has a wrong offset!");
static_assert(offsetof(UStunComponent, OnStunSoundEvent) == 0x000110, "Member 'UStunComponent::OnStunSoundEvent' has a wrong offset!");

// Class Zion.SummonComponent
// 0x0138 (0x01D8 - 0x00A0)
class USummonComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const class ACharacterZionSpirit* Spirit, const class UCommandSet* CommandSet)> OnAutoSpiritEnabledDelegate; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class ACharacterZionSpirit* Spirit, const class UCommandSet* CommandSet)> OnAutoSpiritDisabledDelegate; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSet<TSubclassOf<class ACharacterZionSpirit>> DefaultSpiritClassesToKeepLoaded;                  // 0x00C0(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class ACharacterZionSpirit>, class ACharacterZionSpirit*> CachedSpirits;        // 0x0110(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<TSubclassOf<class ACharacterZionSpirit>> SpiritClassesToKeepLoaded;                         // 0x0160(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x28];                                     // 0x01B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FlushCachedSpirits();
	class ACharacterZionSpirit* GetOrSpawnSpirit(const TSubclassOf<class ACharacterZionSpirit>& SpiritClass);
	bool IsSpiritSummoned(const TSubclassOf<class ACharacterZionSpirit>& SpiritClass);
	void OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void OnGameMapChanged();
	void SetForceSummonNextToggle();
	class ACharacterZionSpirit* SummonSpirit(const TSubclassOf<class ACharacterZionSpirit>& SpiritClass, const TArray<TSubclassOf<class UCommand>>& CommandClasses, const struct FSpiritSummonParameters& SummonParameters, const class UInputAction* InvokedByInputAction, ECommandLayerType CommandLayerType, const class UCommandSet* FallbackCommandSet);
	class ACharacterZionSpirit* SummonSpiritFromCommand(const TSubclassOf<class ACharacterZionSpirit>& SpiritClass, const TArray<TSubclassOf<class UCommand>>& CommandClasses, const struct FSpiritSummonParameters& SummonParameters, const class UCommand* SourceCommand);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonComponent">();
	}
	static class USummonComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonComponent>();
	}
};
static_assert(alignof(USummonComponent) == 0x000008, "Wrong alignment on USummonComponent");
static_assert(sizeof(USummonComponent) == 0x0001D8, "Wrong size on USummonComponent");
static_assert(offsetof(USummonComponent, OnAutoSpiritEnabledDelegate) == 0x0000A0, "Member 'USummonComponent::OnAutoSpiritEnabledDelegate' has a wrong offset!");
static_assert(offsetof(USummonComponent, OnAutoSpiritDisabledDelegate) == 0x0000B0, "Member 'USummonComponent::OnAutoSpiritDisabledDelegate' has a wrong offset!");
static_assert(offsetof(USummonComponent, DefaultSpiritClassesToKeepLoaded) == 0x0000C0, "Member 'USummonComponent::DefaultSpiritClassesToKeepLoaded' has a wrong offset!");
static_assert(offsetof(USummonComponent, CachedSpirits) == 0x000110, "Member 'USummonComponent::CachedSpirits' has a wrong offset!");
static_assert(offsetof(USummonComponent, SpiritClassesToKeepLoaded) == 0x000160, "Member 'USummonComponent::SpiritClassesToKeepLoaded' has a wrong offset!");

// Class Zion.SummonIdleSpiritComponent
// 0x0120 (0x01C0 - 0x00A0)
class USummonIdleSpiritComponent final : public UActorComponent
{
public:
	float                                         IdleDurationBeforeSummon;                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinDurationBeforeSummon;                           // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDurationBeforeSummon;                           // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinDurationBetweenSummon;                          // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDurationBetweenSummon;                          // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinDurationBeforeAutoDismiss;                      // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDurationBeforeAutoDismiss;                      // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinOffsetToPlayer;                                 // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OffsetToPlayerRange;                               // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinOffsetBetweenSpirits;                           // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OffsetBetweenSpiritsRange;                         // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInputAction*>                   IgnoredInputActions;                               // 0x00D0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<ESkillSlot, struct FLoadedIdleSpiritClass> CachedSpiritClasses;                             // 0x00E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FSummonedIdleSpiritData>        ActiveSpiritsData;                                 // 0x0130(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x80];                                     // 0x0140(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FlushCachedSpirits();
	void OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void OnGameMapChanged();
	void OnJustTriggeredInputAction(const class UInputAction* InputAction);
	void OnPostStartCommand(const class UCommand* Command);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonIdleSpiritComponent">();
	}
	static class USummonIdleSpiritComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonIdleSpiritComponent>();
	}
};
static_assert(alignof(USummonIdleSpiritComponent) == 0x000008, "Wrong alignment on USummonIdleSpiritComponent");
static_assert(sizeof(USummonIdleSpiritComponent) == 0x0001C0, "Wrong size on USummonIdleSpiritComponent");
static_assert(offsetof(USummonIdleSpiritComponent, IdleDurationBeforeSummon) == 0x0000A0, "Member 'USummonIdleSpiritComponent::IdleDurationBeforeSummon' has a wrong offset!");
static_assert(offsetof(USummonIdleSpiritComponent, MinDurationBeforeSummon) == 0x0000A4, "Member 'USummonIdleSpiritComponent::MinDurationBeforeSummon' has a wrong offset!");
static_assert(offsetof(USummonIdleSpiritComponent, MaxDurationBeforeSummon) == 0x0000A8, "Member 'USummonIdleSpiritComponent::MaxDurationBeforeSummon' has a wrong offset!");
static_assert(offsetof(USummonIdleSpiritComponent, MinDurationBetweenSummon) == 0x0000AC, "Member 'USummonIdleSpiritComponent::MinDurationBetweenSummon' has a wrong offset!");
static_assert(offsetof(USummonIdleSpiritComponent, MaxDurationBetweenSummon) == 0x0000B0, "Member 'USummonIdleSpiritComponent::MaxDurationBetweenSummon' has a wrong offset!");
static_assert(offsetof(USummonIdleSpiritComponent, MinDurationBeforeAutoDismiss) == 0x0000B4, "Member 'USummonIdleSpiritComponent::MinDurationBeforeAutoDismiss' has a wrong offset!");
static_assert(offsetof(USummonIdleSpiritComponent, MaxDurationBeforeAutoDismiss) == 0x0000B8, "Member 'USummonIdleSpiritComponent::MaxDurationBeforeAutoDismiss' has a wrong offset!");
static_assert(offsetof(USummonIdleSpiritComponent, MinOffsetToPlayer) == 0x0000BC, "Member 'USummonIdleSpiritComponent::MinOffsetToPlayer' has a wrong offset!");
static_assert(offsetof(USummonIdleSpiritComponent, OffsetToPlayerRange) == 0x0000C0, "Member 'USummonIdleSpiritComponent::OffsetToPlayerRange' has a wrong offset!");
static_assert(offsetof(USummonIdleSpiritComponent, MinOffsetBetweenSpirits) == 0x0000C4, "Member 'USummonIdleSpiritComponent::MinOffsetBetweenSpirits' has a wrong offset!");
static_assert(offsetof(USummonIdleSpiritComponent, OffsetBetweenSpiritsRange) == 0x0000C8, "Member 'USummonIdleSpiritComponent::OffsetBetweenSpiritsRange' has a wrong offset!");
static_assert(offsetof(USummonIdleSpiritComponent, IgnoredInputActions) == 0x0000D0, "Member 'USummonIdleSpiritComponent::IgnoredInputActions' has a wrong offset!");
static_assert(offsetof(USummonIdleSpiritComponent, CachedSpiritClasses) == 0x0000E0, "Member 'USummonIdleSpiritComponent::CachedSpiritClasses' has a wrong offset!");
static_assert(offsetof(USummonIdleSpiritComponent, ActiveSpiritsData) == 0x000130, "Member 'USummonIdleSpiritComponent::ActiveSpiritsData' has a wrong offset!");

// Class Zion.SummonRestPointSpiritComponent
// 0x00B0 (0x0150 - 0x00A0)
class USummonRestPointSpiritComponent final : public UActorComponent
{
public:
	float                                         MinOffsetToPlayer;                                 // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinOffsetBetweenSpirits;                           // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TSoftClassPtr<class UClass>, struct FAptitudeArray> AptitudeSpirits_Map;                    // 0x00A8(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   ExplorationSpiritSoftClass;                        // 0x00F8(0x0028)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ACharacterZionSpirit>> CachedSpirits;                                // 0x0120(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x20];                                     // 0x0130(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishSummonRestPointSpirits();
	void OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void RefreshRestPointSpirits();
	void StartSummonRestPointSpirits();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonRestPointSpiritComponent">();
	}
	static class USummonRestPointSpiritComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonRestPointSpiritComponent>();
	}
};
static_assert(alignof(USummonRestPointSpiritComponent) == 0x000008, "Wrong alignment on USummonRestPointSpiritComponent");
static_assert(sizeof(USummonRestPointSpiritComponent) == 0x000150, "Wrong size on USummonRestPointSpiritComponent");
static_assert(offsetof(USummonRestPointSpiritComponent, MinOffsetToPlayer) == 0x0000A0, "Member 'USummonRestPointSpiritComponent::MinOffsetToPlayer' has a wrong offset!");
static_assert(offsetof(USummonRestPointSpiritComponent, MinOffsetBetweenSpirits) == 0x0000A4, "Member 'USummonRestPointSpiritComponent::MinOffsetBetweenSpirits' has a wrong offset!");
static_assert(offsetof(USummonRestPointSpiritComponent, AptitudeSpirits_Map) == 0x0000A8, "Member 'USummonRestPointSpiritComponent::AptitudeSpirits_Map' has a wrong offset!");
static_assert(offsetof(USummonRestPointSpiritComponent, ExplorationSpiritSoftClass) == 0x0000F8, "Member 'USummonRestPointSpiritComponent::ExplorationSpiritSoftClass' has a wrong offset!");
static_assert(offsetof(USummonRestPointSpiritComponent, CachedSpirits) == 0x000120, "Member 'USummonRestPointSpiritComponent::CachedSpirits' has a wrong offset!");

// Class Zion.SystemBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class USystemBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool DoesGameVersionMatchesPakVersion();
	static void FlushTextureStreaming(bool bDeferToEndFrame);
	static class FString GetBinkURLFromPlatformMediaSource(const class UPlatformMediaSource* PlatformMediaSource);
	static EBuildPlatformType GetBuildPlatformType();
	static int32 GetGameBuildNumber();
	static class FString GetGameVersion();
	static class FString GetMoviePathFromMovieName(const class FString& MovieName);
	static class FString GetRHIName();
	static class FString GetRuntimeTextureInfos(const class UTexture2D* Texture2D);
	static TArray<class FString> GetRuntimeTextureInfosFromGroup(const ETextureGroup& TextureGroup);
	static bool GetWindowedResolutions(TArray<struct FIntPoint>* OutResolutions);
	static bool IsBossRecollectionEnabled();
	static bool IsCrashReportAllowedBuild();
	static bool IsDemoBuild();
	static bool IsEarlyAccessBuild();
	static bool IsEditor();
	static bool IsNewGamePlusEnabled();
	static bool IsPCBuild();
	static bool IsPlaystation4Build();
	static bool IsPlaystation5Build();
	static bool IsPlaystationBuild();
	static bool IsShippingBuild();
	static bool IsSwitchBuild();
	static bool IsUsing4KResolution();
	static bool IsXboxFamilyBuild();
	static void UpdateUITexturesForCurrentResolution();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SystemBPFLibrary">();
	}
	static class USystemBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USystemBPFLibrary>();
	}
};
static_assert(alignof(USystemBPFLibrary) == 0x000008, "Wrong alignment on USystemBPFLibrary");
static_assert(sizeof(USystemBPFLibrary) == 0x000028, "Wrong size on USystemBPFLibrary");

// Class Zion.TargetChangeNotifierComponent
// 0x0010 (0x00B0 - 0x00A0)
class UTargetChangeNotifierComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const class AActor* NewTarget)> OnTargetChanged;                   // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetChangeNotifierComponent">();
	}
	static class UTargetChangeNotifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetChangeNotifierComponent>();
	}
};
static_assert(alignof(UTargetChangeNotifierComponent) == 0x000008, "Wrong alignment on UTargetChangeNotifierComponent");
static_assert(sizeof(UTargetChangeNotifierComponent) == 0x0000B0, "Wrong size on UTargetChangeNotifierComponent");
static_assert(offsetof(UTargetChangeNotifierComponent, OnTargetChanged) == 0x0000A0, "Member 'UTargetChangeNotifierComponent::OnTargetChanged' has a wrong offset!");

// Class Zion.TargetPivotProviderInterface
// 0x0000 (0x0000 - 0x0000)
class ITargetPivotProviderInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetPivotProviderInterface">();
	}
	static class ITargetPivotProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITargetPivotProviderInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITargetPivotProviderInterface) == 0x000001, "Wrong alignment on ITargetPivotProviderInterface");
static_assert(sizeof(ITargetPivotProviderInterface) == 0x000001, "Wrong size on ITargetPivotProviderInterface");

// Class Zion.TimeDilationAsyncAction
// 0x0030 (0x0060 - 0x0030)
class UTimeDilationAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTimeDilationAsyncAction* TimeDilation(const class UObject* WorldContextObject, const struct FTimedDilationData& TimedDilation);

	void OnTimedProcessFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeDilationAsyncAction">();
	}
	static class UTimeDilationAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeDilationAsyncAction>();
	}
};
static_assert(alignof(UTimeDilationAsyncAction) == 0x000008, "Wrong alignment on UTimeDilationAsyncAction");
static_assert(sizeof(UTimeDilationAsyncAction) == 0x000060, "Wrong size on UTimeDilationAsyncAction");
static_assert(offsetof(UTimeDilationAsyncAction, OnFinish) == 0x000030, "Member 'UTimeDilationAsyncAction::OnFinish' has a wrong offset!");

// Class Zion.TimeManagerComponent
// 0x0020 (0x00C0 - 0x00A0)
class UTimeManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTimeManagerComponent* Get(const class UObject* WorldContextObject);

	void AddDilation(float TimeDilationOverride, const class FName& Tag);
	void RemoveAllTimeDilation();
	void RemoveDilation(const class FName& Tag);

	bool IsTimeDilationActive(const class FName& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeManagerComponent">();
	}
	static class UTimeManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeManagerComponent>();
	}
};
static_assert(alignof(UTimeManagerComponent) == 0x000008, "Wrong alignment on UTimeManagerComponent");
static_assert(sizeof(UTimeManagerComponent) == 0x0000C0, "Wrong size on UTimeManagerComponent");

// Class Zion.ToggleActorInterface
// 0x0000 (0x0000 - 0x0000)
class IToggleActorInterface final
{
public:
	void OnActorToggle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToggleActorInterface">();
	}
	static class IToggleActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IToggleActorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IToggleActorInterface) == 0x000001, "Wrong alignment on IToggleActorInterface");
static_assert(sizeof(IToggleActorInterface) == 0x000001, "Wrong size on IToggleActorInterface");

// Class Zion.Trigger_GameMapChange
// 0x0070 (0x0310 - 0x02A0)
class ATrigger_GameMapChange : public ATrigger
{
public:
	struct FDataTableRowHandle                    GameMap;                                           // 0x02A0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	class FName                                   PlayerStartTag;                                    // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFadeDescriptionData                   FadeOutDescription;                                // 0x02B8(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FFadeDescriptionData                   FadeInDescription;                                 // 0x02D8(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayConditionChecker              ConditionChecker;                                  // 0x02F8(0x0018)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Trigger_GameMapChange">();
	}
	static class ATrigger_GameMapChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrigger_GameMapChange>();
	}
};
static_assert(alignof(ATrigger_GameMapChange) == 0x000008, "Wrong alignment on ATrigger_GameMapChange");
static_assert(sizeof(ATrigger_GameMapChange) == 0x000310, "Wrong size on ATrigger_GameMapChange");
static_assert(offsetof(ATrigger_GameMapChange, GameMap) == 0x0002A0, "Member 'ATrigger_GameMapChange::GameMap' has a wrong offset!");
static_assert(offsetof(ATrigger_GameMapChange, PlayerStartTag) == 0x0002B0, "Member 'ATrigger_GameMapChange::PlayerStartTag' has a wrong offset!");
static_assert(offsetof(ATrigger_GameMapChange, FadeOutDescription) == 0x0002B8, "Member 'ATrigger_GameMapChange::FadeOutDescription' has a wrong offset!");
static_assert(offsetof(ATrigger_GameMapChange, FadeInDescription) == 0x0002D8, "Member 'ATrigger_GameMapChange::FadeInDescription' has a wrong offset!");
static_assert(offsetof(ATrigger_GameMapChange, ConditionChecker) == 0x0002F8, "Member 'ATrigger_GameMapChange::ConditionChecker' has a wrong offset!");

// Class Zion.Trigger_PlaySound
// 0x0040 (0x02E0 - 0x02A0)
class ATrigger_PlaySound final : public ATrigger
{
public:
	class USceneComponent*                        AttachSoundSceneComponent;                         // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOneShot;                                          // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlaySoundTriggerData>          SoundEventDataList;                                // 0x02B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UFMODAudioComponent>> AudioInstances;                                // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Trigger_PlaySound">();
	}
	static class ATrigger_PlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrigger_PlaySound>();
	}
};
static_assert(alignof(ATrigger_PlaySound) == 0x000008, "Wrong alignment on ATrigger_PlaySound");
static_assert(sizeof(ATrigger_PlaySound) == 0x0002E0, "Wrong size on ATrigger_PlaySound");
static_assert(offsetof(ATrigger_PlaySound, AttachSoundSceneComponent) == 0x0002A0, "Member 'ATrigger_PlaySound::AttachSoundSceneComponent' has a wrong offset!");
static_assert(offsetof(ATrigger_PlaySound, bOneShot) == 0x0002A8, "Member 'ATrigger_PlaySound::bOneShot' has a wrong offset!");
static_assert(offsetof(ATrigger_PlaySound, SoundEventDataList) == 0x0002B0, "Member 'ATrigger_PlaySound::SoundEventDataList' has a wrong offset!");
static_assert(offsetof(ATrigger_PlaySound, AudioInstances) == 0x0002C0, "Member 'ATrigger_PlaySound::AudioInstances' has a wrong offset!");

// Class Zion.Trigger_RegisterRuntimeCheckpoint
// 0x0028 (0x02C8 - 0x02A0)
class ATrigger_RegisterRuntimeCheckpoint : public ATrigger
{
public:
	class UChildActorComponent*                   PlayerStartChildActor;                             // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRuntimeCheckpointData                 RuntimeCheckpointData;                             // 0x02A8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerEndOverlap(class AActor* PlayerActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Trigger_RegisterRuntimeCheckpoint">();
	}
	static class ATrigger_RegisterRuntimeCheckpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrigger_RegisterRuntimeCheckpoint>();
	}
};
static_assert(alignof(ATrigger_RegisterRuntimeCheckpoint) == 0x000008, "Wrong alignment on ATrigger_RegisterRuntimeCheckpoint");
static_assert(sizeof(ATrigger_RegisterRuntimeCheckpoint) == 0x0002C8, "Wrong size on ATrigger_RegisterRuntimeCheckpoint");
static_assert(offsetof(ATrigger_RegisterRuntimeCheckpoint, PlayerStartChildActor) == 0x0002A0, "Member 'ATrigger_RegisterRuntimeCheckpoint::PlayerStartChildActor' has a wrong offset!");
static_assert(offsetof(ATrigger_RegisterRuntimeCheckpoint, RuntimeCheckpointData) == 0x0002A8, "Member 'ATrigger_RegisterRuntimeCheckpoint::RuntimeCheckpointData' has a wrong offset!");

// Class Zion.Trigger_RespawnToRuntimeCheckpoint
// 0x0160 (0x0400 - 0x02A0)
class ATrigger_RespawnToRuntimeCheckpoint final : public ATrigger
{
public:
	struct FFadeDescriptionData                   FadeOutDescription;                                // 0x02A0(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FFadeDescriptionData                   FadeInDescription;                                 // 0x02C0(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAbilityData                           AbilityData;                                       // 0x02E0(0x00E0)(Edit, NativeAccessSpecifierPrivate)
	float                                         RespawnDelay;                                      // 0x03C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityComponent*                      AbilityComponent;                                  // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFactionComponent*                      FactionComponent;                                  // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x28];                                     // 0x03D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRespawnTimerFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Trigger_RespawnToRuntimeCheckpoint">();
	}
	static class ATrigger_RespawnToRuntimeCheckpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrigger_RespawnToRuntimeCheckpoint>();
	}
};
static_assert(alignof(ATrigger_RespawnToRuntimeCheckpoint) == 0x000010, "Wrong alignment on ATrigger_RespawnToRuntimeCheckpoint");
static_assert(sizeof(ATrigger_RespawnToRuntimeCheckpoint) == 0x000400, "Wrong size on ATrigger_RespawnToRuntimeCheckpoint");
static_assert(offsetof(ATrigger_RespawnToRuntimeCheckpoint, FadeOutDescription) == 0x0002A0, "Member 'ATrigger_RespawnToRuntimeCheckpoint::FadeOutDescription' has a wrong offset!");
static_assert(offsetof(ATrigger_RespawnToRuntimeCheckpoint, FadeInDescription) == 0x0002C0, "Member 'ATrigger_RespawnToRuntimeCheckpoint::FadeInDescription' has a wrong offset!");
static_assert(offsetof(ATrigger_RespawnToRuntimeCheckpoint, AbilityData) == 0x0002E0, "Member 'ATrigger_RespawnToRuntimeCheckpoint::AbilityData' has a wrong offset!");
static_assert(offsetof(ATrigger_RespawnToRuntimeCheckpoint, RespawnDelay) == 0x0003C0, "Member 'ATrigger_RespawnToRuntimeCheckpoint::RespawnDelay' has a wrong offset!");
static_assert(offsetof(ATrigger_RespawnToRuntimeCheckpoint, AbilityComponent) == 0x0003C8, "Member 'ATrigger_RespawnToRuntimeCheckpoint::AbilityComponent' has a wrong offset!");
static_assert(offsetof(ATrigger_RespawnToRuntimeCheckpoint, FactionComponent) == 0x0003D0, "Member 'ATrigger_RespawnToRuntimeCheckpoint::FactionComponent' has a wrong offset!");

// Class Zion.UIComponent
// 0x00C0 (0x0160 - 0x00A0)
class UUIComponent final : public UActorComponent
{
public:
	bool                                          bOverrideGaugeOriginComponent;                     // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentReference                    GaugeOriginComponentRef;                           // 0x00A8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                GaugeOriginLocalOffset;                            // 0x00D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                GaugeOriginWorldOffset;                            // 0x00E8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidgetWorldSpaceGauge> WorldSpaceGaugeClass;                              // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TextOriginLocalOffset;                             // 0x0108(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidgetWorldSpaceText>  WorldSpaceTextDamageClass;                         // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidgetWorldSpaceText>  WorldSpaceTextCriticalDamageClass;                 // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidgetWorldSpaceText>  WorldSpaceTextAdvantageDamageClass;                // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidgetWorldSpaceText>  WorldSpaceTextDisadvantageDamageClass;             // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidgetWorldSpaceText>  WorldSpaceTextHealClass;                           // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnDeath();
	void OnReceivedDamage(class AActor* Source, int32 DamageValue);
	void OnReceivedDamageData(class AActor* Source, const struct FDamageData& DamageData);
	void OnReceivedHeal(class AActor* Source, int32 HealValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIComponent">();
	}
	static class UUIComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIComponent>();
	}
};
static_assert(alignof(UUIComponent) == 0x000008, "Wrong alignment on UUIComponent");
static_assert(sizeof(UUIComponent) == 0x000160, "Wrong size on UUIComponent");
static_assert(offsetof(UUIComponent, bOverrideGaugeOriginComponent) == 0x0000A0, "Member 'UUIComponent::bOverrideGaugeOriginComponent' has a wrong offset!");
static_assert(offsetof(UUIComponent, GaugeOriginComponentRef) == 0x0000A8, "Member 'UUIComponent::GaugeOriginComponentRef' has a wrong offset!");
static_assert(offsetof(UUIComponent, GaugeOriginLocalOffset) == 0x0000D0, "Member 'UUIComponent::GaugeOriginLocalOffset' has a wrong offset!");
static_assert(offsetof(UUIComponent, GaugeOriginWorldOffset) == 0x0000E8, "Member 'UUIComponent::GaugeOriginWorldOffset' has a wrong offset!");
static_assert(offsetof(UUIComponent, WorldSpaceGaugeClass) == 0x000100, "Member 'UUIComponent::WorldSpaceGaugeClass' has a wrong offset!");
static_assert(offsetof(UUIComponent, TextOriginLocalOffset) == 0x000108, "Member 'UUIComponent::TextOriginLocalOffset' has a wrong offset!");
static_assert(offsetof(UUIComponent, WorldSpaceTextDamageClass) == 0x000120, "Member 'UUIComponent::WorldSpaceTextDamageClass' has a wrong offset!");
static_assert(offsetof(UUIComponent, WorldSpaceTextCriticalDamageClass) == 0x000128, "Member 'UUIComponent::WorldSpaceTextCriticalDamageClass' has a wrong offset!");
static_assert(offsetof(UUIComponent, WorldSpaceTextAdvantageDamageClass) == 0x000130, "Member 'UUIComponent::WorldSpaceTextAdvantageDamageClass' has a wrong offset!");
static_assert(offsetof(UUIComponent, WorldSpaceTextDisadvantageDamageClass) == 0x000138, "Member 'UUIComponent::WorldSpaceTextDisadvantageDamageClass' has a wrong offset!");
static_assert(offsetof(UUIComponent, WorldSpaceTextHealClass) == 0x000140, "Member 'UUIComponent::WorldSpaceTextHealClass' has a wrong offset!");

// Class Zion.UMGBPFLibrary
// 0x0000 (0x0028 - 0x0028)
class UUMGBPFLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddToViewportAtLayer(class UUserWidget* Widget, EUMGLayer UMGLayer);
	static int32 GetCompletionPercentageForItemType(const class UObject* WorldContextObject, const EInventoryItemType& ItemType);
	static EFocusCause GetFocusCause(const struct FFocusEvent& FocusEvent);
	static int32 GetUMGZOrder(EUMGLayer UMGLayer);
	static void InvalidateAllWidgets();
	static bool IsActionInputTypeKey(const class UObject* WorldContextObject, const struct FKey& Key, const EActionInputType& ActionInputType);
	static bool IsKeyUIInputType(const class UObject* WorldContextObject, const struct FKey& Key, EUIInputType UIInputType);
	static bool IsRepeatKeyEvent(const struct FKeyEvent& KeyEvent);
	static bool IsUICancelKey(const class UObject* WorldContextObject, const struct FKey& Key);
	static bool IsUIConfirmKey(const class UObject* WorldContextObject, const struct FKey& Key);
	static bool IsUIContextAltKey(const class UObject* WorldContextObject, const struct FKey& Key);
	static bool IsUIContextKey(const class UObject* WorldContextObject, const struct FKey& Key);
	static void ResetAllNiagaraWidgets();
	static void SetBrushFromSoftSprite(class UImage* Target, TSoftObjectPtr<class UPaperSprite> SoftSprite, bool bMatchSize);
	static void SetBrushFromSoftSpriteAsync(class UImage* Target, TSoftObjectPtr<class UPaperSprite> SoftSprite, bool bMatchSize);
	static void SetBrushFromSprite(class UImage* Target, class UPaperSprite* Sprite, bool bMatchSize);
	static bool ShouldDisplayCompletionWidget();
	static bool ShouldDisplayExtraUnavailableCharacters(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBPFLibrary">();
	}
	static class UUMGBPFLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBPFLibrary>();
	}
};
static_assert(alignof(UUMGBPFLibrary) == 0x000008, "Wrong alignment on UUMGBPFLibrary");
static_assert(sizeof(UUMGBPFLibrary) == 0x000028, "Wrong size on UUMGBPFLibrary");

// Class Zion.UMGSubsystem
// 0x00F0 (0x0120 - 0x0030)
class UUMGSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FText& Subtitle)> OnSetSubtitle;                       // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0xC8];                                      // 0x0058(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UUMGSubsystem* Get(const class UObject* WorldContextObject);

	void ClearActiveFooter();
	void LockNavigation(class UUserWidget* LockSource);
	void RefreshNavigationLockState();
	void RemapKey(EUIInputType UIInputType, const struct FKey& Key);
	void ResetNavigationLocks();
	void RestoreDefaultBindings(bool bGamepad);
	void SetActiveExplanationWidget(class UUserWidgetExplanation* ExplanationWidget);
	void SetActiveFooter(class UUserWidgetFooter* Footer);
	void UnlockNavigation(class UUserWidget* LockSource);

	class UUserWidgetExplanation* GetActiveExplanationWidget() const;
	class UUserWidgetFooter* GetActiveFooter() const;
	bool IsFocusingFromMouse() const;
	bool IsNavigationLocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSubsystem">();
	}
	static class UUMGSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSubsystem>();
	}
};
static_assert(alignof(UUMGSubsystem) == 0x000008, "Wrong alignment on UUMGSubsystem");
static_assert(sizeof(UUMGSubsystem) == 0x000120, "Wrong size on UUMGSubsystem");
static_assert(offsetof(UUMGSubsystem, OnSetSubtitle) == 0x000048, "Member 'UUMGSubsystem::OnSetSubtitle' has a wrong offset!");

// Class Zion.UniformGridPanelZion
// 0x0010 (0x01C8 - 0x01B8)
class UUniformGridPanelZion final : public UUniformGridPanel
{
public:
	EOrientation                                  Orientation;                                       // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ElementCountPerRow;                                // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHorizontalAlignment                          ContentHorizontalAlignment;                        // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EVerticalAlignment                            ContentVerticalAlignment;                          // 0x01C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C2[0x6];                                      // 0x01C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddChildAuto(class UWidget* Content);

	int32 GetElementCountPerRow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniformGridPanelZion">();
	}
	static class UUniformGridPanelZion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUniformGridPanelZion>();
	}
};
static_assert(alignof(UUniformGridPanelZion) == 0x000008, "Wrong alignment on UUniformGridPanelZion");
static_assert(sizeof(UUniformGridPanelZion) == 0x0001C8, "Wrong size on UUniformGridPanelZion");
static_assert(offsetof(UUniformGridPanelZion, Orientation) == 0x0001B8, "Member 'UUniformGridPanelZion::Orientation' has a wrong offset!");
static_assert(offsetof(UUniformGridPanelZion, ElementCountPerRow) == 0x0001BC, "Member 'UUniformGridPanelZion::ElementCountPerRow' has a wrong offset!");
static_assert(offsetof(UUniformGridPanelZion, ContentHorizontalAlignment) == 0x0001C0, "Member 'UUniformGridPanelZion::ContentHorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UUniformGridPanelZion, ContentVerticalAlignment) == 0x0001C1, "Member 'UUniformGridPanelZion::ContentVerticalAlignment' has a wrong offset!");

// Class Zion.UserWidgetAchievementNotificationHolder
// 0x0018 (0x0478 - 0x0460)
class UUserWidgetAchievementNotificationHolder final : public UUserWidgetZion
{
public:
	bool                                          bIsProcessing;                                     // 0x0460(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AchievementsQueue;                                 // 0x0468(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void LaunchNextNotification();
	void OnDisplayAchievementNotificationsChanged();
	void OnLaunchAchievementNotification(const class FName& AchievementID);
	void OnRefreshVisibility(bool bVisible);
	void QueueAchievementNotification(const class FName& AchievementID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetAchievementNotificationHolder">();
	}
	static class UUserWidgetAchievementNotificationHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetAchievementNotificationHolder>();
	}
};
static_assert(alignof(UUserWidgetAchievementNotificationHolder) == 0x000008, "Wrong alignment on UUserWidgetAchievementNotificationHolder");
static_assert(sizeof(UUserWidgetAchievementNotificationHolder) == 0x000478, "Wrong size on UUserWidgetAchievementNotificationHolder");
static_assert(offsetof(UUserWidgetAchievementNotificationHolder, bIsProcessing) == 0x000460, "Member 'UUserWidgetAchievementNotificationHolder::bIsProcessing' has a wrong offset!");
static_assert(offsetof(UUserWidgetAchievementNotificationHolder, AchievementsQueue) == 0x000468, "Member 'UUserWidgetAchievementNotificationHolder::AchievementsQueue' has a wrong offset!");

// Class Zion.UserWidgetButton
// 0x0020 (0x0480 - 0x0460)
class UUserWidgetButton : public UUserWidgetZion
{
public:
	TMulticastInlineDelegate<void(class UUserWidgetButton* Button)> OnFocused;                       // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FKeyEvent& KeyEvent, class UUserWidgetButton* Button)> OnPressedConfirm; // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnFocusStateChanged(bool bFocused);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetButton">();
	}
	static class UUserWidgetButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetButton>();
	}
};
static_assert(alignof(UUserWidgetButton) == 0x000008, "Wrong alignment on UUserWidgetButton");
static_assert(sizeof(UUserWidgetButton) == 0x000480, "Wrong size on UUserWidgetButton");
static_assert(offsetof(UUserWidgetButton, OnFocused) == 0x000460, "Member 'UUserWidgetButton::OnFocused' has a wrong offset!");
static_assert(offsetof(UUserWidgetButton, OnPressedConfirm) == 0x000470, "Member 'UUserWidgetButton::OnPressedConfirm' has a wrong offset!");

// Class Zion.UserWidgetCurrencyCounter
// 0x00D0 (0x0530 - 0x0460)
class UUserWidgetCurrencyCounter : public UUserWidgetZion
{
public:
	ECurrencyType                                 CurrencyType;                                      // 0x0460(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_461[0x3];                                      // 0x0461(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AccumulatingCurrencyDuration;                      // 0x0464(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     AddingCurrencyDurationCurve;                       // 0x0468(0x0088)(Edit, NativeAccessSpecifierPrivate)
	float                                         WaitingDuration;                                   // 0x04F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F4[0x3C];                                     // 0x04F4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AccumulatingCurrencyTimerFinished();
	void AddCurrency(const ECurrencyType& InCurrencyType, const int32 AddedCount, const int32 PreviousCount);
	void Hide();
	void OnAccumulatingCurrencyTimerFinished();
	void OnHide();
	void OnSetAccumulatedCurrencyText(const int32 Currency);
	void OnSetCurrencyText(const int32 Currency);
	void OnShow();
	void OnStartAccumulatingCurrency();
	void SetAccumulatedCurrencyText(const int32 Currency);
	void SetCurrencyText(const int32 Currency);
	void Show(const bool bRefreshCurrencyText);
	void StartAccumulatingCurrency(const int32 InAccumulatedCurrency);
	void StartAddingCurrency();
	void WaitingTimerFinished();

	int32 GetCurrencyFromInventory() const;
	ECurrencyType GetCurrencyType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetCurrencyCounter">();
	}
	static class UUserWidgetCurrencyCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetCurrencyCounter>();
	}
};
static_assert(alignof(UUserWidgetCurrencyCounter) == 0x000008, "Wrong alignment on UUserWidgetCurrencyCounter");
static_assert(sizeof(UUserWidgetCurrencyCounter) == 0x000530, "Wrong size on UUserWidgetCurrencyCounter");
static_assert(offsetof(UUserWidgetCurrencyCounter, CurrencyType) == 0x000460, "Member 'UUserWidgetCurrencyCounter::CurrencyType' has a wrong offset!");
static_assert(offsetof(UUserWidgetCurrencyCounter, AccumulatingCurrencyDuration) == 0x000464, "Member 'UUserWidgetCurrencyCounter::AccumulatingCurrencyDuration' has a wrong offset!");
static_assert(offsetof(UUserWidgetCurrencyCounter, AddingCurrencyDurationCurve) == 0x000468, "Member 'UUserWidgetCurrencyCounter::AddingCurrencyDurationCurve' has a wrong offset!");
static_assert(offsetof(UUserWidgetCurrencyCounter, WaitingDuration) == 0x0004F0, "Member 'UUserWidgetCurrencyCounter::WaitingDuration' has a wrong offset!");

// Class Zion.UserWidgetCursor
// 0x0010 (0x02F0 - 0x02E0)
class UUserWidgetCursor : public UUserWidget
{
public:
	class UScaleBox*                              DPIScaler;                                         // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCursorVisibilityChanged();
	void SetVisible(bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetCursor">();
	}
	static class UUserWidgetCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetCursor>();
	}
};
static_assert(alignof(UUserWidgetCursor) == 0x000008, "Wrong alignment on UUserWidgetCursor");
static_assert(sizeof(UUserWidgetCursor) == 0x0002F0, "Wrong size on UUserWidgetCursor");
static_assert(offsetof(UUserWidgetCursor, DPIScaler) == 0x0002E0, "Member 'UUserWidgetCursor::DPIScaler' has a wrong offset!");

// Class Zion.UserWidgetDialogOk
// 0x0030 (0x0490 - 0x0460)
class UUserWidgetDialogOk : public UUserWidgetZion
{
public:
	TMulticastInlineDelegate<void()>              OnOK;                                              // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class FText                                   Message;                                           // 0x0470(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	class FText                                   ButtonOK;                                          // 0x0480(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetDialogOk">();
	}
	static class UUserWidgetDialogOk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetDialogOk>();
	}
};
static_assert(alignof(UUserWidgetDialogOk) == 0x000008, "Wrong alignment on UUserWidgetDialogOk");
static_assert(sizeof(UUserWidgetDialogOk) == 0x000490, "Wrong size on UUserWidgetDialogOk");
static_assert(offsetof(UUserWidgetDialogOk, OnOK) == 0x000460, "Member 'UUserWidgetDialogOk::OnOK' has a wrong offset!");
static_assert(offsetof(UUserWidgetDialogOk, Message) == 0x000470, "Member 'UUserWidgetDialogOk::Message' has a wrong offset!");
static_assert(offsetof(UUserWidgetDialogOk, ButtonOK) == 0x000480, "Member 'UUserWidgetDialogOk::ButtonOK' has a wrong offset!");

// Class Zion.UserWidgetDialogYesNo
// 0x0050 (0x04B0 - 0x0460)
class UUserWidgetDialogYesNo : public UUserWidgetZion
{
public:
	TMulticastInlineDelegate<void()>              OnYES;                                             // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnNO;                                              // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class FText                                   Message;                                           // 0x0480(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	class FText                                   ButtonYES;                                         // 0x0490(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	class FText                                   ButtonNO;                                          // 0x04A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetDialogYesNo">();
	}
	static class UUserWidgetDialogYesNo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetDialogYesNo>();
	}
};
static_assert(alignof(UUserWidgetDialogYesNo) == 0x000008, "Wrong alignment on UUserWidgetDialogYesNo");
static_assert(sizeof(UUserWidgetDialogYesNo) == 0x0004B0, "Wrong size on UUserWidgetDialogYesNo");
static_assert(offsetof(UUserWidgetDialogYesNo, OnYES) == 0x000460, "Member 'UUserWidgetDialogYesNo::OnYES' has a wrong offset!");
static_assert(offsetof(UUserWidgetDialogYesNo, OnNO) == 0x000470, "Member 'UUserWidgetDialogYesNo::OnNO' has a wrong offset!");
static_assert(offsetof(UUserWidgetDialogYesNo, Message) == 0x000480, "Member 'UUserWidgetDialogYesNo::Message' has a wrong offset!");
static_assert(offsetof(UUserWidgetDialogYesNo, ButtonYES) == 0x000490, "Member 'UUserWidgetDialogYesNo::ButtonYES' has a wrong offset!");
static_assert(offsetof(UUserWidgetDialogYesNo, ButtonNO) == 0x0004A0, "Member 'UUserWidgetDialogYesNo::ButtonNO' has a wrong offset!");

// Class Zion.UserWidgetEnemyUI
// 0x0140 (0x05A0 - 0x0460)
class UUserWidgetEnemyUI : public UUserWidgetZion
{
public:
	uint8                                         Pad_460[0x140];                                    // 0x0460(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRequestRemoveFromParent(bool bImmediate);

	class AAIController* GetController() const;
	const struct FEnemyData GetEnemyData() const;
	class APawn* GetPawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetEnemyUI">();
	}
	static class UUserWidgetEnemyUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetEnemyUI>();
	}
};
static_assert(alignof(UUserWidgetEnemyUI) == 0x000008, "Wrong alignment on UUserWidgetEnemyUI");
static_assert(sizeof(UUserWidgetEnemyUI) == 0x0005A0, "Wrong size on UUserWidgetEnemyUI");

// Class Zion.UserWidgetExplanation
// 0x0008 (0x0468 - 0x0460)
class UUserWidgetExplanation : public UUserWidgetZion
{
public:
	class URefreshableRichTextBlock*              RefreshableRichTextBlock;                          // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetExplanationText(const class FText& Text, const TArray<struct FRichTextInputElement>& InputElements, const TArray<class FString>& StringElements);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetExplanation">();
	}
	static class UUserWidgetExplanation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetExplanation>();
	}
};
static_assert(alignof(UUserWidgetExplanation) == 0x000008, "Wrong alignment on UUserWidgetExplanation");
static_assert(sizeof(UUserWidgetExplanation) == 0x000468, "Wrong size on UUserWidgetExplanation");
static_assert(offsetof(UUserWidgetExplanation, RefreshableRichTextBlock) == 0x000460, "Member 'UUserWidgetExplanation::RefreshableRichTextBlock' has a wrong offset!");

// Class Zion.UserWidgetExtraDialogGalleryImage
// 0x00B0 (0x0510 - 0x0460)
class UUserWidgetExtraDialogGalleryImage : public UUserWidgetZion
{
public:
	class UImageZion*                             GalleryImage;                                      // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MouseMoveSpeed;                                    // 0x0468(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveSpeed;                                         // 0x0478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              XMinMax;                                           // 0x0480(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              YMinMax;                                           // 0x0490(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x70];                                     // 0x04A0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void ClearInputs();
	void MoveImage(const struct FVector2D& InMoveDelta);
	void PlaceImage(const struct FVector2D& NewImagePosition);
	void SetupImageMinMaxPositions();

	float GetCurrentScaleFactor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetExtraDialogGalleryImage">();
	}
	static class UUserWidgetExtraDialogGalleryImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetExtraDialogGalleryImage>();
	}
};
static_assert(alignof(UUserWidgetExtraDialogGalleryImage) == 0x000008, "Wrong alignment on UUserWidgetExtraDialogGalleryImage");
static_assert(sizeof(UUserWidgetExtraDialogGalleryImage) == 0x000510, "Wrong size on UUserWidgetExtraDialogGalleryImage");
static_assert(offsetof(UUserWidgetExtraDialogGalleryImage, GalleryImage) == 0x000460, "Member 'UUserWidgetExtraDialogGalleryImage::GalleryImage' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogGalleryImage, MouseMoveSpeed) == 0x000468, "Member 'UUserWidgetExtraDialogGalleryImage::MouseMoveSpeed' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogGalleryImage, MoveSpeed) == 0x000478, "Member 'UUserWidgetExtraDialogGalleryImage::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogGalleryImage, XMinMax) == 0x000480, "Member 'UUserWidgetExtraDialogGalleryImage::XMinMax' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogGalleryImage, YMinMax) == 0x000490, "Member 'UUserWidgetExtraDialogGalleryImage::YMinMax' has a wrong offset!");

// Class Zion.UserWidgetExtraDialogSpineViewer
// 0x0378 (0x07D8 - 0x0460)
class UUserWidgetExtraDialogSpineViewer : public UUserWidgetZion
{
public:
	class UOverlay*                               SpineViewerLocationContainer;                      // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               SceneContainer;                                    // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpineWidget*                           SpineWidget;                                       // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanChangeCharacter;                               // 0x0478(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryItemGenericInfoData          CharacterItemData;                                 // 0x0480(0x0238)(Edit, BlueprintVisible, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DefaultNormalBlendMaterial;                        // 0x06B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DefaultScreenBlendMaterial;                        // 0x06C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C8[0x38];                                     // 0x06C8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MouseMoveSpeed;                                    // 0x0700(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveSpeed;                                         // 0x0710(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_714[0x4];                                      // 0x0714(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DefaultXMinMax;                                    // 0x0718(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              DefaultYMinMax;                                    // 0x0728(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              XMinMax;                                           // 0x0738(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              YMinMax;                                           // 0x0748(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              SpineViewerCurrentLocation;                        // 0x0758(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_768[0x70];                                     // 0x0768(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearInputs();
	void ClearSpineAnimation();
	void HandleFocusAfterMouseClick();
	void OnAfterUpdateWorldTransform(class USpineWidget* Skeleton);
	void OnSpineAnimationFinished(class UTrackEntry* TrackEntry);
	void PlayAdditionalAnimations(const TArray<class FString>& AdditionalAnimations);
	void PlaySpineAnimation(const struct FAnimationNameData& AnimationNameData, EExtraAnimationRootMotionMode RootMotionMode);
	void ReplaceSpineMaterials();
	void ResetSpineViewerToDefaultLocation();
	void SetupMinMaxPositions(float MinScaleFactor);

	bool CanMoveSpineViewer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetExtraDialogSpineViewer">();
	}
	static class UUserWidgetExtraDialogSpineViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetExtraDialogSpineViewer>();
	}
};
static_assert(alignof(UUserWidgetExtraDialogSpineViewer) == 0x000008, "Wrong alignment on UUserWidgetExtraDialogSpineViewer");
static_assert(sizeof(UUserWidgetExtraDialogSpineViewer) == 0x0007D8, "Wrong size on UUserWidgetExtraDialogSpineViewer");
static_assert(offsetof(UUserWidgetExtraDialogSpineViewer, SpineViewerLocationContainer) == 0x000460, "Member 'UUserWidgetExtraDialogSpineViewer::SpineViewerLocationContainer' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogSpineViewer, SceneContainer) == 0x000468, "Member 'UUserWidgetExtraDialogSpineViewer::SceneContainer' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogSpineViewer, SpineWidget) == 0x000470, "Member 'UUserWidgetExtraDialogSpineViewer::SpineWidget' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogSpineViewer, bCanChangeCharacter) == 0x000478, "Member 'UUserWidgetExtraDialogSpineViewer::bCanChangeCharacter' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogSpineViewer, CharacterItemData) == 0x000480, "Member 'UUserWidgetExtraDialogSpineViewer::CharacterItemData' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogSpineViewer, DefaultNormalBlendMaterial) == 0x0006B8, "Member 'UUserWidgetExtraDialogSpineViewer::DefaultNormalBlendMaterial' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogSpineViewer, DefaultScreenBlendMaterial) == 0x0006C0, "Member 'UUserWidgetExtraDialogSpineViewer::DefaultScreenBlendMaterial' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogSpineViewer, MouseMoveSpeed) == 0x000700, "Member 'UUserWidgetExtraDialogSpineViewer::MouseMoveSpeed' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogSpineViewer, MoveSpeed) == 0x000710, "Member 'UUserWidgetExtraDialogSpineViewer::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogSpineViewer, DefaultXMinMax) == 0x000718, "Member 'UUserWidgetExtraDialogSpineViewer::DefaultXMinMax' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogSpineViewer, DefaultYMinMax) == 0x000728, "Member 'UUserWidgetExtraDialogSpineViewer::DefaultYMinMax' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogSpineViewer, XMinMax) == 0x000738, "Member 'UUserWidgetExtraDialogSpineViewer::XMinMax' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogSpineViewer, YMinMax) == 0x000748, "Member 'UUserWidgetExtraDialogSpineViewer::YMinMax' has a wrong offset!");
static_assert(offsetof(UUserWidgetExtraDialogSpineViewer, SpineViewerCurrentLocation) == 0x000758, "Member 'UUserWidgetExtraDialogSpineViewer::SpineViewerCurrentLocation' has a wrong offset!");

// Class Zion.UserWidgetFade
// 0x0038 (0x0498 - 0x0460)
class UUserWidgetFade : public UUserWidgetZion
{
public:
	uint8                                         Pad_460[0x38];                                     // 0x0460(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LaunchFadeIn(const struct FFadeParameters& FadeParameters);
	void LaunchFadeOut(const struct FFadeParameters& FadeParameters);
	void NotifyFadeInFinished();
	void NotifyFadeOutFinished();
	void SetupFadeIn(const struct FFadeParameters& FadeParameters);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetFade">();
	}
	static class UUserWidgetFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetFade>();
	}
};
static_assert(alignof(UUserWidgetFade) == 0x000008, "Wrong alignment on UUserWidgetFade");
static_assert(sizeof(UUserWidgetFade) == 0x000498, "Wrong size on UUserWidgetFade");

// Class Zion.UserWidgetFieldTalkHolder
// 0x0008 (0x0468 - 0x0460)
class UUserWidgetFieldTalkHolder : public UUserWidgetZion
{
public:
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishFieldTalk(bool bSkipActiveFieldTalk);
	void OnLaunchFieldTalk();
	void OnShowText(const struct FFieldTalkEntry& FieldTalkEntry);

	bool IsUIReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetFieldTalkHolder">();
	}
	static class UUserWidgetFieldTalkHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetFieldTalkHolder>();
	}
};
static_assert(alignof(UUserWidgetFieldTalkHolder) == 0x000008, "Wrong alignment on UUserWidgetFieldTalkHolder");
static_assert(sizeof(UUserWidgetFieldTalkHolder) == 0x000468, "Wrong size on UUserWidgetFieldTalkHolder");

// Class Zion.UserWidgetFooter
// 0x0000 (0x0460 - 0x0460)
class UUserWidgetFooter : public UUserWidgetZion
{
public:
	void AddEntries(const TArray<struct FFooterData>& FooterDataList, bool bTemporary);
	void AddEntry(const struct FFooterData& FooterData, bool bTemporary);
	void ClearEntries(bool bTemporaryOnly);
	void SetEntriesVisible(bool bVisible);
	void Setup(const TArray<struct FFooterData>& FooterDataList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetFooter">();
	}
	static class UUserWidgetFooter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetFooter>();
	}
};
static_assert(alignof(UUserWidgetFooter) == 0x000008, "Wrong alignment on UUserWidgetFooter");
static_assert(sizeof(UUserWidgetFooter) == 0x000460, "Wrong size on UUserWidgetFooter");

// Class Zion.UserWidgetGameMenu
// 0x0028 (0x0488 - 0x0460)
class UUserWidgetGameMenu : public UUserWidgetZion
{
public:
	class UWidgetSwitcher*                        PageSwitcher;                                      // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAtRestPoint;                                      // 0x0468(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowEquipmentSwitch;                             // 0x0469(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46A[0x6];                                      // 0x046A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameMenuPageData>              PageDataList;                                      // 0x0470(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x8];                                      // 0x0480(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GoToPage(int32 PageIndex);
	void NotifyFastTravelRequested(const class FName& RestPointID, const struct FRestPointData& RestPointData);
	void OnFastTravelRequested(const class FName& RestPointID, const struct FRestPointData& RestPointData);
	void OnPageChanged(int32 NewPageIndex);

	bool CanSwitchEquipment() const;
	int32 GetCurrentPageIndex() const;
	class UUserWidgetFooter* GetFooter() const;
	int32 GetPageCount() const;
	bool IsAtRestPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetGameMenu">();
	}
	static class UUserWidgetGameMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetGameMenu>();
	}
};
static_assert(alignof(UUserWidgetGameMenu) == 0x000008, "Wrong alignment on UUserWidgetGameMenu");
static_assert(sizeof(UUserWidgetGameMenu) == 0x000488, "Wrong size on UUserWidgetGameMenu");
static_assert(offsetof(UUserWidgetGameMenu, PageSwitcher) == 0x000460, "Member 'UUserWidgetGameMenu::PageSwitcher' has a wrong offset!");
static_assert(offsetof(UUserWidgetGameMenu, bAtRestPoint) == 0x000468, "Member 'UUserWidgetGameMenu::bAtRestPoint' has a wrong offset!");
static_assert(offsetof(UUserWidgetGameMenu, bAllowEquipmentSwitch) == 0x000469, "Member 'UUserWidgetGameMenu::bAllowEquipmentSwitch' has a wrong offset!");
static_assert(offsetof(UUserWidgetGameMenu, PageDataList) == 0x000470, "Member 'UUserWidgetGameMenu::PageDataList' has a wrong offset!");

// Class Zion.UserWidgetGameMenu_Page
// 0x0018 (0x0478 - 0x0460)
class UUserWidgetGameMenu_Page : public UUserWidgetZion
{
public:
	TArray<struct FFooterData>                    DefaultFooterEntries;                              // 0x0460(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPageClosed();
	void OnPageOpened();

	bool CanSwitchEquipment() const;
	const TArray<struct FFooterData> GetDefaultFooterEntries() const;
	class UUserWidgetFooter* GetFooter() const;
	class UUserWidgetGameMenu* GetGameMenu() const;
	bool IsAtRestPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetGameMenu_Page">();
	}
	static class UUserWidgetGameMenu_Page* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetGameMenu_Page>();
	}
};
static_assert(alignof(UUserWidgetGameMenu_Page) == 0x000008, "Wrong alignment on UUserWidgetGameMenu_Page");
static_assert(sizeof(UUserWidgetGameMenu_Page) == 0x000478, "Wrong size on UUserWidgetGameMenu_Page");
static_assert(offsetof(UUserWidgetGameMenu_Page, DefaultFooterEntries) == 0x000460, "Member 'UUserWidgetGameMenu_Page::DefaultFooterEntries' has a wrong offset!");

// Class Zion.UserWidgetItemGet
// 0x0018 (0x0478 - 0x0460)
class UUserWidgetItemGet : public UUserWidgetZion
{
public:
	struct FDataTableRowHandle                    ItemDataHandle;                                    // 0x0460(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	int32                                         Count;                                             // 0x0470(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetItemGet">();
	}
	static class UUserWidgetItemGet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetItemGet>();
	}
};
static_assert(alignof(UUserWidgetItemGet) == 0x000008, "Wrong alignment on UUserWidgetItemGet");
static_assert(sizeof(UUserWidgetItemGet) == 0x000478, "Wrong size on UUserWidgetItemGet");
static_assert(offsetof(UUserWidgetItemGet, ItemDataHandle) == 0x000460, "Member 'UUserWidgetItemGet::ItemDataHandle' has a wrong offset!");
static_assert(offsetof(UUserWidgetItemGet, Count) == 0x000470, "Member 'UUserWidgetItemGet::Count' has a wrong offset!");

// Class Zion.UserWidgetLowHPFeedback
// 0x0020 (0x0480 - 0x0460)
class UUserWidgetLowHPFeedback : public UUserWidgetZion
{
public:
	class UWidget*                                Visual;                                            // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LerpSpeed;                                         // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x14];                                     // 0x046C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindToActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetLowHPFeedback">();
	}
	static class UUserWidgetLowHPFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetLowHPFeedback>();
	}
};
static_assert(alignof(UUserWidgetLowHPFeedback) == 0x000008, "Wrong alignment on UUserWidgetLowHPFeedback");
static_assert(sizeof(UUserWidgetLowHPFeedback) == 0x000480, "Wrong size on UUserWidgetLowHPFeedback");
static_assert(offsetof(UUserWidgetLowHPFeedback, Visual) == 0x000460, "Member 'UUserWidgetLowHPFeedback::Visual' has a wrong offset!");
static_assert(offsetof(UUserWidgetLowHPFeedback, LerpSpeed) == 0x000468, "Member 'UUserWidgetLowHPFeedback::LerpSpeed' has a wrong offset!");

// Class Zion.UserWidgetMapCursor
// 0x0080 (0x04E0 - 0x0460)
class UUserWidgetMapCursor : public UUserWidgetZion
{
public:
	uint8                                         Pad_460[0x80];                                     // 0x0460(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapCursor">();
	}
	static class UUserWidgetMapCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapCursor>();
	}
};
static_assert(alignof(UUserWidgetMapCursor) == 0x000008, "Wrong alignment on UUserWidgetMapCursor");
static_assert(sizeof(UUserWidgetMapCursor) == 0x0004E0, "Wrong size on UUserWidgetMapCursor");

// Class Zion.UserWidgetMap
// 0x0278 (0x06D8 - 0x0460)
class UUserWidgetMap : public UUserWidgetZion
{
public:
	class URetainerBox*                           RetainerBox;                                       // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              ScaleBox;                                          // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MapHolder;                                         // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MapAreaHolder;                                     // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidgetMapCursor*                   MapCursor;                                         // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidgetMapIcon_Player*              PlayerIcon;                                        // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidgetMapLegend*                   MapLegend;                                         // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidgetRestPointList*               RestPointList;                                     // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidgetPlayerTrail*                 WBP_PlayerTrail;                                   // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           StoryEventIconsHolder;                             // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           StoryEventDirectionsHolder;                        // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MapAreaTransitionsHolder;                          // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CustomMarkerIconsHolder;                           // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowAllMapIcons;                                  // 0x04C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C9[0x3];                                      // 0x04C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseWheelSpeed;                                   // 0x04CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              MouseMoveSpeed;                                    // 0x04D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ZoomSpeed;                                         // 0x04E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ZoomMin;                                           // 0x04E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ZoomDefault;                                       // 0x04E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ZoomMax;                                           // 0x04EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HideIconsZoomThreshold;                            // 0x04F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ZoomScaledIconsScaleMin;                           // 0x04F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ZoomScaledIconsScaleMax;                           // 0x04F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveSpeed;                                         // 0x04FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<float>                                 MoveSpeedFactors;                                  // 0x0500(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         MoveSpeedFactorRampUpDuration;                     // 0x0510(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveSpeedFactorRampUpTime;                         // 0x0514(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              XMinMax;                                           // 0x0518(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              YMinMax;                                           // 0x0528(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CompletionPercentage;                              // 0x0538(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StickToIconBlendSpeed;                             // 0x053C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   WidgetStoryEventIconClass;                         // 0x0540(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   WidgetStoryEventDirectionClass;                    // 0x0568(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              WidgetStoryEventDirectionShowOffset;               // 0x0590(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A0[0x38];                                     // 0x05A0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUserWidgetMapArea*>             MapAreaWidgets;                                    // 0x05D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UUserWidgetMapTransition*>       CachedMapAreaTransitionWidgets;                    // 0x05E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x88];                                     // 0x05F8(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWidgetMapStoryEventDirectionData> StoryEventsWithDirections;                      // 0x0680(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UUserWidgetMapIcon_CustomMarker*> CustomMarkerWidgets;                              // 0x0690(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         RemoveAllCustomMarkersHoldDuration;                // 0x06A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A4[0x34];                                     // 0x06A4(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void ClearInputs();
	void DebugMarkAllMapIconsAsSeen();
	void DebugMarkAllMapZonesAsVisited();
	void ForceTargetIcon(class UUserWidgetMapIcon* Icon);
	void MoveMap(const struct FVector2D& InMoveDelta);
	void OnCalculateMapCompletionPercentage(int32 Percentage);
	void OnChangeMapAreaUnderCursor(class UUserWidgetMapArea* MapArea);
	void OnNoCustomMarkerAvailable();
	void OnReachedTargetedIcon(class UUserWidgetMapIcon* MapIcon);
	void OnRefreshCustomMarkerAvailableCount();
	void OnRefreshRemoveAllCustomMarkersHoldTime(float CurrentHoldingTime, float HoldingDuration, float Alpha);
	void OnResetMapAreaUnderCursor(class UUserWidgetMapArea* MapArea);
	void OnResetTargetedIcon(class UUserWidgetMapIcon* MapIcon, bool bInstant);
	void OnRestPointListInitialized();
	void OnToggleRestPointList(bool bRestPointListOpened, bool bInstant);
	void RemoveCustomMarkerUnderCursor(class UUserWidgetMapIcon_CustomMarker* CustomMarkerIcon);
	void SetNewZoomScale(float NewZoomScale);
	void ShowAllMapIcons();
	void Zoom(float InZoomDelta);

	int32 GetCustomMarkerAvailableCount() const;
	int32 GetMapCompletionPercentage() const;
	bool HasValidData() const;
	bool IsMapAreaVisited(const class UUserWidgetMapArea* MapAreaWidget) const;
	bool IsRestPointListOpened() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMap">();
	}
	static class UUserWidgetMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMap>();
	}
};
static_assert(alignof(UUserWidgetMap) == 0x000008, "Wrong alignment on UUserWidgetMap");
static_assert(sizeof(UUserWidgetMap) == 0x0006D8, "Wrong size on UUserWidgetMap");
static_assert(offsetof(UUserWidgetMap, RetainerBox) == 0x000460, "Member 'UUserWidgetMap::RetainerBox' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, ScaleBox) == 0x000468, "Member 'UUserWidgetMap::ScaleBox' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, MapHolder) == 0x000470, "Member 'UUserWidgetMap::MapHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, MapAreaHolder) == 0x000478, "Member 'UUserWidgetMap::MapAreaHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, MapCursor) == 0x000480, "Member 'UUserWidgetMap::MapCursor' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, PlayerIcon) == 0x000488, "Member 'UUserWidgetMap::PlayerIcon' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, MapLegend) == 0x000490, "Member 'UUserWidgetMap::MapLegend' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, RestPointList) == 0x000498, "Member 'UUserWidgetMap::RestPointList' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, WBP_PlayerTrail) == 0x0004A0, "Member 'UUserWidgetMap::WBP_PlayerTrail' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, StoryEventIconsHolder) == 0x0004A8, "Member 'UUserWidgetMap::StoryEventIconsHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, StoryEventDirectionsHolder) == 0x0004B0, "Member 'UUserWidgetMap::StoryEventDirectionsHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, MapAreaTransitionsHolder) == 0x0004B8, "Member 'UUserWidgetMap::MapAreaTransitionsHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, CustomMarkerIconsHolder) == 0x0004C0, "Member 'UUserWidgetMap::CustomMarkerIconsHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, bShowAllMapIcons) == 0x0004C8, "Member 'UUserWidgetMap::bShowAllMapIcons' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, MouseWheelSpeed) == 0x0004CC, "Member 'UUserWidgetMap::MouseWheelSpeed' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, MouseMoveSpeed) == 0x0004D0, "Member 'UUserWidgetMap::MouseMoveSpeed' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, ZoomSpeed) == 0x0004E0, "Member 'UUserWidgetMap::ZoomSpeed' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, ZoomMin) == 0x0004E4, "Member 'UUserWidgetMap::ZoomMin' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, ZoomDefault) == 0x0004E8, "Member 'UUserWidgetMap::ZoomDefault' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, ZoomMax) == 0x0004EC, "Member 'UUserWidgetMap::ZoomMax' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, HideIconsZoomThreshold) == 0x0004F0, "Member 'UUserWidgetMap::HideIconsZoomThreshold' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, ZoomScaledIconsScaleMin) == 0x0004F4, "Member 'UUserWidgetMap::ZoomScaledIconsScaleMin' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, ZoomScaledIconsScaleMax) == 0x0004F8, "Member 'UUserWidgetMap::ZoomScaledIconsScaleMax' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, MoveSpeed) == 0x0004FC, "Member 'UUserWidgetMap::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, MoveSpeedFactors) == 0x000500, "Member 'UUserWidgetMap::MoveSpeedFactors' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, MoveSpeedFactorRampUpDuration) == 0x000510, "Member 'UUserWidgetMap::MoveSpeedFactorRampUpDuration' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, MoveSpeedFactorRampUpTime) == 0x000514, "Member 'UUserWidgetMap::MoveSpeedFactorRampUpTime' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, XMinMax) == 0x000518, "Member 'UUserWidgetMap::XMinMax' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, YMinMax) == 0x000528, "Member 'UUserWidgetMap::YMinMax' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, CompletionPercentage) == 0x000538, "Member 'UUserWidgetMap::CompletionPercentage' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, StickToIconBlendSpeed) == 0x00053C, "Member 'UUserWidgetMap::StickToIconBlendSpeed' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, WidgetStoryEventIconClass) == 0x000540, "Member 'UUserWidgetMap::WidgetStoryEventIconClass' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, WidgetStoryEventDirectionClass) == 0x000568, "Member 'UUserWidgetMap::WidgetStoryEventDirectionClass' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, WidgetStoryEventDirectionShowOffset) == 0x000590, "Member 'UUserWidgetMap::WidgetStoryEventDirectionShowOffset' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, MapAreaWidgets) == 0x0005D8, "Member 'UUserWidgetMap::MapAreaWidgets' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, CachedMapAreaTransitionWidgets) == 0x0005E8, "Member 'UUserWidgetMap::CachedMapAreaTransitionWidgets' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, StoryEventsWithDirections) == 0x000680, "Member 'UUserWidgetMap::StoryEventsWithDirections' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, CustomMarkerWidgets) == 0x000690, "Member 'UUserWidgetMap::CustomMarkerWidgets' has a wrong offset!");
static_assert(offsetof(UUserWidgetMap, RemoveAllCustomMarkersHoldDuration) == 0x0006A0, "Member 'UUserWidgetMap::RemoveAllCustomMarkersHoldDuration' has a wrong offset!");

// Class Zion.UserWidgetMapIconDetails
// 0x0010 (0x0470 - 0x0460)
class UUserWidgetMapIconDetails : public UUserWidgetZion
{
public:
	class UUserWidgetMapIcon*                     WidgetMapIcon;                                     // 0x0460(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRestPointListOpened;                            // 0x0468(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_469[0x7];                                      // 0x0469(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRemoveIconDetails(bool bInstant);
	void OnShowIconDetails();
	void RemoveIconDetails(bool bInstant);
	bool SetIsRestPointListOpened(bool bIsOpened);
	void ShowIconDetails();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapIconDetails">();
	}
	static class UUserWidgetMapIconDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapIconDetails>();
	}
};
static_assert(alignof(UUserWidgetMapIconDetails) == 0x000008, "Wrong alignment on UUserWidgetMapIconDetails");
static_assert(sizeof(UUserWidgetMapIconDetails) == 0x000470, "Wrong size on UUserWidgetMapIconDetails");
static_assert(offsetof(UUserWidgetMapIconDetails, WidgetMapIcon) == 0x000460, "Member 'UUserWidgetMapIconDetails::WidgetMapIcon' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIconDetails, bIsRestPointListOpened) == 0x000468, "Member 'UUserWidgetMapIconDetails::bIsRestPointListOpened' has a wrong offset!");

// Class Zion.UserWidgetMapIcon
// 0x0128 (0x0588 - 0x0460)
class UUserWidgetMapIcon : public UUserWidgetZion
{
public:
	class UImage*                                 Icon;                                              // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidgetMapArea*                     ParentMapArea;                                     // 0x0468(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUserWidgetMapIcon*>             DependentIcons;                                    // 0x0470(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FAnchors                               CanvasAnchors;                                     // 0x0480(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              CanvasAlignment;                                   // 0x04A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMapIconGenerationType                        GenerationType;                                    // 0x04B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseIconLocationOffset;                            // 0x04B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B2[0x6];                                      // 0x04B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              IconLocationOffset;                                // 0x04B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseIconLocationLocalOffset;                       // 0x04C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C9[0x7];                                      // 0x04C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              IconLocationLocalOffset;                           // 0x04D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseIconAngleOffset;                               // 0x04E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E1[0x3];                                      // 0x04E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IconAngleOffset;                                   // 0x04E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidgetMapIconDetails>  WidgetMapIconDetails_Class;                        // 0x04E8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   IconDisplayName;                                   // 0x04F0(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	EMapIconType                                  IconType;                                          // 0x0500(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireAptitude;                                  // 0x0501(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAptitudeType                                 AptitudeRequired;                                  // 0x0502(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireGameplayCondition;                         // 0x0503(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_504[0x4];                                      // 0x0504(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPaperSprite>            ConditionNotSatisfiedIcon;                         // 0x0508(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UPaperSprite>            ConditionSatisfiedIcon;                            // 0x0530(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayConditionChecker              ConditionChecker;                                  // 0x0558(0x0018)(Edit, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_570[0x18];                                     // 0x0570(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideIcon();
	void OnAptitudesChanged();
	void OnItemAdded(const class UInventory* Inventory, const class FName& ItemId, int32 AddedCount);
	void SetIconFromSoftSprite(TSoftObjectPtr<class UPaperSprite> NewIcon, bool bMatchSize);
	void ShowIcon();

	EAptitudeType GetAptitudeRequired() const;
	TArray<struct FDataTableRowHandle> GetItemsRequired() const;
	EMapIconType GetMapIconType() const;
	TSubclassOf<class UUserWidgetMapIconDetails> GetWidgetIconDetailsClass() const;
	class FText GetWidgetIconDisplayName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapIcon">();
	}
	static class UUserWidgetMapIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapIcon>();
	}
};
static_assert(alignof(UUserWidgetMapIcon) == 0x000008, "Wrong alignment on UUserWidgetMapIcon");
static_assert(sizeof(UUserWidgetMapIcon) == 0x000588, "Wrong size on UUserWidgetMapIcon");
static_assert(offsetof(UUserWidgetMapIcon, Icon) == 0x000460, "Member 'UUserWidgetMapIcon::Icon' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, ParentMapArea) == 0x000468, "Member 'UUserWidgetMapIcon::ParentMapArea' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, DependentIcons) == 0x000470, "Member 'UUserWidgetMapIcon::DependentIcons' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, CanvasAnchors) == 0x000480, "Member 'UUserWidgetMapIcon::CanvasAnchors' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, CanvasAlignment) == 0x0004A0, "Member 'UUserWidgetMapIcon::CanvasAlignment' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, GenerationType) == 0x0004B0, "Member 'UUserWidgetMapIcon::GenerationType' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, bUseIconLocationOffset) == 0x0004B1, "Member 'UUserWidgetMapIcon::bUseIconLocationOffset' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, IconLocationOffset) == 0x0004B8, "Member 'UUserWidgetMapIcon::IconLocationOffset' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, bUseIconLocationLocalOffset) == 0x0004C8, "Member 'UUserWidgetMapIcon::bUseIconLocationLocalOffset' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, IconLocationLocalOffset) == 0x0004D0, "Member 'UUserWidgetMapIcon::IconLocationLocalOffset' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, bUseIconAngleOffset) == 0x0004E0, "Member 'UUserWidgetMapIcon::bUseIconAngleOffset' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, IconAngleOffset) == 0x0004E4, "Member 'UUserWidgetMapIcon::IconAngleOffset' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, WidgetMapIconDetails_Class) == 0x0004E8, "Member 'UUserWidgetMapIcon::WidgetMapIconDetails_Class' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, IconDisplayName) == 0x0004F0, "Member 'UUserWidgetMapIcon::IconDisplayName' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, IconType) == 0x000500, "Member 'UUserWidgetMapIcon::IconType' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, bRequireAptitude) == 0x000501, "Member 'UUserWidgetMapIcon::bRequireAptitude' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, AptitudeRequired) == 0x000502, "Member 'UUserWidgetMapIcon::AptitudeRequired' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, bRequireGameplayCondition) == 0x000503, "Member 'UUserWidgetMapIcon::bRequireGameplayCondition' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, ConditionNotSatisfiedIcon) == 0x000508, "Member 'UUserWidgetMapIcon::ConditionNotSatisfiedIcon' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, ConditionSatisfiedIcon) == 0x000530, "Member 'UUserWidgetMapIcon::ConditionSatisfiedIcon' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon, ConditionChecker) == 0x000558, "Member 'UUserWidgetMapIcon::ConditionChecker' has a wrong offset!");

// Class Zion.UserWidgetMapIcon_Player
// 0x0000 (0x0588 - 0x0588)
class UUserWidgetMapIcon_Player : public UUserWidgetMapIcon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapIcon_Player">();
	}
	static class UUserWidgetMapIcon_Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapIcon_Player>();
	}
};
static_assert(alignof(UUserWidgetMapIcon_Player) == 0x000008, "Wrong alignment on UUserWidgetMapIcon_Player");
static_assert(sizeof(UUserWidgetMapIcon_Player) == 0x000588, "Wrong size on UUserWidgetMapIcon_Player");

// Class Zion.UserWidgetMapIcon_PlayerTrail
// 0x0000 (0x0588 - 0x0588)
class UUserWidgetMapIcon_PlayerTrail : public UUserWidgetMapIcon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapIcon_PlayerTrail">();
	}
	static class UUserWidgetMapIcon_PlayerTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapIcon_PlayerTrail>();
	}
};
static_assert(alignof(UUserWidgetMapIcon_PlayerTrail) == 0x000008, "Wrong alignment on UUserWidgetMapIcon_PlayerTrail");
static_assert(sizeof(UUserWidgetMapIcon_PlayerTrail) == 0x000588, "Wrong size on UUserWidgetMapIcon_PlayerTrail");

// Class Zion.UserWidgetMapIcon_CustomMarker
// 0x0028 (0x05B0 - 0x0588)
class UUserWidgetMapIcon_CustomMarker : public UUserWidgetMapIcon
{
public:
	struct FMapCustomMarkerIconData               CustomMarkerData;                                  // 0x0588(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSetCustomMarkerData(const struct FMapCustomMarkerIconData& NewCustomMarkerData);
	void OnSetScale(float NewScale);
	void SetScale(float NewScale);

	int32 GetCustomMarkerDisplayID() const;
	const struct FMapCustomMarkerIconData GetCustomMarkerIconData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapIcon_CustomMarker">();
	}
	static class UUserWidgetMapIcon_CustomMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapIcon_CustomMarker>();
	}
};
static_assert(alignof(UUserWidgetMapIcon_CustomMarker) == 0x000008, "Wrong alignment on UUserWidgetMapIcon_CustomMarker");
static_assert(sizeof(UUserWidgetMapIcon_CustomMarker) == 0x0005B0, "Wrong size on UUserWidgetMapIcon_CustomMarker");
static_assert(offsetof(UUserWidgetMapIcon_CustomMarker, CustomMarkerData) == 0x000588, "Member 'UUserWidgetMapIcon_CustomMarker::CustomMarkerData' has a wrong offset!");

// Class Zion.UserWidgetMapIcon_StoryEvent
// 0x0000 (0x0588 - 0x0588)
class UUserWidgetMapIcon_StoryEvent : public UUserWidgetMapIcon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapIcon_StoryEvent">();
	}
	static class UUserWidgetMapIcon_StoryEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapIcon_StoryEvent>();
	}
};
static_assert(alignof(UUserWidgetMapIcon_StoryEvent) == 0x000008, "Wrong alignment on UUserWidgetMapIcon_StoryEvent");
static_assert(sizeof(UUserWidgetMapIcon_StoryEvent) == 0x000588, "Wrong size on UUserWidgetMapIcon_StoryEvent");

// Class Zion.UserWidgetMapIcon_Actor
// 0x0058 (0x05E0 - 0x0588)
class UUserWidgetMapIcon_Actor : public UUserWidgetMapIcon
{
public:
	struct FClearActorData                        ActorData;                                         // 0x0588(0x0010)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideCachedWidgetSize;                         // 0x0598(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_599[0x7];                                      // 0x0599(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CachedWidgetSize;                                  // 0x05A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideClearFogOfWarSize;                        // 0x05B0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B1[0x7];                                      // 0x05B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ClearFogOfWarPositionOffset;                       // 0x05B8(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ClearFogOfWarSizeOverride;                         // 0x05C8(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetActorData(const struct FClearActorData& InActorData);

	const struct FClearActorData GetActorData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapIcon_Actor">();
	}
	static class UUserWidgetMapIcon_Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapIcon_Actor>();
	}
};
static_assert(alignof(UUserWidgetMapIcon_Actor) == 0x000008, "Wrong alignment on UUserWidgetMapIcon_Actor");
static_assert(sizeof(UUserWidgetMapIcon_Actor) == 0x0005E0, "Wrong size on UUserWidgetMapIcon_Actor");
static_assert(offsetof(UUserWidgetMapIcon_Actor, ActorData) == 0x000588, "Member 'UUserWidgetMapIcon_Actor::ActorData' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon_Actor, bOverrideCachedWidgetSize) == 0x000598, "Member 'UUserWidgetMapIcon_Actor::bOverrideCachedWidgetSize' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon_Actor, CachedWidgetSize) == 0x0005A0, "Member 'UUserWidgetMapIcon_Actor::CachedWidgetSize' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon_Actor, bOverrideClearFogOfWarSize) == 0x0005B0, "Member 'UUserWidgetMapIcon_Actor::bOverrideClearFogOfWarSize' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon_Actor, ClearFogOfWarPositionOffset) == 0x0005B8, "Member 'UUserWidgetMapIcon_Actor::ClearFogOfWarPositionOffset' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon_Actor, ClearFogOfWarSizeOverride) == 0x0005C8, "Member 'UUserWidgetMapIcon_Actor::ClearFogOfWarSizeOverride' has a wrong offset!");

// Class Zion.UserWidgetMapIcon_RestPoint
// 0x0008 (0x05E8 - 0x05E0)
class UUserWidgetMapIcon_RestPoint : public UUserWidgetMapIcon_Actor
{
public:
	struct FMapRestPointData                      RestPointData;                                     // 0x05E0(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void SetRestPointData(const struct FMapRestPointData& InRestPointData);

	struct FMapRestPointData GetRestPointData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapIcon_RestPoint">();
	}
	static class UUserWidgetMapIcon_RestPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapIcon_RestPoint>();
	}
};
static_assert(alignof(UUserWidgetMapIcon_RestPoint) == 0x000008, "Wrong alignment on UUserWidgetMapIcon_RestPoint");
static_assert(sizeof(UUserWidgetMapIcon_RestPoint) == 0x0005E8, "Wrong size on UUserWidgetMapIcon_RestPoint");
static_assert(offsetof(UUserWidgetMapIcon_RestPoint, RestPointData) == 0x0005E0, "Member 'UUserWidgetMapIcon_RestPoint::RestPointData' has a wrong offset!");

// Class Zion.UserWidgetMapIcon_Teleport
// 0x0050 (0x0630 - 0x05E0)
class UUserWidgetMapIcon_Teleport : public UUserWidgetMapIcon_Actor
{
public:
	struct FDataTableRowHandle                    MapTransitionHandle;                               // 0x05E0(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                StartWorldLocation;                                // 0x05F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DestinationWorldLocation;                          // 0x0608(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ToDestination_MapSpace;                            // 0x0620(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FVector GetDestinationWorldLocation() const;
	struct FDataTableRowHandle GetMapTransitionHandle() const;
	struct FVector GetStartWorldLocation() const;
	struct FVector2D GetToDestination_MapSpace() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapIcon_Teleport">();
	}
	static class UUserWidgetMapIcon_Teleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapIcon_Teleport>();
	}
};
static_assert(alignof(UUserWidgetMapIcon_Teleport) == 0x000008, "Wrong alignment on UUserWidgetMapIcon_Teleport");
static_assert(sizeof(UUserWidgetMapIcon_Teleport) == 0x000630, "Wrong size on UUserWidgetMapIcon_Teleport");
static_assert(offsetof(UUserWidgetMapIcon_Teleport, MapTransitionHandle) == 0x0005E0, "Member 'UUserWidgetMapIcon_Teleport::MapTransitionHandle' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon_Teleport, StartWorldLocation) == 0x0005F0, "Member 'UUserWidgetMapIcon_Teleport::StartWorldLocation' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon_Teleport, DestinationWorldLocation) == 0x000608, "Member 'UUserWidgetMapIcon_Teleport::DestinationWorldLocation' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapIcon_Teleport, ToDestination_MapSpace) == 0x000620, "Member 'UUserWidgetMapIcon_Teleport::ToDestination_MapSpace' has a wrong offset!");

// Class Zion.UserWidgetMapIcon_Clearable
// 0x0008 (0x05E8 - 0x05E0)
class UUserWidgetMapIcon_Clearable : public UUserWidgetMapIcon_Actor
{
public:
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearIcon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapIcon_Clearable">();
	}
	static class UUserWidgetMapIcon_Clearable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapIcon_Clearable>();
	}
};
static_assert(alignof(UUserWidgetMapIcon_Clearable) == 0x000008, "Wrong alignment on UUserWidgetMapIcon_Clearable");
static_assert(sizeof(UUserWidgetMapIcon_Clearable) == 0x0005E8, "Wrong size on UUserWidgetMapIcon_Clearable");

// Class Zion.UserWidgetMapZone
// 0x0068 (0x04C8 - 0x0460)
class UUserWidgetMapZone : public UUserWidgetZion
{
public:
	struct FAnchors                               CanvasAnchors;                                     // 0x0460(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              CanvasAlignment;                                   // 0x0480(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanvasAutoSize;                                   // 0x0490(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_491[0x3];                                      // 0x0491(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClearActorData                        ZoneActorData;                                     // 0x0494(0x0010)(Edit, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZoneLevelName;                                     // 0x04A4(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AC[0x4];                                      // 0x04AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidgetMapArea*                     ParentMapArea;                                     // 0x04B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x10];                                     // 0x04B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CompleteZone();
	void HideZone();
	void RevealZone();
	void ShowZone();
	void VisitZone();

	bool IsCleared() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapZone">();
	}
	static class UUserWidgetMapZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapZone>();
	}
};
static_assert(alignof(UUserWidgetMapZone) == 0x000008, "Wrong alignment on UUserWidgetMapZone");
static_assert(sizeof(UUserWidgetMapZone) == 0x0004C8, "Wrong size on UUserWidgetMapZone");
static_assert(offsetof(UUserWidgetMapZone, CanvasAnchors) == 0x000460, "Member 'UUserWidgetMapZone::CanvasAnchors' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapZone, CanvasAlignment) == 0x000480, "Member 'UUserWidgetMapZone::CanvasAlignment' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapZone, bCanvasAutoSize) == 0x000490, "Member 'UUserWidgetMapZone::bCanvasAutoSize' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapZone, ZoneActorData) == 0x000494, "Member 'UUserWidgetMapZone::ZoneActorData' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapZone, ZoneLevelName) == 0x0004A4, "Member 'UUserWidgetMapZone::ZoneLevelName' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapZone, ParentMapArea) == 0x0004B0, "Member 'UUserWidgetMapZone::ParentMapArea' has a wrong offset!");

// Class Zion.UserWidgetMapArea
// 0x00C0 (0x0520 - 0x0460)
class UUserWidgetMapArea : public UUserWidgetZion
{
public:
	class UImage*                                 Map;                                               // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ZonesHolder;                                       // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           IconsHolder;                                       // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ZoomScaled_IconsHolder;                            // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MapTransitionsHolder;                              // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIconsRequireRealtimeCheck;                        // 0x0488(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_489[0x3];                                      // 0x0489(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MapRowName;                                        // 0x048C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUserWidgetMapIcon*>             CachedMapIcons;                                    // 0x0498(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<EMapIconType>                            VisibleMapIconTypes;                               // 0x04A8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UUserWidgetMapTransition*>       CachedMapTransitions;                              // 0x04F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_508[0x18];                                     // 0x0508(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShowAllMapAreaIcons();

	int32 GetClearedZoneCount() const;
	int32 GetCompletionPercentage() const;
	class FName GetMapName() const;
	int32 GetZoneCount() const;
	void OnZoneVisited(class AStaticVolume_Zone* ZoneVisited) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMapArea">();
	}
	static class UUserWidgetMapArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMapArea>();
	}
};
static_assert(alignof(UUserWidgetMapArea) == 0x000008, "Wrong alignment on UUserWidgetMapArea");
static_assert(sizeof(UUserWidgetMapArea) == 0x000520, "Wrong size on UUserWidgetMapArea");
static_assert(offsetof(UUserWidgetMapArea, Map) == 0x000460, "Member 'UUserWidgetMapArea::Map' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapArea, ZonesHolder) == 0x000468, "Member 'UUserWidgetMapArea::ZonesHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapArea, IconsHolder) == 0x000470, "Member 'UUserWidgetMapArea::IconsHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapArea, ZoomScaled_IconsHolder) == 0x000478, "Member 'UUserWidgetMapArea::ZoomScaled_IconsHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapArea, MapTransitionsHolder) == 0x000480, "Member 'UUserWidgetMapArea::MapTransitionsHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapArea, bIconsRequireRealtimeCheck) == 0x000488, "Member 'UUserWidgetMapArea::bIconsRequireRealtimeCheck' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapArea, MapRowName) == 0x00048C, "Member 'UUserWidgetMapArea::MapRowName' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapArea, CachedMapIcons) == 0x000498, "Member 'UUserWidgetMapArea::CachedMapIcons' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapArea, VisibleMapIconTypes) == 0x0004A8, "Member 'UUserWidgetMapArea::VisibleMapIconTypes' has a wrong offset!");
static_assert(offsetof(UUserWidgetMapArea, CachedMapTransitions) == 0x0004F8, "Member 'UUserWidgetMapArea::CachedMapTransitions' has a wrong offset!");

// Class Zion.UserWidgetMinimap
// 0x01C0 (0x0620 - 0x0460)
class UUserWidgetMinimap : public UUserWidgetZion
{
public:
	class UCanvasPanel*                           DisplayHolder;                                     // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URetainerBox*                           RetainerBox;                                       // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MinimapHolder;                                     // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               MinimapWidgetHolder;                               // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidgetMapIcon_Player*              PlayerIcon;                                        // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           StoryEventIconsHolder;                             // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           StoryEventDirectionsHolder;                        // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidgetPlayerTrail*                 WBP_PlayerTrail;                                   // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CustomMarkerIconsHolder;                           // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x38];                                     // 0x04A8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidgetMapArea*                     CurrentWidgetMapArea;                              // 0x04E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Zoom;                                              // 0x04E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   WidgetStoryEventIconClass;                         // 0x04F0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   WidgetStoryEventDirectionClass;                    // 0x0518(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              WidgetStoryEventDirectionShowOffset;               // 0x0540(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FWidgetMapStoryEventDirectionData> StoryEventsWithDirections;                      // 0x0550(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_560[0x58];                                     // 0x0560(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnchors                               FullscreenAnchors;                                 // 0x05B8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector2D                              FullscreenPosition;                                // 0x05D8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              FullscreenAlignment;                               // 0x05E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              FullscreenRetainerBoxSize;                         // 0x05F8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FullscreenOpacity;                                 // 0x0608(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60C[0x14];                                     // 0x060C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeDisplayMode();
	void InitializeDefaultDisplayValues();
	void OnGameMapChanged();
	void OnRefreshMinimap();
	void OnStoryLevelChanged();
	void RequestRender();

	bool HasValidData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetMinimap">();
	}
	static class UUserWidgetMinimap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetMinimap>();
	}
};
static_assert(alignof(UUserWidgetMinimap) == 0x000008, "Wrong alignment on UUserWidgetMinimap");
static_assert(sizeof(UUserWidgetMinimap) == 0x000620, "Wrong size on UUserWidgetMinimap");
static_assert(offsetof(UUserWidgetMinimap, DisplayHolder) == 0x000460, "Member 'UUserWidgetMinimap::DisplayHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, RetainerBox) == 0x000468, "Member 'UUserWidgetMinimap::RetainerBox' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, MinimapHolder) == 0x000470, "Member 'UUserWidgetMinimap::MinimapHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, MinimapWidgetHolder) == 0x000478, "Member 'UUserWidgetMinimap::MinimapWidgetHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, PlayerIcon) == 0x000480, "Member 'UUserWidgetMinimap::PlayerIcon' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, StoryEventIconsHolder) == 0x000488, "Member 'UUserWidgetMinimap::StoryEventIconsHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, StoryEventDirectionsHolder) == 0x000490, "Member 'UUserWidgetMinimap::StoryEventDirectionsHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, WBP_PlayerTrail) == 0x000498, "Member 'UUserWidgetMinimap::WBP_PlayerTrail' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, CustomMarkerIconsHolder) == 0x0004A0, "Member 'UUserWidgetMinimap::CustomMarkerIconsHolder' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, CurrentWidgetMapArea) == 0x0004E0, "Member 'UUserWidgetMinimap::CurrentWidgetMapArea' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, Zoom) == 0x0004E8, "Member 'UUserWidgetMinimap::Zoom' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, WidgetStoryEventIconClass) == 0x0004F0, "Member 'UUserWidgetMinimap::WidgetStoryEventIconClass' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, WidgetStoryEventDirectionClass) == 0x000518, "Member 'UUserWidgetMinimap::WidgetStoryEventDirectionClass' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, WidgetStoryEventDirectionShowOffset) == 0x000540, "Member 'UUserWidgetMinimap::WidgetStoryEventDirectionShowOffset' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, StoryEventsWithDirections) == 0x000550, "Member 'UUserWidgetMinimap::StoryEventsWithDirections' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, FullscreenAnchors) == 0x0005B8, "Member 'UUserWidgetMinimap::FullscreenAnchors' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, FullscreenPosition) == 0x0005D8, "Member 'UUserWidgetMinimap::FullscreenPosition' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, FullscreenAlignment) == 0x0005E8, "Member 'UUserWidgetMinimap::FullscreenAlignment' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, FullscreenRetainerBoxSize) == 0x0005F8, "Member 'UUserWidgetMinimap::FullscreenRetainerBoxSize' has a wrong offset!");
static_assert(offsetof(UUserWidgetMinimap, FullscreenOpacity) == 0x000608, "Member 'UUserWidgetMinimap::FullscreenOpacity' has a wrong offset!");

// Class Zion.UserWidgetPlayTimeClock
// 0x0020 (0x0480 - 0x0460)
class UUserWidgetPlayTimeClock : public UUserWidgetZion
{
public:
	class UTextBlock*                             PlayTimeClock;                                     // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PlayTimeText;                                      // 0x0468(0x0010)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdatePlayTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetPlayTimeClock">();
	}
	static class UUserWidgetPlayTimeClock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetPlayTimeClock>();
	}
};
static_assert(alignof(UUserWidgetPlayTimeClock) == 0x000008, "Wrong alignment on UUserWidgetPlayTimeClock");
static_assert(sizeof(UUserWidgetPlayTimeClock) == 0x000480, "Wrong size on UUserWidgetPlayTimeClock");
static_assert(offsetof(UUserWidgetPlayTimeClock, PlayTimeClock) == 0x000460, "Member 'UUserWidgetPlayTimeClock::PlayTimeClock' has a wrong offset!");
static_assert(offsetof(UUserWidgetPlayTimeClock, PlayTimeText) == 0x000468, "Member 'UUserWidgetPlayTimeClock::PlayTimeText' has a wrong offset!");

// Class Zion.UserWidgetStatusEffectIcon
// 0x0068 (0x04C8 - 0x0460)
class UUserWidgetStatusEffectIcon : public UUserWidgetZion
{
public:
	class URadialSliderZion*                      StatusEffectDurationSlider;                        // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UStatusEffect>           CachedStatusEffect;                                // 0x0468(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EStatusEffectType, TSoftObjectPtr<class UPaperSprite>> StatusEffectIcons_Map;               // 0x0470(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStatusEffectFinished();
	void UpdateRemainingDuration();

	class UStatusEffect* GetCachedStatusEffect() const;
	TSoftObjectPtr<class UPaperSprite> GetStatusEffectIconSprite() const;
	TSoftObjectPtr<class UPaperSprite> GetStatusEffectIconSpriteFromType(const EStatusEffectType& StatusEffectType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetStatusEffectIcon">();
	}
	static class UUserWidgetStatusEffectIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetStatusEffectIcon>();
	}
};
static_assert(alignof(UUserWidgetStatusEffectIcon) == 0x000008, "Wrong alignment on UUserWidgetStatusEffectIcon");
static_assert(sizeof(UUserWidgetStatusEffectIcon) == 0x0004C8, "Wrong size on UUserWidgetStatusEffectIcon");
static_assert(offsetof(UUserWidgetStatusEffectIcon, StatusEffectDurationSlider) == 0x000460, "Member 'UUserWidgetStatusEffectIcon::StatusEffectDurationSlider' has a wrong offset!");
static_assert(offsetof(UUserWidgetStatusEffectIcon, CachedStatusEffect) == 0x000468, "Member 'UUserWidgetStatusEffectIcon::CachedStatusEffect' has a wrong offset!");
static_assert(offsetof(UUserWidgetStatusEffectIcon, StatusEffectIcons_Map) == 0x000470, "Member 'UUserWidgetStatusEffectIcon::StatusEffectIcons_Map' has a wrong offset!");

// Class Zion.UserWidgetWorldSpaceDebug
// 0x0000 (0x0318 - 0x0318)
class UUserWidgetWorldSpaceDebug : public UUserWidgetWorldSpace
{
public:
	void ClearTextForTag(class FName Tag);
	void SetTextForTag(class FName Tag, const class FString& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetWorldSpaceDebug">();
	}
	static class UUserWidgetWorldSpaceDebug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetWorldSpaceDebug>();
	}
};
static_assert(alignof(UUserWidgetWorldSpaceDebug) == 0x000008, "Wrong alignment on UUserWidgetWorldSpaceDebug");
static_assert(sizeof(UUserWidgetWorldSpaceDebug) == 0x000318, "Wrong size on UUserWidgetWorldSpaceDebug");

// Class Zion.WaitGameReadyAsyncAction
// 0x0028 (0x0058 - 0x0030)
class UWaitGameReadyAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UWaitGameReadyAsyncAction* WaitGameReady(const class UObject* WorldContextObject, bool bAlsoWaitWorldLoading);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaitGameReadyAsyncAction">();
	}
	static class UWaitGameReadyAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaitGameReadyAsyncAction>();
	}
};
static_assert(alignof(UWaitGameReadyAsyncAction) == 0x000008, "Wrong alignment on UWaitGameReadyAsyncAction");
static_assert(sizeof(UWaitGameReadyAsyncAction) == 0x000058, "Wrong size on UWaitGameReadyAsyncAction");
static_assert(offsetof(UWaitGameReadyAsyncAction, OnFinish) == 0x000030, "Member 'UWaitGameReadyAsyncAction::OnFinish' has a wrong offset!");

// Class Zion.WorldLoaderSubsystem
// 0x0390 (0x03C0 - 0x0030)
class UWorldLoaderSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x390];                                     // 0x0030(0x0390)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadeInFinished();
	void OnFadeOutFinished();
	void OnLevelStreamingDynamicLoaded();
	void OnPostLoad();
	void OpenGameMap(const struct FDataTableRowHandle& GameMapHandle, const class FName PlayerStartTag, bool bForceReload, const struct FFadeDescriptionData& FadeOutDescription, const struct FFadeDescriptionData& FadeInDescription);
	void OpenWorld(TSoftObjectPtr<class UWorld> WorldToLoad, class FName PlayerStartTag, const struct FFadeDescriptionData& FadeOutDescription, const struct FFadeDescriptionData& FadeInDescription);
	void SwitchGameMap_PostFadeIn();
	void SwitchGameMap_PostFadeOut();

	const struct FGameMapData GetCurrentGameMapData() const;
	class FName GetCurrentGameMapID() const;
	class FName GetCurrentPlayerStartTag() const;
	bool IsAvailable() const;
	bool IsLoading(bool bConsiderFadeAsLoading) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldLoaderSubsystem">();
	}
	static class UWorldLoaderSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldLoaderSubsystem>();
	}
};
static_assert(alignof(UWorldLoaderSubsystem) == 0x000008, "Wrong alignment on UWorldLoaderSubsystem");
static_assert(sizeof(UWorldLoaderSubsystem) == 0x0003C0, "Wrong size on UWorldLoaderSubsystem");

// Class Zion.CameraOverrideModule_ZoomOffset
// 0x0010 (0x0038 - 0x0028)
class UCameraOverrideModule_ZoomOffset final : public UCameraOverrideModule
{
public:
	ECameraModuleOverrideType                     OverrideType;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomOffset;                                        // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ZoomOffsetFactor;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_ZoomOffset">();
	}
	static class UCameraOverrideModule_ZoomOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_ZoomOffset>();
	}
};
static_assert(alignof(UCameraOverrideModule_ZoomOffset) == 0x000008, "Wrong alignment on UCameraOverrideModule_ZoomOffset");
static_assert(sizeof(UCameraOverrideModule_ZoomOffset) == 0x000038, "Wrong size on UCameraOverrideModule_ZoomOffset");
static_assert(offsetof(UCameraOverrideModule_ZoomOffset, OverrideType) == 0x000028, "Member 'UCameraOverrideModule_ZoomOffset::OverrideType' has a wrong offset!");
static_assert(offsetof(UCameraOverrideModule_ZoomOffset, ZoomOffset) == 0x00002C, "Member 'UCameraOverrideModule_ZoomOffset::ZoomOffset' has a wrong offset!");
static_assert(offsetof(UCameraOverrideModule_ZoomOffset, ZoomOffsetFactor) == 0x000030, "Member 'UCameraOverrideModule_ZoomOffset::ZoomOffsetFactor' has a wrong offset!");

// Class Zion.CameraOverrideModule_LocalLocationOffset
// 0x0010 (0x0038 - 0x0028)
class UCameraOverrideModule_LocalLocationOffset final : public UCameraOverrideModule
{
public:
	struct FVector2D                              LocalLocationOffset;                               // 0x0028(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_LocalLocationOffset">();
	}
	static class UCameraOverrideModule_LocalLocationOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_LocalLocationOffset>();
	}
};
static_assert(alignof(UCameraOverrideModule_LocalLocationOffset) == 0x000008, "Wrong alignment on UCameraOverrideModule_LocalLocationOffset");
static_assert(sizeof(UCameraOverrideModule_LocalLocationOffset) == 0x000038, "Wrong size on UCameraOverrideModule_LocalLocationOffset");
static_assert(offsetof(UCameraOverrideModule_LocalLocationOffset, LocalLocationOffset) == 0x000028, "Member 'UCameraOverrideModule_LocalLocationOffset::LocalLocationOffset' has a wrong offset!");

// Class Zion.CameraOverrideModule_MaxInputLocationOffset
// 0x0010 (0x0038 - 0x0028)
class UCameraOverrideModule_MaxInputLocationOffset final : public UCameraOverrideModule
{
public:
	struct FVector2D                              MaxInputLocationOffset;                            // 0x0028(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_MaxInputLocationOffset">();
	}
	static class UCameraOverrideModule_MaxInputLocationOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_MaxInputLocationOffset>();
	}
};
static_assert(alignof(UCameraOverrideModule_MaxInputLocationOffset) == 0x000008, "Wrong alignment on UCameraOverrideModule_MaxInputLocationOffset");
static_assert(sizeof(UCameraOverrideModule_MaxInputLocationOffset) == 0x000038, "Wrong size on UCameraOverrideModule_MaxInputLocationOffset");
static_assert(offsetof(UCameraOverrideModule_MaxInputLocationOffset, MaxInputLocationOffset) == 0x000028, "Member 'UCameraOverrideModule_MaxInputLocationOffset::MaxInputLocationOffset' has a wrong offset!");

// Class Zion.CameraOverrideModule_InputLocationOffsetSpeed
// 0x0008 (0x0030 - 0x0028)
class UCameraOverrideModule_InputLocationOffsetSpeed final : public UCameraOverrideModule
{
public:
	float                                         InputLocationOffsetSpeed;                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_InputLocationOffsetSpeed">();
	}
	static class UCameraOverrideModule_InputLocationOffsetSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_InputLocationOffsetSpeed>();
	}
};
static_assert(alignof(UCameraOverrideModule_InputLocationOffsetSpeed) == 0x000008, "Wrong alignment on UCameraOverrideModule_InputLocationOffsetSpeed");
static_assert(sizeof(UCameraOverrideModule_InputLocationOffsetSpeed) == 0x000030, "Wrong size on UCameraOverrideModule_InputLocationOffsetSpeed");
static_assert(offsetof(UCameraOverrideModule_InputLocationOffsetSpeed, InputLocationOffsetSpeed) == 0x000028, "Member 'UCameraOverrideModule_InputLocationOffsetSpeed::InputLocationOffsetSpeed' has a wrong offset!");

// Class Zion.CameraOverrideModule_CenterHorizontalFlag
// 0x0008 (0x0030 - 0x0028)
class UCameraOverrideModule_CenterHorizontalFlag final : public UCameraOverrideModule
{
public:
	bool                                          bCenterHorizontal;                                 // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOverrideModule_CenterHorizontalFlag">();
	}
	static class UCameraOverrideModule_CenterHorizontalFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOverrideModule_CenterHorizontalFlag>();
	}
};
static_assert(alignof(UCameraOverrideModule_CenterHorizontalFlag) == 0x000008, "Wrong alignment on UCameraOverrideModule_CenterHorizontalFlag");
static_assert(sizeof(UCameraOverrideModule_CenterHorizontalFlag) == 0x000030, "Wrong size on UCameraOverrideModule_CenterHorizontalFlag");
static_assert(offsetof(UCameraOverrideModule_CenterHorizontalFlag, bCenterHorizontal) == 0x000028, "Member 'UCameraOverrideModule_CenterHorizontalFlag::bCenterHorizontal' has a wrong offset!");

// Class Zion.ZionInputDeviceSubsystem
// 0x00F8 (0x0128 - 0x0030)
class UZionInputDeviceSubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void()>              OnGamepadConnectionChangedDelegate;                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0xE8];                                      // 0x0040(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetActiveControllerID();
	void LockActiveController();
	void SetInputStyleGamepadOverride(EInputStyle NewInputStyleGamepadOverride);
	void UnlockActiveController(bool bResetLockCount);

	EInputStyle GetInputStyle() const;
	EInputStyle GetInputStyleGamepadOverride() const;
	bool IsActiveControllerLocked() const;
	bool IsAnyGamepadConnected() const;
	bool IsCursorVisible() const;
	bool IsUsingGamepad() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZionInputDeviceSubsystem">();
	}
	static class UZionInputDeviceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZionInputDeviceSubsystem>();
	}
};
static_assert(alignof(UZionInputDeviceSubsystem) == 0x000008, "Wrong alignment on UZionInputDeviceSubsystem");
static_assert(sizeof(UZionInputDeviceSubsystem) == 0x000128, "Wrong size on UZionInputDeviceSubsystem");
static_assert(offsetof(UZionInputDeviceSubsystem, OnGamepadConnectionChangedDelegate) == 0x000030, "Member 'UZionInputDeviceSubsystem::OnGamepadConnectionChangedDelegate' has a wrong offset!");

}

