#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Zion

#include "Basic.hpp"

#include "Zion_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "InputCore_structs.hpp"
#include "Engine_structs.hpp"
#include "EventSystem_structs.hpp"
#include "SpineExtension_structs.hpp"
#include "AIModule_structs.hpp"
#include "SlateCore_structs.hpp"
#include "Slate_structs.hpp"
#include "FMODStudio_structs.hpp"
#include "UMG_structs.hpp"


namespace SDK::Params
{

// Function Zion.AbilityEffect.GetAbilityForward
// 0x0018 (0x0018 - 0x0000)
struct AbilityEffect_GetAbilityForward final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEffect_GetAbilityForward) == 0x000008, "Wrong alignment on AbilityEffect_GetAbilityForward");
static_assert(sizeof(AbilityEffect_GetAbilityForward) == 0x000018, "Wrong size on AbilityEffect_GetAbilityForward");
static_assert(offsetof(AbilityEffect_GetAbilityForward, ReturnValue) == 0x000000, "Member 'AbilityEffect_GetAbilityForward::ReturnValue' has a wrong offset!");

// Function Zion.AbilityEffect.GetAbilityLocation
// 0x0018 (0x0018 - 0x0000)
struct AbilityEffect_GetAbilityLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEffect_GetAbilityLocation) == 0x000008, "Wrong alignment on AbilityEffect_GetAbilityLocation");
static_assert(sizeof(AbilityEffect_GetAbilityLocation) == 0x000018, "Wrong size on AbilityEffect_GetAbilityLocation");
static_assert(offsetof(AbilityEffect_GetAbilityLocation, ReturnValue) == 0x000000, "Member 'AbilityEffect_GetAbilityLocation::ReturnValue' has a wrong offset!");

// Function Zion.AbilityEffect.GetSource
// 0x0008 (0x0008 - 0x0000)
struct AbilityEffect_GetSource final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEffect_GetSource) == 0x000008, "Wrong alignment on AbilityEffect_GetSource");
static_assert(sizeof(AbilityEffect_GetSource) == 0x000008, "Wrong size on AbilityEffect_GetSource");
static_assert(offsetof(AbilityEffect_GetSource, ReturnValue) == 0x000000, "Member 'AbilityEffect_GetSource::ReturnValue' has a wrong offset!");

// Function Zion.AbilityEffect.GetSourceLocation
// 0x0018 (0x0018 - 0x0000)
struct AbilityEffect_GetSourceLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEffect_GetSourceLocation) == 0x000008, "Wrong alignment on AbilityEffect_GetSourceLocation");
static_assert(sizeof(AbilityEffect_GetSourceLocation) == 0x000018, "Wrong size on AbilityEffect_GetSourceLocation");
static_assert(offsetof(AbilityEffect_GetSourceLocation, ReturnValue) == 0x000000, "Member 'AbilityEffect_GetSourceLocation::ReturnValue' has a wrong offset!");

// Function Zion.AbilityEffect.GetTarget
// 0x0008 (0x0008 - 0x0000)
struct AbilityEffect_GetTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEffect_GetTarget) == 0x000008, "Wrong alignment on AbilityEffect_GetTarget");
static_assert(sizeof(AbilityEffect_GetTarget) == 0x000008, "Wrong size on AbilityEffect_GetTarget");
static_assert(offsetof(AbilityEffect_GetTarget, ReturnValue) == 0x000000, "Member 'AbilityEffect_GetTarget::ReturnValue' has a wrong offset!");

// Function Zion.AbilityEffect.GetTargetForward
// 0x0018 (0x0018 - 0x0000)
struct AbilityEffect_GetTargetForward final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEffect_GetTargetForward) == 0x000008, "Wrong alignment on AbilityEffect_GetTargetForward");
static_assert(sizeof(AbilityEffect_GetTargetForward) == 0x000018, "Wrong size on AbilityEffect_GetTargetForward");
static_assert(offsetof(AbilityEffect_GetTargetForward, ReturnValue) == 0x000000, "Member 'AbilityEffect_GetTargetForward::ReturnValue' has a wrong offset!");

// Function Zion.AbilityEffect.GetTargetLocation
// 0x0018 (0x0018 - 0x0000)
struct AbilityEffect_GetTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEffect_GetTargetLocation) == 0x000008, "Wrong alignment on AbilityEffect_GetTargetLocation");
static_assert(sizeof(AbilityEffect_GetTargetLocation) == 0x000018, "Wrong size on AbilityEffect_GetTargetLocation");
static_assert(offsetof(AbilityEffect_GetTargetLocation, ReturnValue) == 0x000000, "Member 'AbilityEffect_GetTargetLocation::ReturnValue' has a wrong offset!");

// Function Zion.AbilityEffect.GetToTargetDirection
// 0x0038 (0x0038 - 0x0000)
struct AbilityEffect_GetToTargetDirection final
{
public:
	EDirectionSource                              DirectionSource;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Axis;                                              // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEffect_GetToTargetDirection) == 0x000008, "Wrong alignment on AbilityEffect_GetToTargetDirection");
static_assert(sizeof(AbilityEffect_GetToTargetDirection) == 0x000038, "Wrong size on AbilityEffect_GetToTargetDirection");
static_assert(offsetof(AbilityEffect_GetToTargetDirection, DirectionSource) == 0x000000, "Member 'AbilityEffect_GetToTargetDirection::DirectionSource' has a wrong offset!");
static_assert(offsetof(AbilityEffect_GetToTargetDirection, Axis) == 0x000008, "Member 'AbilityEffect_GetToTargetDirection::Axis' has a wrong offset!");
static_assert(offsetof(AbilityEffect_GetToTargetDirection, ReturnValue) == 0x000020, "Member 'AbilityEffect_GetToTargetDirection::ReturnValue' has a wrong offset!");

// Function Zion.AbilityEffect.IsFrontalAbility
// 0x0001 (0x0001 - 0x0000)
struct AbilityEffect_IsFrontalAbility final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEffect_IsFrontalAbility) == 0x000001, "Wrong alignment on AbilityEffect_IsFrontalAbility");
static_assert(sizeof(AbilityEffect_IsFrontalAbility) == 0x000001, "Wrong size on AbilityEffect_IsFrontalAbility");
static_assert(offsetof(AbilityEffect_IsFrontalAbility, ReturnValue) == 0x000000, "Member 'AbilityEffect_IsFrontalAbility::ReturnValue' has a wrong offset!");

// Function Zion.EventAction_MoveTo_TalkDistance.OnMoveCompleted
// 0x0008 (0x0008 - 0x0000)
struct EventAction_MoveTo_TalkDistance_OnMoveCompleted final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EPathFollowingResult                          Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EventAction_MoveTo_TalkDistance_OnMoveCompleted) == 0x000004, "Wrong alignment on EventAction_MoveTo_TalkDistance_OnMoveCompleted");
static_assert(sizeof(EventAction_MoveTo_TalkDistance_OnMoveCompleted) == 0x000008, "Wrong size on EventAction_MoveTo_TalkDistance_OnMoveCompleted");
static_assert(offsetof(EventAction_MoveTo_TalkDistance_OnMoveCompleted, RequestID) == 0x000000, "Member 'EventAction_MoveTo_TalkDistance_OnMoveCompleted::RequestID' has a wrong offset!");
static_assert(offsetof(EventAction_MoveTo_TalkDistance_OnMoveCompleted, Result) == 0x000004, "Member 'EventAction_MoveTo_TalkDistance_OnMoveCompleted::Result' has a wrong offset!");

// Function Zion.AbilityEffectTimed.OnUpdate
// 0x000C (0x000C - 0x0000)
struct AbilityEffectTimed_OnUpdate final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         out_ConsumedDeltaTime;                             // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AbilityEffectTimed_OnUpdate) == 0x000004, "Wrong alignment on AbilityEffectTimed_OnUpdate");
static_assert(sizeof(AbilityEffectTimed_OnUpdate) == 0x00000C, "Wrong size on AbilityEffectTimed_OnUpdate");
static_assert(offsetof(AbilityEffectTimed_OnUpdate, DeltaTime) == 0x000000, "Member 'AbilityEffectTimed_OnUpdate::DeltaTime' has a wrong offset!");
static_assert(offsetof(AbilityEffectTimed_OnUpdate, out_ConsumedDeltaTime) == 0x000004, "Member 'AbilityEffectTimed_OnUpdate::out_ConsumedDeltaTime' has a wrong offset!");
static_assert(offsetof(AbilityEffectTimed_OnUpdate, ReturnValue) == 0x000008, "Member 'AbilityEffectTimed_OnUpdate::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossBaseComponent.BossActivation
// 0x0008 (0x0008 - 0x0000)
struct RecollectionBossBaseComponent_BossActivation final
{
public:
	class AEnemySpawner*                          EnemySpawner;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossBaseComponent_BossActivation) == 0x000008, "Wrong alignment on RecollectionBossBaseComponent_BossActivation");
static_assert(sizeof(RecollectionBossBaseComponent_BossActivation) == 0x000008, "Wrong size on RecollectionBossBaseComponent_BossActivation");
static_assert(offsetof(RecollectionBossBaseComponent_BossActivation, EnemySpawner) == 0x000000, "Member 'RecollectionBossBaseComponent_BossActivation::EnemySpawner' has a wrong offset!");

// Function Zion.RecollectionBossBaseComponent.BossDeathEnd
// 0x0008 (0x0008 - 0x0000)
struct RecollectionBossBaseComponent_BossDeathEnd final
{
public:
	class AEnemySpawner*                          EnemySpawner;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossBaseComponent_BossDeathEnd) == 0x000008, "Wrong alignment on RecollectionBossBaseComponent_BossDeathEnd");
static_assert(sizeof(RecollectionBossBaseComponent_BossDeathEnd) == 0x000008, "Wrong size on RecollectionBossBaseComponent_BossDeathEnd");
static_assert(offsetof(RecollectionBossBaseComponent_BossDeathEnd, EnemySpawner) == 0x000000, "Member 'RecollectionBossBaseComponent_BossDeathEnd::EnemySpawner' has a wrong offset!");

// Function Zion.RecollectionBossBaseComponent.BossDeathStart
// 0x0008 (0x0008 - 0x0000)
struct RecollectionBossBaseComponent_BossDeathStart final
{
public:
	class AEnemySpawner*                          EnemySpawner;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossBaseComponent_BossDeathStart) == 0x000008, "Wrong alignment on RecollectionBossBaseComponent_BossDeathStart");
static_assert(sizeof(RecollectionBossBaseComponent_BossDeathStart) == 0x000008, "Wrong size on RecollectionBossBaseComponent_BossDeathStart");
static_assert(offsetof(RecollectionBossBaseComponent_BossDeathStart, EnemySpawner) == 0x000000, "Member 'RecollectionBossBaseComponent_BossDeathStart::EnemySpawner' has a wrong offset!");

// Function Zion.RecollectionBossBaseComponent.InstantiateRetryDialog
// 0x0001 (0x0001 - 0x0000)
struct RecollectionBossBaseComponent_InstantiateRetryDialog final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossBaseComponent_InstantiateRetryDialog) == 0x000001, "Wrong alignment on RecollectionBossBaseComponent_InstantiateRetryDialog");
static_assert(sizeof(RecollectionBossBaseComponent_InstantiateRetryDialog) == 0x000001, "Wrong size on RecollectionBossBaseComponent_InstantiateRetryDialog");
static_assert(offsetof(RecollectionBossBaseComponent_InstantiateRetryDialog, ReturnValue) == 0x000000, "Member 'RecollectionBossBaseComponent_InstantiateRetryDialog::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossBaseComponent.SetNewGameGenerationOverride
// 0x0004 (0x0004 - 0x0000)
struct RecollectionBossBaseComponent_SetNewGameGenerationOverride final
{
public:
	int32                                         GenerationOverride;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossBaseComponent_SetNewGameGenerationOverride) == 0x000004, "Wrong alignment on RecollectionBossBaseComponent_SetNewGameGenerationOverride");
static_assert(sizeof(RecollectionBossBaseComponent_SetNewGameGenerationOverride) == 0x000004, "Wrong size on RecollectionBossBaseComponent_SetNewGameGenerationOverride");
static_assert(offsetof(RecollectionBossBaseComponent_SetNewGameGenerationOverride, GenerationOverride) == 0x000000, "Member 'RecollectionBossBaseComponent_SetNewGameGenerationOverride::GenerationOverride' has a wrong offset!");

// Function Zion.RecollectionBossBaseComponent.CanLeaveRecollectionBoss
// 0x0001 (0x0001 - 0x0000)
struct RecollectionBossBaseComponent_CanLeaveRecollectionBoss final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossBaseComponent_CanLeaveRecollectionBoss) == 0x000001, "Wrong alignment on RecollectionBossBaseComponent_CanLeaveRecollectionBoss");
static_assert(sizeof(RecollectionBossBaseComponent_CanLeaveRecollectionBoss) == 0x000001, "Wrong size on RecollectionBossBaseComponent_CanLeaveRecollectionBoss");
static_assert(offsetof(RecollectionBossBaseComponent_CanLeaveRecollectionBoss, ReturnValue) == 0x000000, "Member 'RecollectionBossBaseComponent_CanLeaveRecollectionBoss::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossBaseComponent.GetCachedEnemySpawner
// 0x0008 (0x0008 - 0x0000)
struct RecollectionBossBaseComponent_GetCachedEnemySpawner final
{
public:
	class AEnemySpawner*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossBaseComponent_GetCachedEnemySpawner) == 0x000008, "Wrong alignment on RecollectionBossBaseComponent_GetCachedEnemySpawner");
static_assert(sizeof(RecollectionBossBaseComponent_GetCachedEnemySpawner) == 0x000008, "Wrong size on RecollectionBossBaseComponent_GetCachedEnemySpawner");
static_assert(offsetof(RecollectionBossBaseComponent_GetCachedEnemySpawner, ReturnValue) == 0x000000, "Member 'RecollectionBossBaseComponent_GetCachedEnemySpawner::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossBaseComponent.GetNewGameGenerationOverride
// 0x0004 (0x0004 - 0x0000)
struct RecollectionBossBaseComponent_GetNewGameGenerationOverride final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossBaseComponent_GetNewGameGenerationOverride) == 0x000004, "Wrong alignment on RecollectionBossBaseComponent_GetNewGameGenerationOverride");
static_assert(sizeof(RecollectionBossBaseComponent_GetNewGameGenerationOverride) == 0x000004, "Wrong size on RecollectionBossBaseComponent_GetNewGameGenerationOverride");
static_assert(offsetof(RecollectionBossBaseComponent_GetNewGameGenerationOverride, ReturnValue) == 0x000000, "Member 'RecollectionBossBaseComponent_GetNewGameGenerationOverride::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossBaseComponent.IsStarted
// 0x0001 (0x0001 - 0x0000)
struct RecollectionBossBaseComponent_IsStarted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossBaseComponent_IsStarted) == 0x000001, "Wrong alignment on RecollectionBossBaseComponent_IsStarted");
static_assert(sizeof(RecollectionBossBaseComponent_IsStarted) == 0x000001, "Wrong size on RecollectionBossBaseComponent_IsStarted");
static_assert(offsetof(RecollectionBossBaseComponent_IsStarted, ReturnValue) == 0x000000, "Member 'RecollectionBossBaseComponent_IsStarted::ReturnValue' has a wrong offset!");

// Function Zion.CommandModule.GetCharacter
// 0x0008 (0x0008 - 0x0000)
struct CommandModule_GetCharacter final
{
public:
	class ACharacter*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandModule_GetCharacter) == 0x000008, "Wrong alignment on CommandModule_GetCharacter");
static_assert(sizeof(CommandModule_GetCharacter) == 0x000008, "Wrong size on CommandModule_GetCharacter");
static_assert(offsetof(CommandModule_GetCharacter, ReturnValue) == 0x000000, "Member 'CommandModule_GetCharacter::ReturnValue' has a wrong offset!");

// Function Zion.CommandModule.GetCommand
// 0x0008 (0x0008 - 0x0000)
struct CommandModule_GetCommand final
{
public:
	class UCommand*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandModule_GetCommand) == 0x000008, "Wrong alignment on CommandModule_GetCommand");
static_assert(sizeof(CommandModule_GetCommand) == 0x000008, "Wrong size on CommandModule_GetCommand");
static_assert(offsetof(CommandModule_GetCommand, ReturnValue) == 0x000000, "Member 'CommandModule_GetCommand::ReturnValue' has a wrong offset!");

// Function Zion.CommandModule.GetExecutionTime
// 0x0004 (0x0004 - 0x0000)
struct CommandModule_GetExecutionTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandModule_GetExecutionTime) == 0x000004, "Wrong alignment on CommandModule_GetExecutionTime");
static_assert(sizeof(CommandModule_GetExecutionTime) == 0x000004, "Wrong size on CommandModule_GetExecutionTime");
static_assert(offsetof(CommandModule_GetExecutionTime, ReturnValue) == 0x000000, "Member 'CommandModule_GetExecutionTime::ReturnValue' has a wrong offset!");

// Function Zion.Ability.GetExecutionTime
// 0x0004 (0x0004 - 0x0000)
struct Ability_GetExecutionTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_GetExecutionTime) == 0x000004, "Wrong alignment on Ability_GetExecutionTime");
static_assert(sizeof(Ability_GetExecutionTime) == 0x000004, "Wrong size on Ability_GetExecutionTime");
static_assert(offsetof(Ability_GetExecutionTime, ReturnValue) == 0x000000, "Member 'Ability_GetExecutionTime::ReturnValue' has a wrong offset!");

// Function Zion.Ability.GetSource
// 0x0008 (0x0008 - 0x0000)
struct Ability_GetSource final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_GetSource) == 0x000008, "Wrong alignment on Ability_GetSource");
static_assert(sizeof(Ability_GetSource) == 0x000008, "Wrong size on Ability_GetSource");
static_assert(offsetof(Ability_GetSource, ReturnValue) == 0x000000, "Member 'Ability_GetSource::ReturnValue' has a wrong offset!");

// Function Zion.Ability.GetWeightCategory
// 0x0001 (0x0001 - 0x0000)
struct Ability_GetWeightCategory final
{
public:
	EAbilityWeightCategory                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_GetWeightCategory) == 0x000001, "Wrong alignment on Ability_GetWeightCategory");
static_assert(sizeof(Ability_GetWeightCategory) == 0x000001, "Wrong size on Ability_GetWeightCategory");
static_assert(offsetof(Ability_GetWeightCategory, ReturnValue) == 0x000000, "Member 'Ability_GetWeightCategory::ReturnValue' has a wrong offset!");

// Function Zion.Command.OnCanBeStarted
// 0x0001 (0x0001 - 0x0000)
struct Command_OnCanBeStarted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_OnCanBeStarted) == 0x000001, "Wrong alignment on Command_OnCanBeStarted");
static_assert(sizeof(Command_OnCanBeStarted) == 0x000001, "Wrong size on Command_OnCanBeStarted");
static_assert(offsetof(Command_OnCanBeStarted, ReturnValue) == 0x000000, "Member 'Command_OnCanBeStarted::ReturnValue' has a wrong offset!");

// Function Zion.Command.OnFinish
// 0x0001 (0x0001 - 0x0000)
struct Command_OnFinish final
{
public:
	ECommandFinishType                            FinishType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_OnFinish) == 0x000001, "Wrong alignment on Command_OnFinish");
static_assert(sizeof(Command_OnFinish) == 0x000001, "Wrong size on Command_OnFinish");
static_assert(offsetof(Command_OnFinish, FinishType) == 0x000000, "Member 'Command_OnFinish::FinishType' has a wrong offset!");

// Function Zion.Command.OnInitialize
// 0x0008 (0x0008 - 0x0000)
struct Command_OnInitialize final
{
public:
	class APawn*                                  PawnOwner;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_OnInitialize) == 0x000008, "Wrong alignment on Command_OnInitialize");
static_assert(sizeof(Command_OnInitialize) == 0x000008, "Wrong size on Command_OnInitialize");
static_assert(offsetof(Command_OnInitialize, PawnOwner) == 0x000000, "Member 'Command_OnInitialize::PawnOwner' has a wrong offset!");

// Function Zion.Command.GetCharacter
// 0x0008 (0x0008 - 0x0000)
struct Command_GetCharacter final
{
public:
	class ACharacter*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_GetCharacter) == 0x000008, "Wrong alignment on Command_GetCharacter");
static_assert(sizeof(Command_GetCharacter) == 0x000008, "Wrong size on Command_GetCharacter");
static_assert(offsetof(Command_GetCharacter, ReturnValue) == 0x000000, "Member 'Command_GetCharacter::ReturnValue' has a wrong offset!");

// Function Zion.Command.GetCommandCategory
// 0x0001 (0x0001 - 0x0000)
struct Command_GetCommandCategory final
{
public:
	ECommandCategory                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_GetCommandCategory) == 0x000001, "Wrong alignment on Command_GetCommandCategory");
static_assert(sizeof(Command_GetCommandCategory) == 0x000001, "Wrong size on Command_GetCommandCategory");
static_assert(offsetof(Command_GetCommandCategory, ReturnValue) == 0x000000, "Member 'Command_GetCommandCategory::ReturnValue' has a wrong offset!");

// Function Zion.Command.GetCommandLayer
// 0x0001 (0x0001 - 0x0000)
struct Command_GetCommandLayer final
{
public:
	ECommandLayerType                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_GetCommandLayer) == 0x000001, "Wrong alignment on Command_GetCommandLayer");
static_assert(sizeof(Command_GetCommandLayer) == 0x000001, "Wrong size on Command_GetCommandLayer");
static_assert(offsetof(Command_GetCommandLayer, ReturnValue) == 0x000000, "Member 'Command_GetCommandLayer::ReturnValue' has a wrong offset!");

// Function Zion.Command.GetExecutionTime
// 0x0004 (0x0004 - 0x0000)
struct Command_GetExecutionTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_GetExecutionTime) == 0x000004, "Wrong alignment on Command_GetExecutionTime");
static_assert(sizeof(Command_GetExecutionTime) == 0x000004, "Wrong size on Command_GetExecutionTime");
static_assert(offsetof(Command_GetExecutionTime, ReturnValue) == 0x000000, "Member 'Command_GetExecutionTime::ReturnValue' has a wrong offset!");

// Function Zion.Command.GetInputSnapshot
// 0x00B8 (0x00B8 - 0x0000)
struct Command_GetInputSnapshot final
{
public:
	struct FInputSnapshot                         ReturnValue;                                       // 0x0000(0x00B8)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_GetInputSnapshot) == 0x000008, "Wrong alignment on Command_GetInputSnapshot");
static_assert(sizeof(Command_GetInputSnapshot) == 0x0000B8, "Wrong size on Command_GetInputSnapshot");
static_assert(offsetof(Command_GetInputSnapshot, ReturnValue) == 0x000000, "Member 'Command_GetInputSnapshot::ReturnValue' has a wrong offset!");

// Function Zion.Command.GetInvokedInputAction
// 0x0008 (0x0008 - 0x0000)
struct Command_GetInvokedInputAction final
{
public:
	const class UInputAction*                     ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_GetInvokedInputAction) == 0x000008, "Wrong alignment on Command_GetInvokedInputAction");
static_assert(sizeof(Command_GetInvokedInputAction) == 0x000008, "Wrong size on Command_GetInvokedInputAction");
static_assert(offsetof(Command_GetInvokedInputAction, ReturnValue) == 0x000000, "Member 'Command_GetInvokedInputAction::ReturnValue' has a wrong offset!");

// Function Zion.Command.GetModule
// 0x0018 (0x0018 - 0x0000)
struct Command_GetModule final
{
public:
	TSubclassOf<class UCommandModule>             CommandModuleClass;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnsureIfMissing;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommandModule*                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_GetModule) == 0x000008, "Wrong alignment on Command_GetModule");
static_assert(sizeof(Command_GetModule) == 0x000018, "Wrong size on Command_GetModule");
static_assert(offsetof(Command_GetModule, CommandModuleClass) == 0x000000, "Member 'Command_GetModule::CommandModuleClass' has a wrong offset!");
static_assert(offsetof(Command_GetModule, bEnsureIfMissing) == 0x000008, "Member 'Command_GetModule::bEnsureIfMissing' has a wrong offset!");
static_assert(offsetof(Command_GetModule, ReturnValue) == 0x000010, "Member 'Command_GetModule::ReturnValue' has a wrong offset!");

// Function Zion.Command.GetMovementComponent
// 0x0008 (0x0008 - 0x0000)
struct Command_GetMovementComponent final
{
public:
	class UMovementComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_GetMovementComponent) == 0x000008, "Wrong alignment on Command_GetMovementComponent");
static_assert(sizeof(Command_GetMovementComponent) == 0x000008, "Wrong size on Command_GetMovementComponent");
static_assert(offsetof(Command_GetMovementComponent, ReturnValue) == 0x000000, "Member 'Command_GetMovementComponent::ReturnValue' has a wrong offset!");

// Function Zion.Command.GetPawn
// 0x0008 (0x0008 - 0x0000)
struct Command_GetPawn final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_GetPawn) == 0x000008, "Wrong alignment on Command_GetPawn");
static_assert(sizeof(Command_GetPawn) == 0x000008, "Wrong size on Command_GetPawn");
static_assert(offsetof(Command_GetPawn, ReturnValue) == 0x000000, "Member 'Command_GetPawn::ReturnValue' has a wrong offset!");

// Function Zion.Command.GetSourceCommandSet
// 0x0008 (0x0008 - 0x0000)
struct Command_GetSourceCommandSet final
{
public:
	const class UCommandSet*                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_GetSourceCommandSet) == 0x000008, "Wrong alignment on Command_GetSourceCommandSet");
static_assert(sizeof(Command_GetSourceCommandSet) == 0x000008, "Wrong size on Command_GetSourceCommandSet");
static_assert(offsetof(Command_GetSourceCommandSet, ReturnValue) == 0x000000, "Member 'Command_GetSourceCommandSet::ReturnValue' has a wrong offset!");

// Function Zion.Command.IsInvokedInputPressed
// 0x0001 (0x0001 - 0x0000)
struct Command_IsInvokedInputPressed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_IsInvokedInputPressed) == 0x000001, "Wrong alignment on Command_IsInvokedInputPressed");
static_assert(sizeof(Command_IsInvokedInputPressed) == 0x000001, "Wrong size on Command_IsInvokedInputPressed");
static_assert(offsetof(Command_IsInvokedInputPressed, ReturnValue) == 0x000000, "Member 'Command_IsInvokedInputPressed::ReturnValue' has a wrong offset!");

// Function Zion.StatusEffectComponent.LaunchStatusEffect
// 0x0001 (0x0001 - 0x0000)
struct StatusEffectComponent_LaunchStatusEffect final
{
public:
	EStatusEffectType                             StatusEffectType;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatusEffectComponent_LaunchStatusEffect) == 0x000001, "Wrong alignment on StatusEffectComponent_LaunchStatusEffect");
static_assert(sizeof(StatusEffectComponent_LaunchStatusEffect) == 0x000001, "Wrong size on StatusEffectComponent_LaunchStatusEffect");
static_assert(offsetof(StatusEffectComponent_LaunchStatusEffect, StatusEffectType) == 0x000000, "Member 'StatusEffectComponent_LaunchStatusEffect::StatusEffectType' has a wrong offset!");

// Function Zion.StatusEffectComponent.LaunchStatusEffectFromClass
// 0x0008 (0x0008 - 0x0000)
struct StatusEffectComponent_LaunchStatusEffectFromClass final
{
public:
	TSubclassOf<class UStatusEffect>              StatusEffectClass;                                 // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatusEffectComponent_LaunchStatusEffectFromClass) == 0x000008, "Wrong alignment on StatusEffectComponent_LaunchStatusEffectFromClass");
static_assert(sizeof(StatusEffectComponent_LaunchStatusEffectFromClass) == 0x000008, "Wrong size on StatusEffectComponent_LaunchStatusEffectFromClass");
static_assert(offsetof(StatusEffectComponent_LaunchStatusEffectFromClass, StatusEffectClass) == 0x000000, "Member 'StatusEffectComponent_LaunchStatusEffectFromClass::StatusEffectClass' has a wrong offset!");

// Function Zion.AbilityHitboxTarget.GetTarget
// 0x0008 (0x0008 - 0x0000)
struct AbilityHitboxTarget_GetTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityHitboxTarget_GetTarget) == 0x000008, "Wrong alignment on AbilityHitboxTarget_GetTarget");
static_assert(sizeof(AbilityHitboxTarget_GetTarget) == 0x000008, "Wrong size on AbilityHitboxTarget_GetTarget");
static_assert(offsetof(AbilityHitboxTarget_GetTarget, ReturnValue) == 0x000000, "Member 'AbilityHitboxTarget_GetTarget::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetMaxResolutionScale
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_GetMaxResolutionScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetMaxResolutionScale) == 0x000004, "Wrong alignment on GameSettingsSubsystem_GetMaxResolutionScale");
static_assert(sizeof(GameSettingsSubsystem_GetMaxResolutionScale) == 0x000004, "Wrong size on GameSettingsSubsystem_GetMaxResolutionScale");
static_assert(offsetof(GameSettingsSubsystem_GetMaxResolutionScale, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetMaxResolutionScale::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetMinResolutionScale
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_GetMinResolutionScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetMinResolutionScale) == 0x000004, "Wrong alignment on GameSettingsSubsystem_GetMinResolutionScale");
static_assert(sizeof(GameSettingsSubsystem_GetMinResolutionScale) == 0x000004, "Wrong size on GameSettingsSubsystem_GetMinResolutionScale");
static_assert(offsetof(GameSettingsSubsystem_GetMinResolutionScale, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetMinResolutionScale::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetAutoClimbDirectionMode
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_ResetAutoClimbDirectionMode final
{
public:
	EAutoClimbDirectionMode                       ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetAutoClimbDirectionMode) == 0x000001, "Wrong alignment on GameSettingsSubsystem_ResetAutoClimbDirectionMode");
static_assert(sizeof(GameSettingsSubsystem_ResetAutoClimbDirectionMode) == 0x000001, "Wrong size on GameSettingsSubsystem_ResetAutoClimbDirectionMode");
static_assert(offsetof(GameSettingsSubsystem_ResetAutoClimbDirectionMode, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetAutoClimbDirectionMode::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetAutoSkipAlreadySeenEvents
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_ResetAutoSkipAlreadySeenEvents final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetAutoSkipAlreadySeenEvents) == 0x000001, "Wrong alignment on GameSettingsSubsystem_ResetAutoSkipAlreadySeenEvents");
static_assert(sizeof(GameSettingsSubsystem_ResetAutoSkipAlreadySeenEvents) == 0x000001, "Wrong size on GameSettingsSubsystem_ResetAutoSkipAlreadySeenEvents");
static_assert(offsetof(GameSettingsSubsystem_ResetAutoSkipAlreadySeenEvents, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetAutoSkipAlreadySeenEvents::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetCameraOscillation
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_ResetCameraOscillation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetCameraOscillation) == 0x000001, "Wrong alignment on GameSettingsSubsystem_ResetCameraOscillation");
static_assert(sizeof(GameSettingsSubsystem_ResetCameraOscillation) == 0x000001, "Wrong size on GameSettingsSubsystem_ResetCameraOscillation");
static_assert(offsetof(GameSettingsSubsystem_ResetCameraOscillation, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetCameraOscillation::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetCameraShake
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_ResetCameraShake final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetCameraShake) == 0x000004, "Wrong alignment on GameSettingsSubsystem_ResetCameraShake");
static_assert(sizeof(GameSettingsSubsystem_ResetCameraShake) == 0x000004, "Wrong size on GameSettingsSubsystem_ResetCameraShake");
static_assert(offsetof(GameSettingsSubsystem_ResetCameraShake, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetCameraShake::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetControllerVibration
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_ResetControllerVibration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetControllerVibration) == 0x000004, "Wrong alignment on GameSettingsSubsystem_ResetControllerVibration");
static_assert(sizeof(GameSettingsSubsystem_ResetControllerVibration) == 0x000004, "Wrong size on GameSettingsSubsystem_ResetControllerVibration");
static_assert(offsetof(GameSettingsSubsystem_ResetControllerVibration, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetControllerVibration::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetDisplayAchievementNotifications
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_ResetDisplayAchievementNotifications final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetDisplayAchievementNotifications) == 0x000001, "Wrong alignment on GameSettingsSubsystem_ResetDisplayAchievementNotifications");
static_assert(sizeof(GameSettingsSubsystem_ResetDisplayAchievementNotifications) == 0x000001, "Wrong size on GameSettingsSubsystem_ResetDisplayAchievementNotifications");
static_assert(offsetof(GameSettingsSubsystem_ResetDisplayAchievementNotifications, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetDisplayAchievementNotifications::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetDisplayDamageValues
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_ResetDisplayDamageValues final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetDisplayDamageValues) == 0x000001, "Wrong alignment on GameSettingsSubsystem_ResetDisplayDamageValues");
static_assert(sizeof(GameSettingsSubsystem_ResetDisplayDamageValues) == 0x000001, "Wrong size on GameSettingsSubsystem_ResetDisplayDamageValues");
static_assert(offsetof(GameSettingsSubsystem_ResetDisplayDamageValues, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetDisplayDamageValues::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetDisplayEnemyGauges
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_ResetDisplayEnemyGauges final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetDisplayEnemyGauges) == 0x000001, "Wrong alignment on GameSettingsSubsystem_ResetDisplayEnemyGauges");
static_assert(sizeof(GameSettingsSubsystem_ResetDisplayEnemyGauges) == 0x000001, "Wrong size on GameSettingsSubsystem_ResetDisplayEnemyGauges");
static_assert(offsetof(GameSettingsSubsystem_ResetDisplayEnemyGauges, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetDisplayEnemyGauges::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetDisplayHealValues
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_ResetDisplayHealValues final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetDisplayHealValues) == 0x000001, "Wrong alignment on GameSettingsSubsystem_ResetDisplayHealValues");
static_assert(sizeof(GameSettingsSubsystem_ResetDisplayHealValues) == 0x000001, "Wrong size on GameSettingsSubsystem_ResetDisplayHealValues");
static_assert(offsetof(GameSettingsSubsystem_ResetDisplayHealValues, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetDisplayHealValues::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetDisplayHPAboveGauge
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_ResetDisplayHPAboveGauge final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetDisplayHPAboveGauge) == 0x000001, "Wrong alignment on GameSettingsSubsystem_ResetDisplayHPAboveGauge");
static_assert(sizeof(GameSettingsSubsystem_ResetDisplayHPAboveGauge) == 0x000001, "Wrong size on GameSettingsSubsystem_ResetDisplayHPAboveGauge");
static_assert(offsetof(GameSettingsSubsystem_ResetDisplayHPAboveGauge, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetDisplayHPAboveGauge::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetDisplayPlayerUI
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_ResetDisplayPlayerUI final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetDisplayPlayerUI) == 0x000001, "Wrong alignment on GameSettingsSubsystem_ResetDisplayPlayerUI");
static_assert(sizeof(GameSettingsSubsystem_ResetDisplayPlayerUI) == 0x000001, "Wrong size on GameSettingsSubsystem_ResetDisplayPlayerUI");
static_assert(offsetof(GameSettingsSubsystem_ResetDisplayPlayerUI, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetDisplayPlayerUI::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetDisplayTutorials
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_ResetDisplayTutorials final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetDisplayTutorials) == 0x000001, "Wrong alignment on GameSettingsSubsystem_ResetDisplayTutorials");
static_assert(sizeof(GameSettingsSubsystem_ResetDisplayTutorials) == 0x000001, "Wrong size on GameSettingsSubsystem_ResetDisplayTutorials");
static_assert(offsetof(GameSettingsSubsystem_ResetDisplayTutorials, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetDisplayTutorials::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetHoldDownToDodgeStill
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_ResetHoldDownToDodgeStill final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetHoldDownToDodgeStill) == 0x000001, "Wrong alignment on GameSettingsSubsystem_ResetHoldDownToDodgeStill");
static_assert(sizeof(GameSettingsSubsystem_ResetHoldDownToDodgeStill) == 0x000001, "Wrong size on GameSettingsSubsystem_ResetHoldDownToDodgeStill");
static_assert(offsetof(GameSettingsSubsystem_ResetHoldDownToDodgeStill, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetHoldDownToDodgeStill::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetLowHPFeedbackOpacity
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_ResetLowHPFeedbackOpacity final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetLowHPFeedbackOpacity) == 0x000004, "Wrong alignment on GameSettingsSubsystem_ResetLowHPFeedbackOpacity");
static_assert(sizeof(GameSettingsSubsystem_ResetLowHPFeedbackOpacity) == 0x000004, "Wrong size on GameSettingsSubsystem_ResetLowHPFeedbackOpacity");
static_assert(offsetof(GameSettingsSubsystem_ResetLowHPFeedbackOpacity, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetLowHPFeedbackOpacity::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetResolutionScale
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_ResetResolutionScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetResolutionScale) == 0x000004, "Wrong alignment on GameSettingsSubsystem_ResetResolutionScale");
static_assert(sizeof(GameSettingsSubsystem_ResetResolutionScale) == 0x000004, "Wrong size on GameSettingsSubsystem_ResetResolutionScale");
static_assert(offsetof(GameSettingsSubsystem_ResetResolutionScale, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_ResetResolutionScale::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.ResetToDefault
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_ResetToDefault final
{
public:
	EGameSettingsType                             GameSettingsToReset;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_ResetToDefault) == 0x000001, "Wrong alignment on GameSettingsSubsystem_ResetToDefault");
static_assert(sizeof(GameSettingsSubsystem_ResetToDefault) == 0x000001, "Wrong size on GameSettingsSubsystem_ResetToDefault");
static_assert(offsetof(GameSettingsSubsystem_ResetToDefault, GameSettingsToReset) == 0x000000, "Member 'GameSettingsSubsystem_ResetToDefault::GameSettingsToReset' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetAntiAliasingMethod
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetAntiAliasingMethod final
{
public:
	EAntiAliasingMethod                           NewAntiAliasingMethod;                             // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAntiAliasingMethod                           ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetAntiAliasingMethod) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetAntiAliasingMethod");
static_assert(sizeof(GameSettingsSubsystem_SetAntiAliasingMethod) == 0x000002, "Wrong size on GameSettingsSubsystem_SetAntiAliasingMethod");
static_assert(offsetof(GameSettingsSubsystem_SetAntiAliasingMethod, NewAntiAliasingMethod) == 0x000000, "Member 'GameSettingsSubsystem_SetAntiAliasingMethod::NewAntiAliasingMethod' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetAntiAliasingMethod, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetAntiAliasingMethod::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetAutoClimbDirectionMode
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetAutoClimbDirectionMode final
{
public:
	EAutoClimbDirectionMode                       NewMode;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAutoClimbDirectionMode                       ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetAutoClimbDirectionMode) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetAutoClimbDirectionMode");
static_assert(sizeof(GameSettingsSubsystem_SetAutoClimbDirectionMode) == 0x000002, "Wrong size on GameSettingsSubsystem_SetAutoClimbDirectionMode");
static_assert(offsetof(GameSettingsSubsystem_SetAutoClimbDirectionMode, NewMode) == 0x000000, "Member 'GameSettingsSubsystem_SetAutoClimbDirectionMode::NewMode' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetAutoClimbDirectionMode, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetAutoClimbDirectionMode::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetAutoSkipAlreadySeenEvents
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetAutoSkipAlreadySeenEvents final
{
public:
	bool                                          bAutoSkip;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetAutoSkipAlreadySeenEvents) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetAutoSkipAlreadySeenEvents");
static_assert(sizeof(GameSettingsSubsystem_SetAutoSkipAlreadySeenEvents) == 0x000002, "Wrong size on GameSettingsSubsystem_SetAutoSkipAlreadySeenEvents");
static_assert(offsetof(GameSettingsSubsystem_SetAutoSkipAlreadySeenEvents, bAutoSkip) == 0x000000, "Member 'GameSettingsSubsystem_SetAutoSkipAlreadySeenEvents::bAutoSkip' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetAutoSkipAlreadySeenEvents, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetAutoSkipAlreadySeenEvents::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetAutoUploadCrashReport
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_SetAutoUploadCrashReport final
{
public:
	bool                                          bNewAutoUploadCrashReport;                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetAutoUploadCrashReport) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetAutoUploadCrashReport");
static_assert(sizeof(GameSettingsSubsystem_SetAutoUploadCrashReport) == 0x000001, "Wrong size on GameSettingsSubsystem_SetAutoUploadCrashReport");
static_assert(offsetof(GameSettingsSubsystem_SetAutoUploadCrashReport, bNewAutoUploadCrashReport) == 0x000000, "Member 'GameSettingsSubsystem_SetAutoUploadCrashReport::bNewAutoUploadCrashReport' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetCameraOscillation
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetCameraOscillation final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetCameraOscillation) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetCameraOscillation");
static_assert(sizeof(GameSettingsSubsystem_SetCameraOscillation) == 0x000002, "Wrong size on GameSettingsSubsystem_SetCameraOscillation");
static_assert(offsetof(GameSettingsSubsystem_SetCameraOscillation, bEnable) == 0x000000, "Member 'GameSettingsSubsystem_SetCameraOscillation::bEnable' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetCameraOscillation, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetCameraOscillation::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetCameraShake
// 0x0008 (0x0008 - 0x0000)
struct GameSettingsSubsystem_SetCameraShake final
{
public:
	float                                         NewCameraShake;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetCameraShake) == 0x000004, "Wrong alignment on GameSettingsSubsystem_SetCameraShake");
static_assert(sizeof(GameSettingsSubsystem_SetCameraShake) == 0x000008, "Wrong size on GameSettingsSubsystem_SetCameraShake");
static_assert(offsetof(GameSettingsSubsystem_SetCameraShake, NewCameraShake) == 0x000000, "Member 'GameSettingsSubsystem_SetCameraShake::NewCameraShake' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetCameraShake, ReturnValue) == 0x000004, "Member 'GameSettingsSubsystem_SetCameraShake::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetConstraintCameraAspectRatio
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetConstraintCameraAspectRatio final
{
public:
	EConstraintCameraAspectRatio                  NewConstraintCameraAspectRatio;                    // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConstraintCameraAspectRatio                  ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetConstraintCameraAspectRatio) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetConstraintCameraAspectRatio");
static_assert(sizeof(GameSettingsSubsystem_SetConstraintCameraAspectRatio) == 0x000002, "Wrong size on GameSettingsSubsystem_SetConstraintCameraAspectRatio");
static_assert(offsetof(GameSettingsSubsystem_SetConstraintCameraAspectRatio, NewConstraintCameraAspectRatio) == 0x000000, "Member 'GameSettingsSubsystem_SetConstraintCameraAspectRatio::NewConstraintCameraAspectRatio' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetConstraintCameraAspectRatio, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetConstraintCameraAspectRatio::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetConstraintHUDAspectRatio
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetConstraintHUDAspectRatio final
{
public:
	bool                                          bNewConstraintHUDAspectRatio;                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetConstraintHUDAspectRatio) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetConstraintHUDAspectRatio");
static_assert(sizeof(GameSettingsSubsystem_SetConstraintHUDAspectRatio) == 0x000002, "Wrong size on GameSettingsSubsystem_SetConstraintHUDAspectRatio");
static_assert(offsetof(GameSettingsSubsystem_SetConstraintHUDAspectRatio, bNewConstraintHUDAspectRatio) == 0x000000, "Member 'GameSettingsSubsystem_SetConstraintHUDAspectRatio::bNewConstraintHUDAspectRatio' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetConstraintHUDAspectRatio, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetConstraintHUDAspectRatio::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetControllerVibration
// 0x0008 (0x0008 - 0x0000)
struct GameSettingsSubsystem_SetControllerVibration final
{
public:
	float                                         NewControllerVibration;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetControllerVibration) == 0x000004, "Wrong alignment on GameSettingsSubsystem_SetControllerVibration");
static_assert(sizeof(GameSettingsSubsystem_SetControllerVibration) == 0x000008, "Wrong size on GameSettingsSubsystem_SetControllerVibration");
static_assert(offsetof(GameSettingsSubsystem_SetControllerVibration, NewControllerVibration) == 0x000000, "Member 'GameSettingsSubsystem_SetControllerVibration::NewControllerVibration' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetControllerVibration, ReturnValue) == 0x000004, "Member 'GameSettingsSubsystem_SetControllerVibration::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetDisplayAchievementNotifications
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetDisplayAchievementNotifications final
{
public:
	bool                                          bDisplay;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetDisplayAchievementNotifications) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetDisplayAchievementNotifications");
static_assert(sizeof(GameSettingsSubsystem_SetDisplayAchievementNotifications) == 0x000002, "Wrong size on GameSettingsSubsystem_SetDisplayAchievementNotifications");
static_assert(offsetof(GameSettingsSubsystem_SetDisplayAchievementNotifications, bDisplay) == 0x000000, "Member 'GameSettingsSubsystem_SetDisplayAchievementNotifications::bDisplay' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetDisplayAchievementNotifications, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetDisplayAchievementNotifications::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetDisplayDamageValues
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetDisplayDamageValues final
{
public:
	bool                                          bDisplayDamageValues;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetDisplayDamageValues) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetDisplayDamageValues");
static_assert(sizeof(GameSettingsSubsystem_SetDisplayDamageValues) == 0x000002, "Wrong size on GameSettingsSubsystem_SetDisplayDamageValues");
static_assert(offsetof(GameSettingsSubsystem_SetDisplayDamageValues, bDisplayDamageValues) == 0x000000, "Member 'GameSettingsSubsystem_SetDisplayDamageValues::bDisplayDamageValues' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetDisplayDamageValues, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetDisplayDamageValues::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetDisplayEnemyGauges
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetDisplayEnemyGauges final
{
public:
	bool                                          bDisplay;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetDisplayEnemyGauges) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetDisplayEnemyGauges");
static_assert(sizeof(GameSettingsSubsystem_SetDisplayEnemyGauges) == 0x000002, "Wrong size on GameSettingsSubsystem_SetDisplayEnemyGauges");
static_assert(offsetof(GameSettingsSubsystem_SetDisplayEnemyGauges, bDisplay) == 0x000000, "Member 'GameSettingsSubsystem_SetDisplayEnemyGauges::bDisplay' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetDisplayEnemyGauges, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetDisplayEnemyGauges::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetDisplayHealValues
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetDisplayHealValues final
{
public:
	bool                                          bDisplayHealValues;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetDisplayHealValues) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetDisplayHealValues");
static_assert(sizeof(GameSettingsSubsystem_SetDisplayHealValues) == 0x000002, "Wrong size on GameSettingsSubsystem_SetDisplayHealValues");
static_assert(offsetof(GameSettingsSubsystem_SetDisplayHealValues, bDisplayHealValues) == 0x000000, "Member 'GameSettingsSubsystem_SetDisplayHealValues::bDisplayHealValues' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetDisplayHealValues, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetDisplayHealValues::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetDisplayHPAboveGauge
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetDisplayHPAboveGauge final
{
public:
	bool                                          bDisplayHPAboveGauge;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetDisplayHPAboveGauge) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetDisplayHPAboveGauge");
static_assert(sizeof(GameSettingsSubsystem_SetDisplayHPAboveGauge) == 0x000002, "Wrong size on GameSettingsSubsystem_SetDisplayHPAboveGauge");
static_assert(offsetof(GameSettingsSubsystem_SetDisplayHPAboveGauge, bDisplayHPAboveGauge) == 0x000000, "Member 'GameSettingsSubsystem_SetDisplayHPAboveGauge::bDisplayHPAboveGauge' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetDisplayHPAboveGauge, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetDisplayHPAboveGauge::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetDisplayPlayerUI
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetDisplayPlayerUI final
{
public:
	bool                                          bDisplay;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetDisplayPlayerUI) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetDisplayPlayerUI");
static_assert(sizeof(GameSettingsSubsystem_SetDisplayPlayerUI) == 0x000002, "Wrong size on GameSettingsSubsystem_SetDisplayPlayerUI");
static_assert(offsetof(GameSettingsSubsystem_SetDisplayPlayerUI, bDisplay) == 0x000000, "Member 'GameSettingsSubsystem_SetDisplayPlayerUI::bDisplay' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetDisplayPlayerUI, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetDisplayPlayerUI::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetDisplayTutorials
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetDisplayTutorials final
{
public:
	bool                                          bDisplay;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetDisplayTutorials) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetDisplayTutorials");
static_assert(sizeof(GameSettingsSubsystem_SetDisplayTutorials) == 0x000002, "Wrong size on GameSettingsSubsystem_SetDisplayTutorials");
static_assert(offsetof(GameSettingsSubsystem_SetDisplayTutorials, bDisplay) == 0x000000, "Member 'GameSettingsSubsystem_SetDisplayTutorials::bDisplay' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetDisplayTutorials, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetDisplayTutorials::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetGamma
// 0x0008 (0x0008 - 0x0000)
struct GameSettingsSubsystem_SetGamma final
{
public:
	float                                         NewGamma;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetGamma) == 0x000004, "Wrong alignment on GameSettingsSubsystem_SetGamma");
static_assert(sizeof(GameSettingsSubsystem_SetGamma) == 0x000008, "Wrong size on GameSettingsSubsystem_SetGamma");
static_assert(offsetof(GameSettingsSubsystem_SetGamma, NewGamma) == 0x000000, "Member 'GameSettingsSubsystem_SetGamma::NewGamma' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetGamma, ReturnValue) == 0x000004, "Member 'GameSettingsSubsystem_SetGamma::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetGammaPercentage
// 0x0008 (0x0008 - 0x0000)
struct GameSettingsSubsystem_SetGammaPercentage final
{
public:
	float                                         NewGammaPercentage;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetGammaPercentage) == 0x000004, "Wrong alignment on GameSettingsSubsystem_SetGammaPercentage");
static_assert(sizeof(GameSettingsSubsystem_SetGammaPercentage) == 0x000008, "Wrong size on GameSettingsSubsystem_SetGammaPercentage");
static_assert(offsetof(GameSettingsSubsystem_SetGammaPercentage, NewGammaPercentage) == 0x000000, "Member 'GameSettingsSubsystem_SetGammaPercentage::NewGammaPercentage' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetGammaPercentage, ReturnValue) == 0x000004, "Member 'GameSettingsSubsystem_SetGammaPercentage::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetHoldDownToDodgeStill
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetHoldDownToDodgeStill final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetHoldDownToDodgeStill) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetHoldDownToDodgeStill");
static_assert(sizeof(GameSettingsSubsystem_SetHoldDownToDodgeStill) == 0x000002, "Wrong size on GameSettingsSubsystem_SetHoldDownToDodgeStill");
static_assert(offsetof(GameSettingsSubsystem_SetHoldDownToDodgeStill, bEnable) == 0x000000, "Member 'GameSettingsSubsystem_SetHoldDownToDodgeStill::bEnable' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetHoldDownToDodgeStill, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetHoldDownToDodgeStill::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetLanguage
// 0x0010 (0x0010 - 0x0000)
struct GameSettingsSubsystem_SetLanguage final
{
public:
	class FString                                 Language;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetLanguage) == 0x000008, "Wrong alignment on GameSettingsSubsystem_SetLanguage");
static_assert(sizeof(GameSettingsSubsystem_SetLanguage) == 0x000010, "Wrong size on GameSettingsSubsystem_SetLanguage");
static_assert(offsetof(GameSettingsSubsystem_SetLanguage, Language) == 0x000000, "Member 'GameSettingsSubsystem_SetLanguage::Language' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetLowHPFeedbackOpacity
// 0x0008 (0x0008 - 0x0000)
struct GameSettingsSubsystem_SetLowHPFeedbackOpacity final
{
public:
	float                                         NewLowHPFeedbackOpacity;                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetLowHPFeedbackOpacity) == 0x000004, "Wrong alignment on GameSettingsSubsystem_SetLowHPFeedbackOpacity");
static_assert(sizeof(GameSettingsSubsystem_SetLowHPFeedbackOpacity) == 0x000008, "Wrong size on GameSettingsSubsystem_SetLowHPFeedbackOpacity");
static_assert(offsetof(GameSettingsSubsystem_SetLowHPFeedbackOpacity, NewLowHPFeedbackOpacity) == 0x000000, "Member 'GameSettingsSubsystem_SetLowHPFeedbackOpacity::NewLowHPFeedbackOpacity' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetLowHPFeedbackOpacity, ReturnValue) == 0x000004, "Member 'GameSettingsSubsystem_SetLowHPFeedbackOpacity::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetResolutionScale
// 0x0008 (0x0008 - 0x0000)
struct GameSettingsSubsystem_SetResolutionScale final
{
public:
	float                                         NewResolutionScale;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetResolutionScale) == 0x000004, "Wrong alignment on GameSettingsSubsystem_SetResolutionScale");
static_assert(sizeof(GameSettingsSubsystem_SetResolutionScale) == 0x000008, "Wrong size on GameSettingsSubsystem_SetResolutionScale");
static_assert(offsetof(GameSettingsSubsystem_SetResolutionScale, NewResolutionScale) == 0x000000, "Member 'GameSettingsSubsystem_SetResolutionScale::NewResolutionScale' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetResolutionScale, ReturnValue) == 0x000004, "Member 'GameSettingsSubsystem_SetResolutionScale::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetStickDeadZone
// 0x000C (0x000C - 0x0000)
struct GameSettingsSubsystem_SetStickDeadZone final
{
public:
	EInputStick                                   InputStick;                                        // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NewDeadZone;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetStickDeadZone) == 0x000004, "Wrong alignment on GameSettingsSubsystem_SetStickDeadZone");
static_assert(sizeof(GameSettingsSubsystem_SetStickDeadZone) == 0x00000C, "Wrong size on GameSettingsSubsystem_SetStickDeadZone");
static_assert(offsetof(GameSettingsSubsystem_SetStickDeadZone, InputStick) == 0x000000, "Member 'GameSettingsSubsystem_SetStickDeadZone::InputStick' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetStickDeadZone, NewDeadZone) == 0x000004, "Member 'GameSettingsSubsystem_SetStickDeadZone::NewDeadZone' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetStickDeadZone, ReturnValue) == 0x000008, "Member 'GameSettingsSubsystem_SetStickDeadZone::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetTitleType
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_SetTitleType final
{
public:
	EGameEndingType                               TitleType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetTitleType) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetTitleType");
static_assert(sizeof(GameSettingsSubsystem_SetTitleType) == 0x000001, "Wrong size on GameSettingsSubsystem_SetTitleType");
static_assert(offsetof(GameSettingsSubsystem_SetTitleType, TitleType) == 0x000000, "Member 'GameSettingsSubsystem_SetTitleType::TitleType' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.SetUIAspectRatio
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_SetUIAspectRatio final
{
public:
	EConstraintCameraAspectRatio                  NewUIAspectRatio;                                  // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConstraintCameraAspectRatio                  ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_SetUIAspectRatio) == 0x000001, "Wrong alignment on GameSettingsSubsystem_SetUIAspectRatio");
static_assert(sizeof(GameSettingsSubsystem_SetUIAspectRatio) == 0x000002, "Wrong size on GameSettingsSubsystem_SetUIAspectRatio");
static_assert(offsetof(GameSettingsSubsystem_SetUIAspectRatio, NewUIAspectRatio) == 0x000000, "Member 'GameSettingsSubsystem_SetUIAspectRatio::NewUIAspectRatio' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_SetUIAspectRatio, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_SetUIAspectRatio::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.DidReachAnyGameEnding
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_DidReachAnyGameEnding final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_DidReachAnyGameEnding) == 0x000001, "Wrong alignment on GameSettingsSubsystem_DidReachAnyGameEnding");
static_assert(sizeof(GameSettingsSubsystem_DidReachAnyGameEnding) == 0x000001, "Wrong size on GameSettingsSubsystem_DidReachAnyGameEnding");
static_assert(offsetof(GameSettingsSubsystem_DidReachAnyGameEnding, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_DidReachAnyGameEnding::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.DidReachGameEnding
// 0x0002 (0x0002 - 0x0000)
struct GameSettingsSubsystem_DidReachGameEnding final
{
public:
	EGameEndingType                               GameEndingType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_DidReachGameEnding) == 0x000001, "Wrong alignment on GameSettingsSubsystem_DidReachGameEnding");
static_assert(sizeof(GameSettingsSubsystem_DidReachGameEnding) == 0x000002, "Wrong size on GameSettingsSubsystem_DidReachGameEnding");
static_assert(offsetof(GameSettingsSubsystem_DidReachGameEnding, GameEndingType) == 0x000000, "Member 'GameSettingsSubsystem_DidReachGameEnding::GameEndingType' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_DidReachGameEnding, ReturnValue) == 0x000001, "Member 'GameSettingsSubsystem_DidReachGameEnding::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetAntiAliasingMethod
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetAntiAliasingMethod final
{
public:
	EAntiAliasingMethod                           ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetAntiAliasingMethod) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetAntiAliasingMethod");
static_assert(sizeof(GameSettingsSubsystem_GetAntiAliasingMethod) == 0x000001, "Wrong size on GameSettingsSubsystem_GetAntiAliasingMethod");
static_assert(offsetof(GameSettingsSubsystem_GetAntiAliasingMethod, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetAntiAliasingMethod::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetAutoClimbDirectionMode
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetAutoClimbDirectionMode final
{
public:
	EAutoClimbDirectionMode                       ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetAutoClimbDirectionMode) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetAutoClimbDirectionMode");
static_assert(sizeof(GameSettingsSubsystem_GetAutoClimbDirectionMode) == 0x000001, "Wrong size on GameSettingsSubsystem_GetAutoClimbDirectionMode");
static_assert(offsetof(GameSettingsSubsystem_GetAutoClimbDirectionMode, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetAutoClimbDirectionMode::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetAutoSkipAlreadySeenEvents
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetAutoSkipAlreadySeenEvents final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetAutoSkipAlreadySeenEvents) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetAutoSkipAlreadySeenEvents");
static_assert(sizeof(GameSettingsSubsystem_GetAutoSkipAlreadySeenEvents) == 0x000001, "Wrong size on GameSettingsSubsystem_GetAutoSkipAlreadySeenEvents");
static_assert(offsetof(GameSettingsSubsystem_GetAutoSkipAlreadySeenEvents, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetAutoSkipAlreadySeenEvents::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetAutoUploadCrashReport
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetAutoUploadCrashReport final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetAutoUploadCrashReport) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetAutoUploadCrashReport");
static_assert(sizeof(GameSettingsSubsystem_GetAutoUploadCrashReport) == 0x000001, "Wrong size on GameSettingsSubsystem_GetAutoUploadCrashReport");
static_assert(offsetof(GameSettingsSubsystem_GetAutoUploadCrashReport, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetAutoUploadCrashReport::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetCameraOscillation
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetCameraOscillation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetCameraOscillation) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetCameraOscillation");
static_assert(sizeof(GameSettingsSubsystem_GetCameraOscillation) == 0x000001, "Wrong size on GameSettingsSubsystem_GetCameraOscillation");
static_assert(offsetof(GameSettingsSubsystem_GetCameraOscillation, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetCameraOscillation::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetCameraShake
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_GetCameraShake final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetCameraShake) == 0x000004, "Wrong alignment on GameSettingsSubsystem_GetCameraShake");
static_assert(sizeof(GameSettingsSubsystem_GetCameraShake) == 0x000004, "Wrong size on GameSettingsSubsystem_GetCameraShake");
static_assert(offsetof(GameSettingsSubsystem_GetCameraShake, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetCameraShake::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetConstraintCameraAspectRatio
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetConstraintCameraAspectRatio final
{
public:
	EConstraintCameraAspectRatio                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetConstraintCameraAspectRatio) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetConstraintCameraAspectRatio");
static_assert(sizeof(GameSettingsSubsystem_GetConstraintCameraAspectRatio) == 0x000001, "Wrong size on GameSettingsSubsystem_GetConstraintCameraAspectRatio");
static_assert(offsetof(GameSettingsSubsystem_GetConstraintCameraAspectRatio, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetConstraintCameraAspectRatio::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetConstraintHUDAspectRatio
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetConstraintHUDAspectRatio final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetConstraintHUDAspectRatio) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetConstraintHUDAspectRatio");
static_assert(sizeof(GameSettingsSubsystem_GetConstraintHUDAspectRatio) == 0x000001, "Wrong size on GameSettingsSubsystem_GetConstraintHUDAspectRatio");
static_assert(offsetof(GameSettingsSubsystem_GetConstraintHUDAspectRatio, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetConstraintHUDAspectRatio::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetControllerVibration
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_GetControllerVibration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetControllerVibration) == 0x000004, "Wrong alignment on GameSettingsSubsystem_GetControllerVibration");
static_assert(sizeof(GameSettingsSubsystem_GetControllerVibration) == 0x000004, "Wrong size on GameSettingsSubsystem_GetControllerVibration");
static_assert(offsetof(GameSettingsSubsystem_GetControllerVibration, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetControllerVibration::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetDisplayAchievementNotifications
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetDisplayAchievementNotifications final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetDisplayAchievementNotifications) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetDisplayAchievementNotifications");
static_assert(sizeof(GameSettingsSubsystem_GetDisplayAchievementNotifications) == 0x000001, "Wrong size on GameSettingsSubsystem_GetDisplayAchievementNotifications");
static_assert(offsetof(GameSettingsSubsystem_GetDisplayAchievementNotifications, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetDisplayAchievementNotifications::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetDisplayDamageValues
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetDisplayDamageValues final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetDisplayDamageValues) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetDisplayDamageValues");
static_assert(sizeof(GameSettingsSubsystem_GetDisplayDamageValues) == 0x000001, "Wrong size on GameSettingsSubsystem_GetDisplayDamageValues");
static_assert(offsetof(GameSettingsSubsystem_GetDisplayDamageValues, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetDisplayDamageValues::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetDisplayEnemyGauges
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetDisplayEnemyGauges final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetDisplayEnemyGauges) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetDisplayEnemyGauges");
static_assert(sizeof(GameSettingsSubsystem_GetDisplayEnemyGauges) == 0x000001, "Wrong size on GameSettingsSubsystem_GetDisplayEnemyGauges");
static_assert(offsetof(GameSettingsSubsystem_GetDisplayEnemyGauges, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetDisplayEnemyGauges::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetDisplayHealValues
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetDisplayHealValues final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetDisplayHealValues) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetDisplayHealValues");
static_assert(sizeof(GameSettingsSubsystem_GetDisplayHealValues) == 0x000001, "Wrong size on GameSettingsSubsystem_GetDisplayHealValues");
static_assert(offsetof(GameSettingsSubsystem_GetDisplayHealValues, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetDisplayHealValues::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetDisplayHPAboveGauge
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetDisplayHPAboveGauge final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetDisplayHPAboveGauge) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetDisplayHPAboveGauge");
static_assert(sizeof(GameSettingsSubsystem_GetDisplayHPAboveGauge) == 0x000001, "Wrong size on GameSettingsSubsystem_GetDisplayHPAboveGauge");
static_assert(offsetof(GameSettingsSubsystem_GetDisplayHPAboveGauge, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetDisplayHPAboveGauge::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetDisplayPlayerUI
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetDisplayPlayerUI final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetDisplayPlayerUI) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetDisplayPlayerUI");
static_assert(sizeof(GameSettingsSubsystem_GetDisplayPlayerUI) == 0x000001, "Wrong size on GameSettingsSubsystem_GetDisplayPlayerUI");
static_assert(offsetof(GameSettingsSubsystem_GetDisplayPlayerUI, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetDisplayPlayerUI::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetDisplayTutorials
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetDisplayTutorials final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetDisplayTutorials) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetDisplayTutorials");
static_assert(sizeof(GameSettingsSubsystem_GetDisplayTutorials) == 0x000001, "Wrong size on GameSettingsSubsystem_GetDisplayTutorials");
static_assert(offsetof(GameSettingsSubsystem_GetDisplayTutorials, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetDisplayTutorials::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetGamma
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_GetGamma final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetGamma) == 0x000004, "Wrong alignment on GameSettingsSubsystem_GetGamma");
static_assert(sizeof(GameSettingsSubsystem_GetGamma) == 0x000004, "Wrong size on GameSettingsSubsystem_GetGamma");
static_assert(offsetof(GameSettingsSubsystem_GetGamma, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetGamma::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetGammaDefault
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_GetGammaDefault final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetGammaDefault) == 0x000004, "Wrong alignment on GameSettingsSubsystem_GetGammaDefault");
static_assert(sizeof(GameSettingsSubsystem_GetGammaDefault) == 0x000004, "Wrong size on GameSettingsSubsystem_GetGammaDefault");
static_assert(offsetof(GameSettingsSubsystem_GetGammaDefault, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetGammaDefault::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetGammaMax
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_GetGammaMax final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetGammaMax) == 0x000004, "Wrong alignment on GameSettingsSubsystem_GetGammaMax");
static_assert(sizeof(GameSettingsSubsystem_GetGammaMax) == 0x000004, "Wrong size on GameSettingsSubsystem_GetGammaMax");
static_assert(offsetof(GameSettingsSubsystem_GetGammaMax, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetGammaMax::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetGammaMin
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_GetGammaMin final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetGammaMin) == 0x000004, "Wrong alignment on GameSettingsSubsystem_GetGammaMin");
static_assert(sizeof(GameSettingsSubsystem_GetGammaMin) == 0x000004, "Wrong size on GameSettingsSubsystem_GetGammaMin");
static_assert(offsetof(GameSettingsSubsystem_GetGammaMin, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetGammaMin::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetGammaPercentage
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_GetGammaPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetGammaPercentage) == 0x000004, "Wrong alignment on GameSettingsSubsystem_GetGammaPercentage");
static_assert(sizeof(GameSettingsSubsystem_GetGammaPercentage) == 0x000004, "Wrong size on GameSettingsSubsystem_GetGammaPercentage");
static_assert(offsetof(GameSettingsSubsystem_GetGammaPercentage, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetGammaPercentage::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetHoldDownToDodgeStill
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetHoldDownToDodgeStill final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetHoldDownToDodgeStill) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetHoldDownToDodgeStill");
static_assert(sizeof(GameSettingsSubsystem_GetHoldDownToDodgeStill) == 0x000001, "Wrong size on GameSettingsSubsystem_GetHoldDownToDodgeStill");
static_assert(offsetof(GameSettingsSubsystem_GetHoldDownToDodgeStill, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetHoldDownToDodgeStill::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetLanguage
// 0x0010 (0x0010 - 0x0000)
struct GameSettingsSubsystem_GetLanguage final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetLanguage) == 0x000008, "Wrong alignment on GameSettingsSubsystem_GetLanguage");
static_assert(sizeof(GameSettingsSubsystem_GetLanguage) == 0x000010, "Wrong size on GameSettingsSubsystem_GetLanguage");
static_assert(offsetof(GameSettingsSubsystem_GetLanguage, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetLanguage::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetLowHPFeedbackOpacity
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_GetLowHPFeedbackOpacity final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetLowHPFeedbackOpacity) == 0x000004, "Wrong alignment on GameSettingsSubsystem_GetLowHPFeedbackOpacity");
static_assert(sizeof(GameSettingsSubsystem_GetLowHPFeedbackOpacity) == 0x000004, "Wrong size on GameSettingsSubsystem_GetLowHPFeedbackOpacity");
static_assert(offsetof(GameSettingsSubsystem_GetLowHPFeedbackOpacity, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetLowHPFeedbackOpacity::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetResolutionScale
// 0x0004 (0x0004 - 0x0000)
struct GameSettingsSubsystem_GetResolutionScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetResolutionScale) == 0x000004, "Wrong alignment on GameSettingsSubsystem_GetResolutionScale");
static_assert(sizeof(GameSettingsSubsystem_GetResolutionScale) == 0x000004, "Wrong size on GameSettingsSubsystem_GetResolutionScale");
static_assert(offsetof(GameSettingsSubsystem_GetResolutionScale, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetResolutionScale::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetStickDeadZone
// 0x0008 (0x0008 - 0x0000)
struct GameSettingsSubsystem_GetStickDeadZone final
{
public:
	EInputStick                                   InputStick;                                        // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetStickDeadZone) == 0x000004, "Wrong alignment on GameSettingsSubsystem_GetStickDeadZone");
static_assert(sizeof(GameSettingsSubsystem_GetStickDeadZone) == 0x000008, "Wrong size on GameSettingsSubsystem_GetStickDeadZone");
static_assert(offsetof(GameSettingsSubsystem_GetStickDeadZone, InputStick) == 0x000000, "Member 'GameSettingsSubsystem_GetStickDeadZone::InputStick' has a wrong offset!");
static_assert(offsetof(GameSettingsSubsystem_GetStickDeadZone, ReturnValue) == 0x000004, "Member 'GameSettingsSubsystem_GetStickDeadZone::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetTitleType
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetTitleType final
{
public:
	EGameEndingType                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetTitleType) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetTitleType");
static_assert(sizeof(GameSettingsSubsystem_GetTitleType) == 0x000001, "Wrong size on GameSettingsSubsystem_GetTitleType");
static_assert(offsetof(GameSettingsSubsystem_GetTitleType, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetTitleType::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.GetUIAspectRatio
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_GetUIAspectRatio final
{
public:
	EConstraintCameraAspectRatio                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_GetUIAspectRatio) == 0x000001, "Wrong alignment on GameSettingsSubsystem_GetUIAspectRatio");
static_assert(sizeof(GameSettingsSubsystem_GetUIAspectRatio) == 0x000001, "Wrong size on GameSettingsSubsystem_GetUIAspectRatio");
static_assert(offsetof(GameSettingsSubsystem_GetUIAspectRatio, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_GetUIAspectRatio::ReturnValue' has a wrong offset!");

// Function Zion.GameSettingsSubsystem.IsInitialSettingsDone
// 0x0001 (0x0001 - 0x0000)
struct GameSettingsSubsystem_IsInitialSettingsDone final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSettingsSubsystem_IsInitialSettingsDone) == 0x000001, "Wrong alignment on GameSettingsSubsystem_IsInitialSettingsDone");
static_assert(sizeof(GameSettingsSubsystem_IsInitialSettingsDone) == 0x000001, "Wrong size on GameSettingsSubsystem_IsInitialSettingsDone");
static_assert(offsetof(GameSettingsSubsystem_IsInitialSettingsDone, ReturnValue) == 0x000000, "Member 'GameSettingsSubsystem_IsInitialSettingsDone::ReturnValue' has a wrong offset!");

// Function Zion.DeathProcess.Initialize
// 0x0008 (0x0008 - 0x0000)
struct DeathProcess_Initialize final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeathProcess_Initialize) == 0x000008, "Wrong alignment on DeathProcess_Initialize");
static_assert(sizeof(DeathProcess_Initialize) == 0x000008, "Wrong size on DeathProcess_Initialize");
static_assert(offsetof(DeathProcess_Initialize, Actor) == 0x000000, "Member 'DeathProcess_Initialize::Actor' has a wrong offset!");

// Function Zion.DeathProcess.Launch
// 0x0008 (0x0008 - 0x0000)
struct DeathProcess_Launch final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeathProcess_Launch) == 0x000008, "Wrong alignment on DeathProcess_Launch");
static_assert(sizeof(DeathProcess_Launch) == 0x000008, "Wrong size on DeathProcess_Launch");
static_assert(offsetof(DeathProcess_Launch, Actor) == 0x000000, "Member 'DeathProcess_Launch::Actor' has a wrong offset!");

// Function Zion.DeathProcess.Update
// 0x0010 (0x0010 - 0x0000)
struct DeathProcess_Update final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DeathProcess_Update) == 0x000008, "Wrong alignment on DeathProcess_Update");
static_assert(sizeof(DeathProcess_Update) == 0x000010, "Wrong size on DeathProcess_Update");
static_assert(offsetof(DeathProcess_Update, Actor) == 0x000000, "Member 'DeathProcess_Update::Actor' has a wrong offset!");
static_assert(offsetof(DeathProcess_Update, DeltaTime) == 0x000008, "Member 'DeathProcess_Update::DeltaTime' has a wrong offset!");

// Function Zion.Trigger_FieldMessage.LaunchFieldMessage
// 0x0008 (0x0008 - 0x0000)
struct Trigger_FieldMessage_LaunchFieldMessage final
{
public:
	class UFieldMessageAsset*                     FieldMessageAssetOverride;                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Trigger_FieldMessage_LaunchFieldMessage) == 0x000008, "Wrong alignment on Trigger_FieldMessage_LaunchFieldMessage");
static_assert(sizeof(Trigger_FieldMessage_LaunchFieldMessage) == 0x000008, "Wrong size on Trigger_FieldMessage_LaunchFieldMessage");
static_assert(offsetof(Trigger_FieldMessage_LaunchFieldMessage, FieldMessageAssetOverride) == 0x000000, "Member 'Trigger_FieldMessage_LaunchFieldMessage::FieldMessageAssetOverride' has a wrong offset!");

// Function Zion.Trigger_FieldMessage.OnClearStatusChecked
// 0x0001 (0x0001 - 0x0000)
struct Trigger_FieldMessage_OnClearStatusChecked final
{
public:
	EClearStatus                                  ClearStatus;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Trigger_FieldMessage_OnClearStatusChecked) == 0x000001, "Wrong alignment on Trigger_FieldMessage_OnClearStatusChecked");
static_assert(sizeof(Trigger_FieldMessage_OnClearStatusChecked) == 0x000001, "Wrong size on Trigger_FieldMessage_OnClearStatusChecked");
static_assert(offsetof(Trigger_FieldMessage_OnClearStatusChecked, ClearStatus) == 0x000000, "Member 'Trigger_FieldMessage_OnClearStatusChecked::ClearStatus' has a wrong offset!");

// Function Zion.Trigger_FieldMessage.GetTargetActor
// 0x0008 (0x0008 - 0x0000)
struct Trigger_FieldMessage_GetTargetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Trigger_FieldMessage_GetTargetActor) == 0x000008, "Wrong alignment on Trigger_FieldMessage_GetTargetActor");
static_assert(sizeof(Trigger_FieldMessage_GetTargetActor) == 0x000008, "Wrong size on Trigger_FieldMessage_GetTargetActor");
static_assert(offsetof(Trigger_FieldMessage_GetTargetActor, ReturnValue) == 0x000000, "Member 'Trigger_FieldMessage_GetTargetActor::ReturnValue' has a wrong offset!");

// Function Zion.Trigger_FieldMessageNPC.OnNPCDestroyed
// 0x0008 (0x0008 - 0x0000)
struct Trigger_FieldMessageNPC_OnNPCDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Trigger_FieldMessageNPC_OnNPCDestroyed) == 0x000008, "Wrong alignment on Trigger_FieldMessageNPC_OnNPCDestroyed");
static_assert(sizeof(Trigger_FieldMessageNPC_OnNPCDestroyed) == 0x000008, "Wrong size on Trigger_FieldMessageNPC_OnNPCDestroyed");
static_assert(offsetof(Trigger_FieldMessageNPC_OnNPCDestroyed, DestroyedActor) == 0x000000, "Member 'Trigger_FieldMessageNPC_OnNPCDestroyed::DestroyedActor' has a wrong offset!");

// Function Zion.Trigger_FieldMessageNPC.GetCollisionComponent
// 0x0008 (0x0008 - 0x0000)
struct Trigger_FieldMessageNPC_GetCollisionComponent final
{
public:
	class UShapeComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Trigger_FieldMessageNPC_GetCollisionComponent) == 0x000008, "Wrong alignment on Trigger_FieldMessageNPC_GetCollisionComponent");
static_assert(sizeof(Trigger_FieldMessageNPC_GetCollisionComponent) == 0x000008, "Wrong size on Trigger_FieldMessageNPC_GetCollisionComponent");
static_assert(offsetof(Trigger_FieldMessageNPC_GetCollisionComponent, ReturnValue) == 0x000000, "Member 'Trigger_FieldMessageNPC_GetCollisionComponent::ReturnValue' has a wrong offset!");

// Function Zion.CommandCondition.GetCharacter
// 0x0008 (0x0008 - 0x0000)
struct CommandCondition_GetCharacter final
{
public:
	class ACharacter*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandCondition_GetCharacter) == 0x000008, "Wrong alignment on CommandCondition_GetCharacter");
static_assert(sizeof(CommandCondition_GetCharacter) == 0x000008, "Wrong size on CommandCondition_GetCharacter");
static_assert(offsetof(CommandCondition_GetCharacter, ReturnValue) == 0x000000, "Member 'CommandCondition_GetCharacter::ReturnValue' has a wrong offset!");

// Function Zion.CommandCondition.GetCommand
// 0x0008 (0x0008 - 0x0000)
struct CommandCondition_GetCommand final
{
public:
	class UCommand*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandCondition_GetCommand) == 0x000008, "Wrong alignment on CommandCondition_GetCommand");
static_assert(sizeof(CommandCondition_GetCommand) == 0x000008, "Wrong size on CommandCondition_GetCommand");
static_assert(offsetof(CommandCondition_GetCommand, ReturnValue) == 0x000000, "Member 'CommandCondition_GetCommand::ReturnValue' has a wrong offset!");

// Function Zion.CommandCondition.OnCheckCondition
// 0x0001 (0x0001 - 0x0000)
struct CommandCondition_OnCheckCondition final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandCondition_OnCheckCondition) == 0x000001, "Wrong alignment on CommandCondition_OnCheckCondition");
static_assert(sizeof(CommandCondition_OnCheckCondition) == 0x000001, "Wrong size on CommandCondition_OnCheckCondition");
static_assert(offsetof(CommandCondition_OnCheckCondition, ReturnValue) == 0x000000, "Member 'CommandCondition_OnCheckCondition::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.ChangeExplanationText
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetZion_ChangeExplanationText final
{
public:
	class FText                                   InExplanationText;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_ChangeExplanationText) == 0x000008, "Wrong alignment on UserWidgetZion_ChangeExplanationText");
static_assert(sizeof(UserWidgetZion_ChangeExplanationText) == 0x000010, "Wrong size on UserWidgetZion_ChangeExplanationText");
static_assert(offsetof(UserWidgetZion_ChangeExplanationText, InExplanationText) == 0x000000, "Member 'UserWidgetZion_ChangeExplanationText::InExplanationText' has a wrong offset!");

// Function Zion.UserWidgetZion.OnChildFocused
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetZion_OnChildFocused final
{
public:
	class UNativeWidgetHost*                      FocusedWidgetHost;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFocusEvent                            FocusEvent;                                        // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnChildFocused) == 0x000008, "Wrong alignment on UserWidgetZion_OnChildFocused");
static_assert(sizeof(UserWidgetZion_OnChildFocused) == 0x000010, "Wrong size on UserWidgetZion_OnChildFocused");
static_assert(offsetof(UserWidgetZion_OnChildFocused, FocusedWidgetHost) == 0x000000, "Member 'UserWidgetZion_OnChildFocused::FocusedWidgetHost' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnChildFocused, FocusEvent) == 0x000008, "Member 'UserWidgetZion_OnChildFocused::FocusEvent' has a wrong offset!");

// Function Zion.UserWidgetZion.OnDownLeft
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnDownLeft final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnDownLeft) == 0x000008, "Wrong alignment on UserWidgetZion_OnDownLeft");
static_assert(sizeof(UserWidgetZion_OnDownLeft) == 0x0000F8, "Wrong size on UserWidgetZion_OnDownLeft");
static_assert(offsetof(UserWidgetZion_OnDownLeft, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnDownLeft::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnDownLeft, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnDownLeft::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnDownNext
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnDownNext final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnDownNext) == 0x000008, "Wrong alignment on UserWidgetZion_OnDownNext");
static_assert(sizeof(UserWidgetZion_OnDownNext) == 0x0000F8, "Wrong size on UserWidgetZion_OnDownNext");
static_assert(offsetof(UserWidgetZion_OnDownNext, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnDownNext::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnDownNext, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnDownNext::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnDownNextAlt
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnDownNextAlt final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnDownNextAlt) == 0x000008, "Wrong alignment on UserWidgetZion_OnDownNextAlt");
static_assert(sizeof(UserWidgetZion_OnDownNextAlt) == 0x0000F8, "Wrong size on UserWidgetZion_OnDownNextAlt");
static_assert(offsetof(UserWidgetZion_OnDownNextAlt, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnDownNextAlt::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnDownNextAlt, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnDownNextAlt::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnDownPrevious
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnDownPrevious final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnDownPrevious) == 0x000008, "Wrong alignment on UserWidgetZion_OnDownPrevious");
static_assert(sizeof(UserWidgetZion_OnDownPrevious) == 0x0000F8, "Wrong size on UserWidgetZion_OnDownPrevious");
static_assert(offsetof(UserWidgetZion_OnDownPrevious, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnDownPrevious::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnDownPrevious, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnDownPrevious::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnDownPreviousAlt
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnDownPreviousAlt final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnDownPreviousAlt) == 0x000008, "Wrong alignment on UserWidgetZion_OnDownPreviousAlt");
static_assert(sizeof(UserWidgetZion_OnDownPreviousAlt) == 0x0000F8, "Wrong size on UserWidgetZion_OnDownPreviousAlt");
static_assert(offsetof(UserWidgetZion_OnDownPreviousAlt, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnDownPreviousAlt::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnDownPreviousAlt, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnDownPreviousAlt::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnDownRight
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnDownRight final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnDownRight) == 0x000008, "Wrong alignment on UserWidgetZion_OnDownRight");
static_assert(sizeof(UserWidgetZion_OnDownRight) == 0x0000F8, "Wrong size on UserWidgetZion_OnDownRight");
static_assert(offsetof(UserWidgetZion_OnDownRight, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnDownRight::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnDownRight, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnDownRight::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnPressCancel
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnPressCancel final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnPressCancel) == 0x000008, "Wrong alignment on UserWidgetZion_OnPressCancel");
static_assert(sizeof(UserWidgetZion_OnPressCancel) == 0x0000F8, "Wrong size on UserWidgetZion_OnPressCancel");
static_assert(offsetof(UserWidgetZion_OnPressCancel, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnPressCancel::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnPressCancel, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnPressCancel::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnPressConfirm
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnPressConfirm final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnPressConfirm) == 0x000008, "Wrong alignment on UserWidgetZion_OnPressConfirm");
static_assert(sizeof(UserWidgetZion_OnPressConfirm) == 0x0000F8, "Wrong size on UserWidgetZion_OnPressConfirm");
static_assert(offsetof(UserWidgetZion_OnPressConfirm, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnPressConfirm::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnPressConfirm, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnPressConfirm::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnPressContext
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnPressContext final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnPressContext) == 0x000008, "Wrong alignment on UserWidgetZion_OnPressContext");
static_assert(sizeof(UserWidgetZion_OnPressContext) == 0x0000F8, "Wrong size on UserWidgetZion_OnPressContext");
static_assert(offsetof(UserWidgetZion_OnPressContext, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnPressContext::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnPressContext, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnPressContext::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnPressContextAlt
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnPressContextAlt final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnPressContextAlt) == 0x000008, "Wrong alignment on UserWidgetZion_OnPressContextAlt");
static_assert(sizeof(UserWidgetZion_OnPressContextAlt) == 0x0000F8, "Wrong size on UserWidgetZion_OnPressContextAlt");
static_assert(offsetof(UserWidgetZion_OnPressContextAlt, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnPressContextAlt::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnPressContextAlt, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnPressContextAlt::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnPressDown
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnPressDown final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnPressDown) == 0x000008, "Wrong alignment on UserWidgetZion_OnPressDown");
static_assert(sizeof(UserWidgetZion_OnPressDown) == 0x0000F8, "Wrong size on UserWidgetZion_OnPressDown");
static_assert(offsetof(UserWidgetZion_OnPressDown, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnPressDown::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnPressDown, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnPressDown::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnPressLeft
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnPressLeft final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnPressLeft) == 0x000008, "Wrong alignment on UserWidgetZion_OnPressLeft");
static_assert(sizeof(UserWidgetZion_OnPressLeft) == 0x0000F8, "Wrong size on UserWidgetZion_OnPressLeft");
static_assert(offsetof(UserWidgetZion_OnPressLeft, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnPressLeft::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnPressLeft, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnPressLeft::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnPressNext
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnPressNext final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnPressNext) == 0x000008, "Wrong alignment on UserWidgetZion_OnPressNext");
static_assert(sizeof(UserWidgetZion_OnPressNext) == 0x0000F8, "Wrong size on UserWidgetZion_OnPressNext");
static_assert(offsetof(UserWidgetZion_OnPressNext, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnPressNext::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnPressNext, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnPressNext::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnPressNextAlt
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnPressNextAlt final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnPressNextAlt) == 0x000008, "Wrong alignment on UserWidgetZion_OnPressNextAlt");
static_assert(sizeof(UserWidgetZion_OnPressNextAlt) == 0x0000F8, "Wrong size on UserWidgetZion_OnPressNextAlt");
static_assert(offsetof(UserWidgetZion_OnPressNextAlt, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnPressNextAlt::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnPressNextAlt, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnPressNextAlt::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnPressPrevious
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnPressPrevious final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnPressPrevious) == 0x000008, "Wrong alignment on UserWidgetZion_OnPressPrevious");
static_assert(sizeof(UserWidgetZion_OnPressPrevious) == 0x0000F8, "Wrong size on UserWidgetZion_OnPressPrevious");
static_assert(offsetof(UserWidgetZion_OnPressPrevious, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnPressPrevious::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnPressPrevious, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnPressPrevious::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnPressPreviousAlt
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnPressPreviousAlt final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnPressPreviousAlt) == 0x000008, "Wrong alignment on UserWidgetZion_OnPressPreviousAlt");
static_assert(sizeof(UserWidgetZion_OnPressPreviousAlt) == 0x0000F8, "Wrong size on UserWidgetZion_OnPressPreviousAlt");
static_assert(offsetof(UserWidgetZion_OnPressPreviousAlt, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnPressPreviousAlt::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnPressPreviousAlt, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnPressPreviousAlt::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnPressRight
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnPressRight final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnPressRight) == 0x000008, "Wrong alignment on UserWidgetZion_OnPressRight");
static_assert(sizeof(UserWidgetZion_OnPressRight) == 0x0000F8, "Wrong size on UserWidgetZion_OnPressRight");
static_assert(offsetof(UserWidgetZion_OnPressRight, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnPressRight::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnPressRight, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnPressRight::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnPressUp
// 0x00F8 (0x00F8 - 0x0000)
struct UserWidgetZion_OnPressUp final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FEventReply                            ReturnValue;                                       // 0x0040(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnPressUp) == 0x000008, "Wrong alignment on UserWidgetZion_OnPressUp");
static_assert(sizeof(UserWidgetZion_OnPressUp) == 0x0000F8, "Wrong size on UserWidgetZion_OnPressUp");
static_assert(offsetof(UserWidgetZion_OnPressUp, KeyEvent) == 0x000000, "Member 'UserWidgetZion_OnPressUp::KeyEvent' has a wrong offset!");
static_assert(offsetof(UserWidgetZion_OnPressUp, ReturnValue) == 0x000040, "Member 'UserWidgetZion_OnPressUp::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.OnSetIsEnabled
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetZion_OnSetIsEnabled final
{
public:
	bool                                          bInIsEnabled;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_OnSetIsEnabled) == 0x000001, "Wrong alignment on UserWidgetZion_OnSetIsEnabled");
static_assert(sizeof(UserWidgetZion_OnSetIsEnabled) == 0x000001, "Wrong size on UserWidgetZion_OnSetIsEnabled");
static_assert(offsetof(UserWidgetZion_OnSetIsEnabled, bInIsEnabled) == 0x000000, "Member 'UserWidgetZion_OnSetIsEnabled::bInIsEnabled' has a wrong offset!");

// Function Zion.UserWidgetZion.SetFocusToLastFocusedChild
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetZion_SetFocusToLastFocusedChild final
{
public:
	class UWidget*                                FallbackWidget;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_SetFocusToLastFocusedChild) == 0x000008, "Wrong alignment on UserWidgetZion_SetFocusToLastFocusedChild");
static_assert(sizeof(UserWidgetZion_SetFocusToLastFocusedChild) == 0x000008, "Wrong size on UserWidgetZion_SetFocusToLastFocusedChild");
static_assert(offsetof(UserWidgetZion_SetFocusToLastFocusedChild, FallbackWidget) == 0x000000, "Member 'UserWidgetZion_SetFocusToLastFocusedChild::FallbackWidget' has a wrong offset!");

// Function Zion.UserWidgetZion.IsFocusedFromMouse
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetZion_IsFocusedFromMouse final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_IsFocusedFromMouse) == 0x000001, "Wrong alignment on UserWidgetZion_IsFocusedFromMouse");
static_assert(sizeof(UserWidgetZion_IsFocusedFromMouse) == 0x000001, "Wrong size on UserWidgetZion_IsFocusedFromMouse");
static_assert(offsetof(UserWidgetZion_IsFocusedFromMouse, ReturnValue) == 0x000000, "Member 'UserWidgetZion_IsFocusedFromMouse::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.IsOnFocusPath
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetZion_IsOnFocusPath final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_IsOnFocusPath) == 0x000001, "Wrong alignment on UserWidgetZion_IsOnFocusPath");
static_assert(sizeof(UserWidgetZion_IsOnFocusPath) == 0x000001, "Wrong size on UserWidgetZion_IsOnFocusPath");
static_assert(offsetof(UserWidgetZion_IsOnFocusPath, ReturnValue) == 0x000000, "Member 'UserWidgetZion_IsOnFocusPath::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetZion.PlaySoundEvent
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetZion_PlaySoundEvent final
{
public:
	class UFMODEvent*                             SoundEffect;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZion_PlaySoundEvent) == 0x000008, "Wrong alignment on UserWidgetZion_PlaySoundEvent");
static_assert(sizeof(UserWidgetZion_PlaySoundEvent) == 0x000008, "Wrong size on UserWidgetZion_PlaySoundEvent");
static_assert(offsetof(UserWidgetZion_PlaySoundEvent, SoundEffect) == 0x000000, "Member 'UserWidgetZion_PlaySoundEvent::SoundEffect' has a wrong offset!");

// Function Zion.UserWidgetEvent.CompleteChoices
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetEvent_CompleteChoices final
{
public:
	int32                                         SelectedChoiceIndex;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetEvent_CompleteChoices) == 0x000004, "Wrong alignment on UserWidgetEvent_CompleteChoices");
static_assert(sizeof(UserWidgetEvent_CompleteChoices) == 0x000004, "Wrong size on UserWidgetEvent_CompleteChoices");
static_assert(offsetof(UserWidgetEvent_CompleteChoices, SelectedChoiceIndex) == 0x000000, "Member 'UserWidgetEvent_CompleteChoices::SelectedChoiceIndex' has a wrong offset!");

// Function Zion.UserWidgetEvent.OnPlayChoices
// 0x0030 (0x0030 - 0x0000)
struct UserWidgetEvent_OnPlayChoices final
{
public:
	class FText                                   SpeakerName;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FText>                           Choices;                                           // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetEvent_OnPlayChoices) == 0x000008, "Wrong alignment on UserWidgetEvent_OnPlayChoices");
static_assert(sizeof(UserWidgetEvent_OnPlayChoices) == 0x000030, "Wrong size on UserWidgetEvent_OnPlayChoices");
static_assert(offsetof(UserWidgetEvent_OnPlayChoices, SpeakerName) == 0x000000, "Member 'UserWidgetEvent_OnPlayChoices::SpeakerName' has a wrong offset!");
static_assert(offsetof(UserWidgetEvent_OnPlayChoices, Text) == 0x000010, "Member 'UserWidgetEvent_OnPlayChoices::Text' has a wrong offset!");
static_assert(offsetof(UserWidgetEvent_OnPlayChoices, Choices) == 0x000020, "Member 'UserWidgetEvent_OnPlayChoices::Choices' has a wrong offset!");

// Function Zion.UserWidgetEvent.OnTalk
// 0x0028 (0x0028 - 0x0000)
struct UserWidgetEvent_OnTalk final
{
public:
	class FText                                   SpeakerName;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserWidgetEvent_OnTalk) == 0x000008, "Wrong alignment on UserWidgetEvent_OnTalk");
static_assert(sizeof(UserWidgetEvent_OnTalk) == 0x000028, "Wrong size on UserWidgetEvent_OnTalk");
static_assert(offsetof(UserWidgetEvent_OnTalk, SpeakerName) == 0x000000, "Member 'UserWidgetEvent_OnTalk::SpeakerName' has a wrong offset!");
static_assert(offsetof(UserWidgetEvent_OnTalk, Text) == 0x000010, "Member 'UserWidgetEvent_OnTalk::Text' has a wrong offset!");
static_assert(offsetof(UserWidgetEvent_OnTalk, Duration) == 0x000020, "Member 'UserWidgetEvent_OnTalk::Duration' has a wrong offset!");

// Function Zion.UserWidgetEvent.CanAutoSkipEvent
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetEvent_CanAutoSkipEvent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetEvent_CanAutoSkipEvent) == 0x000001, "Wrong alignment on UserWidgetEvent_CanAutoSkipEvent");
static_assert(sizeof(UserWidgetEvent_CanAutoSkipEvent) == 0x000001, "Wrong size on UserWidgetEvent_CanAutoSkipEvent");
static_assert(offsetof(UserWidgetEvent_CanAutoSkipEvent, ReturnValue) == 0x000000, "Member 'UserWidgetEvent_CanAutoSkipEvent::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetEvent.CanSkipEvent
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetEvent_CanSkipEvent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetEvent_CanSkipEvent) == 0x000001, "Wrong alignment on UserWidgetEvent_CanSkipEvent");
static_assert(sizeof(UserWidgetEvent_CanSkipEvent) == 0x000001, "Wrong size on UserWidgetEvent_CanSkipEvent");
static_assert(offsetof(UserWidgetEvent_CanSkipEvent, ReturnValue) == 0x000000, "Member 'UserWidgetEvent_CanSkipEvent::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetEvent.GetEventPlayer
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetEvent_GetEventPlayer final
{
public:
	class UEventPlayer*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetEvent_GetEventPlayer) == 0x000008, "Wrong alignment on UserWidgetEvent_GetEventPlayer");
static_assert(sizeof(UserWidgetEvent_GetEventPlayer) == 0x000008, "Wrong size on UserWidgetEvent_GetEventPlayer");
static_assert(offsetof(UserWidgetEvent_GetEventPlayer, ReturnValue) == 0x000000, "Member 'UserWidgetEvent_GetEventPlayer::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetEvent.IsEventAlreadySeen
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetEvent_IsEventAlreadySeen final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetEvent_IsEventAlreadySeen) == 0x000001, "Wrong alignment on UserWidgetEvent_IsEventAlreadySeen");
static_assert(sizeof(UserWidgetEvent_IsEventAlreadySeen) == 0x000001, "Wrong size on UserWidgetEvent_IsEventAlreadySeen");
static_assert(offsetof(UserWidgetEvent_IsEventAlreadySeen, ReturnValue) == 0x000000, "Member 'UserWidgetEvent_IsEventAlreadySeen::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetEvent.ShouldUsePostSkipFadeIn
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetEvent_ShouldUsePostSkipFadeIn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetEvent_ShouldUsePostSkipFadeIn) == 0x000001, "Wrong alignment on UserWidgetEvent_ShouldUsePostSkipFadeIn");
static_assert(sizeof(UserWidgetEvent_ShouldUsePostSkipFadeIn) == 0x000001, "Wrong size on UserWidgetEvent_ShouldUsePostSkipFadeIn");
static_assert(offsetof(UserWidgetEvent_ShouldUsePostSkipFadeIn, ReturnValue) == 0x000000, "Member 'UserWidgetEvent_ShouldUsePostSkipFadeIn::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetEvent.ShouldUsePreSkipFadeOut
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetEvent_ShouldUsePreSkipFadeOut final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetEvent_ShouldUsePreSkipFadeOut) == 0x000001, "Wrong alignment on UserWidgetEvent_ShouldUsePreSkipFadeOut");
static_assert(sizeof(UserWidgetEvent_ShouldUsePreSkipFadeOut) == 0x000001, "Wrong size on UserWidgetEvent_ShouldUsePreSkipFadeOut");
static_assert(offsetof(UserWidgetEvent_ShouldUsePreSkipFadeOut, ReturnValue) == 0x000000, "Member 'UserWidgetEvent_ShouldUsePreSkipFadeOut::ReturnValue' has a wrong offset!");

// Function Zion.Collectable.Collect
// 0x0008 (0x0008 - 0x0000)
struct Collectable_Collect final
{
public:
	class AActor*                                 CollectActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Collectable_Collect) == 0x000008, "Wrong alignment on Collectable_Collect");
static_assert(sizeof(Collectable_Collect) == 0x000008, "Wrong size on Collectable_Collect");
static_assert(offsetof(Collectable_Collect, CollectActor) == 0x000000, "Member 'Collectable_Collect::CollectActor' has a wrong offset!");

// Function Zion.Collectable.OnPostSwitchZone
// 0x0008 (0x0008 - 0x0000)
struct Collectable_OnPostSwitchZone final
{
public:
	const class AStaticVolume_Zone*               ActiveZone;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Collectable_OnPostSwitchZone) == 0x000008, "Wrong alignment on Collectable_OnPostSwitchZone");
static_assert(sizeof(Collectable_OnPostSwitchZone) == 0x000008, "Wrong size on Collectable_OnPostSwitchZone");
static_assert(offsetof(Collectable_OnPostSwitchZone, ActiveZone) == 0x000000, "Member 'Collectable_OnPostSwitchZone::ActiveZone' has a wrong offset!");

// Function Zion.Collectable.OnTargetOverlapBegin
// 0x0118 (0x0118 - 0x0000)
struct Collectable_OnTargetOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlapComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Collectable_OnTargetOverlapBegin) == 0x000008, "Wrong alignment on Collectable_OnTargetOverlapBegin");
static_assert(sizeof(Collectable_OnTargetOverlapBegin) == 0x000118, "Wrong size on Collectable_OnTargetOverlapBegin");
static_assert(offsetof(Collectable_OnTargetOverlapBegin, OverlapComponent) == 0x000000, "Member 'Collectable_OnTargetOverlapBegin::OverlapComponent' has a wrong offset!");
static_assert(offsetof(Collectable_OnTargetOverlapBegin, OtherActor) == 0x000008, "Member 'Collectable_OnTargetOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(Collectable_OnTargetOverlapBegin, OtherComp) == 0x000010, "Member 'Collectable_OnTargetOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(Collectable_OnTargetOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'Collectable_OnTargetOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(Collectable_OnTargetOverlapBegin, bFromSweep) == 0x00001C, "Member 'Collectable_OnTargetOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(Collectable_OnTargetOverlapBegin, SweepResult) == 0x000020, "Member 'Collectable_OnTargetOverlapBegin::SweepResult' has a wrong offset!");

// Function Zion.Collectable.SetActive
// 0x0001 (0x0001 - 0x0000)
struct Collectable_SetActive final
{
public:
	bool                                          bSetActive;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Collectable_SetActive) == 0x000001, "Wrong alignment on Collectable_SetActive");
static_assert(sizeof(Collectable_SetActive) == 0x000001, "Wrong size on Collectable_SetActive");
static_assert(offsetof(Collectable_SetActive, bSetActive) == 0x000000, "Member 'Collectable_SetActive::bSetActive' has a wrong offset!");

// Function Zion.Collectable.GetCollectingActor
// 0x0008 (0x0008 - 0x0000)
struct Collectable_GetCollectingActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Collectable_GetCollectingActor) == 0x000008, "Wrong alignment on Collectable_GetCollectingActor");
static_assert(sizeof(Collectable_GetCollectingActor) == 0x000008, "Wrong size on Collectable_GetCollectingActor");
static_assert(offsetof(Collectable_GetCollectingActor, ReturnValue) == 0x000000, "Member 'Collectable_GetCollectingActor::ReturnValue' has a wrong offset!");

// Function Zion.Collectable.GetTargetDetectionRange
// 0x0004 (0x0004 - 0x0000)
struct Collectable_GetTargetDetectionRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Collectable_GetTargetDetectionRange) == 0x000004, "Wrong alignment on Collectable_GetTargetDetectionRange");
static_assert(sizeof(Collectable_GetTargetDetectionRange) == 0x000004, "Wrong size on Collectable_GetTargetDetectionRange");
static_assert(offsetof(Collectable_GetTargetDetectionRange, ReturnValue) == 0x000000, "Member 'Collectable_GetTargetDetectionRange::ReturnValue' has a wrong offset!");

// Function Zion.Collectable.IsActive
// 0x0001 (0x0001 - 0x0000)
struct Collectable_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Collectable_IsActive) == 0x000001, "Wrong alignment on Collectable_IsActive");
static_assert(sizeof(Collectable_IsActive) == 0x000001, "Wrong size on Collectable_IsActive");
static_assert(offsetof(Collectable_IsActive, ReturnValue) == 0x000000, "Member 'Collectable_IsActive::ReturnValue' has a wrong offset!");

// Function Zion.RefreshableRichTextBlock.SetDecoratorMode
// 0x0001 (0x0001 - 0x0000)
struct RefreshableRichTextBlock_SetDecoratorMode final
{
public:
	ERichTextDecoratorMode                        NewDecoratorMode;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RefreshableRichTextBlock_SetDecoratorMode) == 0x000001, "Wrong alignment on RefreshableRichTextBlock_SetDecoratorMode");
static_assert(sizeof(RefreshableRichTextBlock_SetDecoratorMode) == 0x000001, "Wrong size on RefreshableRichTextBlock_SetDecoratorMode");
static_assert(offsetof(RefreshableRichTextBlock_SetDecoratorMode, NewDecoratorMode) == 0x000000, "Member 'RefreshableRichTextBlock_SetDecoratorMode::NewDecoratorMode' has a wrong offset!");

// Function Zion.RefreshableRichTextBlock.SetFormat
// 0x0010 (0x0010 - 0x0000)
struct RefreshableRichTextBlock_SetFormat final
{
public:
	class FText                                   NewFormat;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(RefreshableRichTextBlock_SetFormat) == 0x000008, "Wrong alignment on RefreshableRichTextBlock_SetFormat");
static_assert(sizeof(RefreshableRichTextBlock_SetFormat) == 0x000010, "Wrong size on RefreshableRichTextBlock_SetFormat");
static_assert(offsetof(RefreshableRichTextBlock_SetFormat, NewFormat) == 0x000000, "Member 'RefreshableRichTextBlock_SetFormat::NewFormat' has a wrong offset!");

// Function Zion.RefreshableRichTextBlock.SetFormatElements
// 0x0020 (0x0020 - 0x0000)
struct RefreshableRichTextBlock_SetFormatElements final
{
public:
	TArray<struct FRichTextInputElement>          NewFormatElements;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FString>                         NewStringElements;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(RefreshableRichTextBlock_SetFormatElements) == 0x000008, "Wrong alignment on RefreshableRichTextBlock_SetFormatElements");
static_assert(sizeof(RefreshableRichTextBlock_SetFormatElements) == 0x000020, "Wrong size on RefreshableRichTextBlock_SetFormatElements");
static_assert(offsetof(RefreshableRichTextBlock_SetFormatElements, NewFormatElements) == 0x000000, "Member 'RefreshableRichTextBlock_SetFormatElements::NewFormatElements' has a wrong offset!");
static_assert(offsetof(RefreshableRichTextBlock_SetFormatElements, NewStringElements) == 0x000010, "Member 'RefreshableRichTextBlock_SetFormatElements::NewStringElements' has a wrong offset!");

// Function Zion.RefreshableRichTextBlock.SetupAndRefresh
// 0x0030 (0x0030 - 0x0000)
struct RefreshableRichTextBlock_SetupAndRefresh final
{
public:
	class FText                                   NewFormat;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FRichTextInputElement>          NewFormatElements;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FString>                         NewStringElements;                                 // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(RefreshableRichTextBlock_SetupAndRefresh) == 0x000008, "Wrong alignment on RefreshableRichTextBlock_SetupAndRefresh");
static_assert(sizeof(RefreshableRichTextBlock_SetupAndRefresh) == 0x000030, "Wrong size on RefreshableRichTextBlock_SetupAndRefresh");
static_assert(offsetof(RefreshableRichTextBlock_SetupAndRefresh, NewFormat) == 0x000000, "Member 'RefreshableRichTextBlock_SetupAndRefresh::NewFormat' has a wrong offset!");
static_assert(offsetof(RefreshableRichTextBlock_SetupAndRefresh, NewFormatElements) == 0x000010, "Member 'RefreshableRichTextBlock_SetupAndRefresh::NewFormatElements' has a wrong offset!");
static_assert(offsetof(RefreshableRichTextBlock_SetupAndRefresh, NewStringElements) == 0x000020, "Member 'RefreshableRichTextBlock_SetupAndRefresh::NewStringElements' has a wrong offset!");

// Function Zion.RefreshableRichTextBlock.GetDecoratorMode
// 0x0001 (0x0001 - 0x0000)
struct RefreshableRichTextBlock_GetDecoratorMode final
{
public:
	ERichTextDecoratorMode                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RefreshableRichTextBlock_GetDecoratorMode) == 0x000001, "Wrong alignment on RefreshableRichTextBlock_GetDecoratorMode");
static_assert(sizeof(RefreshableRichTextBlock_GetDecoratorMode) == 0x000001, "Wrong size on RefreshableRichTextBlock_GetDecoratorMode");
static_assert(offsetof(RefreshableRichTextBlock_GetDecoratorMode, ReturnValue) == 0x000000, "Member 'RefreshableRichTextBlock_GetDecoratorMode::ReturnValue' has a wrong offset!");

// Function Zion.RefreshableRichTextBlock.GetFormatElements
// 0x0010 (0x0010 - 0x0000)
struct RefreshableRichTextBlock_GetFormatElements final
{
public:
	TArray<struct FRichTextInputElement>          ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(RefreshableRichTextBlock_GetFormatElements) == 0x000008, "Wrong alignment on RefreshableRichTextBlock_GetFormatElements");
static_assert(sizeof(RefreshableRichTextBlock_GetFormatElements) == 0x000010, "Wrong size on RefreshableRichTextBlock_GetFormatElements");
static_assert(offsetof(RefreshableRichTextBlock_GetFormatElements, ReturnValue) == 0x000000, "Member 'RefreshableRichTextBlock_GetFormatElements::ReturnValue' has a wrong offset!");

// Function Zion.DebugDisplayComponent.OnAnimationEnd
// 0x0008 (0x0008 - 0x0000)
struct DebugDisplayComponent_OnAnimationEnd final
{
public:
	class UTrackEntry*                            Entry;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugDisplayComponent_OnAnimationEnd) == 0x000008, "Wrong alignment on DebugDisplayComponent_OnAnimationEnd");
static_assert(sizeof(DebugDisplayComponent_OnAnimationEnd) == 0x000008, "Wrong size on DebugDisplayComponent_OnAnimationEnd");
static_assert(offsetof(DebugDisplayComponent_OnAnimationEnd, Entry) == 0x000000, "Member 'DebugDisplayComponent_OnAnimationEnd::Entry' has a wrong offset!");

// Function Zion.DebugDisplayComponent.OnAnimationStart
// 0x0008 (0x0008 - 0x0000)
struct DebugDisplayComponent_OnAnimationStart final
{
public:
	class UTrackEntry*                            Entry;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugDisplayComponent_OnAnimationStart) == 0x000008, "Wrong alignment on DebugDisplayComponent_OnAnimationStart");
static_assert(sizeof(DebugDisplayComponent_OnAnimationStart) == 0x000008, "Wrong size on DebugDisplayComponent_OnAnimationStart");
static_assert(offsetof(DebugDisplayComponent_OnAnimationStart, Entry) == 0x000000, "Member 'DebugDisplayComponent_OnAnimationStart::Entry' has a wrong offset!");

// Function Zion.DebugDisplayComponent.OnCommandFinished
// 0x0010 (0x0010 - 0x0000)
struct DebugDisplayComponent_OnCommandFinished final
{
public:
	const class UCommand*                         Command;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommandFinishType                            FinishType;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DebugDisplayComponent_OnCommandFinished) == 0x000008, "Wrong alignment on DebugDisplayComponent_OnCommandFinished");
static_assert(sizeof(DebugDisplayComponent_OnCommandFinished) == 0x000010, "Wrong size on DebugDisplayComponent_OnCommandFinished");
static_assert(offsetof(DebugDisplayComponent_OnCommandFinished, Command) == 0x000000, "Member 'DebugDisplayComponent_OnCommandFinished::Command' has a wrong offset!");
static_assert(offsetof(DebugDisplayComponent_OnCommandFinished, FinishType) == 0x000008, "Member 'DebugDisplayComponent_OnCommandFinished::FinishType' has a wrong offset!");

// Function Zion.DebugDisplayComponent.OnCommandStart
// 0x0008 (0x0008 - 0x0000)
struct DebugDisplayComponent_OnCommandStart final
{
public:
	const class UCommand*                         Command;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugDisplayComponent_OnCommandStart) == 0x000008, "Wrong alignment on DebugDisplayComponent_OnCommandStart");
static_assert(sizeof(DebugDisplayComponent_OnCommandStart) == 0x000008, "Wrong size on DebugDisplayComponent_OnCommandStart");
static_assert(offsetof(DebugDisplayComponent_OnCommandStart, Command) == 0x000000, "Member 'DebugDisplayComponent_OnCommandStart::Command' has a wrong offset!");

// Function Zion.DebugDisplayComponent.OnMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct DebugDisplayComponent_OnMovementModeChanged final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DebugDisplayComponent_OnMovementModeChanged) == 0x000008, "Wrong alignment on DebugDisplayComponent_OnMovementModeChanged");
static_assert(sizeof(DebugDisplayComponent_OnMovementModeChanged) == 0x000010, "Wrong size on DebugDisplayComponent_OnMovementModeChanged");
static_assert(offsetof(DebugDisplayComponent_OnMovementModeChanged, Character) == 0x000000, "Member 'DebugDisplayComponent_OnMovementModeChanged::Character' has a wrong offset!");
static_assert(offsetof(DebugDisplayComponent_OnMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'DebugDisplayComponent_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(DebugDisplayComponent_OnMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'DebugDisplayComponent_OnMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function Zion.Trigger_Event.OnEventFinished
// 0x0010 (0x0010 - 0x0000)
struct Trigger_Event_OnEventFinished final
{
public:
	class UEventPlayer*                           InEventPlayer;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompletedEvent;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEventPlayerResult                            EventResult;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Trigger_Event_OnEventFinished) == 0x000008, "Wrong alignment on Trigger_Event_OnEventFinished");
static_assert(sizeof(Trigger_Event_OnEventFinished) == 0x000010, "Wrong size on Trigger_Event_OnEventFinished");
static_assert(offsetof(Trigger_Event_OnEventFinished, InEventPlayer) == 0x000000, "Member 'Trigger_Event_OnEventFinished::InEventPlayer' has a wrong offset!");
static_assert(offsetof(Trigger_Event_OnEventFinished, bCompletedEvent) == 0x000008, "Member 'Trigger_Event_OnEventFinished::bCompletedEvent' has a wrong offset!");
static_assert(offsetof(Trigger_Event_OnEventFinished, EventResult) == 0x000009, "Member 'Trigger_Event_OnEventFinished::EventResult' has a wrong offset!");

// Function Zion.DelayFrameAsyncAction.DelayFrame
// 0x0018 (0x0018 - 0x0000)
struct DelayFrameAsyncAction_DelayFrame final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DelayInFrames;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDelayFrameAsyncAction*                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DelayFrameAsyncAction_DelayFrame) == 0x000008, "Wrong alignment on DelayFrameAsyncAction_DelayFrame");
static_assert(sizeof(DelayFrameAsyncAction_DelayFrame) == 0x000018, "Wrong size on DelayFrameAsyncAction_DelayFrame");
static_assert(offsetof(DelayFrameAsyncAction_DelayFrame, WorldContextObject) == 0x000000, "Member 'DelayFrameAsyncAction_DelayFrame::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DelayFrameAsyncAction_DelayFrame, DelayInFrames) == 0x000008, "Member 'DelayFrameAsyncAction_DelayFrame::DelayInFrames' has a wrong offset!");
static_assert(offsetof(DelayFrameAsyncAction_DelayFrame, ReturnValue) == 0x000010, "Member 'DelayFrameAsyncAction_DelayFrame::ReturnValue' has a wrong offset!");

// Function Zion.CommandCharge.OnChargeLevelUp
// 0x0004 (0x0004 - 0x0000)
struct CommandCharge_OnChargeLevelUp final
{
public:
	int32                                         NewChargeLevel;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandCharge_OnChargeLevelUp) == 0x000004, "Wrong alignment on CommandCharge_OnChargeLevelUp");
static_assert(sizeof(CommandCharge_OnChargeLevelUp) == 0x000004, "Wrong size on CommandCharge_OnChargeLevelUp");
static_assert(offsetof(CommandCharge_OnChargeLevelUp, NewChargeLevel) == 0x000000, "Member 'CommandCharge_OnChargeLevelUp::NewChargeLevel' has a wrong offset!");

// Function Zion.CommandCharge.GetChargeLevel
// 0x0004 (0x0004 - 0x0000)
struct CommandCharge_GetChargeLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandCharge_GetChargeLevel) == 0x000004, "Wrong alignment on CommandCharge_GetChargeLevel");
static_assert(sizeof(CommandCharge_GetChargeLevel) == 0x000004, "Wrong size on CommandCharge_GetChargeLevel");
static_assert(offsetof(CommandCharge_GetChargeLevel, ReturnValue) == 0x000000, "Member 'CommandCharge_GetChargeLevel::ReturnValue' has a wrong offset!");

// Function Zion.CommandCharge.IsReleased
// 0x0001 (0x0001 - 0x0000)
struct CommandCharge_IsReleased final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandCharge_IsReleased) == 0x000001, "Wrong alignment on CommandCharge_IsReleased");
static_assert(sizeof(CommandCharge_IsReleased) == 0x000001, "Wrong size on CommandCharge_IsReleased");
static_assert(offsetof(CommandCharge_IsReleased, ReturnValue) == 0x000000, "Member 'CommandCharge_IsReleased::ReturnValue' has a wrong offset!");

// Function Zion.GameplayCondition.CheckGameplayCondition
// 0x0018 (0x0018 - 0x0000)
struct GameplayCondition_CheckGameplayCondition final
{
public:
	TSubclassOf<class UGameplayCondition>         GameplayConditionClass;                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      PlayerController;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayCondition_CheckGameplayCondition) == 0x000008, "Wrong alignment on GameplayCondition_CheckGameplayCondition");
static_assert(sizeof(GameplayCondition_CheckGameplayCondition) == 0x000018, "Wrong size on GameplayCondition_CheckGameplayCondition");
static_assert(offsetof(GameplayCondition_CheckGameplayCondition, GameplayConditionClass) == 0x000000, "Member 'GameplayCondition_CheckGameplayCondition::GameplayConditionClass' has a wrong offset!");
static_assert(offsetof(GameplayCondition_CheckGameplayCondition, PlayerController) == 0x000008, "Member 'GameplayCondition_CheckGameplayCondition::PlayerController' has a wrong offset!");
static_assert(offsetof(GameplayCondition_CheckGameplayCondition, ReturnValue) == 0x000010, "Member 'GameplayCondition_CheckGameplayCondition::ReturnValue' has a wrong offset!");

// Function Zion.GameplayCondition.OnCheckCondition
// 0x0010 (0x0010 - 0x0000)
struct GameplayCondition_OnCheckCondition final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayCondition_OnCheckCondition) == 0x000008, "Wrong alignment on GameplayCondition_OnCheckCondition");
static_assert(sizeof(GameplayCondition_OnCheckCondition) == 0x000010, "Wrong size on GameplayCondition_OnCheckCondition");
static_assert(offsetof(GameplayCondition_OnCheckCondition, PlayerController) == 0x000000, "Member 'GameplayCondition_OnCheckCondition::PlayerController' has a wrong offset!");
static_assert(offsetof(GameplayCondition_OnCheckCondition, ReturnValue) == 0x000008, "Member 'GameplayCondition_OnCheckCondition::ReturnValue' has a wrong offset!");

// Function Zion.AchievementsSubsystem.IsAchievementUnlocked
// 0x0002 (0x0002 - 0x0000)
struct AchievementsSubsystem_IsAchievementUnlocked final
{
public:
	EZionAchievement                              Achievement;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AchievementsSubsystem_IsAchievementUnlocked) == 0x000001, "Wrong alignment on AchievementsSubsystem_IsAchievementUnlocked");
static_assert(sizeof(AchievementsSubsystem_IsAchievementUnlocked) == 0x000002, "Wrong size on AchievementsSubsystem_IsAchievementUnlocked");
static_assert(offsetof(AchievementsSubsystem_IsAchievementUnlocked, Achievement) == 0x000000, "Member 'AchievementsSubsystem_IsAchievementUnlocked::Achievement' has a wrong offset!");
static_assert(offsetof(AchievementsSubsystem_IsAchievementUnlocked, ReturnValue) == 0x000001, "Member 'AchievementsSubsystem_IsAchievementUnlocked::ReturnValue' has a wrong offset!");

// Function Zion.AchievementsSubsystem.IsUsingInternalAchievements
// 0x0001 (0x0001 - 0x0000)
struct AchievementsSubsystem_IsUsingInternalAchievements final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AchievementsSubsystem_IsUsingInternalAchievements) == 0x000001, "Wrong alignment on AchievementsSubsystem_IsUsingInternalAchievements");
static_assert(sizeof(AchievementsSubsystem_IsUsingInternalAchievements) == 0x000001, "Wrong size on AchievementsSubsystem_IsUsingInternalAchievements");
static_assert(offsetof(AchievementsSubsystem_IsUsingInternalAchievements, ReturnValue) == 0x000000, "Member 'AchievementsSubsystem_IsUsingInternalAchievements::ReturnValue' has a wrong offset!");

// Function Zion.SkillComponent.Equip
// 0x0010 (0x0010 - 0x0000)
struct SkillComponent_Equip final
{
public:
	ESkillSlot                                    SkillSlot;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkillID;                                           // 0x0004(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrentLoadout;                              // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoLoad;                                         // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkillComponent_Equip) == 0x000004, "Wrong alignment on SkillComponent_Equip");
static_assert(sizeof(SkillComponent_Equip) == 0x000010, "Wrong size on SkillComponent_Equip");
static_assert(offsetof(SkillComponent_Equip, SkillSlot) == 0x000000, "Member 'SkillComponent_Equip::SkillSlot' has a wrong offset!");
static_assert(offsetof(SkillComponent_Equip, SkillID) == 0x000004, "Member 'SkillComponent_Equip::SkillID' has a wrong offset!");
static_assert(offsetof(SkillComponent_Equip, bAddToCurrentLoadout) == 0x00000C, "Member 'SkillComponent_Equip::bAddToCurrentLoadout' has a wrong offset!");
static_assert(offsetof(SkillComponent_Equip, bAutoLoad) == 0x00000D, "Member 'SkillComponent_Equip::bAutoLoad' has a wrong offset!");

// Function Zion.SkillComponent.EquipSkillLoadout
// 0x0008 (0x0008 - 0x0000)
struct SkillComponent_EquipSkillLoadout final
{
public:
	int32                                         LoadoutIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoLoad;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkillComponent_EquipSkillLoadout) == 0x000004, "Wrong alignment on SkillComponent_EquipSkillLoadout");
static_assert(sizeof(SkillComponent_EquipSkillLoadout) == 0x000008, "Wrong size on SkillComponent_EquipSkillLoadout");
static_assert(offsetof(SkillComponent_EquipSkillLoadout, LoadoutIndex) == 0x000000, "Member 'SkillComponent_EquipSkillLoadout::LoadoutIndex' has a wrong offset!");
static_assert(offsetof(SkillComponent_EquipSkillLoadout, bAutoLoad) == 0x000004, "Member 'SkillComponent_EquipSkillLoadout::bAutoLoad' has a wrong offset!");

// Function Zion.SkillComponent.UnEquip
// 0x0002 (0x0002 - 0x0000)
struct SkillComponent_UnEquip final
{
public:
	ESkillSlot                                    SkillSlot;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveFromCurrentLoadout;                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_UnEquip) == 0x000001, "Wrong alignment on SkillComponent_UnEquip");
static_assert(sizeof(SkillComponent_UnEquip) == 0x000002, "Wrong size on SkillComponent_UnEquip");
static_assert(offsetof(SkillComponent_UnEquip, SkillSlot) == 0x000000, "Member 'SkillComponent_UnEquip::SkillSlot' has a wrong offset!");
static_assert(offsetof(SkillComponent_UnEquip, bRemoveFromCurrentLoadout) == 0x000001, "Member 'SkillComponent_UnEquip::bRemoveFromCurrentLoadout' has a wrong offset!");

// Function Zion.SkillComponent.UnEquipAll
// 0x0001 (0x0001 - 0x0000)
struct SkillComponent_UnEquipAll final
{
public:
	bool                                          bRemoveFromCurrentLoadout;                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_UnEquipAll) == 0x000001, "Wrong alignment on SkillComponent_UnEquipAll");
static_assert(sizeof(SkillComponent_UnEquipAll) == 0x000001, "Wrong size on SkillComponent_UnEquipAll");
static_assert(offsetof(SkillComponent_UnEquipAll, bRemoveFromCurrentLoadout) == 0x000000, "Member 'SkillComponent_UnEquipAll::bRemoveFromCurrentLoadout' has a wrong offset!");

// Function Zion.SkillComponent.GetCurrentSkillLoadoutIndex
// 0x0004 (0x0004 - 0x0000)
struct SkillComponent_GetCurrentSkillLoadoutIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_GetCurrentSkillLoadoutIndex) == 0x000004, "Wrong alignment on SkillComponent_GetCurrentSkillLoadoutIndex");
static_assert(sizeof(SkillComponent_GetCurrentSkillLoadoutIndex) == 0x000004, "Wrong size on SkillComponent_GetCurrentSkillLoadoutIndex");
static_assert(offsetof(SkillComponent_GetCurrentSkillLoadoutIndex, ReturnValue) == 0x000000, "Member 'SkillComponent_GetCurrentSkillLoadoutIndex::ReturnValue' has a wrong offset!");

// Function Zion.SkillComponent.GetEquippedCommandSet
// 0x0010 (0x0010 - 0x0000)
struct SkillComponent_GetEquippedCommandSet final
{
public:
	ESkillSlot                                    SkillSlot;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommandSet*                            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_GetEquippedCommandSet) == 0x000008, "Wrong alignment on SkillComponent_GetEquippedCommandSet");
static_assert(sizeof(SkillComponent_GetEquippedCommandSet) == 0x000010, "Wrong size on SkillComponent_GetEquippedCommandSet");
static_assert(offsetof(SkillComponent_GetEquippedCommandSet, SkillSlot) == 0x000000, "Member 'SkillComponent_GetEquippedCommandSet::SkillSlot' has a wrong offset!");
static_assert(offsetof(SkillComponent_GetEquippedCommandSet, ReturnValue) == 0x000008, "Member 'SkillComponent_GetEquippedCommandSet::ReturnValue' has a wrong offset!");

// Function Zion.SkillComponent.GetEquippedItemSkillData
// 0x0290 (0x0290 - 0x0000)
struct SkillComponent_GetEquippedItemSkillData final
{
public:
	ESkillSlot                                    SkillSlot;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryItemSkillData                ReturnValue;                                       // 0x0008(0x0288)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_GetEquippedItemSkillData) == 0x000008, "Wrong alignment on SkillComponent_GetEquippedItemSkillData");
static_assert(sizeof(SkillComponent_GetEquippedItemSkillData) == 0x000290, "Wrong size on SkillComponent_GetEquippedItemSkillData");
static_assert(offsetof(SkillComponent_GetEquippedItemSkillData, SkillSlot) == 0x000000, "Member 'SkillComponent_GetEquippedItemSkillData::SkillSlot' has a wrong offset!");
static_assert(offsetof(SkillComponent_GetEquippedItemSkillData, ReturnValue) == 0x000008, "Member 'SkillComponent_GetEquippedItemSkillData::ReturnValue' has a wrong offset!");

// Function Zion.SkillComponent.GetEquippedSkillID
// 0x000C (0x000C - 0x0000)
struct SkillComponent_GetEquippedSkillID final
{
public:
	ESkillSlot                                    SkillSlot;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_GetEquippedSkillID) == 0x000004, "Wrong alignment on SkillComponent_GetEquippedSkillID");
static_assert(sizeof(SkillComponent_GetEquippedSkillID) == 0x00000C, "Wrong size on SkillComponent_GetEquippedSkillID");
static_assert(offsetof(SkillComponent_GetEquippedSkillID, SkillSlot) == 0x000000, "Member 'SkillComponent_GetEquippedSkillID::SkillSlot' has a wrong offset!");
static_assert(offsetof(SkillComponent_GetEquippedSkillID, ReturnValue) == 0x000004, "Member 'SkillComponent_GetEquippedSkillID::ReturnValue' has a wrong offset!");

// Function Zion.SkillComponent.GetEquippedSkillInputActionFromSpirit
// 0x0210 (0x0210 - 0x0000)
struct SkillComponent_GetEquippedSkillInputActionFromSpirit final
{
public:
	struct FInventoryItemSpiritData               SpiritData;                                        // 0x0000(0x0208)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UInputAction*                     ReturnValue;                                       // 0x0208(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_GetEquippedSkillInputActionFromSpirit) == 0x000008, "Wrong alignment on SkillComponent_GetEquippedSkillInputActionFromSpirit");
static_assert(sizeof(SkillComponent_GetEquippedSkillInputActionFromSpirit) == 0x000210, "Wrong size on SkillComponent_GetEquippedSkillInputActionFromSpirit");
static_assert(offsetof(SkillComponent_GetEquippedSkillInputActionFromSpirit, SpiritData) == 0x000000, "Member 'SkillComponent_GetEquippedSkillInputActionFromSpirit::SpiritData' has a wrong offset!");
static_assert(offsetof(SkillComponent_GetEquippedSkillInputActionFromSpirit, ReturnValue) == 0x000208, "Member 'SkillComponent_GetEquippedSkillInputActionFromSpirit::ReturnValue' has a wrong offset!");

// Function Zion.SkillComponent.GetEquippedSkillLevelData
// 0x00F0 (0x00F0 - 0x0000)
struct SkillComponent_GetEquippedSkillLevelData final
{
public:
	ESkillSlot                                    SkillSlot;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkillLevelData                        ReturnValue;                                       // 0x0008(0x00E8)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_GetEquippedSkillLevelData) == 0x000008, "Wrong alignment on SkillComponent_GetEquippedSkillLevelData");
static_assert(sizeof(SkillComponent_GetEquippedSkillLevelData) == 0x0000F0, "Wrong size on SkillComponent_GetEquippedSkillLevelData");
static_assert(offsetof(SkillComponent_GetEquippedSkillLevelData, SkillSlot) == 0x000000, "Member 'SkillComponent_GetEquippedSkillLevelData::SkillSlot' has a wrong offset!");
static_assert(offsetof(SkillComponent_GetEquippedSkillLevelData, ReturnValue) == 0x000008, "Member 'SkillComponent_GetEquippedSkillLevelData::ReturnValue' has a wrong offset!");

// Function Zion.SkillComponent.GetEquippedSkillSlotFromID
// 0x000C (0x000C - 0x0000)
struct SkillComponent_GetEquippedSkillSlotFromID final
{
public:
	class FName                                   SkillID;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillSlot                                    ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkillComponent_GetEquippedSkillSlotFromID) == 0x000004, "Wrong alignment on SkillComponent_GetEquippedSkillSlotFromID");
static_assert(sizeof(SkillComponent_GetEquippedSkillSlotFromID) == 0x00000C, "Wrong size on SkillComponent_GetEquippedSkillSlotFromID");
static_assert(offsetof(SkillComponent_GetEquippedSkillSlotFromID, SkillID) == 0x000000, "Member 'SkillComponent_GetEquippedSkillSlotFromID::SkillID' has a wrong offset!");
static_assert(offsetof(SkillComponent_GetEquippedSkillSlotFromID, ReturnValue) == 0x000008, "Member 'SkillComponent_GetEquippedSkillSlotFromID::ReturnValue' has a wrong offset!");

// Function Zion.SkillComponent.GetMinimumEquippedSPCost
// 0x0004 (0x0004 - 0x0000)
struct SkillComponent_GetMinimumEquippedSPCost final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_GetMinimumEquippedSPCost) == 0x000004, "Wrong alignment on SkillComponent_GetMinimumEquippedSPCost");
static_assert(sizeof(SkillComponent_GetMinimumEquippedSPCost) == 0x000004, "Wrong size on SkillComponent_GetMinimumEquippedSPCost");
static_assert(offsetof(SkillComponent_GetMinimumEquippedSPCost, ReturnValue) == 0x000000, "Member 'SkillComponent_GetMinimumEquippedSPCost::ReturnValue' has a wrong offset!");

// Function Zion.SkillComponent.HasAnyEquippedSkill
// 0x0001 (0x0001 - 0x0000)
struct SkillComponent_HasAnyEquippedSkill final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_HasAnyEquippedSkill) == 0x000001, "Wrong alignment on SkillComponent_HasAnyEquippedSkill");
static_assert(sizeof(SkillComponent_HasAnyEquippedSkill) == 0x000001, "Wrong size on SkillComponent_HasAnyEquippedSkill");
static_assert(offsetof(SkillComponent_HasAnyEquippedSkill, ReturnValue) == 0x000000, "Member 'SkillComponent_HasAnyEquippedSkill::ReturnValue' has a wrong offset!");

// Function Zion.SkillComponent.HasEquippedSkill
// 0x0002 (0x0002 - 0x0000)
struct SkillComponent_HasEquippedSkill final
{
public:
	ESkillSlot                                    SkillSlot;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_HasEquippedSkill) == 0x000001, "Wrong alignment on SkillComponent_HasEquippedSkill");
static_assert(sizeof(SkillComponent_HasEquippedSkill) == 0x000002, "Wrong size on SkillComponent_HasEquippedSkill");
static_assert(offsetof(SkillComponent_HasEquippedSkill, SkillSlot) == 0x000000, "Member 'SkillComponent_HasEquippedSkill::SkillSlot' has a wrong offset!");
static_assert(offsetof(SkillComponent_HasEquippedSkill, ReturnValue) == 0x000001, "Member 'SkillComponent_HasEquippedSkill::ReturnValue' has a wrong offset!");

// Function Zion.AbilityComponent.LaunchAbility
// 0x0160 (0x0160 - 0x0000)
struct AbilityComponent_LaunchAbility final
{
public:
	struct FAbilityData                           AbilityData;                                       // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAbilityAdditionalData                 AdditionalData;                                    // 0x00E0(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             GlobalOffset;                                      // 0x00F0(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAbility*                               ReturnValue;                                       // 0x0150(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AbilityComponent_LaunchAbility) == 0x000010, "Wrong alignment on AbilityComponent_LaunchAbility");
static_assert(sizeof(AbilityComponent_LaunchAbility) == 0x000160, "Wrong size on AbilityComponent_LaunchAbility");
static_assert(offsetof(AbilityComponent_LaunchAbility, AbilityData) == 0x000000, "Member 'AbilityComponent_LaunchAbility::AbilityData' has a wrong offset!");
static_assert(offsetof(AbilityComponent_LaunchAbility, AdditionalData) == 0x0000E0, "Member 'AbilityComponent_LaunchAbility::AdditionalData' has a wrong offset!");
static_assert(offsetof(AbilityComponent_LaunchAbility, GlobalOffset) == 0x0000F0, "Member 'AbilityComponent_LaunchAbility::GlobalOffset' has a wrong offset!");
static_assert(offsetof(AbilityComponent_LaunchAbility, ReturnValue) == 0x000150, "Member 'AbilityComponent_LaunchAbility::ReturnValue' has a wrong offset!");

// Function Zion.AbilityComponent.LaunchAbilityInstant
// 0x0110 (0x0110 - 0x0000)
struct AbilityComponent_LaunchAbilityInstant final
{
public:
	struct FAbilityData                           AbilityData;                                       // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Targets;                                           // 0x00E0(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAbilityAdditionalData                 AdditionalData;                                    // 0x00F0(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class AAbilityInstant*                        ReturnValue;                                       // 0x0100(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AbilityComponent_LaunchAbilityInstant) == 0x000010, "Wrong alignment on AbilityComponent_LaunchAbilityInstant");
static_assert(sizeof(AbilityComponent_LaunchAbilityInstant) == 0x000110, "Wrong size on AbilityComponent_LaunchAbilityInstant");
static_assert(offsetof(AbilityComponent_LaunchAbilityInstant, AbilityData) == 0x000000, "Member 'AbilityComponent_LaunchAbilityInstant::AbilityData' has a wrong offset!");
static_assert(offsetof(AbilityComponent_LaunchAbilityInstant, Targets) == 0x0000E0, "Member 'AbilityComponent_LaunchAbilityInstant::Targets' has a wrong offset!");
static_assert(offsetof(AbilityComponent_LaunchAbilityInstant, AdditionalData) == 0x0000F0, "Member 'AbilityComponent_LaunchAbilityInstant::AdditionalData' has a wrong offset!");
static_assert(offsetof(AbilityComponent_LaunchAbilityInstant, ReturnValue) == 0x000100, "Member 'AbilityComponent_LaunchAbilityInstant::ReturnValue' has a wrong offset!");

// Function Zion.ZionInputComponent.AddInputMappingContext
// 0x0010 (0x0010 - 0x0000)
struct ZionInputComponent_AddInputMappingContext final
{
public:
	const class UInputMappingContext*             InputMappingContext;                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputMappingPriority                         Priority;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ZionInputComponent_AddInputMappingContext) == 0x000008, "Wrong alignment on ZionInputComponent_AddInputMappingContext");
static_assert(sizeof(ZionInputComponent_AddInputMappingContext) == 0x000010, "Wrong size on ZionInputComponent_AddInputMappingContext");
static_assert(offsetof(ZionInputComponent_AddInputMappingContext, InputMappingContext) == 0x000000, "Member 'ZionInputComponent_AddInputMappingContext::InputMappingContext' has a wrong offset!");
static_assert(offsetof(ZionInputComponent_AddInputMappingContext, Priority) == 0x000008, "Member 'ZionInputComponent_AddInputMappingContext::Priority' has a wrong offset!");

// Function Zion.ZionInputComponent.RemoveInputMappingContext
// 0x0008 (0x0008 - 0x0000)
struct ZionInputComponent_RemoveInputMappingContext final
{
public:
	const class UInputMappingContext*             InputMappingContext;                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionInputComponent_RemoveInputMappingContext) == 0x000008, "Wrong alignment on ZionInputComponent_RemoveInputMappingContext");
static_assert(sizeof(ZionInputComponent_RemoveInputMappingContext) == 0x000008, "Wrong size on ZionInputComponent_RemoveInputMappingContext");
static_assert(offsetof(ZionInputComponent_RemoveInputMappingContext, InputMappingContext) == 0x000000, "Member 'ZionInputComponent_RemoveInputMappingContext::InputMappingContext' has a wrong offset!");

// Function Zion.LocomotionComponent.SetFacing
// 0x0001 (0x0001 - 0x0000)
struct LocomotionComponent_SetFacing final
{
public:
	EFacingType                                   FacingType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_SetFacing) == 0x000001, "Wrong alignment on LocomotionComponent_SetFacing");
static_assert(sizeof(LocomotionComponent_SetFacing) == 0x000001, "Wrong size on LocomotionComponent_SetFacing");
static_assert(offsetof(LocomotionComponent_SetFacing, FacingType) == 0x000000, "Member 'LocomotionComponent_SetFacing::FacingType' has a wrong offset!");

// Function Zion.LocomotionComponent.SetFacingFromVector
// 0x0018 (0x0018 - 0x0000)
struct LocomotionComponent_SetFacingFromVector final
{
public:
	struct FVector                                Vector;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_SetFacingFromVector) == 0x000008, "Wrong alignment on LocomotionComponent_SetFacingFromVector");
static_assert(sizeof(LocomotionComponent_SetFacingFromVector) == 0x000018, "Wrong size on LocomotionComponent_SetFacingFromVector");
static_assert(offsetof(LocomotionComponent_SetFacingFromVector, Vector) == 0x000000, "Member 'LocomotionComponent_SetFacingFromVector::Vector' has a wrong offset!");

// Function Zion.LocomotionComponent.SetUpdateFacing
// 0x0001 (0x0001 - 0x0000)
struct LocomotionComponent_SetUpdateFacing final
{
public:
	bool                                          bNewUpdateFacing;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_SetUpdateFacing) == 0x000001, "Wrong alignment on LocomotionComponent_SetUpdateFacing");
static_assert(sizeof(LocomotionComponent_SetUpdateFacing) == 0x000001, "Wrong size on LocomotionComponent_SetUpdateFacing");
static_assert(offsetof(LocomotionComponent_SetUpdateFacing, bNewUpdateFacing) == 0x000000, "Member 'LocomotionComponent_SetUpdateFacing::bNewUpdateFacing' has a wrong offset!");

// Function Zion.LocomotionComponent.SetUpVector
// 0x0018 (0x0018 - 0x0000)
struct LocomotionComponent_SetUpVector final
{
public:
	struct FVector                                NewUpVector;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_SetUpVector) == 0x000008, "Wrong alignment on LocomotionComponent_SetUpVector");
static_assert(sizeof(LocomotionComponent_SetUpVector) == 0x000018, "Wrong size on LocomotionComponent_SetUpVector");
static_assert(offsetof(LocomotionComponent_SetUpVector, NewUpVector) == 0x000000, "Member 'LocomotionComponent_SetUpVector::NewUpVector' has a wrong offset!");

// Function Zion.LocomotionComponent.GetFacing
// 0x0001 (0x0001 - 0x0000)
struct LocomotionComponent_GetFacing final
{
public:
	EFacingType                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_GetFacing) == 0x000001, "Wrong alignment on LocomotionComponent_GetFacing");
static_assert(sizeof(LocomotionComponent_GetFacing) == 0x000001, "Wrong size on LocomotionComponent_GetFacing");
static_assert(offsetof(LocomotionComponent_GetFacing, ReturnValue) == 0x000000, "Member 'LocomotionComponent_GetFacing::ReturnValue' has a wrong offset!");

// Function Zion.LocomotionComponent.GetUpdateFacing
// 0x0001 (0x0001 - 0x0000)
struct LocomotionComponent_GetUpdateFacing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_GetUpdateFacing) == 0x000001, "Wrong alignment on LocomotionComponent_GetUpdateFacing");
static_assert(sizeof(LocomotionComponent_GetUpdateFacing) == 0x000001, "Wrong size on LocomotionComponent_GetUpdateFacing");
static_assert(offsetof(LocomotionComponent_GetUpdateFacing, ReturnValue) == 0x000000, "Member 'LocomotionComponent_GetUpdateFacing::ReturnValue' has a wrong offset!");

// Function Zion.LocomotionComponent.GetUpVector
// 0x0018 (0x0018 - 0x0000)
struct LocomotionComponent_GetUpVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_GetUpVector) == 0x000008, "Wrong alignment on LocomotionComponent_GetUpVector");
static_assert(sizeof(LocomotionComponent_GetUpVector) == 0x000018, "Wrong size on LocomotionComponent_GetUpVector");
static_assert(offsetof(LocomotionComponent_GetUpVector, ReturnValue) == 0x000000, "Member 'LocomotionComponent_GetUpVector::ReturnValue' has a wrong offset!");

// Function Zion.LocomotionComponent.GetWorldUpToUpRotation
// 0x0020 (0x0020 - 0x0000)
struct LocomotionComponent_GetWorldUpToUpRotation final
{
public:
	struct FQuat                                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionComponent_GetWorldUpToUpRotation) == 0x000010, "Wrong alignment on LocomotionComponent_GetWorldUpToUpRotation");
static_assert(sizeof(LocomotionComponent_GetWorldUpToUpRotation) == 0x000020, "Wrong size on LocomotionComponent_GetWorldUpToUpRotation");
static_assert(offsetof(LocomotionComponent_GetWorldUpToUpRotation, ReturnValue) == 0x000000, "Member 'LocomotionComponent_GetWorldUpToUpRotation::ReturnValue' has a wrong offset!");

// Function Zion.FXComponent.ActivateAuraFXs
// 0x0008 (0x0008 - 0x0000)
struct FXComponent_ActivateAuraFXs final
{
public:
	class FName                                   AuraFXTag;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXComponent_ActivateAuraFXs) == 0x000004, "Wrong alignment on FXComponent_ActivateAuraFXs");
static_assert(sizeof(FXComponent_ActivateAuraFXs) == 0x000008, "Wrong size on FXComponent_ActivateAuraFXs");
static_assert(offsetof(FXComponent_ActivateAuraFXs, AuraFXTag) == 0x000000, "Member 'FXComponent_ActivateAuraFXs::AuraFXTag' has a wrong offset!");

// Function Zion.FXComponent.DeactivateAuraFXs
// 0x0008 (0x0008 - 0x0000)
struct FXComponent_DeactivateAuraFXs final
{
public:
	class FName                                   AuraFXTag;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXComponent_DeactivateAuraFXs) == 0x000004, "Wrong alignment on FXComponent_DeactivateAuraFXs");
static_assert(sizeof(FXComponent_DeactivateAuraFXs) == 0x000008, "Wrong size on FXComponent_DeactivateAuraFXs");
static_assert(offsetof(FXComponent_DeactivateAuraFXs, AuraFXTag) == 0x000000, "Member 'FXComponent_DeactivateAuraFXs::AuraFXTag' has a wrong offset!");

// Function Zion.FXComponent.OnFinishCommand
// 0x0010 (0x0010 - 0x0000)
struct FXComponent_OnFinishCommand final
{
public:
	const class UCommand*                         Command;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommandFinishType                            FinishType;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FXComponent_OnFinishCommand) == 0x000008, "Wrong alignment on FXComponent_OnFinishCommand");
static_assert(sizeof(FXComponent_OnFinishCommand) == 0x000010, "Wrong size on FXComponent_OnFinishCommand");
static_assert(offsetof(FXComponent_OnFinishCommand, Command) == 0x000000, "Member 'FXComponent_OnFinishCommand::Command' has a wrong offset!");
static_assert(offsetof(FXComponent_OnFinishCommand, FinishType) == 0x000008, "Member 'FXComponent_OnFinishCommand::FinishType' has a wrong offset!");

// Function Zion.FXComponent.OnGuarded
// 0x0010 (0x0010 - 0x0000)
struct FXComponent_OnGuarded final
{
public:
	class AAbility*                               Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXComponent_OnGuarded) == 0x000008, "Wrong alignment on FXComponent_OnGuarded");
static_assert(sizeof(FXComponent_OnGuarded) == 0x000010, "Wrong size on FXComponent_OnGuarded");
static_assert(offsetof(FXComponent_OnGuarded, Ability) == 0x000000, "Member 'FXComponent_OnGuarded::Ability' has a wrong offset!");
static_assert(offsetof(FXComponent_OnGuarded, Source) == 0x000008, "Member 'FXComponent_OnGuarded::Source' has a wrong offset!");

// Function Zion.FXComponent.OnLanded
// 0x00F8 (0x00F8 - 0x0000)
struct FXComponent_OnLanded final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXComponent_OnLanded) == 0x000008, "Wrong alignment on FXComponent_OnLanded");
static_assert(sizeof(FXComponent_OnLanded) == 0x0000F8, "Wrong size on FXComponent_OnLanded");
static_assert(offsetof(FXComponent_OnLanded, Hit) == 0x000000, "Member 'FXComponent_OnLanded::Hit' has a wrong offset!");

// Function Zion.FXComponent.OnParried
// 0x0010 (0x0010 - 0x0000)
struct FXComponent_OnParried final
{
public:
	class AAbility*                               Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXComponent_OnParried) == 0x000008, "Wrong alignment on FXComponent_OnParried");
static_assert(sizeof(FXComponent_OnParried) == 0x000010, "Wrong size on FXComponent_OnParried");
static_assert(offsetof(FXComponent_OnParried, Ability) == 0x000000, "Member 'FXComponent_OnParried::Ability' has a wrong offset!");
static_assert(offsetof(FXComponent_OnParried, Source) == 0x000008, "Member 'FXComponent_OnParried::Source' has a wrong offset!");

// Function Zion.FXComponent.OnStatusEffectLaunched
// 0x0008 (0x0008 - 0x0000)
struct FXComponent_OnStatusEffectLaunched final
{
public:
	class UStatusEffect*                          StatusEffect;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXComponent_OnStatusEffectLaunched) == 0x000008, "Wrong alignment on FXComponent_OnStatusEffectLaunched");
static_assert(sizeof(FXComponent_OnStatusEffectLaunched) == 0x000008, "Wrong size on FXComponent_OnStatusEffectLaunched");
static_assert(offsetof(FXComponent_OnStatusEffectLaunched, StatusEffect) == 0x000000, "Member 'FXComponent_OnStatusEffectLaunched::StatusEffect' has a wrong offset!");

// Function Zion.FXComponent.OnStatusEffectStopped
// 0x0008 (0x0008 - 0x0000)
struct FXComponent_OnStatusEffectStopped final
{
public:
	class UStatusEffect*                          StatusEffect;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXComponent_OnStatusEffectStopped) == 0x000008, "Wrong alignment on FXComponent_OnStatusEffectStopped");
static_assert(sizeof(FXComponent_OnStatusEffectStopped) == 0x000008, "Wrong size on FXComponent_OnStatusEffectStopped");
static_assert(offsetof(FXComponent_OnStatusEffectStopped, StatusEffect) == 0x000000, "Member 'FXComponent_OnStatusEffectStopped::StatusEffect' has a wrong offset!");

// Function Zion.MoveComponent.SetVelocity
// 0x0018 (0x0018 - 0x0000)
struct MoveComponent_SetVelocity final
{
public:
	struct FVector                                NewVelocity;                                       // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoveComponent_SetVelocity) == 0x000008, "Wrong alignment on MoveComponent_SetVelocity");
static_assert(sizeof(MoveComponent_SetVelocity) == 0x000018, "Wrong size on MoveComponent_SetVelocity");
static_assert(offsetof(MoveComponent_SetVelocity, NewVelocity) == 0x000000, "Member 'MoveComponent_SetVelocity::NewVelocity' has a wrong offset!");

// Function Zion.AbilityHitboxBounce.OnProjectileBounce
// 0x0110 (0x0110 - 0x0000)
struct AbilityHitboxBounce_OnProjectileBounce final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x00F8(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityHitboxBounce_OnProjectileBounce) == 0x000008, "Wrong alignment on AbilityHitboxBounce_OnProjectileBounce");
static_assert(sizeof(AbilityHitboxBounce_OnProjectileBounce) == 0x000110, "Wrong size on AbilityHitboxBounce_OnProjectileBounce");
static_assert(offsetof(AbilityHitboxBounce_OnProjectileBounce, ImpactResult) == 0x000000, "Member 'AbilityHitboxBounce_OnProjectileBounce::ImpactResult' has a wrong offset!");
static_assert(offsetof(AbilityHitboxBounce_OnProjectileBounce, ImpactVelocity) == 0x0000F8, "Member 'AbilityHitboxBounce_OnProjectileBounce::ImpactVelocity' has a wrong offset!");

// Function Zion.InputSettingsSubsystem.RemapKey
// 0x0078 (0x0078 - 0x0000)
struct InputSettingsSubsystem_RemapKey final
{
public:
	EActionInputType                              ActionInputType;                                   // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   NewKey;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<EActionInputType>                        InvalidInputTypes;                                 // 0x0020(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bIsGamepadKey;                                     // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0071(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputSettingsSubsystem_RemapKey) == 0x000008, "Wrong alignment on InputSettingsSubsystem_RemapKey");
static_assert(sizeof(InputSettingsSubsystem_RemapKey) == 0x000078, "Wrong size on InputSettingsSubsystem_RemapKey");
static_assert(offsetof(InputSettingsSubsystem_RemapKey, ActionInputType) == 0x000000, "Member 'InputSettingsSubsystem_RemapKey::ActionInputType' has a wrong offset!");
static_assert(offsetof(InputSettingsSubsystem_RemapKey, NewKey) == 0x000008, "Member 'InputSettingsSubsystem_RemapKey::NewKey' has a wrong offset!");
static_assert(offsetof(InputSettingsSubsystem_RemapKey, InvalidInputTypes) == 0x000020, "Member 'InputSettingsSubsystem_RemapKey::InvalidInputTypes' has a wrong offset!");
static_assert(offsetof(InputSettingsSubsystem_RemapKey, bIsGamepadKey) == 0x000070, "Member 'InputSettingsSubsystem_RemapKey::bIsGamepadKey' has a wrong offset!");
static_assert(offsetof(InputSettingsSubsystem_RemapKey, ReturnValue) == 0x000071, "Member 'InputSettingsSubsystem_RemapKey::ReturnValue' has a wrong offset!");

// Function Zion.InputSettingsSubsystem.ResetAllInputMappingContextsToDefault
// 0x0001 (0x0001 - 0x0000)
struct InputSettingsSubsystem_ResetAllInputMappingContextsToDefault final
{
public:
	bool                                          bIsGamepad;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InputSettingsSubsystem_ResetAllInputMappingContextsToDefault) == 0x000001, "Wrong alignment on InputSettingsSubsystem_ResetAllInputMappingContextsToDefault");
static_assert(sizeof(InputSettingsSubsystem_ResetAllInputMappingContextsToDefault) == 0x000001, "Wrong size on InputSettingsSubsystem_ResetAllInputMappingContextsToDefault");
static_assert(offsetof(InputSettingsSubsystem_ResetAllInputMappingContextsToDefault, bIsGamepad) == 0x000000, "Member 'InputSettingsSubsystem_ResetAllInputMappingContextsToDefault::bIsGamepad' has a wrong offset!");

// Function Zion.InputSettingsSubsystem.ResetInputMappingContextToDefault
// 0x0010 (0x0010 - 0x0000)
struct InputSettingsSubsystem_ResetInputMappingContextToDefault final
{
public:
	class UInputMappingContext*                   InputMappingContext;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGamepad;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputSettingsSubsystem_ResetInputMappingContextToDefault) == 0x000008, "Wrong alignment on InputSettingsSubsystem_ResetInputMappingContextToDefault");
static_assert(sizeof(InputSettingsSubsystem_ResetInputMappingContextToDefault) == 0x000010, "Wrong size on InputSettingsSubsystem_ResetInputMappingContextToDefault");
static_assert(offsetof(InputSettingsSubsystem_ResetInputMappingContextToDefault, InputMappingContext) == 0x000000, "Member 'InputSettingsSubsystem_ResetInputMappingContextToDefault::InputMappingContext' has a wrong offset!");
static_assert(offsetof(InputSettingsSubsystem_ResetInputMappingContextToDefault, bIsGamepad) == 0x000008, "Member 'InputSettingsSubsystem_ResetInputMappingContextToDefault::bIsGamepad' has a wrong offset!");

// Function Zion.InputSettingsSubsystem.GetMappedKey
// 0x0020 (0x0020 - 0x0000)
struct InputSettingsSubsystem_GetMappedKey final
{
public:
	class FName                                   MappingName;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InputSettingsSubsystem_GetMappedKey) == 0x000008, "Wrong alignment on InputSettingsSubsystem_GetMappedKey");
static_assert(sizeof(InputSettingsSubsystem_GetMappedKey) == 0x000020, "Wrong size on InputSettingsSubsystem_GetMappedKey");
static_assert(offsetof(InputSettingsSubsystem_GetMappedKey, MappingName) == 0x000000, "Member 'InputSettingsSubsystem_GetMappedKey::MappingName' has a wrong offset!");
static_assert(offsetof(InputSettingsSubsystem_GetMappedKey, ReturnValue) == 0x000008, "Member 'InputSettingsSubsystem_GetMappedKey::ReturnValue' has a wrong offset!");

// Function Zion.InputSettingsSubsystem.GetMappingNameFromInputAction
// 0x0018 (0x0018 - 0x0000)
struct InputSettingsSubsystem_GetMappingNameFromInputAction final
{
public:
	const class UInputAction*                     InputAction;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGamepad;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputSettingsSubsystem_GetMappingNameFromInputAction) == 0x000008, "Wrong alignment on InputSettingsSubsystem_GetMappingNameFromInputAction");
static_assert(sizeof(InputSettingsSubsystem_GetMappingNameFromInputAction) == 0x000018, "Wrong size on InputSettingsSubsystem_GetMappingNameFromInputAction");
static_assert(offsetof(InputSettingsSubsystem_GetMappingNameFromInputAction, InputAction) == 0x000000, "Member 'InputSettingsSubsystem_GetMappingNameFromInputAction::InputAction' has a wrong offset!");
static_assert(offsetof(InputSettingsSubsystem_GetMappingNameFromInputAction, bIsGamepad) == 0x000008, "Member 'InputSettingsSubsystem_GetMappingNameFromInputAction::bIsGamepad' has a wrong offset!");
static_assert(offsetof(InputSettingsSubsystem_GetMappingNameFromInputAction, ReturnValue) == 0x00000C, "Member 'InputSettingsSubsystem_GetMappingNameFromInputAction::ReturnValue' has a wrong offset!");

// Function Zion.CommandModule_Summon.GetSpirit
// 0x0008 (0x0008 - 0x0000)
struct CommandModule_Summon_GetSpirit final
{
public:
	const class ACharacterZionSpirit*             ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandModule_Summon_GetSpirit) == 0x000008, "Wrong alignment on CommandModule_Summon_GetSpirit");
static_assert(sizeof(CommandModule_Summon_GetSpirit) == 0x000008, "Wrong size on CommandModule_Summon_GetSpirit");
static_assert(offsetof(CommandModule_Summon_GetSpirit, ReturnValue) == 0x000000, "Member 'CommandModule_Summon_GetSpirit::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.AddCurrency
// 0x000C (0x000C - 0x0000)
struct InventoryComponent_AddCurrency final
{
public:
	ECurrencyType                                 CurrencyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrencyToAdd;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_AddCurrency) == 0x000004, "Wrong alignment on InventoryComponent_AddCurrency");
static_assert(sizeof(InventoryComponent_AddCurrency) == 0x00000C, "Wrong size on InventoryComponent_AddCurrency");
static_assert(offsetof(InventoryComponent_AddCurrency, CurrencyType) == 0x000000, "Member 'InventoryComponent_AddCurrency::CurrencyType' has a wrong offset!");
static_assert(offsetof(InventoryComponent_AddCurrency, CurrencyToAdd) == 0x000004, "Member 'InventoryComponent_AddCurrency::CurrencyToAdd' has a wrong offset!");
static_assert(offsetof(InventoryComponent_AddCurrency, ReturnValue) == 0x000008, "Member 'InventoryComponent_AddCurrency::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.AddDrop
// 0x01F8 (0x01F8 - 0x0000)
struct InventoryComponent_AddDrop final
{
public:
	struct FDrop                                  Drop;                                              // 0x0000(0x01F0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         DropFactor;                                        // 0x01F0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x01F4(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F5[0x3];                                      // 0x01F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryComponent_AddDrop) == 0x000008, "Wrong alignment on InventoryComponent_AddDrop");
static_assert(sizeof(InventoryComponent_AddDrop) == 0x0001F8, "Wrong size on InventoryComponent_AddDrop");
static_assert(offsetof(InventoryComponent_AddDrop, Drop) == 0x000000, "Member 'InventoryComponent_AddDrop::Drop' has a wrong offset!");
static_assert(offsetof(InventoryComponent_AddDrop, DropFactor) == 0x0001F0, "Member 'InventoryComponent_AddDrop::DropFactor' has a wrong offset!");
static_assert(offsetof(InventoryComponent_AddDrop, ReturnValue) == 0x0001F4, "Member 'InventoryComponent_AddDrop::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.AddItem
// 0x0018 (0x0018 - 0x0000)
struct InventoryComponent_AddItem final
{
public:
	struct FDataTableRowHandle                    ItemHandle;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryComponent_AddItem) == 0x000008, "Wrong alignment on InventoryComponent_AddItem");
static_assert(sizeof(InventoryComponent_AddItem) == 0x000018, "Wrong size on InventoryComponent_AddItem");
static_assert(offsetof(InventoryComponent_AddItem, ItemHandle) == 0x000000, "Member 'InventoryComponent_AddItem::ItemHandle' has a wrong offset!");
static_assert(offsetof(InventoryComponent_AddItem, Count) == 0x000010, "Member 'InventoryComponent_AddItem::Count' has a wrong offset!");
static_assert(offsetof(InventoryComponent_AddItem, ReturnValue) == 0x000014, "Member 'InventoryComponent_AddItem::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.HasItem
// 0x0018 (0x0018 - 0x0000)
struct InventoryComponent_HasItem final
{
public:
	struct FDataTableRowHandle                    ItemHandle;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryComponent_HasItem) == 0x000008, "Wrong alignment on InventoryComponent_HasItem");
static_assert(sizeof(InventoryComponent_HasItem) == 0x000018, "Wrong size on InventoryComponent_HasItem");
static_assert(offsetof(InventoryComponent_HasItem, ItemHandle) == 0x000000, "Member 'InventoryComponent_HasItem::ItemHandle' has a wrong offset!");
static_assert(offsetof(InventoryComponent_HasItem, Count) == 0x000010, "Member 'InventoryComponent_HasItem::Count' has a wrong offset!");
static_assert(offsetof(InventoryComponent_HasItem, ReturnValue) == 0x000014, "Member 'InventoryComponent_HasItem::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.MarkItemAsChecked
// 0x0010 (0x0010 - 0x0000)
struct InventoryComponent_MarkItemAsChecked final
{
public:
	struct FDataTableRowHandle                    ItemHandle;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_MarkItemAsChecked) == 0x000008, "Wrong alignment on InventoryComponent_MarkItemAsChecked");
static_assert(sizeof(InventoryComponent_MarkItemAsChecked) == 0x000010, "Wrong size on InventoryComponent_MarkItemAsChecked");
static_assert(offsetof(InventoryComponent_MarkItemAsChecked, ItemHandle) == 0x000000, "Member 'InventoryComponent_MarkItemAsChecked::ItemHandle' has a wrong offset!");

// Function Zion.InventoryComponent.RemoveItem
// 0x0018 (0x0018 - 0x0000)
struct InventoryComponent_RemoveItem final
{
public:
	struct FDataTableRowHandle                    ItemHandle;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryComponent_RemoveItem) == 0x000008, "Wrong alignment on InventoryComponent_RemoveItem");
static_assert(sizeof(InventoryComponent_RemoveItem) == 0x000018, "Wrong size on InventoryComponent_RemoveItem");
static_assert(offsetof(InventoryComponent_RemoveItem, ItemHandle) == 0x000000, "Member 'InventoryComponent_RemoveItem::ItemHandle' has a wrong offset!");
static_assert(offsetof(InventoryComponent_RemoveItem, Count) == 0x000010, "Member 'InventoryComponent_RemoveItem::Count' has a wrong offset!");
static_assert(offsetof(InventoryComponent_RemoveItem, ReturnValue) == 0x000014, "Member 'InventoryComponent_RemoveItem::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.SpendCurrency
// 0x000C (0x000C - 0x0000)
struct InventoryComponent_SpendCurrency final
{
public:
	struct FCurrencyValue                         CurrencyValue;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_SpendCurrency) == 0x000004, "Wrong alignment on InventoryComponent_SpendCurrency");
static_assert(sizeof(InventoryComponent_SpendCurrency) == 0x00000C, "Wrong size on InventoryComponent_SpendCurrency");
static_assert(offsetof(InventoryComponent_SpendCurrency, CurrencyValue) == 0x000000, "Member 'InventoryComponent_SpendCurrency::CurrencyValue' has a wrong offset!");
static_assert(offsetof(InventoryComponent_SpendCurrency, ReturnValue) == 0x000008, "Member 'InventoryComponent_SpendCurrency::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.CanSpendCurrency
// 0x000C (0x000C - 0x0000)
struct InventoryComponent_CanSpendCurrency final
{
public:
	struct FCurrencyValue                         CurrencyValue;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryComponent_CanSpendCurrency) == 0x000004, "Wrong alignment on InventoryComponent_CanSpendCurrency");
static_assert(sizeof(InventoryComponent_CanSpendCurrency) == 0x00000C, "Wrong size on InventoryComponent_CanSpendCurrency");
static_assert(offsetof(InventoryComponent_CanSpendCurrency, CurrencyValue) == 0x000000, "Member 'InventoryComponent_CanSpendCurrency::CurrencyValue' has a wrong offset!");
static_assert(offsetof(InventoryComponent_CanSpendCurrency, ReturnValue) == 0x000008, "Member 'InventoryComponent_CanSpendCurrency::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetAptitudeInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetAptitudeInventory final
{
public:
	class UInventoryAptitude*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetAptitudeInventory) == 0x000008, "Wrong alignment on InventoryComponent_GetAptitudeInventory");
static_assert(sizeof(InventoryComponent_GetAptitudeInventory) == 0x000008, "Wrong size on InventoryComponent_GetAptitudeInventory");
static_assert(offsetof(InventoryComponent_GetAptitudeInventory, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetAptitudeInventory::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetAssistInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetAssistInventory final
{
public:
	class UInventory*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetAssistInventory) == 0x000008, "Wrong alignment on InventoryComponent_GetAssistInventory");
static_assert(sizeof(InventoryComponent_GetAssistInventory) == 0x000008, "Wrong size on InventoryComponent_GetAssistInventory");
static_assert(offsetof(InventoryComponent_GetAssistInventory, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetAssistInventory::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetCostumeInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetCostumeInventory final
{
public:
	class UInventory*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetCostumeInventory) == 0x000008, "Wrong alignment on InventoryComponent_GetCostumeInventory");
static_assert(sizeof(InventoryComponent_GetCostumeInventory) == 0x000008, "Wrong size on InventoryComponent_GetCostumeInventory");
static_assert(offsetof(InventoryComponent_GetCostumeInventory, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetCostumeInventory::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetCountOfItem
// 0x0018 (0x0018 - 0x0000)
struct InventoryComponent_GetCountOfItem final
{
public:
	struct FDataTableRowHandle                    ItemHandle;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryComponent_GetCountOfItem) == 0x000008, "Wrong alignment on InventoryComponent_GetCountOfItem");
static_assert(sizeof(InventoryComponent_GetCountOfItem) == 0x000018, "Wrong size on InventoryComponent_GetCountOfItem");
static_assert(offsetof(InventoryComponent_GetCountOfItem, ItemHandle) == 0x000000, "Member 'InventoryComponent_GetCountOfItem::ItemHandle' has a wrong offset!");
static_assert(offsetof(InventoryComponent_GetCountOfItem, ReturnValue) == 0x000010, "Member 'InventoryComponent_GetCountOfItem::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetCurrency
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetCurrency final
{
public:
	ECurrencyType                                 CurrencyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetCurrency) == 0x000004, "Wrong alignment on InventoryComponent_GetCurrency");
static_assert(sizeof(InventoryComponent_GetCurrency) == 0x000008, "Wrong size on InventoryComponent_GetCurrency");
static_assert(offsetof(InventoryComponent_GetCurrency, CurrencyType) == 0x000000, "Member 'InventoryComponent_GetCurrency::CurrencyType' has a wrong offset!");
static_assert(offsetof(InventoryComponent_GetCurrency, ReturnValue) == 0x000004, "Member 'InventoryComponent_GetCurrency::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetCurrencyInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetCurrencyInventory final
{
public:
	class UInventory*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetCurrencyInventory) == 0x000008, "Wrong alignment on InventoryComponent_GetCurrencyInventory");
static_assert(sizeof(InventoryComponent_GetCurrencyInventory) == 0x000008, "Wrong size on InventoryComponent_GetCurrencyInventory");
static_assert(offsetof(InventoryComponent_GetCurrencyInventory, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetCurrencyInventory::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetEnemyInfoInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetEnemyInfoInventory final
{
public:
	class UInventory*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetEnemyInfoInventory) == 0x000008, "Wrong alignment on InventoryComponent_GetEnemyInfoInventory");
static_assert(sizeof(InventoryComponent_GetEnemyInfoInventory) == 0x000008, "Wrong size on InventoryComponent_GetEnemyInfoInventory");
static_assert(offsetof(InventoryComponent_GetEnemyInfoInventory, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetEnemyInfoInventory::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetEquipmentInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetEquipmentInventory final
{
public:
	class UInventory*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetEquipmentInventory) == 0x000008, "Wrong alignment on InventoryComponent_GetEquipmentInventory");
static_assert(sizeof(InventoryComponent_GetEquipmentInventory) == 0x000008, "Wrong size on InventoryComponent_GetEquipmentInventory");
static_assert(offsetof(InventoryComponent_GetEquipmentInventory, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetEquipmentInventory::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetGalleryInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetGalleryInventory final
{
public:
	class UInventory*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetGalleryInventory) == 0x000008, "Wrong alignment on InventoryComponent_GetGalleryInventory");
static_assert(sizeof(InventoryComponent_GetGalleryInventory) == 0x000008, "Wrong size on InventoryComponent_GetGalleryInventory");
static_assert(offsetof(InventoryComponent_GetGalleryInventory, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetGalleryInventory::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetInventoryFromItemType
// 0x0010 (0x0010 - 0x0000)
struct InventoryComponent_GetInventoryFromItemType final
{
public:
	EInventoryItemType                            ItemType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventory*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetInventoryFromItemType) == 0x000008, "Wrong alignment on InventoryComponent_GetInventoryFromItemType");
static_assert(sizeof(InventoryComponent_GetInventoryFromItemType) == 0x000010, "Wrong size on InventoryComponent_GetInventoryFromItemType");
static_assert(offsetof(InventoryComponent_GetInventoryFromItemType, ItemType) == 0x000000, "Member 'InventoryComponent_GetInventoryFromItemType::ItemType' has a wrong offset!");
static_assert(offsetof(InventoryComponent_GetInventoryFromItemType, ReturnValue) == 0x000008, "Member 'InventoryComponent_GetInventoryFromItemType::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetNPCInfoInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetNPCInfoInventory final
{
public:
	class UInventory*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetNPCInfoInventory) == 0x000008, "Wrong alignment on InventoryComponent_GetNPCInfoInventory");
static_assert(sizeof(InventoryComponent_GetNPCInfoInventory) == 0x000008, "Wrong size on InventoryComponent_GetNPCInfoInventory");
static_assert(offsetof(InventoryComponent_GetNPCInfoInventory, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetNPCInfoInventory::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetPassiveInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetPassiveInventory final
{
public:
	class UInventory*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetPassiveInventory) == 0x000008, "Wrong alignment on InventoryComponent_GetPassiveInventory");
static_assert(sizeof(InventoryComponent_GetPassiveInventory) == 0x000008, "Wrong size on InventoryComponent_GetPassiveInventory");
static_assert(offsetof(InventoryComponent_GetPassiveInventory, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetPassiveInventory::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetSkillInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetSkillInventory final
{
public:
	class UInventorySkill*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetSkillInventory) == 0x000008, "Wrong alignment on InventoryComponent_GetSkillInventory");
static_assert(sizeof(InventoryComponent_GetSkillInventory) == 0x000008, "Wrong size on InventoryComponent_GetSkillInventory");
static_assert(offsetof(InventoryComponent_GetSkillInventory, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetSkillInventory::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetSpiritInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetSpiritInventory final
{
public:
	class UInventory*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetSpiritInventory) == 0x000008, "Wrong alignment on InventoryComponent_GetSpiritInventory");
static_assert(sizeof(InventoryComponent_GetSpiritInventory) == 0x000008, "Wrong size on InventoryComponent_GetSpiritInventory");
static_assert(offsetof(InventoryComponent_GetSpiritInventory, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetSpiritInventory::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetStatsInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetStatsInventory final
{
public:
	class UInventory*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetStatsInventory) == 0x000008, "Wrong alignment on InventoryComponent_GetStatsInventory");
static_assert(sizeof(InventoryComponent_GetStatsInventory) == 0x000008, "Wrong size on InventoryComponent_GetStatsInventory");
static_assert(offsetof(InventoryComponent_GetStatsInventory, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetStatsInventory::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetTipInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetTipInventory final
{
public:
	class UInventory*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetTipInventory) == 0x000008, "Wrong alignment on InventoryComponent_GetTipInventory");
static_assert(sizeof(InventoryComponent_GetTipInventory) == 0x000008, "Wrong size on InventoryComponent_GetTipInventory");
static_assert(offsetof(InventoryComponent_GetTipInventory, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetTipInventory::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.GetTutorialInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_GetTutorialInventory final
{
public:
	class UInventory*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetTutorialInventory) == 0x000008, "Wrong alignment on InventoryComponent_GetTutorialInventory");
static_assert(sizeof(InventoryComponent_GetTutorialInventory) == 0x000008, "Wrong size on InventoryComponent_GetTutorialInventory");
static_assert(offsetof(InventoryComponent_GetTutorialInventory, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetTutorialInventory::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.HasAptitude
// 0x0002 (0x0002 - 0x0000)
struct InventoryComponent_HasAptitude final
{
public:
	EAptitudeType                                 AptitudeType;                                      // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_HasAptitude) == 0x000001, "Wrong alignment on InventoryComponent_HasAptitude");
static_assert(sizeof(InventoryComponent_HasAptitude) == 0x000002, "Wrong size on InventoryComponent_HasAptitude");
static_assert(offsetof(InventoryComponent_HasAptitude, AptitudeType) == 0x000000, "Member 'InventoryComponent_HasAptitude::AptitudeType' has a wrong offset!");
static_assert(offsetof(InventoryComponent_HasAptitude, ReturnValue) == 0x000001, "Member 'InventoryComponent_HasAptitude::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.HasNonCheckedItem
// 0x0002 (0x0002 - 0x0000)
struct InventoryComponent_HasNonCheckedItem final
{
public:
	EInventoryItemType                            ItemType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_HasNonCheckedItem) == 0x000001, "Wrong alignment on InventoryComponent_HasNonCheckedItem");
static_assert(sizeof(InventoryComponent_HasNonCheckedItem) == 0x000002, "Wrong size on InventoryComponent_HasNonCheckedItem");
static_assert(offsetof(InventoryComponent_HasNonCheckedItem, ItemType) == 0x000000, "Member 'InventoryComponent_HasNonCheckedItem::ItemType' has a wrong offset!");
static_assert(offsetof(InventoryComponent_HasNonCheckedItem, ReturnValue) == 0x000001, "Member 'InventoryComponent_HasNonCheckedItem::ReturnValue' has a wrong offset!");

// Function Zion.InventoryComponent.IsItemChecked
// 0x0018 (0x0018 - 0x0000)
struct InventoryComponent_IsItemChecked final
{
public:
	struct FDataTableRowHandle                    ItemHandle;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryComponent_IsItemChecked) == 0x000008, "Wrong alignment on InventoryComponent_IsItemChecked");
static_assert(sizeof(InventoryComponent_IsItemChecked) == 0x000018, "Wrong size on InventoryComponent_IsItemChecked");
static_assert(offsetof(InventoryComponent_IsItemChecked, ItemHandle) == 0x000000, "Member 'InventoryComponent_IsItemChecked::ItemHandle' has a wrong offset!");
static_assert(offsetof(InventoryComponent_IsItemChecked, ReturnValue) == 0x000010, "Member 'InventoryComponent_IsItemChecked::ReturnValue' has a wrong offset!");

// Function Zion.AbilityInstant.SetTargets
// 0x0010 (0x0010 - 0x0000)
struct AbilityInstant_SetTargets final
{
public:
	TArray<class AActor*>                         InTargets;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityInstant_SetTargets) == 0x000008, "Wrong alignment on AbilityInstant_SetTargets");
static_assert(sizeof(AbilityInstant_SetTargets) == 0x000010, "Wrong size on AbilityInstant_SetTargets");
static_assert(offsetof(AbilityInstant_SetTargets, InTargets) == 0x000000, "Member 'AbilityInstant_SetTargets::InTargets' has a wrong offset!");

// Function Zion.ActorBPFLibrary.ClearMovementBase
// 0x0008 (0x0008 - 0x0000)
struct ActorBPFLibrary_ClearMovementBase final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBPFLibrary_ClearMovementBase) == 0x000008, "Wrong alignment on ActorBPFLibrary_ClearMovementBase");
static_assert(sizeof(ActorBPFLibrary_ClearMovementBase) == 0x000008, "Wrong size on ActorBPFLibrary_ClearMovementBase");
static_assert(offsetof(ActorBPFLibrary_ClearMovementBase, Character) == 0x000000, "Member 'ActorBPFLibrary_ClearMovementBase::Character' has a wrong offset!");

// Function Zion.ActorBPFLibrary.FlushAnimations
// 0x0010 (0x0010 - 0x0000)
struct ActorBPFLibrary_FlushAnimations final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetAnimator;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ActorBPFLibrary_FlushAnimations) == 0x000008, "Wrong alignment on ActorBPFLibrary_FlushAnimations");
static_assert(sizeof(ActorBPFLibrary_FlushAnimations) == 0x000010, "Wrong size on ActorBPFLibrary_FlushAnimations");
static_assert(offsetof(ActorBPFLibrary_FlushAnimations, Actor) == 0x000000, "Member 'ActorBPFLibrary_FlushAnimations::Actor' has a wrong offset!");
static_assert(offsetof(ActorBPFLibrary_FlushAnimations, bResetAnimator) == 0x000008, "Member 'ActorBPFLibrary_FlushAnimations::bResetAnimator' has a wrong offset!");

// Function Zion.ActorBPFLibrary.GenerateClearIDForActor
// 0x0010 (0x0010 - 0x0000)
struct ActorBPFLibrary_GenerateClearIDForActor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBPFLibrary_GenerateClearIDForActor) == 0x000008, "Wrong alignment on ActorBPFLibrary_GenerateClearIDForActor");
static_assert(sizeof(ActorBPFLibrary_GenerateClearIDForActor) == 0x000010, "Wrong size on ActorBPFLibrary_GenerateClearIDForActor");
static_assert(offsetof(ActorBPFLibrary_GenerateClearIDForActor, Actor) == 0x000000, "Member 'ActorBPFLibrary_GenerateClearIDForActor::Actor' has a wrong offset!");
static_assert(offsetof(ActorBPFLibrary_GenerateClearIDForActor, ReturnValue) == 0x000008, "Member 'ActorBPFLibrary_GenerateClearIDForActor::ReturnValue' has a wrong offset!");

// Function Zion.ActorBPFLibrary.GetActorID
// 0x0010 (0x0010 - 0x0000)
struct ActorBPFLibrary_GetActorID final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBPFLibrary_GetActorID) == 0x000008, "Wrong alignment on ActorBPFLibrary_GetActorID");
static_assert(sizeof(ActorBPFLibrary_GetActorID) == 0x000010, "Wrong size on ActorBPFLibrary_GetActorID");
static_assert(offsetof(ActorBPFLibrary_GetActorID, Actor) == 0x000000, "Member 'ActorBPFLibrary_GetActorID::Actor' has a wrong offset!");
static_assert(offsetof(ActorBPFLibrary_GetActorID, ReturnValue) == 0x000008, "Member 'ActorBPFLibrary_GetActorID::ReturnValue' has a wrong offset!");

// Function Zion.ActorBPFLibrary.GetBottomLocation
// 0x0020 (0x0020 - 0x0000)
struct ActorBPFLibrary_GetBottomLocation final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBPFLibrary_GetBottomLocation) == 0x000008, "Wrong alignment on ActorBPFLibrary_GetBottomLocation");
static_assert(sizeof(ActorBPFLibrary_GetBottomLocation) == 0x000020, "Wrong size on ActorBPFLibrary_GetBottomLocation");
static_assert(offsetof(ActorBPFLibrary_GetBottomLocation, Actor) == 0x000000, "Member 'ActorBPFLibrary_GetBottomLocation::Actor' has a wrong offset!");
static_assert(offsetof(ActorBPFLibrary_GetBottomLocation, ReturnValue) == 0x000008, "Member 'ActorBPFLibrary_GetBottomLocation::ReturnValue' has a wrong offset!");

// Function Zion.ActorBPFLibrary.GetHalfHeight
// 0x0010 (0x0010 - 0x0000)
struct ActorBPFLibrary_GetHalfHeight final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ActorBPFLibrary_GetHalfHeight) == 0x000008, "Wrong alignment on ActorBPFLibrary_GetHalfHeight");
static_assert(sizeof(ActorBPFLibrary_GetHalfHeight) == 0x000010, "Wrong size on ActorBPFLibrary_GetHalfHeight");
static_assert(offsetof(ActorBPFLibrary_GetHalfHeight, Actor) == 0x000000, "Member 'ActorBPFLibrary_GetHalfHeight::Actor' has a wrong offset!");
static_assert(offsetof(ActorBPFLibrary_GetHalfHeight, ReturnValue) == 0x000008, "Member 'ActorBPFLibrary_GetHalfHeight::ReturnValue' has a wrong offset!");

// Function Zion.ActorBPFLibrary.GetTargetPivotComponent
// 0x0010 (0x0010 - 0x0000)
struct ActorBPFLibrary_GetTargetPivotComponent final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class USceneComponent*                  ReturnValue;                                       // 0x0008(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBPFLibrary_GetTargetPivotComponent) == 0x000008, "Wrong alignment on ActorBPFLibrary_GetTargetPivotComponent");
static_assert(sizeof(ActorBPFLibrary_GetTargetPivotComponent) == 0x000010, "Wrong size on ActorBPFLibrary_GetTargetPivotComponent");
static_assert(offsetof(ActorBPFLibrary_GetTargetPivotComponent, Actor) == 0x000000, "Member 'ActorBPFLibrary_GetTargetPivotComponent::Actor' has a wrong offset!");
static_assert(offsetof(ActorBPFLibrary_GetTargetPivotComponent, ReturnValue) == 0x000008, "Member 'ActorBPFLibrary_GetTargetPivotComponent::ReturnValue' has a wrong offset!");

// Function Zion.ActorBPFLibrary.GetTargetPivotLocation
// 0x0020 (0x0020 - 0x0000)
struct ActorBPFLibrary_GetTargetPivotLocation final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBPFLibrary_GetTargetPivotLocation) == 0x000008, "Wrong alignment on ActorBPFLibrary_GetTargetPivotLocation");
static_assert(sizeof(ActorBPFLibrary_GetTargetPivotLocation) == 0x000020, "Wrong size on ActorBPFLibrary_GetTargetPivotLocation");
static_assert(offsetof(ActorBPFLibrary_GetTargetPivotLocation, Actor) == 0x000000, "Member 'ActorBPFLibrary_GetTargetPivotLocation::Actor' has a wrong offset!");
static_assert(offsetof(ActorBPFLibrary_GetTargetPivotLocation, ReturnValue) == 0x000008, "Member 'ActorBPFLibrary_GetTargetPivotLocation::ReturnValue' has a wrong offset!");

// Function Zion.ActorBPFLibrary.GetTopLocation
// 0x0020 (0x0020 - 0x0000)
struct ActorBPFLibrary_GetTopLocation final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBPFLibrary_GetTopLocation) == 0x000008, "Wrong alignment on ActorBPFLibrary_GetTopLocation");
static_assert(sizeof(ActorBPFLibrary_GetTopLocation) == 0x000020, "Wrong size on ActorBPFLibrary_GetTopLocation");
static_assert(offsetof(ActorBPFLibrary_GetTopLocation, Actor) == 0x000000, "Member 'ActorBPFLibrary_GetTopLocation::Actor' has a wrong offset!");
static_assert(offsetof(ActorBPFLibrary_GetTopLocation, ReturnValue) == 0x000008, "Member 'ActorBPFLibrary_GetTopLocation::ReturnValue' has a wrong offset!");

// Function Zion.ActorBPFLibrary.GetWorldIDForActor
// 0x0010 (0x0010 - 0x0000)
struct ActorBPFLibrary_GetWorldIDForActor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBPFLibrary_GetWorldIDForActor) == 0x000008, "Wrong alignment on ActorBPFLibrary_GetWorldIDForActor");
static_assert(sizeof(ActorBPFLibrary_GetWorldIDForActor) == 0x000010, "Wrong size on ActorBPFLibrary_GetWorldIDForActor");
static_assert(offsetof(ActorBPFLibrary_GetWorldIDForActor, Actor) == 0x000000, "Member 'ActorBPFLibrary_GetWorldIDForActor::Actor' has a wrong offset!");
static_assert(offsetof(ActorBPFLibrary_GetWorldIDForActor, ReturnValue) == 0x000008, "Member 'ActorBPFLibrary_GetWorldIDForActor::ReturnValue' has a wrong offset!");

// Function Zion.ActorBPFLibrary.IsPlayer
// 0x0010 (0x0010 - 0x0000)
struct ActorBPFLibrary_IsPlayer final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ActorBPFLibrary_IsPlayer) == 0x000008, "Wrong alignment on ActorBPFLibrary_IsPlayer");
static_assert(sizeof(ActorBPFLibrary_IsPlayer) == 0x000010, "Wrong size on ActorBPFLibrary_IsPlayer");
static_assert(offsetof(ActorBPFLibrary_IsPlayer, Actor) == 0x000000, "Member 'ActorBPFLibrary_IsPlayer::Actor' has a wrong offset!");
static_assert(offsetof(ActorBPFLibrary_IsPlayer, ReturnValue) == 0x000008, "Member 'ActorBPFLibrary_IsPlayer::ReturnValue' has a wrong offset!");

// Function Zion.ActorBPFLibrary.ResetVelocity
// 0x0010 (0x0010 - 0x0000)
struct ActorBPFLibrary_ResetVelocity final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetX;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetY;                                           // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetZ;                                           // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ActorBPFLibrary_ResetVelocity) == 0x000008, "Wrong alignment on ActorBPFLibrary_ResetVelocity");
static_assert(sizeof(ActorBPFLibrary_ResetVelocity) == 0x000010, "Wrong size on ActorBPFLibrary_ResetVelocity");
static_assert(offsetof(ActorBPFLibrary_ResetVelocity, Actor) == 0x000000, "Member 'ActorBPFLibrary_ResetVelocity::Actor' has a wrong offset!");
static_assert(offsetof(ActorBPFLibrary_ResetVelocity, bResetX) == 0x000008, "Member 'ActorBPFLibrary_ResetVelocity::bResetX' has a wrong offset!");
static_assert(offsetof(ActorBPFLibrary_ResetVelocity, bResetY) == 0x000009, "Member 'ActorBPFLibrary_ResetVelocity::bResetY' has a wrong offset!");
static_assert(offsetof(ActorBPFLibrary_ResetVelocity, bResetZ) == 0x00000A, "Member 'ActorBPFLibrary_ResetVelocity::bResetZ' has a wrong offset!");

// Function Zion.ActorBPFLibrary.ToggleActor
// 0x0008 (0x0008 - 0x0000)
struct ActorBPFLibrary_ToggleActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBPFLibrary_ToggleActor) == 0x000008, "Wrong alignment on ActorBPFLibrary_ToggleActor");
static_assert(sizeof(ActorBPFLibrary_ToggleActor) == 0x000008, "Wrong size on ActorBPFLibrary_ToggleActor");
static_assert(offsetof(ActorBPFLibrary_ToggleActor, Actor) == 0x000000, "Member 'ActorBPFLibrary_ToggleActor::Actor' has a wrong offset!");

// Function Zion.HookComponent.OnComponentOverlapBegin
// 0x0118 (0x0118 - 0x0000)
struct HookComponent_OnComponentOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlapComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HookComponent_OnComponentOverlapBegin) == 0x000008, "Wrong alignment on HookComponent_OnComponentOverlapBegin");
static_assert(sizeof(HookComponent_OnComponentOverlapBegin) == 0x000118, "Wrong size on HookComponent_OnComponentOverlapBegin");
static_assert(offsetof(HookComponent_OnComponentOverlapBegin, OverlapComponent) == 0x000000, "Member 'HookComponent_OnComponentOverlapBegin::OverlapComponent' has a wrong offset!");
static_assert(offsetof(HookComponent_OnComponentOverlapBegin, OtherActor) == 0x000008, "Member 'HookComponent_OnComponentOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(HookComponent_OnComponentOverlapBegin, OtherComp) == 0x000010, "Member 'HookComponent_OnComponentOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(HookComponent_OnComponentOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'HookComponent_OnComponentOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(HookComponent_OnComponentOverlapBegin, bFromSweep) == 0x00001C, "Member 'HookComponent_OnComponentOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(HookComponent_OnComponentOverlapBegin, SweepResult) == 0x000020, "Member 'HookComponent_OnComponentOverlapBegin::SweepResult' has a wrong offset!");

// Function Zion.HookComponent.OnComponentOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct HookComponent_OnComponentOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlapComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HookComponent_OnComponentOverlapEnd) == 0x000008, "Wrong alignment on HookComponent_OnComponentOverlapEnd");
static_assert(sizeof(HookComponent_OnComponentOverlapEnd) == 0x000020, "Wrong size on HookComponent_OnComponentOverlapEnd");
static_assert(offsetof(HookComponent_OnComponentOverlapEnd, OverlapComponent) == 0x000000, "Member 'HookComponent_OnComponentOverlapEnd::OverlapComponent' has a wrong offset!");
static_assert(offsetof(HookComponent_OnComponentOverlapEnd, OtherActor) == 0x000008, "Member 'HookComponent_OnComponentOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(HookComponent_OnComponentOverlapEnd, OtherComp) == 0x000010, "Member 'HookComponent_OnComponentOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(HookComponent_OnComponentOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'HookComponent_OnComponentOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function Zion.HookComponent.OnLockHook
// 0x0008 (0x0008 - 0x0000)
struct HookComponent_OnLockHook final
{
public:
	class AHookPoint*                             HookPoint;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HookComponent_OnLockHook) == 0x000008, "Wrong alignment on HookComponent_OnLockHook");
static_assert(sizeof(HookComponent_OnLockHook) == 0x000008, "Wrong size on HookComponent_OnLockHook");
static_assert(offsetof(HookComponent_OnLockHook, HookPoint) == 0x000000, "Member 'HookComponent_OnLockHook::HookPoint' has a wrong offset!");

// Function Zion.HookComponent.OnUnlockHook
// 0x0008 (0x0008 - 0x0000)
struct HookComponent_OnUnlockHook final
{
public:
	class AHookPoint*                             HookPoint;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HookComponent_OnUnlockHook) == 0x000008, "Wrong alignment on HookComponent_OnUnlockHook");
static_assert(sizeof(HookComponent_OnUnlockHook) == 0x000008, "Wrong size on HookComponent_OnUnlockHook");
static_assert(offsetof(HookComponent_OnUnlockHook, HookPoint) == 0x000000, "Member 'HookComponent_OnUnlockHook::HookPoint' has a wrong offset!");

// Function Zion.HookComponent.SetOverrideHookPoint
// 0x0008 (0x0008 - 0x0000)
struct HookComponent_SetOverrideHookPoint final
{
public:
	class AHookPoint*                             NewHookPoint;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HookComponent_SetOverrideHookPoint) == 0x000008, "Wrong alignment on HookComponent_SetOverrideHookPoint");
static_assert(sizeof(HookComponent_SetOverrideHookPoint) == 0x000008, "Wrong size on HookComponent_SetOverrideHookPoint");
static_assert(offsetof(HookComponent_SetOverrideHookPoint, NewHookPoint) == 0x000000, "Member 'HookComponent_SetOverrideHookPoint::NewHookPoint' has a wrong offset!");

// Function Zion.HookComponent.SetOverrideHookWorldLocation
// 0x0018 (0x0018 - 0x0000)
struct HookComponent_SetOverrideHookWorldLocation final
{
public:
	struct FVector                                NewHookWorldLocation;                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HookComponent_SetOverrideHookWorldLocation) == 0x000008, "Wrong alignment on HookComponent_SetOverrideHookWorldLocation");
static_assert(sizeof(HookComponent_SetOverrideHookWorldLocation) == 0x000018, "Wrong size on HookComponent_SetOverrideHookWorldLocation");
static_assert(offsetof(HookComponent_SetOverrideHookWorldLocation, NewHookWorldLocation) == 0x000000, "Member 'HookComponent_SetOverrideHookWorldLocation::NewHookWorldLocation' has a wrong offset!");

// Function Zion.HookComponent.CanTargetHook
// 0x0002 (0x0002 - 0x0000)
struct HookComponent_CanTargetHook final
{
public:
	EHookType                                     HookType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HookComponent_CanTargetHook) == 0x000001, "Wrong alignment on HookComponent_CanTargetHook");
static_assert(sizeof(HookComponent_CanTargetHook) == 0x000002, "Wrong size on HookComponent_CanTargetHook");
static_assert(offsetof(HookComponent_CanTargetHook, HookType) == 0x000000, "Member 'HookComponent_CanTargetHook::HookType' has a wrong offset!");
static_assert(offsetof(HookComponent_CanTargetHook, ReturnValue) == 0x000001, "Member 'HookComponent_CanTargetHook::ReturnValue' has a wrong offset!");

// Function Zion.HookComponent.GetHookWorldLocation
// 0x0018 (0x0018 - 0x0000)
struct HookComponent_GetHookWorldLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HookComponent_GetHookWorldLocation) == 0x000008, "Wrong alignment on HookComponent_GetHookWorldLocation");
static_assert(sizeof(HookComponent_GetHookWorldLocation) == 0x000018, "Wrong size on HookComponent_GetHookWorldLocation");
static_assert(offsetof(HookComponent_GetHookWorldLocation, ReturnValue) == 0x000000, "Member 'HookComponent_GetHookWorldLocation::ReturnValue' has a wrong offset!");

// Function Zion.ActorSpawner.OnPostSpawnActor
// 0x0010 (0x0010 - 0x0000)
struct ActorSpawner_OnPostSpawnActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreview;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ActorSpawner_OnPostSpawnActor) == 0x000008, "Wrong alignment on ActorSpawner_OnPostSpawnActor");
static_assert(sizeof(ActorSpawner_OnPostSpawnActor) == 0x000010, "Wrong size on ActorSpawner_OnPostSpawnActor");
static_assert(offsetof(ActorSpawner_OnPostSpawnActor, Actor) == 0x000000, "Member 'ActorSpawner_OnPostSpawnActor::Actor' has a wrong offset!");
static_assert(offsetof(ActorSpawner_OnPostSpawnActor, bPreview) == 0x000008, "Member 'ActorSpawner_OnPostSpawnActor::bPreview' has a wrong offset!");

// Function Zion.ActorSpawner.OnPreSpawnActor
// 0x0008 (0x0008 - 0x0000)
struct ActorSpawner_OnPreSpawnActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorSpawner_OnPreSpawnActor) == 0x000008, "Wrong alignment on ActorSpawner_OnPreSpawnActor");
static_assert(sizeof(ActorSpawner_OnPreSpawnActor) == 0x000008, "Wrong size on ActorSpawner_OnPreSpawnActor");
static_assert(offsetof(ActorSpawner_OnPreSpawnActor, Actor) == 0x000000, "Member 'ActorSpawner_OnPreSpawnActor::Actor' has a wrong offset!");

// Function Zion.ActorSpawner.SetActorToSpawn
// 0x0028 (0x0028 - 0x0000)
struct ActorSpawner_SetActorToSpawn final
{
public:
	TSoftClassPtr<class UClass>                   InActorClassToSpawn;                               // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorSpawner_SetActorToSpawn) == 0x000008, "Wrong alignment on ActorSpawner_SetActorToSpawn");
static_assert(sizeof(ActorSpawner_SetActorToSpawn) == 0x000028, "Wrong size on ActorSpawner_SetActorToSpawn");
static_assert(offsetof(ActorSpawner_SetActorToSpawn, InActorClassToSpawn) == 0x000000, "Member 'ActorSpawner_SetActorToSpawn::InActorClassToSpawn' has a wrong offset!");

// Function Zion.AfterImageRenderer.OnSetup
// 0x0070 (0x0070 - 0x0000)
struct AfterImageRenderer_OnSetup final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 Texture;                                           // 0x0060(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AfterImageRenderer_OnSetup) == 0x000010, "Wrong alignment on AfterImageRenderer_OnSetup");
static_assert(sizeof(AfterImageRenderer_OnSetup) == 0x000070, "Wrong size on AfterImageRenderer_OnSetup");
static_assert(offsetof(AfterImageRenderer_OnSetup, Transform) == 0x000000, "Member 'AfterImageRenderer_OnSetup::Transform' has a wrong offset!");
static_assert(offsetof(AfterImageRenderer_OnSetup, Texture) == 0x000060, "Member 'AfterImageRenderer_OnSetup::Texture' has a wrong offset!");

// Function Zion.AfterImageComponent.SetAfterImageType
// 0x0001 (0x0001 - 0x0000)
struct AfterImageComponent_SetAfterImageType final
{
public:
	EAfterImageType                               NewAfterImageType;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AfterImageComponent_SetAfterImageType) == 0x000001, "Wrong alignment on AfterImageComponent_SetAfterImageType");
static_assert(sizeof(AfterImageComponent_SetAfterImageType) == 0x000001, "Wrong size on AfterImageComponent_SetAfterImageType");
static_assert(offsetof(AfterImageComponent_SetAfterImageType, NewAfterImageType) == 0x000000, "Member 'AfterImageComponent_SetAfterImageType::NewAfterImageType' has a wrong offset!");

// Function Zion.AfterImageComponent.GetAfterImageType
// 0x0001 (0x0001 - 0x0000)
struct AfterImageComponent_GetAfterImageType final
{
public:
	EAfterImageType                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AfterImageComponent_GetAfterImageType) == 0x000001, "Wrong alignment on AfterImageComponent_GetAfterImageType");
static_assert(sizeof(AfterImageComponent_GetAfterImageType) == 0x000001, "Wrong size on AfterImageComponent_GetAfterImageType");
static_assert(offsetof(AfterImageComponent_GetAfterImageType, ReturnValue) == 0x000000, "Member 'AfterImageComponent_GetAfterImageType::ReturnValue' has a wrong offset!");

// Function Zion.Command_HoldGuard.OnGuarded
// 0x0010 (0x0010 - 0x0000)
struct Command_HoldGuard_OnGuarded final
{
public:
	class AAbility*                               Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_HoldGuard_OnGuarded) == 0x000008, "Wrong alignment on Command_HoldGuard_OnGuarded");
static_assert(sizeof(Command_HoldGuard_OnGuarded) == 0x000010, "Wrong size on Command_HoldGuard_OnGuarded");
static_assert(offsetof(Command_HoldGuard_OnGuarded, Ability) == 0x000000, "Member 'Command_HoldGuard_OnGuarded::Ability' has a wrong offset!");
static_assert(offsetof(Command_HoldGuard_OnGuarded, Source) == 0x000008, "Member 'Command_HoldGuard_OnGuarded::Source' has a wrong offset!");

// Function Zion.Command_HoldGuard.OnReceivedDamage
// 0x0010 (0x0010 - 0x0000)
struct Command_HoldGuard_OnReceivedDamage final
{
public:
	class AActor*                                 Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Command_HoldGuard_OnReceivedDamage) == 0x000008, "Wrong alignment on Command_HoldGuard_OnReceivedDamage");
static_assert(sizeof(Command_HoldGuard_OnReceivedDamage) == 0x000010, "Wrong size on Command_HoldGuard_OnReceivedDamage");
static_assert(offsetof(Command_HoldGuard_OnReceivedDamage, Source) == 0x000000, "Member 'Command_HoldGuard_OnReceivedDamage::Source' has a wrong offset!");
static_assert(offsetof(Command_HoldGuard_OnReceivedDamage, Value) == 0x000008, "Member 'Command_HoldGuard_OnReceivedDamage::Value' has a wrong offset!");

// Function Zion.Command_HoldGuard.IsReleased
// 0x0001 (0x0001 - 0x0000)
struct Command_HoldGuard_IsReleased final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_HoldGuard_IsReleased) == 0x000001, "Wrong alignment on Command_HoldGuard_IsReleased");
static_assert(sizeof(Command_HoldGuard_IsReleased) == 0x000001, "Wrong size on Command_HoldGuard_IsReleased");
static_assert(offsetof(Command_HoldGuard_IsReleased, ReturnValue) == 0x000000, "Member 'Command_HoldGuard_IsReleased::ReturnValue' has a wrong offset!");

// Function Zion.AICommandClassProviderInterface.GetFindEnemyCommandClass
// 0x0008 (0x0008 - 0x0000)
struct AICommandClassProviderInterface_GetFindEnemyCommandClass final
{
public:
	TSubclassOf<class UCommand>                   out_CommandClass;                                  // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AICommandClassProviderInterface_GetFindEnemyCommandClass) == 0x000008, "Wrong alignment on AICommandClassProviderInterface_GetFindEnemyCommandClass");
static_assert(sizeof(AICommandClassProviderInterface_GetFindEnemyCommandClass) == 0x000008, "Wrong size on AICommandClassProviderInterface_GetFindEnemyCommandClass");
static_assert(offsetof(AICommandClassProviderInterface_GetFindEnemyCommandClass, out_CommandClass) == 0x000000, "Member 'AICommandClassProviderInterface_GetFindEnemyCommandClass::out_CommandClass' has a wrong offset!");

// Function Zion.AICommandClassProviderInterface.GetIdlePeaceCommandClass
// 0x0008 (0x0008 - 0x0000)
struct AICommandClassProviderInterface_GetIdlePeaceCommandClass final
{
public:
	TSubclassOf<class UCommand>                   out_CommandClass;                                  // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AICommandClassProviderInterface_GetIdlePeaceCommandClass) == 0x000008, "Wrong alignment on AICommandClassProviderInterface_GetIdlePeaceCommandClass");
static_assert(sizeof(AICommandClassProviderInterface_GetIdlePeaceCommandClass) == 0x000008, "Wrong size on AICommandClassProviderInterface_GetIdlePeaceCommandClass");
static_assert(offsetof(AICommandClassProviderInterface_GetIdlePeaceCommandClass, out_CommandClass) == 0x000000, "Member 'AICommandClassProviderInterface_GetIdlePeaceCommandClass::out_CommandClass' has a wrong offset!");

// Function Zion.HookPoint.GetHookAttachComponent
// 0x0008 (0x0008 - 0x0000)
struct HookPoint_GetHookAttachComponent final
{
public:
	class USceneComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HookPoint_GetHookAttachComponent) == 0x000008, "Wrong alignment on HookPoint_GetHookAttachComponent");
static_assert(sizeof(HookPoint_GetHookAttachComponent) == 0x000008, "Wrong size on HookPoint_GetHookAttachComponent");
static_assert(offsetof(HookPoint_GetHookAttachComponent, ReturnValue) == 0x000000, "Member 'HookPoint_GetHookAttachComponent::ReturnValue' has a wrong offset!");

// Function Zion.HookPoint.GetHookLocation
// 0x0018 (0x0018 - 0x0000)
struct HookPoint_GetHookLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HookPoint_GetHookLocation) == 0x000008, "Wrong alignment on HookPoint_GetHookLocation");
static_assert(sizeof(HookPoint_GetHookLocation) == 0x000018, "Wrong size on HookPoint_GetHookLocation");
static_assert(offsetof(HookPoint_GetHookLocation, ReturnValue) == 0x000000, "Member 'HookPoint_GetHookLocation::ReturnValue' has a wrong offset!");

// Function Zion.HookPoint.GetHookTransform
// 0x0060 (0x0060 - 0x0000)
struct HookPoint_GetHookTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HookPoint_GetHookTransform) == 0x000010, "Wrong alignment on HookPoint_GetHookTransform");
static_assert(sizeof(HookPoint_GetHookTransform) == 0x000060, "Wrong size on HookPoint_GetHookTransform");
static_assert(offsetof(HookPoint_GetHookTransform, ReturnValue) == 0x000000, "Member 'HookPoint_GetHookTransform::ReturnValue' has a wrong offset!");

// Function Zion.HookPoint.GetHookType
// 0x0001 (0x0001 - 0x0000)
struct HookPoint_GetHookType final
{
public:
	EHookType                                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HookPoint_GetHookType) == 0x000001, "Wrong alignment on HookPoint_GetHookType");
static_assert(sizeof(HookPoint_GetHookType) == 0x000001, "Wrong size on HookPoint_GetHookType");
static_assert(offsetof(HookPoint_GetHookType, ReturnValue) == 0x000000, "Member 'HookPoint_GetHookType::ReturnValue' has a wrong offset!");

// Function Zion.HookPoint_Moving.OnComponentOverlapBegin
// 0x0118 (0x0118 - 0x0000)
struct HookPoint_Moving_OnComponentOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlapComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HookPoint_Moving_OnComponentOverlapBegin) == 0x000008, "Wrong alignment on HookPoint_Moving_OnComponentOverlapBegin");
static_assert(sizeof(HookPoint_Moving_OnComponentOverlapBegin) == 0x000118, "Wrong size on HookPoint_Moving_OnComponentOverlapBegin");
static_assert(offsetof(HookPoint_Moving_OnComponentOverlapBegin, OverlapComponent) == 0x000000, "Member 'HookPoint_Moving_OnComponentOverlapBegin::OverlapComponent' has a wrong offset!");
static_assert(offsetof(HookPoint_Moving_OnComponentOverlapBegin, OtherActor) == 0x000008, "Member 'HookPoint_Moving_OnComponentOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(HookPoint_Moving_OnComponentOverlapBegin, OtherComp) == 0x000010, "Member 'HookPoint_Moving_OnComponentOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(HookPoint_Moving_OnComponentOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'HookPoint_Moving_OnComponentOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(HookPoint_Moving_OnComponentOverlapBegin, bFromSweep) == 0x00001C, "Member 'HookPoint_Moving_OnComponentOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(HookPoint_Moving_OnComponentOverlapBegin, SweepResult) == 0x000020, "Member 'HookPoint_Moving_OnComponentOverlapBegin::SweepResult' has a wrong offset!");

// Function Zion.HookPoint_Moving.OnMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct HookPoint_Moving_OnMovementModeChanged final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HookPoint_Moving_OnMovementModeChanged) == 0x000008, "Wrong alignment on HookPoint_Moving_OnMovementModeChanged");
static_assert(sizeof(HookPoint_Moving_OnMovementModeChanged) == 0x000010, "Wrong size on HookPoint_Moving_OnMovementModeChanged");
static_assert(offsetof(HookPoint_Moving_OnMovementModeChanged, Character) == 0x000000, "Member 'HookPoint_Moving_OnMovementModeChanged::Character' has a wrong offset!");
static_assert(offsetof(HookPoint_Moving_OnMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'HookPoint_Moving_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(HookPoint_Moving_OnMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'HookPoint_Moving_OnMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function Zion.AIControllerZion.OnChangeTarget
// 0x0008 (0x0008 - 0x0000)
struct AIControllerZion_OnChangeTarget final
{
public:
	const class AActor*                           NewTarget;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIControllerZion_OnChangeTarget) == 0x000008, "Wrong alignment on AIControllerZion_OnChangeTarget");
static_assert(sizeof(AIControllerZion_OnChangeTarget) == 0x000008, "Wrong size on AIControllerZion_OnChangeTarget");
static_assert(offsetof(AIControllerZion_OnChangeTarget, NewTarget) == 0x000000, "Member 'AIControllerZion_OnChangeTarget::NewTarget' has a wrong offset!");

// Function Zion.UserWidgetWrapBox.AddChild
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetWrapBox_AddChild final
{
public:
	class UWidget*                                Content;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetWrapBox_AddChild) == 0x000008, "Wrong alignment on UserWidgetWrapBox_AddChild");
static_assert(sizeof(UserWidgetWrapBox_AddChild) == 0x000008, "Wrong size on UserWidgetWrapBox_AddChild");
static_assert(offsetof(UserWidgetWrapBox_AddChild, Content) == 0x000000, "Member 'UserWidgetWrapBox_AddChild::Content' has a wrong offset!");

// Function Zion.UserWidgetWrapBox.RemoveChild
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetWrapBox_RemoveChild final
{
public:
	class UWidget*                                Content;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserWidgetWrapBox_RemoveChild) == 0x000008, "Wrong alignment on UserWidgetWrapBox_RemoveChild");
static_assert(sizeof(UserWidgetWrapBox_RemoveChild) == 0x000010, "Wrong size on UserWidgetWrapBox_RemoveChild");
static_assert(offsetof(UserWidgetWrapBox_RemoveChild, Content) == 0x000000, "Member 'UserWidgetWrapBox_RemoveChild::Content' has a wrong offset!");
static_assert(offsetof(UserWidgetWrapBox_RemoveChild, ReturnValue) == 0x000008, "Member 'UserWidgetWrapBox_RemoveChild::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetWrapBox.RemoveChildAt
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetWrapBox_RemoveChildAt final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserWidgetWrapBox_RemoveChildAt) == 0x000004, "Wrong alignment on UserWidgetWrapBox_RemoveChildAt");
static_assert(sizeof(UserWidgetWrapBox_RemoveChildAt) == 0x000008, "Wrong size on UserWidgetWrapBox_RemoveChildAt");
static_assert(offsetof(UserWidgetWrapBox_RemoveChildAt, Index_0) == 0x000000, "Member 'UserWidgetWrapBox_RemoveChildAt::Index_0' has a wrong offset!");
static_assert(offsetof(UserWidgetWrapBox_RemoveChildAt, ReturnValue) == 0x000004, "Member 'UserWidgetWrapBox_RemoveChildAt::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetWrapBox.GetAllChildren
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetWrapBox_GetAllChildren final
{
public:
	TArray<class UWidget*>                        ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetWrapBox_GetAllChildren) == 0x000008, "Wrong alignment on UserWidgetWrapBox_GetAllChildren");
static_assert(sizeof(UserWidgetWrapBox_GetAllChildren) == 0x000010, "Wrong size on UserWidgetWrapBox_GetAllChildren");
static_assert(offsetof(UserWidgetWrapBox_GetAllChildren, ReturnValue) == 0x000000, "Member 'UserWidgetWrapBox_GetAllChildren::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetWrapBox.GetChildAt
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetWrapBox_GetChildAt final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetWrapBox_GetChildAt) == 0x000008, "Wrong alignment on UserWidgetWrapBox_GetChildAt");
static_assert(sizeof(UserWidgetWrapBox_GetChildAt) == 0x000010, "Wrong size on UserWidgetWrapBox_GetChildAt");
static_assert(offsetof(UserWidgetWrapBox_GetChildAt, Index_0) == 0x000000, "Member 'UserWidgetWrapBox_GetChildAt::Index_0' has a wrong offset!");
static_assert(offsetof(UserWidgetWrapBox_GetChildAt, ReturnValue) == 0x000008, "Member 'UserWidgetWrapBox_GetChildAt::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetWrapBox.GetChildIndex
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetWrapBox_GetChildIndex final
{
public:
	const class UWidget*                          Content;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserWidgetWrapBox_GetChildIndex) == 0x000008, "Wrong alignment on UserWidgetWrapBox_GetChildIndex");
static_assert(sizeof(UserWidgetWrapBox_GetChildIndex) == 0x000010, "Wrong size on UserWidgetWrapBox_GetChildIndex");
static_assert(offsetof(UserWidgetWrapBox_GetChildIndex, Content) == 0x000000, "Member 'UserWidgetWrapBox_GetChildIndex::Content' has a wrong offset!");
static_assert(offsetof(UserWidgetWrapBox_GetChildIndex, ReturnValue) == 0x000008, "Member 'UserWidgetWrapBox_GetChildIndex::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetWrapBox.GetChildrenCount
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetWrapBox_GetChildrenCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetWrapBox_GetChildrenCount) == 0x000004, "Wrong alignment on UserWidgetWrapBox_GetChildrenCount");
static_assert(sizeof(UserWidgetWrapBox_GetChildrenCount) == 0x000004, "Wrong size on UserWidgetWrapBox_GetChildrenCount");
static_assert(offsetof(UserWidgetWrapBox_GetChildrenCount, ReturnValue) == 0x000000, "Member 'UserWidgetWrapBox_GetChildrenCount::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetWrapBox.GetWrapNavigationWidget
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetWrapBox_GetWrapNavigationWidget final
{
public:
	bool                                          bWrapToTop;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetWrapBox_GetWrapNavigationWidget) == 0x000008, "Wrong alignment on UserWidgetWrapBox_GetWrapNavigationWidget");
static_assert(sizeof(UserWidgetWrapBox_GetWrapNavigationWidget) == 0x000010, "Wrong size on UserWidgetWrapBox_GetWrapNavigationWidget");
static_assert(offsetof(UserWidgetWrapBox_GetWrapNavigationWidget, bWrapToTop) == 0x000000, "Member 'UserWidgetWrapBox_GetWrapNavigationWidget::bWrapToTop' has a wrong offset!");
static_assert(offsetof(UserWidgetWrapBox_GetWrapNavigationWidget, ReturnValue) == 0x000008, "Member 'UserWidgetWrapBox_GetWrapNavigationWidget::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetWrapBox.HasAnyChildren
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetWrapBox_HasAnyChildren final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetWrapBox_HasAnyChildren) == 0x000001, "Wrong alignment on UserWidgetWrapBox_HasAnyChildren");
static_assert(sizeof(UserWidgetWrapBox_HasAnyChildren) == 0x000001, "Wrong size on UserWidgetWrapBox_HasAnyChildren");
static_assert(offsetof(UserWidgetWrapBox_HasAnyChildren, ReturnValue) == 0x000000, "Member 'UserWidgetWrapBox_HasAnyChildren::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetWrapBox.HasChild
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetWrapBox_HasChild final
{
public:
	class UWidget*                                Content;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserWidgetWrapBox_HasChild) == 0x000008, "Wrong alignment on UserWidgetWrapBox_HasChild");
static_assert(sizeof(UserWidgetWrapBox_HasChild) == 0x000010, "Wrong size on UserWidgetWrapBox_HasChild");
static_assert(offsetof(UserWidgetWrapBox_HasChild, Content) == 0x000000, "Member 'UserWidgetWrapBox_HasChild::Content' has a wrong offset!");
static_assert(offsetof(UserWidgetWrapBox_HasChild, ReturnValue) == 0x000008, "Member 'UserWidgetWrapBox_HasChild::ReturnValue' has a wrong offset!");

// Function Zion.ArrayBPFLibrary.SortNames
// 0x0020 (0x0020 - 0x0000)
struct ArrayBPFLibrary_SortNames final
{
public:
	TArray<class FName>                           Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayBPFLibrary_SortNames) == 0x000008, "Wrong alignment on ArrayBPFLibrary_SortNames");
static_assert(sizeof(ArrayBPFLibrary_SortNames) == 0x000020, "Wrong size on ArrayBPFLibrary_SortNames");
static_assert(offsetof(ArrayBPFLibrary_SortNames, Array) == 0x000000, "Member 'ArrayBPFLibrary_SortNames::Array' has a wrong offset!");
static_assert(offsetof(ArrayBPFLibrary_SortNames, ReturnValue) == 0x000010, "Member 'ArrayBPFLibrary_SortNames::ReturnValue' has a wrong offset!");

// Function Zion.ArrayBPFLibrary.SortTextIntStructs
// 0x0020 (0x0020 - 0x0000)
struct ArrayBPFLibrary_SortTextIntStructs final
{
public:
	TArray<struct FTextIntStruct>                 Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FTextIntStruct>                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayBPFLibrary_SortTextIntStructs) == 0x000008, "Wrong alignment on ArrayBPFLibrary_SortTextIntStructs");
static_assert(sizeof(ArrayBPFLibrary_SortTextIntStructs) == 0x000020, "Wrong size on ArrayBPFLibrary_SortTextIntStructs");
static_assert(offsetof(ArrayBPFLibrary_SortTextIntStructs, Array) == 0x000000, "Member 'ArrayBPFLibrary_SortTextIntStructs::Array' has a wrong offset!");
static_assert(offsetof(ArrayBPFLibrary_SortTextIntStructs, ReturnValue) == 0x000010, "Member 'ArrayBPFLibrary_SortTextIntStructs::ReturnValue' has a wrong offset!");

// Function Zion.WorldSpaceWidgetHolder.CreateWorldSpaceWidgetHolder
// 0x0020 (0x0020 - 0x0000)
struct WorldSpaceWidgetHolder_CreateWorldSpaceWidgetHolder final
{
public:
	const class UObject*                          WorldObjectContext;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidgetWorldSpace>      UserWidgetWorldSpaceClass;                         // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWidgetReleaseMode                            ReleaseMode;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AWorldSpaceWidgetHolder*                ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WorldSpaceWidgetHolder_CreateWorldSpaceWidgetHolder) == 0x000008, "Wrong alignment on WorldSpaceWidgetHolder_CreateWorldSpaceWidgetHolder");
static_assert(sizeof(WorldSpaceWidgetHolder_CreateWorldSpaceWidgetHolder) == 0x000020, "Wrong size on WorldSpaceWidgetHolder_CreateWorldSpaceWidgetHolder");
static_assert(offsetof(WorldSpaceWidgetHolder_CreateWorldSpaceWidgetHolder, WorldObjectContext) == 0x000000, "Member 'WorldSpaceWidgetHolder_CreateWorldSpaceWidgetHolder::WorldObjectContext' has a wrong offset!");
static_assert(offsetof(WorldSpaceWidgetHolder_CreateWorldSpaceWidgetHolder, UserWidgetWorldSpaceClass) == 0x000008, "Member 'WorldSpaceWidgetHolder_CreateWorldSpaceWidgetHolder::UserWidgetWorldSpaceClass' has a wrong offset!");
static_assert(offsetof(WorldSpaceWidgetHolder_CreateWorldSpaceWidgetHolder, ReleaseMode) == 0x000010, "Member 'WorldSpaceWidgetHolder_CreateWorldSpaceWidgetHolder::ReleaseMode' has a wrong offset!");
static_assert(offsetof(WorldSpaceWidgetHolder_CreateWorldSpaceWidgetHolder, ReturnValue) == 0x000018, "Member 'WorldSpaceWidgetHolder_CreateWorldSpaceWidgetHolder::ReturnValue' has a wrong offset!");

// Function Zion.EventAction_MoveTo.OnMoveCompleted
// 0x0008 (0x0008 - 0x0000)
struct EventAction_MoveTo_OnMoveCompleted final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EPathFollowingResult                          Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EventAction_MoveTo_OnMoveCompleted) == 0x000004, "Wrong alignment on EventAction_MoveTo_OnMoveCompleted");
static_assert(sizeof(EventAction_MoveTo_OnMoveCompleted) == 0x000008, "Wrong size on EventAction_MoveTo_OnMoveCompleted");
static_assert(offsetof(EventAction_MoveTo_OnMoveCompleted, RequestID) == 0x000000, "Member 'EventAction_MoveTo_OnMoveCompleted::RequestID' has a wrong offset!");
static_assert(offsetof(EventAction_MoveTo_OnMoveCompleted, Result) == 0x000004, "Member 'EventAction_MoveTo_OnMoveCompleted::Result' has a wrong offset!");

// Function Zion.AssistComponent.EquipAssist
// 0x000C (0x000C - 0x0000)
struct AssistComponent_EquipAssist final
{
public:
	class FName                                   AssistID;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrentLoadout;                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AssistComponent_EquipAssist) == 0x000004, "Wrong alignment on AssistComponent_EquipAssist");
static_assert(sizeof(AssistComponent_EquipAssist) == 0x00000C, "Wrong size on AssistComponent_EquipAssist");
static_assert(offsetof(AssistComponent_EquipAssist, AssistID) == 0x000000, "Member 'AssistComponent_EquipAssist::AssistID' has a wrong offset!");
static_assert(offsetof(AssistComponent_EquipAssist, bAddToCurrentLoadout) == 0x000008, "Member 'AssistComponent_EquipAssist::bAddToCurrentLoadout' has a wrong offset!");

// Function Zion.AssistComponent.EquipAssistLoadout
// 0x0004 (0x0004 - 0x0000)
struct AssistComponent_EquipAssistLoadout final
{
public:
	int32                                         LoadoutIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AssistComponent_EquipAssistLoadout) == 0x000004, "Wrong alignment on AssistComponent_EquipAssistLoadout");
static_assert(sizeof(AssistComponent_EquipAssistLoadout) == 0x000004, "Wrong size on AssistComponent_EquipAssistLoadout");
static_assert(offsetof(AssistComponent_EquipAssistLoadout, LoadoutIndex) == 0x000000, "Member 'AssistComponent_EquipAssistLoadout::LoadoutIndex' has a wrong offset!");

// Function Zion.AssistComponent.OnPossessedPawnChanged
// 0x0010 (0x0010 - 0x0000)
struct AssistComponent_OnPossessedPawnChanged final
{
public:
	class APawn*                                  OldPawn;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  NewPawn;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AssistComponent_OnPossessedPawnChanged) == 0x000008, "Wrong alignment on AssistComponent_OnPossessedPawnChanged");
static_assert(sizeof(AssistComponent_OnPossessedPawnChanged) == 0x000010, "Wrong size on AssistComponent_OnPossessedPawnChanged");
static_assert(offsetof(AssistComponent_OnPossessedPawnChanged, OldPawn) == 0x000000, "Member 'AssistComponent_OnPossessedPawnChanged::OldPawn' has a wrong offset!");
static_assert(offsetof(AssistComponent_OnPossessedPawnChanged, NewPawn) == 0x000008, "Member 'AssistComponent_OnPossessedPawnChanged::NewPawn' has a wrong offset!");

// Function Zion.AssistComponent.UnEquipAssist
// 0x0001 (0x0001 - 0x0000)
struct AssistComponent_UnEquipAssist final
{
public:
	bool                                          bRemoveFromCurrentLoadout;                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AssistComponent_UnEquipAssist) == 0x000001, "Wrong alignment on AssistComponent_UnEquipAssist");
static_assert(sizeof(AssistComponent_UnEquipAssist) == 0x000001, "Wrong size on AssistComponent_UnEquipAssist");
static_assert(offsetof(AssistComponent_UnEquipAssist, bRemoveFromCurrentLoadout) == 0x000000, "Member 'AssistComponent_UnEquipAssist::bRemoveFromCurrentLoadout' has a wrong offset!");

// Function Zion.AssistComponent.GetAssistDataFromID
// 0x0210 (0x0210 - 0x0000)
struct AssistComponent_GetAssistDataFromID final
{
public:
	class FName                                   AssistID;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInventoryItemAssistData               ReturnValue;                                       // 0x0008(0x0208)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AssistComponent_GetAssistDataFromID) == 0x000008, "Wrong alignment on AssistComponent_GetAssistDataFromID");
static_assert(sizeof(AssistComponent_GetAssistDataFromID) == 0x000210, "Wrong size on AssistComponent_GetAssistDataFromID");
static_assert(offsetof(AssistComponent_GetAssistDataFromID, AssistID) == 0x000000, "Member 'AssistComponent_GetAssistDataFromID::AssistID' has a wrong offset!");
static_assert(offsetof(AssistComponent_GetAssistDataFromID, ReturnValue) == 0x000008, "Member 'AssistComponent_GetAssistDataFromID::ReturnValue' has a wrong offset!");

// Function Zion.AssistComponent.GetAssistID
// 0x0008 (0x0008 - 0x0000)
struct AssistComponent_GetAssistID final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AssistComponent_GetAssistID) == 0x000004, "Wrong alignment on AssistComponent_GetAssistID");
static_assert(sizeof(AssistComponent_GetAssistID) == 0x000008, "Wrong size on AssistComponent_GetAssistID");
static_assert(offsetof(AssistComponent_GetAssistID, ReturnValue) == 0x000000, "Member 'AssistComponent_GetAssistID::ReturnValue' has a wrong offset!");

// Function Zion.AssistComponent.GetCurrentAssistLoadoutIndex
// 0x0004 (0x0004 - 0x0000)
struct AssistComponent_GetCurrentAssistLoadoutIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AssistComponent_GetCurrentAssistLoadoutIndex) == 0x000004, "Wrong alignment on AssistComponent_GetCurrentAssistLoadoutIndex");
static_assert(sizeof(AssistComponent_GetCurrentAssistLoadoutIndex) == 0x000004, "Wrong size on AssistComponent_GetCurrentAssistLoadoutIndex");
static_assert(offsetof(AssistComponent_GetCurrentAssistLoadoutIndex, ReturnValue) == 0x000000, "Member 'AssistComponent_GetCurrentAssistLoadoutIndex::ReturnValue' has a wrong offset!");

// Function Zion.AssistComponent.GetEquippedAssistData
// 0x0208 (0x0208 - 0x0000)
struct AssistComponent_GetEquippedAssistData final
{
public:
	struct FInventoryItemAssistData               ReturnValue;                                       // 0x0000(0x0208)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AssistComponent_GetEquippedAssistData) == 0x000008, "Wrong alignment on AssistComponent_GetEquippedAssistData");
static_assert(sizeof(AssistComponent_GetEquippedAssistData) == 0x000208, "Wrong size on AssistComponent_GetEquippedAssistData");
static_assert(offsetof(AssistComponent_GetEquippedAssistData, ReturnValue) == 0x000000, "Member 'AssistComponent_GetEquippedAssistData::ReturnValue' has a wrong offset!");

// Function Zion.EnemySpawner.OnClearStatusChecked
// 0x0001 (0x0001 - 0x0000)
struct EnemySpawner_OnClearStatusChecked final
{
public:
	EClearStatus                                  ClearStatus;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnemySpawner_OnClearStatusChecked) == 0x000001, "Wrong alignment on EnemySpawner_OnClearStatusChecked");
static_assert(sizeof(EnemySpawner_OnClearStatusChecked) == 0x000001, "Wrong size on EnemySpawner_OnClearStatusChecked");
static_assert(offsetof(EnemySpawner_OnClearStatusChecked, ClearStatus) == 0x000000, "Member 'EnemySpawner_OnClearStatusChecked::ClearStatus' has a wrong offset!");

// Function Zion.EnemySpawner.OnEnemyBreakPart
// 0x0001 (0x0001 - 0x0000)
struct EnemySpawner_OnEnemyBreakPart final
{
public:
	EBreakType                                    BreakType;                                         // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnemySpawner_OnEnemyBreakPart) == 0x000001, "Wrong alignment on EnemySpawner_OnEnemyBreakPart");
static_assert(sizeof(EnemySpawner_OnEnemyBreakPart) == 0x000001, "Wrong size on EnemySpawner_OnEnemyBreakPart");
static_assert(offsetof(EnemySpawner_OnEnemyBreakPart, BreakType) == 0x000000, "Member 'EnemySpawner_OnEnemyBreakPart::BreakType' has a wrong offset!");

// Function Zion.EnemySpawner.OnRegisterEnemy
// 0x0008 (0x0008 - 0x0000)
struct EnemySpawner_OnRegisterEnemy final
{
public:
	class ACharacterZion*                         Enemy;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnemySpawner_OnRegisterEnemy) == 0x000008, "Wrong alignment on EnemySpawner_OnRegisterEnemy");
static_assert(sizeof(EnemySpawner_OnRegisterEnemy) == 0x000008, "Wrong size on EnemySpawner_OnRegisterEnemy");
static_assert(offsetof(EnemySpawner_OnRegisterEnemy, Enemy) == 0x000000, "Member 'EnemySpawner_OnRegisterEnemy::Enemy' has a wrong offset!");

// Function Zion.EnemySpawner.OnUnregisterEnemy
// 0x0008 (0x0008 - 0x0000)
struct EnemySpawner_OnUnregisterEnemy final
{
public:
	class ACharacterZion*                         Enemy;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnemySpawner_OnUnregisterEnemy) == 0x000008, "Wrong alignment on EnemySpawner_OnUnregisterEnemy");
static_assert(sizeof(EnemySpawner_OnUnregisterEnemy) == 0x000008, "Wrong size on EnemySpawner_OnUnregisterEnemy");
static_assert(offsetof(EnemySpawner_OnUnregisterEnemy, Enemy) == 0x000000, "Member 'EnemySpawner_OnUnregisterEnemy::Enemy' has a wrong offset!");

// Function Zion.EnemySpawner.ReplaceEnemy
// 0x0070 (0x0070 - 0x0000)
struct EnemySpawner_ReplaceEnemy final
{
public:
	struct FDataTableRowHandle                    NewEnemyRowHandle;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnemySpawner_ReplaceEnemy) == 0x000010, "Wrong alignment on EnemySpawner_ReplaceEnemy");
static_assert(sizeof(EnemySpawner_ReplaceEnemy) == 0x000070, "Wrong size on EnemySpawner_ReplaceEnemy");
static_assert(offsetof(EnemySpawner_ReplaceEnemy, NewEnemyRowHandle) == 0x000000, "Member 'EnemySpawner_ReplaceEnemy::NewEnemyRowHandle' has a wrong offset!");
static_assert(offsetof(EnemySpawner_ReplaceEnemy, SpawnTransform) == 0x000010, "Member 'EnemySpawner_ReplaceEnemy::SpawnTransform' has a wrong offset!");

// Function Zion.EnemySpawner.GetEnemy
// 0x0008 (0x0008 - 0x0000)
struct EnemySpawner_GetEnemy final
{
public:
	class ACharacterZion*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnemySpawner_GetEnemy) == 0x000008, "Wrong alignment on EnemySpawner_GetEnemy");
static_assert(sizeof(EnemySpawner_GetEnemy) == 0x000008, "Wrong size on EnemySpawner_GetEnemy");
static_assert(offsetof(EnemySpawner_GetEnemy, ReturnValue) == 0x000000, "Member 'EnemySpawner_GetEnemy::ReturnValue' has a wrong offset!");

// Function Zion.EnemySpawner.GetEnemyAIController
// 0x0008 (0x0008 - 0x0000)
struct EnemySpawner_GetEnemyAIController final
{
public:
	class AAIControllerZion*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnemySpawner_GetEnemyAIController) == 0x000008, "Wrong alignment on EnemySpawner_GetEnemyAIController");
static_assert(sizeof(EnemySpawner_GetEnemyAIController) == 0x000008, "Wrong size on EnemySpawner_GetEnemyAIController");
static_assert(offsetof(EnemySpawner_GetEnemyAIController, ReturnValue) == 0x000000, "Member 'EnemySpawner_GetEnemyAIController::ReturnValue' has a wrong offset!");

// Function Zion.EnemySpawner.IsEnemyActivated
// 0x0001 (0x0001 - 0x0000)
struct EnemySpawner_IsEnemyActivated final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnemySpawner_IsEnemyActivated) == 0x000001, "Wrong alignment on EnemySpawner_IsEnemyActivated");
static_assert(sizeof(EnemySpawner_IsEnemyActivated) == 0x000001, "Wrong size on EnemySpawner_IsEnemyActivated");
static_assert(offsetof(EnemySpawner_IsEnemyActivated, ReturnValue) == 0x000000, "Member 'EnemySpawner_IsEnemyActivated::ReturnValue' has a wrong offset!");

// Function Zion.EnemySpawner.ShouldSpawnEvenWhenCleared
// 0x0001 (0x0001 - 0x0000)
struct EnemySpawner_ShouldSpawnEvenWhenCleared final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnemySpawner_ShouldSpawnEvenWhenCleared) == 0x000001, "Wrong alignment on EnemySpawner_ShouldSpawnEvenWhenCleared");
static_assert(sizeof(EnemySpawner_ShouldSpawnEvenWhenCleared) == 0x000001, "Wrong size on EnemySpawner_ShouldSpawnEvenWhenCleared");
static_assert(offsetof(EnemySpawner_ShouldSpawnEvenWhenCleared, ReturnValue) == 0x000000, "Member 'EnemySpawner_ShouldSpawnEvenWhenCleared::ReturnValue' has a wrong offset!");

// Function Zion.ZoneSystemComponent.Get
// 0x0010 (0x0010 - 0x0000)
struct ZoneSystemComponent_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UZoneSystemComponent*                   ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZoneSystemComponent_Get) == 0x000008, "Wrong alignment on ZoneSystemComponent_Get");
static_assert(sizeof(ZoneSystemComponent_Get) == 0x000010, "Wrong size on ZoneSystemComponent_Get");
static_assert(offsetof(ZoneSystemComponent_Get, WorldContextObject) == 0x000000, "Member 'ZoneSystemComponent_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ZoneSystemComponent_Get, ReturnValue) == 0x000008, "Member 'ZoneSystemComponent_Get::ReturnValue' has a wrong offset!");

// Function Zion.ZoneSystemComponent.BindActorToZone
// 0x0008 (0x0008 - 0x0000)
struct ZoneSystemComponent_BindActorToZone final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZoneSystemComponent_BindActorToZone) == 0x000008, "Wrong alignment on ZoneSystemComponent_BindActorToZone");
static_assert(sizeof(ZoneSystemComponent_BindActorToZone) == 0x000008, "Wrong size on ZoneSystemComponent_BindActorToZone");
static_assert(offsetof(ZoneSystemComponent_BindActorToZone, Actor) == 0x000000, "Member 'ZoneSystemComponent_BindActorToZone::Actor' has a wrong offset!");

// Function Zion.ZoneSystemComponent.GetActiveZoneLevelName
// 0x0010 (0x0010 - 0x0000)
struct ZoneSystemComponent_GetActiveZoneLevelName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZoneSystemComponent_GetActiveZoneLevelName) == 0x000008, "Wrong alignment on ZoneSystemComponent_GetActiveZoneLevelName");
static_assert(sizeof(ZoneSystemComponent_GetActiveZoneLevelName) == 0x000010, "Wrong size on ZoneSystemComponent_GetActiveZoneLevelName");
static_assert(offsetof(ZoneSystemComponent_GetActiveZoneLevelName, ReturnValue) == 0x000000, "Member 'ZoneSystemComponent_GetActiveZoneLevelName::ReturnValue' has a wrong offset!");

// Function Zion.ZoneSystemComponent.GetActiveZoneName
// 0x0010 (0x0010 - 0x0000)
struct ZoneSystemComponent_GetActiveZoneName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZoneSystemComponent_GetActiveZoneName) == 0x000008, "Wrong alignment on ZoneSystemComponent_GetActiveZoneName");
static_assert(sizeof(ZoneSystemComponent_GetActiveZoneName) == 0x000010, "Wrong size on ZoneSystemComponent_GetActiveZoneName");
static_assert(offsetof(ZoneSystemComponent_GetActiveZoneName, ReturnValue) == 0x000000, "Member 'ZoneSystemComponent_GetActiveZoneName::ReturnValue' has a wrong offset!");

// Function Zion.ZoneSystemComponent.IsInAnyZone
// 0x0001 (0x0001 - 0x0000)
struct ZoneSystemComponent_IsInAnyZone final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZoneSystemComponent_IsInAnyZone) == 0x000001, "Wrong alignment on ZoneSystemComponent_IsInAnyZone");
static_assert(sizeof(ZoneSystemComponent_IsInAnyZone) == 0x000001, "Wrong size on ZoneSystemComponent_IsInAnyZone");
static_assert(offsetof(ZoneSystemComponent_IsInAnyZone, ReturnValue) == 0x000000, "Member 'ZoneSystemComponent_IsInAnyZone::ReturnValue' has a wrong offset!");

// Function Zion.AssistTrigger_ParrySuccess.OnParried
// 0x0010 (0x0010 - 0x0000)
struct AssistTrigger_ParrySuccess_OnParried final
{
public:
	class AAbility*                               Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AssistTrigger_ParrySuccess_OnParried) == 0x000008, "Wrong alignment on AssistTrigger_ParrySuccess_OnParried");
static_assert(sizeof(AssistTrigger_ParrySuccess_OnParried) == 0x000010, "Wrong size on AssistTrigger_ParrySuccess_OnParried");
static_assert(offsetof(AssistTrigger_ParrySuccess_OnParried, Ability) == 0x000000, "Member 'AssistTrigger_ParrySuccess_OnParried::Ability' has a wrong offset!");
static_assert(offsetof(AssistTrigger_ParrySuccess_OnParried, Source) == 0x000008, "Member 'AssistTrigger_ParrySuccess_OnParried::Source' has a wrong offset!");

// Function Zion.CustomMarkerComponent.GetCustomMarkerMaxCount
// 0x0004 (0x0004 - 0x0000)
struct CustomMarkerComponent_GetCustomMarkerMaxCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomMarkerComponent_GetCustomMarkerMaxCount) == 0x000004, "Wrong alignment on CustomMarkerComponent_GetCustomMarkerMaxCount");
static_assert(sizeof(CustomMarkerComponent_GetCustomMarkerMaxCount) == 0x000004, "Wrong size on CustomMarkerComponent_GetCustomMarkerMaxCount");
static_assert(offsetof(CustomMarkerComponent_GetCustomMarkerMaxCount, ReturnValue) == 0x000000, "Member 'CustomMarkerComponent_GetCustomMarkerMaxCount::ReturnValue' has a wrong offset!");

// Function Zion.AssistTrigger_ReceiveStatusEffect.OnStatusEffectLaunched
// 0x0008 (0x0008 - 0x0000)
struct AssistTrigger_ReceiveStatusEffect_OnStatusEffectLaunched final
{
public:
	class UStatusEffect*                          StatusEffect;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AssistTrigger_ReceiveStatusEffect_OnStatusEffectLaunched) == 0x000008, "Wrong alignment on AssistTrigger_ReceiveStatusEffect_OnStatusEffectLaunched");
static_assert(sizeof(AssistTrigger_ReceiveStatusEffect_OnStatusEffectLaunched) == 0x000008, "Wrong size on AssistTrigger_ReceiveStatusEffect_OnStatusEffectLaunched");
static_assert(offsetof(AssistTrigger_ReceiveStatusEffect_OnStatusEffectLaunched, StatusEffect) == 0x000000, "Member 'AssistTrigger_ReceiveStatusEffect_OnStatusEffectLaunched::StatusEffect' has a wrong offset!");

// Function Zion.UserWidgetZionShowHide.Hide
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetZionShowHide_Hide final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZionShowHide_Hide) == 0x000001, "Wrong alignment on UserWidgetZionShowHide_Hide");
static_assert(sizeof(UserWidgetZionShowHide_Hide) == 0x000001, "Wrong size on UserWidgetZionShowHide_Hide");
static_assert(offsetof(UserWidgetZionShowHide_Hide, bInstant) == 0x000000, "Member 'UserWidgetZionShowHide_Hide::bInstant' has a wrong offset!");

// Function Zion.UserWidgetZionShowHide.HideAndRemoveFromParent
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetZionShowHide_HideAndRemoveFromParent final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZionShowHide_HideAndRemoveFromParent) == 0x000001, "Wrong alignment on UserWidgetZionShowHide_HideAndRemoveFromParent");
static_assert(sizeof(UserWidgetZionShowHide_HideAndRemoveFromParent) == 0x000001, "Wrong size on UserWidgetZionShowHide_HideAndRemoveFromParent");
static_assert(offsetof(UserWidgetZionShowHide_HideAndRemoveFromParent, bInstant) == 0x000000, "Member 'UserWidgetZionShowHide_HideAndRemoveFromParent::bInstant' has a wrong offset!");

// Function Zion.UserWidgetZionShowHide.Show
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetZionShowHide_Show final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetZionShowHide_Show) == 0x000001, "Wrong alignment on UserWidgetZionShowHide_Show");
static_assert(sizeof(UserWidgetZionShowHide_Show) == 0x000001, "Wrong size on UserWidgetZionShowHide_Show");
static_assert(offsetof(UserWidgetZionShowHide_Show, bInstant) == 0x000000, "Member 'UserWidgetZionShowHide_Show::bInstant' has a wrong offset!");

// Function Zion.AutoClimbComponent.MarkActorAsIgnored
// 0x0008 (0x0008 - 0x0000)
struct AutoClimbComponent_MarkActorAsIgnored final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutoClimbComponent_MarkActorAsIgnored) == 0x000008, "Wrong alignment on AutoClimbComponent_MarkActorAsIgnored");
static_assert(sizeof(AutoClimbComponent_MarkActorAsIgnored) == 0x000008, "Wrong size on AutoClimbComponent_MarkActorAsIgnored");
static_assert(offsetof(AutoClimbComponent_MarkActorAsIgnored, Actor) == 0x000000, "Member 'AutoClimbComponent_MarkActorAsIgnored::Actor' has a wrong offset!");

// Function Zion.AutoClimbComponent.OnComponentOverlapBegin
// 0x0118 (0x0118 - 0x0000)
struct AutoClimbComponent_OnComponentOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlapComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutoClimbComponent_OnComponentOverlapBegin) == 0x000008, "Wrong alignment on AutoClimbComponent_OnComponentOverlapBegin");
static_assert(sizeof(AutoClimbComponent_OnComponentOverlapBegin) == 0x000118, "Wrong size on AutoClimbComponent_OnComponentOverlapBegin");
static_assert(offsetof(AutoClimbComponent_OnComponentOverlapBegin, OverlapComponent) == 0x000000, "Member 'AutoClimbComponent_OnComponentOverlapBegin::OverlapComponent' has a wrong offset!");
static_assert(offsetof(AutoClimbComponent_OnComponentOverlapBegin, OtherActor) == 0x000008, "Member 'AutoClimbComponent_OnComponentOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(AutoClimbComponent_OnComponentOverlapBegin, OtherComp) == 0x000010, "Member 'AutoClimbComponent_OnComponentOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(AutoClimbComponent_OnComponentOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'AutoClimbComponent_OnComponentOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(AutoClimbComponent_OnComponentOverlapBegin, bFromSweep) == 0x00001C, "Member 'AutoClimbComponent_OnComponentOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(AutoClimbComponent_OnComponentOverlapBegin, SweepResult) == 0x000020, "Member 'AutoClimbComponent_OnComponentOverlapBegin::SweepResult' has a wrong offset!");

// Function Zion.AutoClimbComponent.OnComponentOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct AutoClimbComponent_OnComponentOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlapComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AutoClimbComponent_OnComponentOverlapEnd) == 0x000008, "Wrong alignment on AutoClimbComponent_OnComponentOverlapEnd");
static_assert(sizeof(AutoClimbComponent_OnComponentOverlapEnd) == 0x000020, "Wrong size on AutoClimbComponent_OnComponentOverlapEnd");
static_assert(offsetof(AutoClimbComponent_OnComponentOverlapEnd, OverlapComponent) == 0x000000, "Member 'AutoClimbComponent_OnComponentOverlapEnd::OverlapComponent' has a wrong offset!");
static_assert(offsetof(AutoClimbComponent_OnComponentOverlapEnd, OtherActor) == 0x000008, "Member 'AutoClimbComponent_OnComponentOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(AutoClimbComponent_OnComponentOverlapEnd, OtherComp) == 0x000010, "Member 'AutoClimbComponent_OnComponentOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(AutoClimbComponent_OnComponentOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'AutoClimbComponent_OnComponentOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function Zion.AutoClimbComponent.OnMoveBlocked
// 0x00F8 (0x00F8 - 0x0000)
struct AutoClimbComponent_OnMoveBlocked final
{
public:
	struct FHitResult                             Impact;                                            // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutoClimbComponent_OnMoveBlocked) == 0x000008, "Wrong alignment on AutoClimbComponent_OnMoveBlocked");
static_assert(sizeof(AutoClimbComponent_OnMoveBlocked) == 0x0000F8, "Wrong size on AutoClimbComponent_OnMoveBlocked");
static_assert(offsetof(AutoClimbComponent_OnMoveBlocked, Impact) == 0x000000, "Member 'AutoClimbComponent_OnMoveBlocked::Impact' has a wrong offset!");

// Function Zion.AutoClimbComponent.UnmarkActorAsIgnored
// 0x0008 (0x0008 - 0x0000)
struct AutoClimbComponent_UnmarkActorAsIgnored final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutoClimbComponent_UnmarkActorAsIgnored) == 0x000008, "Wrong alignment on AutoClimbComponent_UnmarkActorAsIgnored");
static_assert(sizeof(AutoClimbComponent_UnmarkActorAsIgnored) == 0x000008, "Wrong size on AutoClimbComponent_UnmarkActorAsIgnored");
static_assert(offsetof(AutoClimbComponent_UnmarkActorAsIgnored, Actor) == 0x000000, "Member 'AutoClimbComponent_UnmarkActorAsIgnored::Actor' has a wrong offset!");

// Function Zion.AutoClimbComponent.GetLastTargetLocation
// 0x0018 (0x0018 - 0x0000)
struct AutoClimbComponent_GetLastTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutoClimbComponent_GetLastTargetLocation) == 0x000008, "Wrong alignment on AutoClimbComponent_GetLastTargetLocation");
static_assert(sizeof(AutoClimbComponent_GetLastTargetLocation) == 0x000018, "Wrong size on AutoClimbComponent_GetLastTargetLocation");
static_assert(offsetof(AutoClimbComponent_GetLastTargetLocation, ReturnValue) == 0x000000, "Member 'AutoClimbComponent_GetLastTargetLocation::ReturnValue' has a wrong offset!");

// Function Zion.BattleColorComponent.SetAlpha
// 0x0004 (0x0004 - 0x0000)
struct BattleColorComponent_SetAlpha final
{
public:
	float                                         NewAlpha;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BattleColorComponent_SetAlpha) == 0x000004, "Wrong alignment on BattleColorComponent_SetAlpha");
static_assert(sizeof(BattleColorComponent_SetAlpha) == 0x000004, "Wrong size on BattleColorComponent_SetAlpha");
static_assert(offsetof(BattleColorComponent_SetAlpha, NewAlpha) == 0x000000, "Member 'BattleColorComponent_SetAlpha::NewAlpha' has a wrong offset!");

// Function Zion.BattleColorComponent.SetBattleColorEnabled
// 0x0001 (0x0001 - 0x0000)
struct BattleColorComponent_SetBattleColorEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BattleColorComponent_SetBattleColorEnabled) == 0x000001, "Wrong alignment on BattleColorComponent_SetBattleColorEnabled");
static_assert(sizeof(BattleColorComponent_SetBattleColorEnabled) == 0x000001, "Wrong size on BattleColorComponent_SetBattleColorEnabled");
static_assert(offsetof(BattleColorComponent_SetBattleColorEnabled, bEnable) == 0x000000, "Member 'BattleColorComponent_SetBattleColorEnabled::bEnable' has a wrong offset!");

// Function Zion.BoxBPFLibrary.GetCenter
// 0x0050 (0x0050 - 0x0000)
struct BoxBPFLibrary_GetCenter final
{
public:
	struct FBox                                   Box;                                               // 0x0000(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoxBPFLibrary_GetCenter) == 0x000008, "Wrong alignment on BoxBPFLibrary_GetCenter");
static_assert(sizeof(BoxBPFLibrary_GetCenter) == 0x000050, "Wrong size on BoxBPFLibrary_GetCenter");
static_assert(offsetof(BoxBPFLibrary_GetCenter, Box) == 0x000000, "Member 'BoxBPFLibrary_GetCenter::Box' has a wrong offset!");
static_assert(offsetof(BoxBPFLibrary_GetCenter, ReturnValue) == 0x000038, "Member 'BoxBPFLibrary_GetCenter::ReturnValue' has a wrong offset!");

// Function Zion.BoxBPFLibrary.IsValid
// 0x0040 (0x0040 - 0x0000)
struct BoxBPFLibrary_IsValid final
{
public:
	struct FBox                                   Box;                                               // 0x0000(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BoxBPFLibrary_IsValid) == 0x000008, "Wrong alignment on BoxBPFLibrary_IsValid");
static_assert(sizeof(BoxBPFLibrary_IsValid) == 0x000040, "Wrong size on BoxBPFLibrary_IsValid");
static_assert(offsetof(BoxBPFLibrary_IsValid, Box) == 0x000000, "Member 'BoxBPFLibrary_IsValid::Box' has a wrong offset!");
static_assert(offsetof(BoxBPFLibrary_IsValid, ReturnValue) == 0x000038, "Member 'BoxBPFLibrary_IsValid::ReturnValue' has a wrong offset!");

// Function Zion.Breakable.OnBreakableReceivedDamage
// 0x0010 (0x0010 - 0x0000)
struct Breakable_OnBreakableReceivedDamage final
{
public:
	class AActor*                                 Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Breakable_OnBreakableReceivedDamage) == 0x000008, "Wrong alignment on Breakable_OnBreakableReceivedDamage");
static_assert(sizeof(Breakable_OnBreakableReceivedDamage) == 0x000010, "Wrong size on Breakable_OnBreakableReceivedDamage");
static_assert(offsetof(Breakable_OnBreakableReceivedDamage, Source) == 0x000000, "Member 'Breakable_OnBreakableReceivedDamage::Source' has a wrong offset!");
static_assert(offsetof(Breakable_OnBreakableReceivedDamage, Value) == 0x000008, "Member 'Breakable_OnBreakableReceivedDamage::Value' has a wrong offset!");

// Function Zion.Breakable.OnClearStatusChecked
// 0x0001 (0x0001 - 0x0000)
struct Breakable_OnClearStatusChecked final
{
public:
	EClearStatus                                  ClearStatus;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Breakable_OnClearStatusChecked) == 0x000001, "Wrong alignment on Breakable_OnClearStatusChecked");
static_assert(sizeof(Breakable_OnClearStatusChecked) == 0x000001, "Wrong size on Breakable_OnClearStatusChecked");
static_assert(offsetof(Breakable_OnClearStatusChecked, ClearStatus) == 0x000000, "Member 'Breakable_OnClearStatusChecked::ClearStatus' has a wrong offset!");

// Function Zion.BreakPartStateManagerComponent.Get
// 0x0010 (0x0010 - 0x0000)
struct BreakPartStateManagerComponent_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBreakPartStateManagerComponent*        ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BreakPartStateManagerComponent_Get) == 0x000008, "Wrong alignment on BreakPartStateManagerComponent_Get");
static_assert(sizeof(BreakPartStateManagerComponent_Get) == 0x000010, "Wrong size on BreakPartStateManagerComponent_Get");
static_assert(offsetof(BreakPartStateManagerComponent_Get, WorldContextObject) == 0x000000, "Member 'BreakPartStateManagerComponent_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BreakPartStateManagerComponent_Get, ReturnValue) == 0x000008, "Member 'BreakPartStateManagerComponent_Get::ReturnValue' has a wrong offset!");

// Function Zion.BreakPartStateManagerComponent.RegisterBreakPartState
// 0x0010 (0x0010 - 0x0000)
struct BreakPartStateManagerComponent_RegisterBreakPartState final
{
public:
	const class AEnemySpawner*                    EnemySpawner;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBreakType                                    ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BreakPartStateManagerComponent_RegisterBreakPartState) == 0x000008, "Wrong alignment on BreakPartStateManagerComponent_RegisterBreakPartState");
static_assert(sizeof(BreakPartStateManagerComponent_RegisterBreakPartState) == 0x000010, "Wrong size on BreakPartStateManagerComponent_RegisterBreakPartState");
static_assert(offsetof(BreakPartStateManagerComponent_RegisterBreakPartState, EnemySpawner) == 0x000000, "Member 'BreakPartStateManagerComponent_RegisterBreakPartState::EnemySpawner' has a wrong offset!");
static_assert(offsetof(BreakPartStateManagerComponent_RegisterBreakPartState, ReturnValue) == 0x000008, "Member 'BreakPartStateManagerComponent_RegisterBreakPartState::ReturnValue' has a wrong offset!");

// Function Zion.BreakPartStateManagerComponent.GetBreakPartState
// 0x0010 (0x0010 - 0x0000)
struct BreakPartStateManagerComponent_GetBreakPartState final
{
public:
	const class AEnemySpawner*                    EnemySpawner;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBreakType                                    ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BreakPartStateManagerComponent_GetBreakPartState) == 0x000008, "Wrong alignment on BreakPartStateManagerComponent_GetBreakPartState");
static_assert(sizeof(BreakPartStateManagerComponent_GetBreakPartState) == 0x000010, "Wrong size on BreakPartStateManagerComponent_GetBreakPartState");
static_assert(offsetof(BreakPartStateManagerComponent_GetBreakPartState, EnemySpawner) == 0x000000, "Member 'BreakPartStateManagerComponent_GetBreakPartState::EnemySpawner' has a wrong offset!");
static_assert(offsetof(BreakPartStateManagerComponent_GetBreakPartState, ReturnValue) == 0x000008, "Member 'BreakPartStateManagerComponent_GetBreakPartState::ReturnValue' has a wrong offset!");

// Function Zion.GunmanIKBoneTargetComponent.OnSpiritActivationChanged
// 0x0001 (0x0001 - 0x0000)
struct GunmanIKBoneTargetComponent_OnSpiritActivationChanged final
{
public:
	bool                                          bNewActive;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GunmanIKBoneTargetComponent_OnSpiritActivationChanged) == 0x000001, "Wrong alignment on GunmanIKBoneTargetComponent_OnSpiritActivationChanged");
static_assert(sizeof(GunmanIKBoneTargetComponent_OnSpiritActivationChanged) == 0x000001, "Wrong size on GunmanIKBoneTargetComponent_OnSpiritActivationChanged");
static_assert(offsetof(GunmanIKBoneTargetComponent_OnSpiritActivationChanged, bNewActive) == 0x000000, "Member 'GunmanIKBoneTargetComponent_OnSpiritActivationChanged::bNewActive' has a wrong offset!");

// Function Zion.GunmanIKBoneTargetComponent.GetAbilityGlobalOffset
// 0x0060 (0x0060 - 0x0000)
struct GunmanIKBoneTargetComponent_GetAbilityGlobalOffset final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GunmanIKBoneTargetComponent_GetAbilityGlobalOffset) == 0x000010, "Wrong alignment on GunmanIKBoneTargetComponent_GetAbilityGlobalOffset");
static_assert(sizeof(GunmanIKBoneTargetComponent_GetAbilityGlobalOffset) == 0x000060, "Wrong size on GunmanIKBoneTargetComponent_GetAbilityGlobalOffset");
static_assert(offsetof(GunmanIKBoneTargetComponent_GetAbilityGlobalOffset, ReturnValue) == 0x000000, "Member 'GunmanIKBoneTargetComponent_GetAbilityGlobalOffset::ReturnValue' has a wrong offset!");

// Function Zion.OneWayPlatform.OnComponentOverlapBegin
// 0x0118 (0x0118 - 0x0000)
struct OneWayPlatform_OnComponentOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlapComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OneWayPlatform_OnComponentOverlapBegin) == 0x000008, "Wrong alignment on OneWayPlatform_OnComponentOverlapBegin");
static_assert(sizeof(OneWayPlatform_OnComponentOverlapBegin) == 0x000118, "Wrong size on OneWayPlatform_OnComponentOverlapBegin");
static_assert(offsetof(OneWayPlatform_OnComponentOverlapBegin, OverlapComponent) == 0x000000, "Member 'OneWayPlatform_OnComponentOverlapBegin::OverlapComponent' has a wrong offset!");
static_assert(offsetof(OneWayPlatform_OnComponentOverlapBegin, OtherActor) == 0x000008, "Member 'OneWayPlatform_OnComponentOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(OneWayPlatform_OnComponentOverlapBegin, OtherComp) == 0x000010, "Member 'OneWayPlatform_OnComponentOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(OneWayPlatform_OnComponentOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'OneWayPlatform_OnComponentOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(OneWayPlatform_OnComponentOverlapBegin, bFromSweep) == 0x00001C, "Member 'OneWayPlatform_OnComponentOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(OneWayPlatform_OnComponentOverlapBegin, SweepResult) == 0x000020, "Member 'OneWayPlatform_OnComponentOverlapBegin::SweepResult' has a wrong offset!");

// Function Zion.OneWayPlatform.OnComponentOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct OneWayPlatform_OnComponentOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlapComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OneWayPlatform_OnComponentOverlapEnd) == 0x000008, "Wrong alignment on OneWayPlatform_OnComponentOverlapEnd");
static_assert(sizeof(OneWayPlatform_OnComponentOverlapEnd) == 0x000020, "Wrong size on OneWayPlatform_OnComponentOverlapEnd");
static_assert(offsetof(OneWayPlatform_OnComponentOverlapEnd, OverlapComponent) == 0x000000, "Member 'OneWayPlatform_OnComponentOverlapEnd::OverlapComponent' has a wrong offset!");
static_assert(offsetof(OneWayPlatform_OnComponentOverlapEnd, OtherActor) == 0x000008, "Member 'OneWayPlatform_OnComponentOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(OneWayPlatform_OnComponentOverlapEnd, OtherComp) == 0x000010, "Member 'OneWayPlatform_OnComponentOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(OneWayPlatform_OnComponentOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'OneWayPlatform_OnComponentOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function Zion.OneWayPlatform.IsFallThrough
// 0x0001 (0x0001 - 0x0000)
struct OneWayPlatform_IsFallThrough final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OneWayPlatform_IsFallThrough) == 0x000001, "Wrong alignment on OneWayPlatform_IsFallThrough");
static_assert(sizeof(OneWayPlatform_IsFallThrough) == 0x000001, "Wrong size on OneWayPlatform_IsFallThrough");
static_assert(offsetof(OneWayPlatform_IsFallThrough, ReturnValue) == 0x000000, "Member 'OneWayPlatform_IsFallThrough::ReturnValue' has a wrong offset!");

// Function Zion.GameplayCamera.RegisterEnemyPawn
// 0x0008 (0x0008 - 0x0000)
struct GameplayCamera_RegisterEnemyPawn final
{
public:
	class APawn*                                  EnemyPawnToAdd;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayCamera_RegisterEnemyPawn) == 0x000008, "Wrong alignment on GameplayCamera_RegisterEnemyPawn");
static_assert(sizeof(GameplayCamera_RegisterEnemyPawn) == 0x000008, "Wrong size on GameplayCamera_RegisterEnemyPawn");
static_assert(offsetof(GameplayCamera_RegisterEnemyPawn, EnemyPawnToAdd) == 0x000000, "Member 'GameplayCamera_RegisterEnemyPawn::EnemyPawnToAdd' has a wrong offset!");

// Function Zion.GameplayCamera.RegisterEnemyPawns
// 0x0010 (0x0010 - 0x0000)
struct GameplayCamera_RegisterEnemyPawns final
{
public:
	TArray<class APawn*>                          EnemyPawnsToAdd;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayCamera_RegisterEnemyPawns) == 0x000008, "Wrong alignment on GameplayCamera_RegisterEnemyPawns");
static_assert(sizeof(GameplayCamera_RegisterEnemyPawns) == 0x000010, "Wrong size on GameplayCamera_RegisterEnemyPawns");
static_assert(offsetof(GameplayCamera_RegisterEnemyPawns, EnemyPawnsToAdd) == 0x000000, "Member 'GameplayCamera_RegisterEnemyPawns::EnemyPawnsToAdd' has a wrong offset!");

// Function Zion.GameplayCamera.SetSettings
// 0x0078 (0x0078 - 0x0000)
struct GameplayCamera_SetSettings final
{
public:
	struct FGameplayCameraSettings                NewSettings;                                       // 0x0000(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayCamera_SetSettings) == 0x000008, "Wrong alignment on GameplayCamera_SetSettings");
static_assert(sizeof(GameplayCamera_SetSettings) == 0x000078, "Wrong size on GameplayCamera_SetSettings");
static_assert(offsetof(GameplayCamera_SetSettings, NewSettings) == 0x000000, "Member 'GameplayCamera_SetSettings::NewSettings' has a wrong offset!");

// Function Zion.GameplayCamera.UnregisterEnemyPawn
// 0x0008 (0x0008 - 0x0000)
struct GameplayCamera_UnregisterEnemyPawn final
{
public:
	class APawn*                                  EnemyPawnToRemove;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayCamera_UnregisterEnemyPawn) == 0x000008, "Wrong alignment on GameplayCamera_UnregisterEnemyPawn");
static_assert(sizeof(GameplayCamera_UnregisterEnemyPawn) == 0x000008, "Wrong size on GameplayCamera_UnregisterEnemyPawn");
static_assert(offsetof(GameplayCamera_UnregisterEnemyPawn, EnemyPawnToRemove) == 0x000000, "Member 'GameplayCamera_UnregisterEnemyPawn::EnemyPawnToRemove' has a wrong offset!");

// Function Zion.GameplayCamera.UnregisterEnemyPawns
// 0x0010 (0x0010 - 0x0000)
struct GameplayCamera_UnregisterEnemyPawns final
{
public:
	TArray<class APawn*>                          EnemyPawnsToRemove;                                // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayCamera_UnregisterEnemyPawns) == 0x000008, "Wrong alignment on GameplayCamera_UnregisterEnemyPawns");
static_assert(sizeof(GameplayCamera_UnregisterEnemyPawns) == 0x000010, "Wrong size on GameplayCamera_UnregisterEnemyPawns");
static_assert(offsetof(GameplayCamera_UnregisterEnemyPawns, EnemyPawnsToRemove) == 0x000000, "Member 'GameplayCamera_UnregisterEnemyPawns::EnemyPawnsToRemove' has a wrong offset!");

// Function Zion.UserWidgetPlayerUI.HideUI
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetPlayerUI_HideUI final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetPlayerUI_HideUI) == 0x000001, "Wrong alignment on UserWidgetPlayerUI_HideUI");
static_assert(sizeof(UserWidgetPlayerUI_HideUI) == 0x000001, "Wrong size on UserWidgetPlayerUI_HideUI");
static_assert(offsetof(UserWidgetPlayerUI_HideUI, bInstant) == 0x000000, "Member 'UserWidgetPlayerUI_HideUI::bInstant' has a wrong offset!");

// Function Zion.UserWidgetPlayerUI.OnRefreshLowHPFeedbackOpacity
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetPlayerUI_OnRefreshLowHPFeedbackOpacity final
{
public:
	float                                         Opacity;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetPlayerUI_OnRefreshLowHPFeedbackOpacity) == 0x000004, "Wrong alignment on UserWidgetPlayerUI_OnRefreshLowHPFeedbackOpacity");
static_assert(sizeof(UserWidgetPlayerUI_OnRefreshLowHPFeedbackOpacity) == 0x000004, "Wrong size on UserWidgetPlayerUI_OnRefreshLowHPFeedbackOpacity");
static_assert(offsetof(UserWidgetPlayerUI_OnRefreshLowHPFeedbackOpacity, Opacity) == 0x000000, "Member 'UserWidgetPlayerUI_OnRefreshLowHPFeedbackOpacity::Opacity' has a wrong offset!");

// Function Zion.UserWidgetPlayerUI.OnRefreshPlayerUIVisibility
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetPlayerUI_OnRefreshPlayerUIVisibility final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetPlayerUI_OnRefreshPlayerUIVisibility) == 0x000001, "Wrong alignment on UserWidgetPlayerUI_OnRefreshPlayerUIVisibility");
static_assert(sizeof(UserWidgetPlayerUI_OnRefreshPlayerUIVisibility) == 0x000001, "Wrong size on UserWidgetPlayerUI_OnRefreshPlayerUIVisibility");
static_assert(offsetof(UserWidgetPlayerUI_OnRefreshPlayerUIVisibility, bVisible) == 0x000000, "Member 'UserWidgetPlayerUI_OnRefreshPlayerUIVisibility::bVisible' has a wrong offset!");

// Function Zion.UserWidgetPlayerUI.CanShowHeal
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetPlayerUI_CanShowHeal final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetPlayerUI_CanShowHeal) == 0x000001, "Wrong alignment on UserWidgetPlayerUI_CanShowHeal");
static_assert(sizeof(UserWidgetPlayerUI_CanShowHeal) == 0x000001, "Wrong size on UserWidgetPlayerUI_CanShowHeal");
static_assert(offsetof(UserWidgetPlayerUI_CanShowHeal, ReturnValue) == 0x000000, "Member 'UserWidgetPlayerUI_CanShowHeal::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetPlayerUI.CanShowSP
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetPlayerUI_CanShowSP final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetPlayerUI_CanShowSP) == 0x000001, "Wrong alignment on UserWidgetPlayerUI_CanShowSP");
static_assert(sizeof(UserWidgetPlayerUI_CanShowSP) == 0x000001, "Wrong size on UserWidgetPlayerUI_CanShowSP");
static_assert(offsetof(UserWidgetPlayerUI_CanShowSP, ReturnValue) == 0x000000, "Member 'UserWidgetPlayerUI_CanShowSP::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetPlayerUI.GetController
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetPlayerUI_GetController final
{
public:
	class APlayerController*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetPlayerUI_GetController) == 0x000008, "Wrong alignment on UserWidgetPlayerUI_GetController");
static_assert(sizeof(UserWidgetPlayerUI_GetController) == 0x000008, "Wrong size on UserWidgetPlayerUI_GetController");
static_assert(offsetof(UserWidgetPlayerUI_GetController, ReturnValue) == 0x000000, "Member 'UserWidgetPlayerUI_GetController::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetPlayerUI.GetFieldTalkHolder
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetPlayerUI_GetFieldTalkHolder final
{
public:
	class UUserWidgetFieldTalkHolder*             ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetPlayerUI_GetFieldTalkHolder) == 0x000008, "Wrong alignment on UserWidgetPlayerUI_GetFieldTalkHolder");
static_assert(sizeof(UserWidgetPlayerUI_GetFieldTalkHolder) == 0x000008, "Wrong size on UserWidgetPlayerUI_GetFieldTalkHolder");
static_assert(offsetof(UserWidgetPlayerUI_GetFieldTalkHolder, ReturnValue) == 0x000000, "Member 'UserWidgetPlayerUI_GetFieldTalkHolder::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetPlayerUI.GetMinimapWidget
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetPlayerUI_GetMinimapWidget final
{
public:
	class UUserWidgetMinimap*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetPlayerUI_GetMinimapWidget) == 0x000008, "Wrong alignment on UserWidgetPlayerUI_GetMinimapWidget");
static_assert(sizeof(UserWidgetPlayerUI_GetMinimapWidget) == 0x000008, "Wrong size on UserWidgetPlayerUI_GetMinimapWidget");
static_assert(offsetof(UserWidgetPlayerUI_GetMinimapWidget, ReturnValue) == 0x000000, "Member 'UserWidgetPlayerUI_GetMinimapWidget::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetPlayerUI.GetPawn
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetPlayerUI_GetPawn final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetPlayerUI_GetPawn) == 0x000008, "Wrong alignment on UserWidgetPlayerUI_GetPawn");
static_assert(sizeof(UserWidgetPlayerUI_GetPawn) == 0x000008, "Wrong size on UserWidgetPlayerUI_GetPawn");
static_assert(offsetof(UserWidgetPlayerUI_GetPawn, ReturnValue) == 0x000000, "Member 'UserWidgetPlayerUI_GetPawn::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetNotificationHolder.OnLaunchNotification
// 0x0040 (0x0040 - 0x0000)
struct UserWidgetNotificationHolder_OnLaunchNotification final
{
public:
	struct FNotificationData                      NotificationData;                                  // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetNotificationHolder_OnLaunchNotification) == 0x000008, "Wrong alignment on UserWidgetNotificationHolder_OnLaunchNotification");
static_assert(sizeof(UserWidgetNotificationHolder_OnLaunchNotification) == 0x000040, "Wrong size on UserWidgetNotificationHolder_OnLaunchNotification");
static_assert(offsetof(UserWidgetNotificationHolder_OnLaunchNotification, NotificationData) == 0x000000, "Member 'UserWidgetNotificationHolder_OnLaunchNotification::NotificationData' has a wrong offset!");

// Function Zion.UserWidgetNotificationHolder.IsUIReady
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetNotificationHolder_IsUIReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetNotificationHolder_IsUIReady) == 0x000001, "Wrong alignment on UserWidgetNotificationHolder_IsUIReady");
static_assert(sizeof(UserWidgetNotificationHolder_IsUIReady) == 0x000001, "Wrong size on UserWidgetNotificationHolder_IsUIReady");
static_assert(offsetof(UserWidgetNotificationHolder_IsUIReady, ReturnValue) == 0x000000, "Member 'UserWidgetNotificationHolder_IsUIReady::ReturnValue' has a wrong offset!");

// Function Zion.Command_AI_DashTo.OnMoveBlocked
// 0x00F8 (0x00F8 - 0x0000)
struct Command_AI_DashTo_OnMoveBlocked final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_AI_DashTo_OnMoveBlocked) == 0x000008, "Wrong alignment on Command_AI_DashTo_OnMoveBlocked");
static_assert(sizeof(Command_AI_DashTo_OnMoveBlocked) == 0x0000F8, "Wrong size on Command_AI_DashTo_OnMoveBlocked");
static_assert(offsetof(Command_AI_DashTo_OnMoveBlocked, Hit) == 0x000000, "Member 'Command_AI_DashTo_OnMoveBlocked::Hit' has a wrong offset!");

// Function Zion.GameViewportZion.Get
// 0x0008 (0x0008 - 0x0000)
struct GameViewportZion_Get final
{
public:
	class UGameViewportZion*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameViewportZion_Get) == 0x000008, "Wrong alignment on GameViewportZion_Get");
static_assert(sizeof(GameViewportZion_Get) == 0x000008, "Wrong size on GameViewportZion_Get");
static_assert(offsetof(GameViewportZion_Get, ReturnValue) == 0x000000, "Member 'GameViewportZion_Get::ReturnValue' has a wrong offset!");

// Function Zion.GameViewportZion.SetViewportOverlayRenderOpacity
// 0x0004 (0x0004 - 0x0000)
struct GameViewportZion_SetViewportOverlayRenderOpacity final
{
public:
	float                                         Opacity;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameViewportZion_SetViewportOverlayRenderOpacity) == 0x000004, "Wrong alignment on GameViewportZion_SetViewportOverlayRenderOpacity");
static_assert(sizeof(GameViewportZion_SetViewportOverlayRenderOpacity) == 0x000004, "Wrong size on GameViewportZion_SetViewportOverlayRenderOpacity");
static_assert(offsetof(GameViewportZion_SetViewportOverlayRenderOpacity, Opacity) == 0x000000, "Member 'GameViewportZion_SetViewportOverlayRenderOpacity::Opacity' has a wrong offset!");

// Function Zion.GameViewportZion.SetViewportOverlayWidgetVisible
// 0x0001 (0x0001 - 0x0000)
struct GameViewportZion_SetViewportOverlayWidgetVisible final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameViewportZion_SetViewportOverlayWidgetVisible) == 0x000001, "Wrong alignment on GameViewportZion_SetViewportOverlayWidgetVisible");
static_assert(sizeof(GameViewportZion_SetViewportOverlayWidgetVisible) == 0x000001, "Wrong size on GameViewportZion_SetViewportOverlayWidgetVisible");
static_assert(offsetof(GameViewportZion_SetViewportOverlayWidgetVisible, bVisible) == 0x000000, "Member 'GameViewportZion_SetViewportOverlayWidgetVisible::bVisible' has a wrong offset!");

// Function Zion.GameViewportZion.SetWorldRenderingEnable
// 0x0001 (0x0001 - 0x0000)
struct GameViewportZion_SetWorldRenderingEnable final
{
public:
	bool                                          bEnableWorldRendering;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameViewportZion_SetWorldRenderingEnable) == 0x000001, "Wrong alignment on GameViewportZion_SetWorldRenderingEnable");
static_assert(sizeof(GameViewportZion_SetWorldRenderingEnable) == 0x000001, "Wrong size on GameViewportZion_SetWorldRenderingEnable");
static_assert(offsetof(GameViewportZion_SetWorldRenderingEnable, bEnableWorldRendering) == 0x000000, "Member 'GameViewportZion_SetWorldRenderingEnable::bEnableWorldRendering' has a wrong offset!");

// Function Zion.GameViewportZion.GetUserWidgetInStack
// 0x0010 (0x0010 - 0x0000)
struct GameViewportZion_GetUserWidgetInStack final
{
public:
	TSubclassOf<class UUserWidget>                ClassToFind;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameViewportZion_GetUserWidgetInStack) == 0x000008, "Wrong alignment on GameViewportZion_GetUserWidgetInStack");
static_assert(sizeof(GameViewportZion_GetUserWidgetInStack) == 0x000010, "Wrong size on GameViewportZion_GetUserWidgetInStack");
static_assert(offsetof(GameViewportZion_GetUserWidgetInStack, ClassToFind) == 0x000000, "Member 'GameViewportZion_GetUserWidgetInStack::ClassToFind' has a wrong offset!");
static_assert(offsetof(GameViewportZion_GetUserWidgetInStack, ReturnValue) == 0x000008, "Member 'GameViewportZion_GetUserWidgetInStack::ReturnValue' has a wrong offset!");

// Function Zion.GameViewportZion.IsShowingCollision
// 0x0001 (0x0001 - 0x0000)
struct GameViewportZion_IsShowingCollision final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameViewportZion_IsShowingCollision) == 0x000001, "Wrong alignment on GameViewportZion_IsShowingCollision");
static_assert(sizeof(GameViewportZion_IsShowingCollision) == 0x000001, "Wrong size on GameViewportZion_IsShowingCollision");
static_assert(offsetof(GameViewportZion_IsShowingCollision, ReturnValue) == 0x000000, "Member 'GameViewportZion_IsShowingCollision::ReturnValue' has a wrong offset!");

// Function Zion.BTTask_Execute.OnFinishCommand
// 0x0010 (0x0010 - 0x0000)
struct BTTask_Execute_OnFinishCommand final
{
public:
	const class UCommand*                         Command;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommandFinishType                            FinishType;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BTTask_Execute_OnFinishCommand) == 0x000008, "Wrong alignment on BTTask_Execute_OnFinishCommand");
static_assert(sizeof(BTTask_Execute_OnFinishCommand) == 0x000010, "Wrong size on BTTask_Execute_OnFinishCommand");
static_assert(offsetof(BTTask_Execute_OnFinishCommand, Command) == 0x000000, "Member 'BTTask_Execute_OnFinishCommand::Command' has a wrong offset!");
static_assert(offsetof(BTTask_Execute_OnFinishCommand, FinishType) == 0x000008, "Member 'BTTask_Execute_OnFinishCommand::FinishType' has a wrong offset!");

// Function Zion.DeathProcess_Transform.OnMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct DeathProcess_Transform_OnMovementModeChanged final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DeathProcess_Transform_OnMovementModeChanged) == 0x000008, "Wrong alignment on DeathProcess_Transform_OnMovementModeChanged");
static_assert(sizeof(DeathProcess_Transform_OnMovementModeChanged) == 0x000010, "Wrong size on DeathProcess_Transform_OnMovementModeChanged");
static_assert(offsetof(DeathProcess_Transform_OnMovementModeChanged, Character) == 0x000000, "Member 'DeathProcess_Transform_OnMovementModeChanged::Character' has a wrong offset!");
static_assert(offsetof(DeathProcess_Transform_OnMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'DeathProcess_Transform_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(DeathProcess_Transform_OnMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'DeathProcess_Transform_OnMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function Zion.FollowSplineComponent.IsClosedLoop
// 0x0001 (0x0001 - 0x0000)
struct FollowSplineComponent_IsClosedLoop final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FollowSplineComponent_IsClosedLoop) == 0x000001, "Wrong alignment on FollowSplineComponent_IsClosedLoop");
static_assert(sizeof(FollowSplineComponent_IsClosedLoop) == 0x000001, "Wrong size on FollowSplineComponent_IsClosedLoop");
static_assert(offsetof(FollowSplineComponent_IsClosedLoop, ReturnValue) == 0x000000, "Member 'FollowSplineComponent_IsClosedLoop::ReturnValue' has a wrong offset!");

// Function Zion.ContactDamageComponent.OnHitboxBeginOverlap
// 0x0118 (0x0118 - 0x0000)
struct ContactDamageComponent_OnHitboxBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ContactDamageComponent_OnHitboxBeginOverlap) == 0x000008, "Wrong alignment on ContactDamageComponent_OnHitboxBeginOverlap");
static_assert(sizeof(ContactDamageComponent_OnHitboxBeginOverlap) == 0x000118, "Wrong size on ContactDamageComponent_OnHitboxBeginOverlap");
static_assert(offsetof(ContactDamageComponent_OnHitboxBeginOverlap, OverlappedComponent) == 0x000000, "Member 'ContactDamageComponent_OnHitboxBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ContactDamageComponent_OnHitboxBeginOverlap, OtherActor) == 0x000008, "Member 'ContactDamageComponent_OnHitboxBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ContactDamageComponent_OnHitboxBeginOverlap, OtherComp) == 0x000010, "Member 'ContactDamageComponent_OnHitboxBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(ContactDamageComponent_OnHitboxBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'ContactDamageComponent_OnHitboxBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(ContactDamageComponent_OnHitboxBeginOverlap, bFromSweep) == 0x00001C, "Member 'ContactDamageComponent_OnHitboxBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(ContactDamageComponent_OnHitboxBeginOverlap, SweepResult) == 0x000020, "Member 'ContactDamageComponent_OnHitboxBeginOverlap::SweepResult' has a wrong offset!");

// Function Zion.ContactDamageComponent.OnHitboxEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct ContactDamageComponent_OnHitboxEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ContactDamageComponent_OnHitboxEndOverlap) == 0x000008, "Wrong alignment on ContactDamageComponent_OnHitboxEndOverlap");
static_assert(sizeof(ContactDamageComponent_OnHitboxEndOverlap) == 0x000020, "Wrong size on ContactDamageComponent_OnHitboxEndOverlap");
static_assert(offsetof(ContactDamageComponent_OnHitboxEndOverlap, OverlappedComponent) == 0x000000, "Member 'ContactDamageComponent_OnHitboxEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ContactDamageComponent_OnHitboxEndOverlap, OtherActor) == 0x000008, "Member 'ContactDamageComponent_OnHitboxEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ContactDamageComponent_OnHitboxEndOverlap, OtherComp) == 0x000010, "Member 'ContactDamageComponent_OnHitboxEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(ContactDamageComponent_OnHitboxEndOverlap, OtherBodyIndex) == 0x000018, "Member 'ContactDamageComponent_OnHitboxEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function Zion.GameMapChangeDataProviderInterface.GetGameMapChangeProviderData
// 0x0040 (0x0040 - 0x0000)
struct GameMapChangeDataProviderInterface_GetGameMapChangeProviderData final
{
public:
	struct FGameMapChangeProviderData             OutGameMapChangeProviderData;                      // 0x0000(0x0040)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMapChangeDataProviderInterface_GetGameMapChangeProviderData) == 0x000008, "Wrong alignment on GameMapChangeDataProviderInterface_GetGameMapChangeProviderData");
static_assert(sizeof(GameMapChangeDataProviderInterface_GetGameMapChangeProviderData) == 0x000040, "Wrong size on GameMapChangeDataProviderInterface_GetGameMapChangeProviderData");
static_assert(offsetof(GameMapChangeDataProviderInterface_GetGameMapChangeProviderData, OutGameMapChangeProviderData) == 0x000000, "Member 'GameMapChangeDataProviderInterface_GetGameMapChangeProviderData::OutGameMapChangeProviderData' has a wrong offset!");

// Function Zion.DashChargeComponent.OnCommandStart
// 0x0008 (0x0008 - 0x0000)
struct DashChargeComponent_OnCommandStart final
{
public:
	const class UCommand*                         Command;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DashChargeComponent_OnCommandStart) == 0x000008, "Wrong alignment on DashChargeComponent_OnCommandStart");
static_assert(sizeof(DashChargeComponent_OnCommandStart) == 0x000008, "Wrong size on DashChargeComponent_OnCommandStart");
static_assert(offsetof(DashChargeComponent_OnCommandStart, Command) == 0x000000, "Member 'DashChargeComponent_OnCommandStart::Command' has a wrong offset!");

// Function Zion.DashChargeComponent.OnStartAnimation
// 0x0008 (0x0008 - 0x0000)
struct DashChargeComponent_OnStartAnimation final
{
public:
	class UTrackEntry*                            TrackEntry;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DashChargeComponent_OnStartAnimation) == 0x000008, "Wrong alignment on DashChargeComponent_OnStartAnimation");
static_assert(sizeof(DashChargeComponent_OnStartAnimation) == 0x000008, "Wrong size on DashChargeComponent_OnStartAnimation");
static_assert(offsetof(DashChargeComponent_OnStartAnimation, TrackEntry) == 0x000000, "Member 'DashChargeComponent_OnStartAnimation::TrackEntry' has a wrong offset!");

// Function Zion.DashChargeComponent.IsDashCharged
// 0x0001 (0x0001 - 0x0000)
struct DashChargeComponent_IsDashCharged final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DashChargeComponent_IsDashCharged) == 0x000001, "Wrong alignment on DashChargeComponent_IsDashCharged");
static_assert(sizeof(DashChargeComponent_IsDashCharged) == 0x000001, "Wrong size on DashChargeComponent_IsDashCharged");
static_assert(offsetof(DashChargeComponent_IsDashCharged, ReturnValue) == 0x000000, "Member 'DashChargeComponent_IsDashCharged::ReturnValue' has a wrong offset!");

// Function Zion.CharacterZion.OnGuarded
// 0x0010 (0x0010 - 0x0000)
struct CharacterZion_OnGuarded final
{
public:
	class AAbility*                               Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZion_OnGuarded) == 0x000008, "Wrong alignment on CharacterZion_OnGuarded");
static_assert(sizeof(CharacterZion_OnGuarded) == 0x000010, "Wrong size on CharacterZion_OnGuarded");
static_assert(offsetof(CharacterZion_OnGuarded, Ability) == 0x000000, "Member 'CharacterZion_OnGuarded::Ability' has a wrong offset!");
static_assert(offsetof(CharacterZion_OnGuarded, Source) == 0x000008, "Member 'CharacterZion_OnGuarded::Source' has a wrong offset!");

// Function Zion.CharacterZion.OnParried
// 0x0010 (0x0010 - 0x0000)
struct CharacterZion_OnParried final
{
public:
	class AAbility*                               Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZion_OnParried) == 0x000008, "Wrong alignment on CharacterZion_OnParried");
static_assert(sizeof(CharacterZion_OnParried) == 0x000010, "Wrong size on CharacterZion_OnParried");
static_assert(offsetof(CharacterZion_OnParried, Ability) == 0x000000, "Member 'CharacterZion_OnParried::Ability' has a wrong offset!");
static_assert(offsetof(CharacterZion_OnParried, Source) == 0x000008, "Member 'CharacterZion_OnParried::Source' has a wrong offset!");

// Function Zion.CharacterZion.OnReceivedDamage
// 0x0010 (0x0010 - 0x0000)
struct CharacterZion_OnReceivedDamage final
{
public:
	class AActor*                                 Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterZion_OnReceivedDamage) == 0x000008, "Wrong alignment on CharacterZion_OnReceivedDamage");
static_assert(sizeof(CharacterZion_OnReceivedDamage) == 0x000010, "Wrong size on CharacterZion_OnReceivedDamage");
static_assert(offsetof(CharacterZion_OnReceivedDamage, Source) == 0x000000, "Member 'CharacterZion_OnReceivedDamage::Source' has a wrong offset!");
static_assert(offsetof(CharacterZion_OnReceivedDamage, Value) == 0x000008, "Member 'CharacterZion_OnReceivedDamage::Value' has a wrong offset!");

// Function Zion.CharacterZion.GetCollisionComponent
// 0x0008 (0x0008 - 0x0000)
struct CharacterZion_GetCollisionComponent final
{
public:
	class UCollisionComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZion_GetCollisionComponent) == 0x000008, "Wrong alignment on CharacterZion_GetCollisionComponent");
static_assert(sizeof(CharacterZion_GetCollisionComponent) == 0x000008, "Wrong size on CharacterZion_GetCollisionComponent");
static_assert(offsetof(CharacterZion_GetCollisionComponent, ReturnValue) == 0x000000, "Member 'CharacterZion_GetCollisionComponent::ReturnValue' has a wrong offset!");

// Function Zion.CharacterZion.GetZionCharacterMovement
// 0x0008 (0x0008 - 0x0000)
struct CharacterZion_GetZionCharacterMovement final
{
public:
	class UZionCharacterMovementComponent*        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZion_GetZionCharacterMovement) == 0x000008, "Wrong alignment on CharacterZion_GetZionCharacterMovement");
static_assert(sizeof(CharacterZion_GetZionCharacterMovement) == 0x000008, "Wrong size on CharacterZion_GetZionCharacterMovement");
static_assert(offsetof(CharacterZion_GetZionCharacterMovement, ReturnValue) == 0x000000, "Member 'CharacterZion_GetZionCharacterMovement::ReturnValue' has a wrong offset!");

// Function Zion.CharacterZion.IsInEvent
// 0x0001 (0x0001 - 0x0000)
struct CharacterZion_IsInEvent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZion_IsInEvent) == 0x000001, "Wrong alignment on CharacterZion_IsInEvent");
static_assert(sizeof(CharacterZion_IsInEvent) == 0x000001, "Wrong size on CharacterZion_IsInEvent");
static_assert(offsetof(CharacterZion_IsInEvent, ReturnValue) == 0x000000, "Member 'CharacterZion_IsInEvent::ReturnValue' has a wrong offset!");

// Function Zion.CharacterZion.ShouldConsiderJumpAsAirborne
// 0x0001 (0x0001 - 0x0000)
struct CharacterZion_ShouldConsiderJumpAsAirborne final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZion_ShouldConsiderJumpAsAirborne) == 0x000001, "Wrong alignment on CharacterZion_ShouldConsiderJumpAsAirborne");
static_assert(sizeof(CharacterZion_ShouldConsiderJumpAsAirborne) == 0x000001, "Wrong size on CharacterZion_ShouldConsiderJumpAsAirborne");
static_assert(offsetof(CharacterZion_ShouldConsiderJumpAsAirborne, ReturnValue) == 0x000000, "Member 'CharacterZion_ShouldConsiderJumpAsAirborne::ReturnValue' has a wrong offset!");

// Function Zion.CharacterZion.ShouldConsiderJumpAsGrounded
// 0x0001 (0x0001 - 0x0000)
struct CharacterZion_ShouldConsiderJumpAsGrounded final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZion_ShouldConsiderJumpAsGrounded) == 0x000001, "Wrong alignment on CharacterZion_ShouldConsiderJumpAsGrounded");
static_assert(sizeof(CharacterZion_ShouldConsiderJumpAsGrounded) == 0x000001, "Wrong size on CharacterZion_ShouldConsiderJumpAsGrounded");
static_assert(offsetof(CharacterZion_ShouldConsiderJumpAsGrounded, ReturnValue) == 0x000000, "Member 'CharacterZion_ShouldConsiderJumpAsGrounded::ReturnValue' has a wrong offset!");

// Function Zion.CharacterZion.ShouldConsiderJumpAsHookAttach
// 0x0001 (0x0001 - 0x0000)
struct CharacterZion_ShouldConsiderJumpAsHookAttach final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZion_ShouldConsiderJumpAsHookAttach) == 0x000001, "Wrong alignment on CharacterZion_ShouldConsiderJumpAsHookAttach");
static_assert(sizeof(CharacterZion_ShouldConsiderJumpAsHookAttach) == 0x000001, "Wrong size on CharacterZion_ShouldConsiderJumpAsHookAttach");
static_assert(offsetof(CharacterZion_ShouldConsiderJumpAsHookAttach, ReturnValue) == 0x000000, "Member 'CharacterZion_ShouldConsiderJumpAsHookAttach::ReturnValue' has a wrong offset!");

// Function Zion.CharacterZion.ShouldConsiderJumpAsWallGrab
// 0x0001 (0x0001 - 0x0000)
struct CharacterZion_ShouldConsiderJumpAsWallGrab final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZion_ShouldConsiderJumpAsWallGrab) == 0x000001, "Wrong alignment on CharacterZion_ShouldConsiderJumpAsWallGrab");
static_assert(sizeof(CharacterZion_ShouldConsiderJumpAsWallGrab) == 0x000001, "Wrong size on CharacterZion_ShouldConsiderJumpAsWallGrab");
static_assert(offsetof(CharacterZion_ShouldConsiderJumpAsWallGrab, ReturnValue) == 0x000000, "Member 'CharacterZion_ShouldConsiderJumpAsWallGrab::ReturnValue' has a wrong offset!");

// Function Zion.CharacterZionNPC.SetIdleOverrideAnimations
// 0x0010 (0x0010 - 0x0000)
struct CharacterZionNPC_SetIdleOverrideAnimations final
{
public:
	TArray<struct FSpineAnimationDefinition>      NewIdleOverrideAnimations;                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZionNPC_SetIdleOverrideAnimations) == 0x000008, "Wrong alignment on CharacterZionNPC_SetIdleOverrideAnimations");
static_assert(sizeof(CharacterZionNPC_SetIdleOverrideAnimations) == 0x000010, "Wrong size on CharacterZionNPC_SetIdleOverrideAnimations");
static_assert(offsetof(CharacterZionNPC_SetIdleOverrideAnimations, NewIdleOverrideAnimations) == 0x000000, "Member 'CharacterZionNPC_SetIdleOverrideAnimations::NewIdleOverrideAnimations' has a wrong offset!");

// Function Zion.CharacterZionSpirit.DelayedDismiss
// 0x0004 (0x0004 - 0x0000)
struct CharacterZionSpirit_DelayedDismiss final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZionSpirit_DelayedDismiss) == 0x000004, "Wrong alignment on CharacterZionSpirit_DelayedDismiss");
static_assert(sizeof(CharacterZionSpirit_DelayedDismiss) == 0x000004, "Wrong size on CharacterZionSpirit_DelayedDismiss");
static_assert(offsetof(CharacterZionSpirit_DelayedDismiss, Delay) == 0x000000, "Member 'CharacterZionSpirit_DelayedDismiss::Delay' has a wrong offset!");

// Function Zion.CharacterZionSpirit.Dismiss
// 0x0001 (0x0001 - 0x0000)
struct CharacterZionSpirit_Dismiss final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZionSpirit_Dismiss) == 0x000001, "Wrong alignment on CharacterZionSpirit_Dismiss");
static_assert(sizeof(CharacterZionSpirit_Dismiss) == 0x000001, "Wrong size on CharacterZionSpirit_Dismiss");
static_assert(offsetof(CharacterZionSpirit_Dismiss, bInstant) == 0x000000, "Member 'CharacterZionSpirit_Dismiss::bInstant' has a wrong offset!");

// Function Zion.CharacterZionSpirit.OnLocationBlendEnd
// 0x0030 (0x0030 - 0x0000)
struct CharacterZionSpirit_OnLocationBlendEnd final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZionSpirit_OnLocationBlendEnd) == 0x000008, "Wrong alignment on CharacterZionSpirit_OnLocationBlendEnd");
static_assert(sizeof(CharacterZionSpirit_OnLocationBlendEnd) == 0x000030, "Wrong size on CharacterZionSpirit_OnLocationBlendEnd");
static_assert(offsetof(CharacterZionSpirit_OnLocationBlendEnd, StartLocation) == 0x000000, "Member 'CharacterZionSpirit_OnLocationBlendEnd::StartLocation' has a wrong offset!");
static_assert(offsetof(CharacterZionSpirit_OnLocationBlendEnd, EndLocation) == 0x000018, "Member 'CharacterZionSpirit_OnLocationBlendEnd::EndLocation' has a wrong offset!");

// Function Zion.CharacterZionSpirit.OnLocationBlendStart
// 0x0030 (0x0030 - 0x0000)
struct CharacterZionSpirit_OnLocationBlendStart final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZionSpirit_OnLocationBlendStart) == 0x000008, "Wrong alignment on CharacterZionSpirit_OnLocationBlendStart");
static_assert(sizeof(CharacterZionSpirit_OnLocationBlendStart) == 0x000030, "Wrong size on CharacterZionSpirit_OnLocationBlendStart");
static_assert(offsetof(CharacterZionSpirit_OnLocationBlendStart, StartLocation) == 0x000000, "Member 'CharacterZionSpirit_OnLocationBlendStart::StartLocation' has a wrong offset!");
static_assert(offsetof(CharacterZionSpirit_OnLocationBlendStart, EndLocation) == 0x000018, "Member 'CharacterZionSpirit_OnLocationBlendStart::EndLocation' has a wrong offset!");

// Function Zion.CharacterZionSpirit.OnTeleport
// 0x0030 (0x0030 - 0x0000)
struct CharacterZionSpirit_OnTeleport final
{
public:
	struct FVector                                From;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                To;                                                // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZionSpirit_OnTeleport) == 0x000008, "Wrong alignment on CharacterZionSpirit_OnTeleport");
static_assert(sizeof(CharacterZionSpirit_OnTeleport) == 0x000030, "Wrong size on CharacterZionSpirit_OnTeleport");
static_assert(offsetof(CharacterZionSpirit_OnTeleport, From) == 0x000000, "Member 'CharacterZionSpirit_OnTeleport::From' has a wrong offset!");
static_assert(offsetof(CharacterZionSpirit_OnTeleport, To) == 0x000018, "Member 'CharacterZionSpirit_OnTeleport::To' has a wrong offset!");

// Function Zion.CharacterZionSpirit.SetActive
// 0x0001 (0x0001 - 0x0000)
struct CharacterZionSpirit_SetActive final
{
public:
	bool                                          bNewActive;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZionSpirit_SetActive) == 0x000001, "Wrong alignment on CharacterZionSpirit_SetActive");
static_assert(sizeof(CharacterZionSpirit_SetActive) == 0x000001, "Wrong size on CharacterZionSpirit_SetActive");
static_assert(offsetof(CharacterZionSpirit_SetActive, bNewActive) == 0x000000, "Member 'CharacterZionSpirit_SetActive::bNewActive' has a wrong offset!");

// Function Zion.CharacterZionSpirit.GetSummoner
// 0x0008 (0x0008 - 0x0000)
struct CharacterZionSpirit_GetSummoner final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZionSpirit_GetSummoner) == 0x000008, "Wrong alignment on CharacterZionSpirit_GetSummoner");
static_assert(sizeof(CharacterZionSpirit_GetSummoner) == 0x000008, "Wrong size on CharacterZionSpirit_GetSummoner");
static_assert(offsetof(CharacterZionSpirit_GetSummoner, ReturnValue) == 0x000000, "Member 'CharacterZionSpirit_GetSummoner::ReturnValue' has a wrong offset!");

// Function Zion.CharacterZionSpirit.IsActive
// 0x0001 (0x0001 - 0x0000)
struct CharacterZionSpirit_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZionSpirit_IsActive) == 0x000001, "Wrong alignment on CharacterZionSpirit_IsActive");
static_assert(sizeof(CharacterZionSpirit_IsActive) == 0x000001, "Wrong size on CharacterZionSpirit_IsActive");
static_assert(offsetof(CharacterZionSpirit_IsActive, ReturnValue) == 0x000000, "Member 'CharacterZionSpirit_IsActive::ReturnValue' has a wrong offset!");

// Function Zion.CharacterZionSpirit.IsSummoned
// 0x0001 (0x0001 - 0x0000)
struct CharacterZionSpirit_IsSummoned final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterZionSpirit_IsSummoned) == 0x000001, "Wrong alignment on CharacterZionSpirit_IsSummoned");
static_assert(sizeof(CharacterZionSpirit_IsSummoned) == 0x000001, "Wrong size on CharacterZionSpirit_IsSummoned");
static_assert(offsetof(CharacterZionSpirit_IsSummoned, ReturnValue) == 0x000000, "Member 'CharacterZionSpirit_IsSummoned::ReturnValue' has a wrong offset!");

// Function Zion.StatsComponent.GetAttack
// 0x0004 (0x0004 - 0x0000)
struct StatsComponent_GetAttack final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsComponent_GetAttack) == 0x000004, "Wrong alignment on StatsComponent_GetAttack");
static_assert(sizeof(StatsComponent_GetAttack) == 0x000004, "Wrong size on StatsComponent_GetAttack");
static_assert(offsetof(StatsComponent_GetAttack, ReturnValue) == 0x000000, "Member 'StatsComponent_GetAttack::ReturnValue' has a wrong offset!");

// Function Zion.StatsComponent.GetDamageCutPercentage
// 0x0008 (0x0008 - 0x0000)
struct StatsComponent_GetDamageCutPercentage final
{
public:
	EAttackType                                   Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsComponent_GetDamageCutPercentage) == 0x000004, "Wrong alignment on StatsComponent_GetDamageCutPercentage");
static_assert(sizeof(StatsComponent_GetDamageCutPercentage) == 0x000008, "Wrong size on StatsComponent_GetDamageCutPercentage");
static_assert(offsetof(StatsComponent_GetDamageCutPercentage, Type) == 0x000000, "Member 'StatsComponent_GetDamageCutPercentage::Type' has a wrong offset!");
static_assert(offsetof(StatsComponent_GetDamageCutPercentage, ReturnValue) == 0x000004, "Member 'StatsComponent_GetDamageCutPercentage::ReturnValue' has a wrong offset!");

// Function Zion.StatsComponent.GetDefense
// 0x0004 (0x0004 - 0x0000)
struct StatsComponent_GetDefense final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsComponent_GetDefense) == 0x000004, "Wrong alignment on StatsComponent_GetDefense");
static_assert(sizeof(StatsComponent_GetDefense) == 0x000004, "Wrong size on StatsComponent_GetDefense");
static_assert(offsetof(StatsComponent_GetDefense, ReturnValue) == 0x000000, "Member 'StatsComponent_GetDefense::ReturnValue' has a wrong offset!");

// Function Zion.StatsComponent.GetStaminaCutPercentage
// 0x0008 (0x0008 - 0x0000)
struct StatsComponent_GetStaminaCutPercentage final
{
public:
	EAttackType                                   Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsComponent_GetStaminaCutPercentage) == 0x000004, "Wrong alignment on StatsComponent_GetStaminaCutPercentage");
static_assert(sizeof(StatsComponent_GetStaminaCutPercentage) == 0x000008, "Wrong size on StatsComponent_GetStaminaCutPercentage");
static_assert(offsetof(StatsComponent_GetStaminaCutPercentage, Type) == 0x000000, "Member 'StatsComponent_GetStaminaCutPercentage::Type' has a wrong offset!");
static_assert(offsetof(StatsComponent_GetStaminaCutPercentage, ReturnValue) == 0x000004, "Member 'StatsComponent_GetStaminaCutPercentage::ReturnValue' has a wrong offset!");

// Function Zion.ClearComponent.GetClearStatus
// 0x0001 (0x0001 - 0x0000)
struct ClearComponent_GetClearStatus final
{
public:
	EClearStatus                                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClearComponent_GetClearStatus) == 0x000001, "Wrong alignment on ClearComponent_GetClearStatus");
static_assert(sizeof(ClearComponent_GetClearStatus) == 0x000001, "Wrong size on ClearComponent_GetClearStatus");
static_assert(offsetof(ClearComponent_GetClearStatus, ReturnValue) == 0x000000, "Member 'ClearComponent_GetClearStatus::ReturnValue' has a wrong offset!");

// Function Zion.ClearComponent.GetPreviousRunsClearStatus
// 0x0001 (0x0001 - 0x0000)
struct ClearComponent_GetPreviousRunsClearStatus final
{
public:
	EClearStatus                                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClearComponent_GetPreviousRunsClearStatus) == 0x000001, "Wrong alignment on ClearComponent_GetPreviousRunsClearStatus");
static_assert(sizeof(ClearComponent_GetPreviousRunsClearStatus) == 0x000001, "Wrong size on ClearComponent_GetPreviousRunsClearStatus");
static_assert(offsetof(ClearComponent_GetPreviousRunsClearStatus, ReturnValue) == 0x000000, "Member 'ClearComponent_GetPreviousRunsClearStatus::ReturnValue' has a wrong offset!");

// Function Zion.ClearComponent.IsCleared
// 0x0001 (0x0001 - 0x0000)
struct ClearComponent_IsCleared final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClearComponent_IsCleared) == 0x000001, "Wrong alignment on ClearComponent_IsCleared");
static_assert(sizeof(ClearComponent_IsCleared) == 0x000001, "Wrong size on ClearComponent_IsCleared");
static_assert(offsetof(ClearComponent_IsCleared, ReturnValue) == 0x000000, "Member 'ClearComponent_IsCleared::ReturnValue' has a wrong offset!");

// Function Zion.ClearComponent.WasClearedOnPreviousRuns
// 0x0001 (0x0001 - 0x0000)
struct ClearComponent_WasClearedOnPreviousRuns final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClearComponent_WasClearedOnPreviousRuns) == 0x000001, "Wrong alignment on ClearComponent_WasClearedOnPreviousRuns");
static_assert(sizeof(ClearComponent_WasClearedOnPreviousRuns) == 0x000001, "Wrong size on ClearComponent_WasClearedOnPreviousRuns");
static_assert(offsetof(ClearComponent_WasClearedOnPreviousRuns, ReturnValue) == 0x000000, "Member 'ClearComponent_WasClearedOnPreviousRuns::ReturnValue' has a wrong offset!");

// Function Zion.ClearManagerComponent.Get
// 0x0010 (0x0010 - 0x0000)
struct ClearManagerComponent_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClearManagerComponent*                 ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClearManagerComponent_Get) == 0x000008, "Wrong alignment on ClearManagerComponent_Get");
static_assert(sizeof(ClearManagerComponent_Get) == 0x000010, "Wrong size on ClearManagerComponent_Get");
static_assert(offsetof(ClearManagerComponent_Get, WorldContextObject) == 0x000000, "Member 'ClearManagerComponent_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ClearManagerComponent_Get, ReturnValue) == 0x000008, "Member 'ClearManagerComponent_Get::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.ChangeMapArea
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetRestPointList_ChangeMapArea final
{
public:
	int32                                         IndexOffset;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidgetMapIcon_RestPoint*           ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_ChangeMapArea) == 0x000008, "Wrong alignment on UserWidgetRestPointList_ChangeMapArea");
static_assert(sizeof(UserWidgetRestPointList_ChangeMapArea) == 0x000010, "Wrong size on UserWidgetRestPointList_ChangeMapArea");
static_assert(offsetof(UserWidgetRestPointList_ChangeMapArea, IndexOffset) == 0x000000, "Member 'UserWidgetRestPointList_ChangeMapArea::IndexOffset' has a wrong offset!");
static_assert(offsetof(UserWidgetRestPointList_ChangeMapArea, ReturnValue) == 0x000008, "Member 'UserWidgetRestPointList_ChangeMapArea::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.Close
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetRestPointList_Close final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_Close) == 0x000001, "Wrong alignment on UserWidgetRestPointList_Close");
static_assert(sizeof(UserWidgetRestPointList_Close) == 0x000001, "Wrong size on UserWidgetRestPointList_Close");
static_assert(offsetof(UserWidgetRestPointList_Close, bInstant) == 0x000000, "Member 'UserWidgetRestPointList_Close::bInstant' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.FindNearestRestPointIcon
// 0x0020 (0x0020 - 0x0000)
struct UserWidgetRestPointList_FindNearestRestPointIcon final
{
public:
	struct FVector2D                              CurrentMapPosition;                                // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutMapAreaIndex;                                   // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidgetMapIcon_RestPoint*           ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_FindNearestRestPointIcon) == 0x000008, "Wrong alignment on UserWidgetRestPointList_FindNearestRestPointIcon");
static_assert(sizeof(UserWidgetRestPointList_FindNearestRestPointIcon) == 0x000020, "Wrong size on UserWidgetRestPointList_FindNearestRestPointIcon");
static_assert(offsetof(UserWidgetRestPointList_FindNearestRestPointIcon, CurrentMapPosition) == 0x000000, "Member 'UserWidgetRestPointList_FindNearestRestPointIcon::CurrentMapPosition' has a wrong offset!");
static_assert(offsetof(UserWidgetRestPointList_FindNearestRestPointIcon, OutMapAreaIndex) == 0x000010, "Member 'UserWidgetRestPointList_FindNearestRestPointIcon::OutMapAreaIndex' has a wrong offset!");
static_assert(offsetof(UserWidgetRestPointList_FindNearestRestPointIcon, ReturnValue) == 0x000018, "Member 'UserWidgetRestPointList_FindNearestRestPointIcon::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.GoToMapAreaFromIndex
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetRestPointList_GoToMapAreaFromIndex final
{
public:
	int32                                         MapAreaIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidgetMapIcon_RestPoint*           NearestRestPointIcon;                              // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_GoToMapAreaFromIndex) == 0x000008, "Wrong alignment on UserWidgetRestPointList_GoToMapAreaFromIndex");
static_assert(sizeof(UserWidgetRestPointList_GoToMapAreaFromIndex) == 0x000010, "Wrong size on UserWidgetRestPointList_GoToMapAreaFromIndex");
static_assert(offsetof(UserWidgetRestPointList_GoToMapAreaFromIndex, MapAreaIndex) == 0x000000, "Member 'UserWidgetRestPointList_GoToMapAreaFromIndex::MapAreaIndex' has a wrong offset!");
static_assert(offsetof(UserWidgetRestPointList_GoToMapAreaFromIndex, NearestRestPointIcon) == 0x000008, "Member 'UserWidgetRestPointList_GoToMapAreaFromIndex::NearestRestPointIcon' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.InstantiateRestPointList
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetRestPointList_InstantiateRestPointList final
{
public:
	TArray<struct FRestPointListData>             ListData;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_InstantiateRestPointList) == 0x000008, "Wrong alignment on UserWidgetRestPointList_InstantiateRestPointList");
static_assert(sizeof(UserWidgetRestPointList_InstantiateRestPointList) == 0x000010, "Wrong size on UserWidgetRestPointList_InstantiateRestPointList");
static_assert(offsetof(UserWidgetRestPointList_InstantiateRestPointList, ListData) == 0x000000, "Member 'UserWidgetRestPointList_InstantiateRestPointList::ListData' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.OnClosed
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetRestPointList_OnClosed final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_OnClosed) == 0x000001, "Wrong alignment on UserWidgetRestPointList_OnClosed");
static_assert(sizeof(UserWidgetRestPointList_OnClosed) == 0x000001, "Wrong size on UserWidgetRestPointList_OnClosed");
static_assert(offsetof(UserWidgetRestPointList_OnClosed, bInstant) == 0x000000, "Member 'UserWidgetRestPointList_OnClosed::bInstant' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.OnOpened
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetRestPointList_OnOpened final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_OnOpened) == 0x000001, "Wrong alignment on UserWidgetRestPointList_OnOpened");
static_assert(sizeof(UserWidgetRestPointList_OnOpened) == 0x000001, "Wrong size on UserWidgetRestPointList_OnOpened");
static_assert(offsetof(UserWidgetRestPointList_OnOpened, bInstant) == 0x000000, "Member 'UserWidgetRestPointList_OnOpened::bInstant' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.Open
// 0x0018 (0x0018 - 0x0000)
struct UserWidgetRestPointList_Open final
{
public:
	struct FVector2D                              CurrentMapPosition;                                // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstant;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserWidgetRestPointList_Open) == 0x000008, "Wrong alignment on UserWidgetRestPointList_Open");
static_assert(sizeof(UserWidgetRestPointList_Open) == 0x000018, "Wrong size on UserWidgetRestPointList_Open");
static_assert(offsetof(UserWidgetRestPointList_Open, CurrentMapPosition) == 0x000000, "Member 'UserWidgetRestPointList_Open::CurrentMapPosition' has a wrong offset!");
static_assert(offsetof(UserWidgetRestPointList_Open, bInstant) == 0x000010, "Member 'UserWidgetRestPointList_Open::bInstant' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.RestPointEntryFocused
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetRestPointList_RestPointEntryFocused final
{
public:
	int32                                         MapAreaIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidgetMapIcon_RestPoint*           RestPointIcon;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_RestPointEntryFocused) == 0x000008, "Wrong alignment on UserWidgetRestPointList_RestPointEntryFocused");
static_assert(sizeof(UserWidgetRestPointList_RestPointEntryFocused) == 0x000010, "Wrong size on UserWidgetRestPointList_RestPointEntryFocused");
static_assert(offsetof(UserWidgetRestPointList_RestPointEntryFocused, MapAreaIndex) == 0x000000, "Member 'UserWidgetRestPointList_RestPointEntryFocused::MapAreaIndex' has a wrong offset!");
static_assert(offsetof(UserWidgetRestPointList_RestPointEntryFocused, RestPointIcon) == 0x000008, "Member 'UserWidgetRestPointList_RestPointEntryFocused::RestPointIcon' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.RestPointEntryPressed
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetRestPointList_RestPointEntryPressed final
{
public:
	struct FMapRestPointData                      RestPointData;                                     // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_RestPointEntryPressed) == 0x000004, "Wrong alignment on UserWidgetRestPointList_RestPointEntryPressed");
static_assert(sizeof(UserWidgetRestPointList_RestPointEntryPressed) == 0x000008, "Wrong size on UserWidgetRestPointList_RestPointEntryPressed");
static_assert(offsetof(UserWidgetRestPointList_RestPointEntryPressed, RestPointData) == 0x000000, "Member 'UserWidgetRestPointList_RestPointEntryPressed::RestPointData' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.SetCurrentMapAreaIndex
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetRestPointList_SetCurrentMapAreaIndex final
{
public:
	int32                                         NewMapAreaIndex;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_SetCurrentMapAreaIndex) == 0x000004, "Wrong alignment on UserWidgetRestPointList_SetCurrentMapAreaIndex");
static_assert(sizeof(UserWidgetRestPointList_SetCurrentMapAreaIndex) == 0x000008, "Wrong size on UserWidgetRestPointList_SetCurrentMapAreaIndex");
static_assert(offsetof(UserWidgetRestPointList_SetCurrentMapAreaIndex, NewMapAreaIndex) == 0x000000, "Member 'UserWidgetRestPointList_SetCurrentMapAreaIndex::NewMapAreaIndex' has a wrong offset!");
static_assert(offsetof(UserWidgetRestPointList_SetCurrentMapAreaIndex, ReturnValue) == 0x000004, "Member 'UserWidgetRestPointList_SetCurrentMapAreaIndex::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.CanBeOpened
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetRestPointList_CanBeOpened final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_CanBeOpened) == 0x000001, "Wrong alignment on UserWidgetRestPointList_CanBeOpened");
static_assert(sizeof(UserWidgetRestPointList_CanBeOpened) == 0x000001, "Wrong size on UserWidgetRestPointList_CanBeOpened");
static_assert(offsetof(UserWidgetRestPointList_CanBeOpened, ReturnValue) == 0x000000, "Member 'UserWidgetRestPointList_CanBeOpened::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.CanChangeMapArea
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetRestPointList_CanChangeMapArea final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_CanChangeMapArea) == 0x000001, "Wrong alignment on UserWidgetRestPointList_CanChangeMapArea");
static_assert(sizeof(UserWidgetRestPointList_CanChangeMapArea) == 0x000001, "Wrong size on UserWidgetRestPointList_CanChangeMapArea");
static_assert(offsetof(UserWidgetRestPointList_CanChangeMapArea, ReturnValue) == 0x000000, "Member 'UserWidgetRestPointList_CanChangeMapArea::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.GetIndexFromMapAreaName
// 0x000C (0x000C - 0x0000)
struct UserWidgetRestPointList_GetIndexFromMapAreaName final
{
public:
	class FName                                   MapAreaName;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_GetIndexFromMapAreaName) == 0x000004, "Wrong alignment on UserWidgetRestPointList_GetIndexFromMapAreaName");
static_assert(sizeof(UserWidgetRestPointList_GetIndexFromMapAreaName) == 0x00000C, "Wrong size on UserWidgetRestPointList_GetIndexFromMapAreaName");
static_assert(offsetof(UserWidgetRestPointList_GetIndexFromMapAreaName, MapAreaName) == 0x000000, "Member 'UserWidgetRestPointList_GetIndexFromMapAreaName::MapAreaName' has a wrong offset!");
static_assert(offsetof(UserWidgetRestPointList_GetIndexFromMapAreaName, ReturnValue) == 0x000008, "Member 'UserWidgetRestPointList_GetIndexFromMapAreaName::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.GetNewMapAreaIndex
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetRestPointList_GetNewMapAreaIndex final
{
public:
	int32                                         IndexOffset;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_GetNewMapAreaIndex) == 0x000004, "Wrong alignment on UserWidgetRestPointList_GetNewMapAreaIndex");
static_assert(sizeof(UserWidgetRestPointList_GetNewMapAreaIndex) == 0x000008, "Wrong size on UserWidgetRestPointList_GetNewMapAreaIndex");
static_assert(offsetof(UserWidgetRestPointList_GetNewMapAreaIndex, IndexOffset) == 0x000000, "Member 'UserWidgetRestPointList_GetNewMapAreaIndex::IndexOffset' has a wrong offset!");
static_assert(offsetof(UserWidgetRestPointList_GetNewMapAreaIndex, ReturnValue) == 0x000004, "Member 'UserWidgetRestPointList_GetNewMapAreaIndex::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetRestPointList.IsOpened
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetRestPointList_IsOpened final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointList_IsOpened) == 0x000001, "Wrong alignment on UserWidgetRestPointList_IsOpened");
static_assert(sizeof(UserWidgetRestPointList_IsOpened) == 0x000001, "Wrong size on UserWidgetRestPointList_IsOpened");
static_assert(offsetof(UserWidgetRestPointList_IsOpened, ReturnValue) == 0x000000, "Member 'UserWidgetRestPointList_IsOpened::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapTransition.OnSetIconsVisibility
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetMapTransition_OnSetIconsVisibility final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapTransition_OnSetIconsVisibility) == 0x000001, "Wrong alignment on UserWidgetMapTransition_OnSetIconsVisibility");
static_assert(sizeof(UserWidgetMapTransition_OnSetIconsVisibility) == 0x000001, "Wrong size on UserWidgetMapTransition_OnSetIconsVisibility");
static_assert(offsetof(UserWidgetMapTransition_OnSetIconsVisibility, bVisible) == 0x000000, "Member 'UserWidgetMapTransition_OnSetIconsVisibility::bVisible' has a wrong offset!");

// Function Zion.UserWidgetMapTransition.OnSetScale
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetMapTransition_OnSetScale final
{
public:
	float                                         NewScale;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapTransition_OnSetScale) == 0x000004, "Wrong alignment on UserWidgetMapTransition_OnSetScale");
static_assert(sizeof(UserWidgetMapTransition_OnSetScale) == 0x000004, "Wrong size on UserWidgetMapTransition_OnSetScale");
static_assert(offsetof(UserWidgetMapTransition_OnSetScale, NewScale) == 0x000000, "Member 'UserWidgetMapTransition_OnSetScale::NewScale' has a wrong offset!");

// Function Zion.UserWidgetMapTransition.SetIconsVisibility
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetMapTransition_SetIconsVisibility final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapTransition_SetIconsVisibility) == 0x000001, "Wrong alignment on UserWidgetMapTransition_SetIconsVisibility");
static_assert(sizeof(UserWidgetMapTransition_SetIconsVisibility) == 0x000001, "Wrong size on UserWidgetMapTransition_SetIconsVisibility");
static_assert(offsetof(UserWidgetMapTransition_SetIconsVisibility, bVisible) == 0x000000, "Member 'UserWidgetMapTransition_SetIconsVisibility::bVisible' has a wrong offset!");

// Function Zion.UserWidgetMapTransition.SetScale
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetMapTransition_SetScale final
{
public:
	float                                         NewScale;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapTransition_SetScale) == 0x000004, "Wrong alignment on UserWidgetMapTransition_SetScale");
static_assert(sizeof(UserWidgetMapTransition_SetScale) == 0x000004, "Wrong size on UserWidgetMapTransition_SetScale");
static_assert(offsetof(UserWidgetMapTransition_SetScale, NewScale) == 0x000000, "Member 'UserWidgetMapTransition_SetScale::NewScale' has a wrong offset!");

// Function Zion.ComboBoxStringZion.AddOptions
// 0x0010 (0x0010 - 0x0000)
struct ComboBoxStringZion_AddOptions final
{
public:
	TArray<class FString>                         OptionsToAdd;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboBoxStringZion_AddOptions) == 0x000008, "Wrong alignment on ComboBoxStringZion_AddOptions");
static_assert(sizeof(ComboBoxStringZion_AddOptions) == 0x000010, "Wrong size on ComboBoxStringZion_AddOptions");
static_assert(offsetof(ComboBoxStringZion_AddOptions, OptionsToAdd) == 0x000000, "Member 'ComboBoxStringZion_AddOptions::OptionsToAdd' has a wrong offset!");

// Function Zion.CommandComponent.AddCommands
// 0x0020 (0x0020 - 0x0000)
struct CommandComponent_AddCommands final
{
public:
	TArray<struct FCommandSettings>               CommandSettingsArray;                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	const class UCommandSet*                      OverrideCommandSet;                                // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CommandComponent_AddCommands) == 0x000008, "Wrong alignment on CommandComponent_AddCommands");
static_assert(sizeof(CommandComponent_AddCommands) == 0x000020, "Wrong size on CommandComponent_AddCommands");
static_assert(offsetof(CommandComponent_AddCommands, CommandSettingsArray) == 0x000000, "Member 'CommandComponent_AddCommands::CommandSettingsArray' has a wrong offset!");
static_assert(offsetof(CommandComponent_AddCommands, OverrideCommandSet) == 0x000010, "Member 'CommandComponent_AddCommands::OverrideCommandSet' has a wrong offset!");
static_assert(offsetof(CommandComponent_AddCommands, ReturnValue) == 0x000018, "Member 'CommandComponent_AddCommands::ReturnValue' has a wrong offset!");

// Function Zion.CommandComponent.AddCommandsFromClasses
// 0x0028 (0x0028 - 0x0000)
struct CommandComponent_AddCommandsFromClasses final
{
public:
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	const class UInputAction*                     InvokedByInputAction;                              // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommandLayerType                             CommandLayerType;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveOnStartFailure;                             // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	const class UCommandSet*                      OverrideCommandSet;                                // 0x0020(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandComponent_AddCommandsFromClasses) == 0x000008, "Wrong alignment on CommandComponent_AddCommandsFromClasses");
static_assert(sizeof(CommandComponent_AddCommandsFromClasses) == 0x000028, "Wrong size on CommandComponent_AddCommandsFromClasses");
static_assert(offsetof(CommandComponent_AddCommandsFromClasses, CommandClasses) == 0x000000, "Member 'CommandComponent_AddCommandsFromClasses::CommandClasses' has a wrong offset!");
static_assert(offsetof(CommandComponent_AddCommandsFromClasses, InvokedByInputAction) == 0x000010, "Member 'CommandComponent_AddCommandsFromClasses::InvokedByInputAction' has a wrong offset!");
static_assert(offsetof(CommandComponent_AddCommandsFromClasses, CommandLayerType) == 0x000018, "Member 'CommandComponent_AddCommandsFromClasses::CommandLayerType' has a wrong offset!");
static_assert(offsetof(CommandComponent_AddCommandsFromClasses, bRemoveOnStartFailure) == 0x000019, "Member 'CommandComponent_AddCommandsFromClasses::bRemoveOnStartFailure' has a wrong offset!");
static_assert(offsetof(CommandComponent_AddCommandsFromClasses, OverrideCommandSet) == 0x000020, "Member 'CommandComponent_AddCommandsFromClasses::OverrideCommandSet' has a wrong offset!");

// Function Zion.CommandComponent.AddCommandsToVirtualBufferFromClasses
// 0x0020 (0x0020 - 0x0000)
struct CommandComponent_AddCommandsToVirtualBufferFromClasses final
{
public:
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	const class UInputAction*                     InvokedByInputAction;                              // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommandLayerType                             CommandLayerType;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BufferTTL;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandComponent_AddCommandsToVirtualBufferFromClasses) == 0x000008, "Wrong alignment on CommandComponent_AddCommandsToVirtualBufferFromClasses");
static_assert(sizeof(CommandComponent_AddCommandsToVirtualBufferFromClasses) == 0x000020, "Wrong size on CommandComponent_AddCommandsToVirtualBufferFromClasses");
static_assert(offsetof(CommandComponent_AddCommandsToVirtualBufferFromClasses, CommandClasses) == 0x000000, "Member 'CommandComponent_AddCommandsToVirtualBufferFromClasses::CommandClasses' has a wrong offset!");
static_assert(offsetof(CommandComponent_AddCommandsToVirtualBufferFromClasses, InvokedByInputAction) == 0x000010, "Member 'CommandComponent_AddCommandsToVirtualBufferFromClasses::InvokedByInputAction' has a wrong offset!");
static_assert(offsetof(CommandComponent_AddCommandsToVirtualBufferFromClasses, CommandLayerType) == 0x000018, "Member 'CommandComponent_AddCommandsToVirtualBufferFromClasses::CommandLayerType' has a wrong offset!");
static_assert(offsetof(CommandComponent_AddCommandsToVirtualBufferFromClasses, BufferTTL) == 0x00001C, "Member 'CommandComponent_AddCommandsToVirtualBufferFromClasses::BufferTTL' has a wrong offset!");

// Function Zion.CommandComponent.ClearCommands
// 0x0001 (0x0001 - 0x0000)
struct CommandComponent_ClearCommands final
{
public:
	bool                                          bStopCurrentCommand;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandComponent_ClearCommands) == 0x000001, "Wrong alignment on CommandComponent_ClearCommands");
static_assert(sizeof(CommandComponent_ClearCommands) == 0x000001, "Wrong size on CommandComponent_ClearCommands");
static_assert(offsetof(CommandComponent_ClearCommands, bStopCurrentCommand) == 0x000000, "Member 'CommandComponent_ClearCommands::bStopCurrentCommand' has a wrong offset!");

// Function Zion.CommandComponent.OnMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct CommandComponent_OnMovementModeChanged final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CommandComponent_OnMovementModeChanged) == 0x000008, "Wrong alignment on CommandComponent_OnMovementModeChanged");
static_assert(sizeof(CommandComponent_OnMovementModeChanged) == 0x000010, "Wrong size on CommandComponent_OnMovementModeChanged");
static_assert(offsetof(CommandComponent_OnMovementModeChanged, Character) == 0x000000, "Member 'CommandComponent_OnMovementModeChanged::Character' has a wrong offset!");
static_assert(offsetof(CommandComponent_OnMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'CommandComponent_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(CommandComponent_OnMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'CommandComponent_OnMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function Zion.CommandComponent.ResetFallingExecutionCountsOfCategories
// 0x0010 (0x0010 - 0x0000)
struct CommandComponent_ResetFallingExecutionCountsOfCategories final
{
public:
	TArray<ECommandCategory>                      CategoriesToReset;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandComponent_ResetFallingExecutionCountsOfCategories) == 0x000008, "Wrong alignment on CommandComponent_ResetFallingExecutionCountsOfCategories");
static_assert(sizeof(CommandComponent_ResetFallingExecutionCountsOfCategories) == 0x000010, "Wrong size on CommandComponent_ResetFallingExecutionCountsOfCategories");
static_assert(offsetof(CommandComponent_ResetFallingExecutionCountsOfCategories, CategoriesToReset) == 0x000000, "Member 'CommandComponent_ResetFallingExecutionCountsOfCategories::CategoriesToReset' has a wrong offset!");

// Function Zion.CommandComponent.GetCooldownForCommandSet
// 0x0010 (0x0010 - 0x0000)
struct CommandComponent_GetCooldownForCommandSet final
{
public:
	const class UCommandSet*                      CommandSet;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CommandComponent_GetCooldownForCommandSet) == 0x000008, "Wrong alignment on CommandComponent_GetCooldownForCommandSet");
static_assert(sizeof(CommandComponent_GetCooldownForCommandSet) == 0x000010, "Wrong size on CommandComponent_GetCooldownForCommandSet");
static_assert(offsetof(CommandComponent_GetCooldownForCommandSet, CommandSet) == 0x000000, "Member 'CommandComponent_GetCooldownForCommandSet::CommandSet' has a wrong offset!");
static_assert(offsetof(CommandComponent_GetCooldownForCommandSet, ReturnValue) == 0x000008, "Member 'CommandComponent_GetCooldownForCommandSet::ReturnValue' has a wrong offset!");

// Function Zion.CommandComponent.GetCooldownRatioForCommandSet
// 0x0010 (0x0010 - 0x0000)
struct CommandComponent_GetCooldownRatioForCommandSet final
{
public:
	const class UCommandSet*                      CommandSet;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CommandComponent_GetCooldownRatioForCommandSet) == 0x000008, "Wrong alignment on CommandComponent_GetCooldownRatioForCommandSet");
static_assert(sizeof(CommandComponent_GetCooldownRatioForCommandSet) == 0x000010, "Wrong size on CommandComponent_GetCooldownRatioForCommandSet");
static_assert(offsetof(CommandComponent_GetCooldownRatioForCommandSet, CommandSet) == 0x000000, "Member 'CommandComponent_GetCooldownRatioForCommandSet::CommandSet' has a wrong offset!");
static_assert(offsetof(CommandComponent_GetCooldownRatioForCommandSet, ReturnValue) == 0x000008, "Member 'CommandComponent_GetCooldownRatioForCommandSet::ReturnValue' has a wrong offset!");

// Function Zion.CommandComponent.HasCommand
// 0x0001 (0x0001 - 0x0000)
struct CommandComponent_HasCommand final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommandComponent_HasCommand) == 0x000001, "Wrong alignment on CommandComponent_HasCommand");
static_assert(sizeof(CommandComponent_HasCommand) == 0x000001, "Wrong size on CommandComponent_HasCommand");
static_assert(offsetof(CommandComponent_HasCommand, ReturnValue) == 0x000000, "Member 'CommandComponent_HasCommand::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetWorldSpaceText.SetText
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetWorldSpaceText_SetText final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetWorldSpaceText_SetText) == 0x000008, "Wrong alignment on UserWidgetWorldSpaceText_SetText");
static_assert(sizeof(UserWidgetWorldSpaceText_SetText) == 0x000010, "Wrong size on UserWidgetWorldSpaceText_SetText");
static_assert(offsetof(UserWidgetWorldSpaceText_SetText, Text) == 0x000000, "Member 'UserWidgetWorldSpaceText_SetText::Text' has a wrong offset!");

// Function Zion.UserWidgetWorldSpaceText_Interact.SetAvailable
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetWorldSpaceText_Interact_SetAvailable final
{
public:
	bool                                          bAvailable;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetWorldSpaceText_Interact_SetAvailable) == 0x000001, "Wrong alignment on UserWidgetWorldSpaceText_Interact_SetAvailable");
static_assert(sizeof(UserWidgetWorldSpaceText_Interact_SetAvailable) == 0x000001, "Wrong size on UserWidgetWorldSpaceText_Interact_SetAvailable");
static_assert(offsetof(UserWidgetWorldSpaceText_Interact_SetAvailable, bAvailable) == 0x000000, "Member 'UserWidgetWorldSpaceText_Interact_SetAvailable::bAvailable' has a wrong offset!");

// Function Zion.UserWidgetRestPointListMapArea.GenerateRestPointListEntries
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetRestPointListMapArea_GenerateRestPointListEntries final
{
public:
	TArray<class UUserWidgetMapIcon_RestPoint*>   RestPointIcons;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointListMapArea_GenerateRestPointListEntries) == 0x000008, "Wrong alignment on UserWidgetRestPointListMapArea_GenerateRestPointListEntries");
static_assert(sizeof(UserWidgetRestPointListMapArea_GenerateRestPointListEntries) == 0x000010, "Wrong size on UserWidgetRestPointListMapArea_GenerateRestPointListEntries");
static_assert(offsetof(UserWidgetRestPointListMapArea_GenerateRestPointListEntries, RestPointIcons) == 0x000000, "Member 'UserWidgetRestPointListMapArea_GenerateRestPointListEntries::RestPointIcons' has a wrong offset!");

// Function Zion.UserWidgetRestPointListMapArea.RestPointEntryFocused
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetRestPointListMapArea_RestPointEntryFocused final
{
public:
	class UUserWidgetMapIcon_RestPoint*           RestPointIcon;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointListMapArea_RestPointEntryFocused) == 0x000008, "Wrong alignment on UserWidgetRestPointListMapArea_RestPointEntryFocused");
static_assert(sizeof(UserWidgetRestPointListMapArea_RestPointEntryFocused) == 0x000008, "Wrong size on UserWidgetRestPointListMapArea_RestPointEntryFocused");
static_assert(offsetof(UserWidgetRestPointListMapArea_RestPointEntryFocused, RestPointIcon) == 0x000000, "Member 'UserWidgetRestPointListMapArea_RestPointEntryFocused::RestPointIcon' has a wrong offset!");

// Function Zion.UserWidgetRestPointListMapArea.RestPointEntryPressed
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetRestPointListMapArea_RestPointEntryPressed final
{
public:
	struct FMapRestPointData                      RestPointData;                                     // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointListMapArea_RestPointEntryPressed) == 0x000004, "Wrong alignment on UserWidgetRestPointListMapArea_RestPointEntryPressed");
static_assert(sizeof(UserWidgetRestPointListMapArea_RestPointEntryPressed) == 0x000008, "Wrong size on UserWidgetRestPointListMapArea_RestPointEntryPressed");
static_assert(offsetof(UserWidgetRestPointListMapArea_RestPointEntryPressed, RestPointData) == 0x000000, "Member 'UserWidgetRestPointListMapArea_RestPointEntryPressed::RestPointData' has a wrong offset!");

// Function Zion.UserWidgetRestPointListMapArea.SetCompleted
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetRestPointListMapArea_SetCompleted final
{
public:
	bool                                          bIsCompleted;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointListMapArea_SetCompleted) == 0x000001, "Wrong alignment on UserWidgetRestPointListMapArea_SetCompleted");
static_assert(sizeof(UserWidgetRestPointListMapArea_SetCompleted) == 0x000001, "Wrong size on UserWidgetRestPointListMapArea_SetCompleted");
static_assert(offsetof(UserWidgetRestPointListMapArea_SetCompleted, bIsCompleted) == 0x000000, "Member 'UserWidgetRestPointListMapArea_SetCompleted::bIsCompleted' has a wrong offset!");

// Function Zion.UserWidgetRestPointListMapArea.SetMapAreaIndex
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetRestPointListMapArea_SetMapAreaIndex final
{
public:
	int32                                         NewMapAreaIndex;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointListMapArea_SetMapAreaIndex) == 0x000004, "Wrong alignment on UserWidgetRestPointListMapArea_SetMapAreaIndex");
static_assert(sizeof(UserWidgetRestPointListMapArea_SetMapAreaIndex) == 0x000004, "Wrong size on UserWidgetRestPointListMapArea_SetMapAreaIndex");
static_assert(offsetof(UserWidgetRestPointListMapArea_SetMapAreaIndex, NewMapAreaIndex) == 0x000000, "Member 'UserWidgetRestPointListMapArea_SetMapAreaIndex::NewMapAreaIndex' has a wrong offset!");

// Function Zion.UserWidgetRestPointListMapArea.SetMapAreaName
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetRestPointListMapArea_SetMapAreaName final
{
public:
	class FText                                   NewMapAreaName;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointListMapArea_SetMapAreaName) == 0x000008, "Wrong alignment on UserWidgetRestPointListMapArea_SetMapAreaName");
static_assert(sizeof(UserWidgetRestPointListMapArea_SetMapAreaName) == 0x000010, "Wrong size on UserWidgetRestPointListMapArea_SetMapAreaName");
static_assert(offsetof(UserWidgetRestPointListMapArea_SetMapAreaName, NewMapAreaName) == 0x000000, "Member 'UserWidgetRestPointListMapArea_SetMapAreaName::NewMapAreaName' has a wrong offset!");

// Function Zion.WaitGameUnpaused.WaitGameUnpaused
// 0x0010 (0x0010 - 0x0000)
struct WaitGameUnpaused_WaitGameUnpaused final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWaitGameUnpaused*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WaitGameUnpaused_WaitGameUnpaused) == 0x000008, "Wrong alignment on WaitGameUnpaused_WaitGameUnpaused");
static_assert(sizeof(WaitGameUnpaused_WaitGameUnpaused) == 0x000010, "Wrong size on WaitGameUnpaused_WaitGameUnpaused");
static_assert(offsetof(WaitGameUnpaused_WaitGameUnpaused, WorldContextObject) == 0x000000, "Member 'WaitGameUnpaused_WaitGameUnpaused::WorldContextObject' has a wrong offset!");
static_assert(offsetof(WaitGameUnpaused_WaitGameUnpaused, ReturnValue) == 0x000008, "Member 'WaitGameUnpaused_WaitGameUnpaused::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetWorldSpaceGauge.SetCurrentRatio
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetWorldSpaceGauge_SetCurrentRatio final
{
public:
	float                                         CurrentRatio;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetWorldSpaceGauge_SetCurrentRatio) == 0x000004, "Wrong alignment on UserWidgetWorldSpaceGauge_SetCurrentRatio");
static_assert(sizeof(UserWidgetWorldSpaceGauge_SetCurrentRatio) == 0x000004, "Wrong size on UserWidgetWorldSpaceGauge_SetCurrentRatio");
static_assert(offsetof(UserWidgetWorldSpaceGauge_SetCurrentRatio, CurrentRatio) == 0x000000, "Member 'UserWidgetWorldSpaceGauge_SetCurrentRatio::CurrentRatio' has a wrong offset!");

// Function Zion.UserWidgetWorldSpaceGauge.SetTargetActor
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetWorldSpaceGauge_SetTargetActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetWorldSpaceGauge_SetTargetActor) == 0x000008, "Wrong alignment on UserWidgetWorldSpaceGauge_SetTargetActor");
static_assert(sizeof(UserWidgetWorldSpaceGauge_SetTargetActor) == 0x000008, "Wrong size on UserWidgetWorldSpaceGauge_SetTargetActor");
static_assert(offsetof(UserWidgetWorldSpaceGauge_SetTargetActor, Actor) == 0x000000, "Member 'UserWidgetWorldSpaceGauge_SetTargetActor::Actor' has a wrong offset!");

// Function Zion.DeathComponent.IsDead
// 0x0001 (0x0001 - 0x0000)
struct DeathComponent_IsDead final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeathComponent_IsDead) == 0x000001, "Wrong alignment on DeathComponent_IsDead");
static_assert(sizeof(DeathComponent_IsDead) == 0x000001, "Wrong size on DeathComponent_IsDead");
static_assert(offsetof(DeathComponent_IsDead, ReturnValue) == 0x000000, "Member 'DeathComponent_IsDead::ReturnValue' has a wrong offset!");

// Function Zion.WallGrabComponent.OnMoveBlocked
// 0x00F8 (0x00F8 - 0x0000)
struct WallGrabComponent_OnMoveBlocked final
{
public:
	struct FHitResult                             Impact;                                            // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(WallGrabComponent_OnMoveBlocked) == 0x000008, "Wrong alignment on WallGrabComponent_OnMoveBlocked");
static_assert(sizeof(WallGrabComponent_OnMoveBlocked) == 0x0000F8, "Wrong size on WallGrabComponent_OnMoveBlocked");
static_assert(offsetof(WallGrabComponent_OnMoveBlocked, Impact) == 0x000000, "Member 'WallGrabComponent_OnMoveBlocked::Impact' has a wrong offset!");

// Function Zion.WallGrabComponent.OnMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct WallGrabComponent_OnMovementModeChanged final
{
public:
	class ACharacter*                             InCharacter;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WallGrabComponent_OnMovementModeChanged) == 0x000008, "Wrong alignment on WallGrabComponent_OnMovementModeChanged");
static_assert(sizeof(WallGrabComponent_OnMovementModeChanged) == 0x000010, "Wrong size on WallGrabComponent_OnMovementModeChanged");
static_assert(offsetof(WallGrabComponent_OnMovementModeChanged, InCharacter) == 0x000000, "Member 'WallGrabComponent_OnMovementModeChanged::InCharacter' has a wrong offset!");
static_assert(offsetof(WallGrabComponent_OnMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'WallGrabComponent_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(WallGrabComponent_OnMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'WallGrabComponent_OnMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function Zion.WallGrabComponent.OnStartAnimation
// 0x0008 (0x0008 - 0x0000)
struct WallGrabComponent_OnStartAnimation final
{
public:
	class UTrackEntry*                            TrackEntry;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WallGrabComponent_OnStartAnimation) == 0x000008, "Wrong alignment on WallGrabComponent_OnStartAnimation");
static_assert(sizeof(WallGrabComponent_OnStartAnimation) == 0x000008, "Wrong size on WallGrabComponent_OnStartAnimation");
static_assert(offsetof(WallGrabComponent_OnStartAnimation, TrackEntry) == 0x000000, "Member 'WallGrabComponent_OnStartAnimation::TrackEntry' has a wrong offset!");

// Function Zion.WallGrabComponent.IsGrabbingWall
// 0x0001 (0x0001 - 0x0000)
struct WallGrabComponent_IsGrabbingWall final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WallGrabComponent_IsGrabbingWall) == 0x000001, "Wrong alignment on WallGrabComponent_IsGrabbingWall");
static_assert(sizeof(WallGrabComponent_IsGrabbingWall) == 0x000001, "Wrong size on WallGrabComponent_IsGrabbingWall");
static_assert(offsetof(WallGrabComponent_IsGrabbingWall, ReturnValue) == 0x000000, "Member 'WallGrabComponent_IsGrabbingWall::ReturnValue' has a wrong offset!");

// Function Zion.WallGrabComponent.IsWallOnRight
// 0x0001 (0x0001 - 0x0000)
struct WallGrabComponent_IsWallOnRight final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WallGrabComponent_IsWallOnRight) == 0x000001, "Wrong alignment on WallGrabComponent_IsWallOnRight");
static_assert(sizeof(WallGrabComponent_IsWallOnRight) == 0x000001, "Wrong size on WallGrabComponent_IsWallOnRight");
static_assert(offsetof(WallGrabComponent_IsWallOnRight, ReturnValue) == 0x000000, "Member 'WallGrabComponent_IsWallOnRight::ReturnValue' has a wrong offset!");

// Function Zion.CommandModule_Timeline_Move.OnMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct CommandModule_Timeline_Move_OnMovementModeChanged final
{
public:
	class ACharacter*                             InCharacter;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CommandModule_Timeline_Move_OnMovementModeChanged) == 0x000008, "Wrong alignment on CommandModule_Timeline_Move_OnMovementModeChanged");
static_assert(sizeof(CommandModule_Timeline_Move_OnMovementModeChanged) == 0x000010, "Wrong size on CommandModule_Timeline_Move_OnMovementModeChanged");
static_assert(offsetof(CommandModule_Timeline_Move_OnMovementModeChanged, InCharacter) == 0x000000, "Member 'CommandModule_Timeline_Move_OnMovementModeChanged::InCharacter' has a wrong offset!");
static_assert(offsetof(CommandModule_Timeline_Move_OnMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'CommandModule_Timeline_Move_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(CommandModule_Timeline_Move_OnMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'CommandModule_Timeline_Move_OnMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function Zion.Command_AI_WarpTo.OnAnimationStart
// 0x0008 (0x0008 - 0x0000)
struct Command_AI_WarpTo_OnAnimationStart final
{
public:
	class UTrackEntry*                            TrackEntry;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_AI_WarpTo_OnAnimationStart) == 0x000008, "Wrong alignment on Command_AI_WarpTo_OnAnimationStart");
static_assert(sizeof(Command_AI_WarpTo_OnAnimationStart) == 0x000008, "Wrong size on Command_AI_WarpTo_OnAnimationStart");
static_assert(offsetof(Command_AI_WarpTo_OnAnimationStart, TrackEntry) == 0x000000, "Member 'Command_AI_WarpTo_OnAnimationStart::TrackEntry' has a wrong offset!");

// Function Zion.Command_Hook.OnMoveBlocked
// 0x00F8 (0x00F8 - 0x0000)
struct Command_Hook_OnMoveBlocked final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_Hook_OnMoveBlocked) == 0x000008, "Wrong alignment on Command_Hook_OnMoveBlocked");
static_assert(sizeof(Command_Hook_OnMoveBlocked) == 0x0000F8, "Wrong size on Command_Hook_OnMoveBlocked");
static_assert(offsetof(Command_Hook_OnMoveBlocked, HitResult) == 0x000000, "Member 'Command_Hook_OnMoveBlocked::HitResult' has a wrong offset!");

// Function Zion.Command_Hook.OnMovementUpdated
// 0x0038 (0x0038 - 0x0000)
struct Command_Hook_OnMovementUpdated final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OldLocation;                                       // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OldVelocity;                                       // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_Hook_OnMovementUpdated) == 0x000008, "Wrong alignment on Command_Hook_OnMovementUpdated");
static_assert(sizeof(Command_Hook_OnMovementUpdated) == 0x000038, "Wrong size on Command_Hook_OnMovementUpdated");
static_assert(offsetof(Command_Hook_OnMovementUpdated, DeltaSeconds) == 0x000000, "Member 'Command_Hook_OnMovementUpdated::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(Command_Hook_OnMovementUpdated, OldLocation) == 0x000008, "Member 'Command_Hook_OnMovementUpdated::OldLocation' has a wrong offset!");
static_assert(offsetof(Command_Hook_OnMovementUpdated, OldVelocity) == 0x000020, "Member 'Command_Hook_OnMovementUpdated::OldVelocity' has a wrong offset!");

// Function Zion.Command_WallDash_Release.OnMoveBlocked
// 0x00F8 (0x00F8 - 0x0000)
struct Command_WallDash_Release_OnMoveBlocked final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Command_WallDash_Release_OnMoveBlocked) == 0x000008, "Wrong alignment on Command_WallDash_Release_OnMoveBlocked");
static_assert(sizeof(Command_WallDash_Release_OnMoveBlocked) == 0x0000F8, "Wrong size on Command_WallDash_Release_OnMoveBlocked");
static_assert(offsetof(Command_WallDash_Release_OnMoveBlocked, Hit) == 0x000000, "Member 'Command_WallDash_Release_OnMoveBlocked::Hit' has a wrong offset!");

// Function Zion.ConditionedTextureData.GetConditionedTextures
// 0x0010 (0x0010 - 0x0000)
struct ConditionedTextureData_GetConditionedTextures final
{
public:
	TArray<struct FConditionedTexture>            ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConditionedTextureData_GetConditionedTextures) == 0x000008, "Wrong alignment on ConditionedTextureData_GetConditionedTextures");
static_assert(sizeof(ConditionedTextureData_GetConditionedTextures) == 0x000010, "Wrong size on ConditionedTextureData_GetConditionedTextures");
static_assert(offsetof(ConditionedTextureData_GetConditionedTextures, ReturnValue) == 0x000000, "Member 'ConditionedTextureData_GetConditionedTextures::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.Get
// 0x0018 (0x0018 - 0x0000)
struct PlayerControllerZion_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerControllerZion*                  ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_Get) == 0x000008, "Wrong alignment on PlayerControllerZion_Get");
static_assert(sizeof(PlayerControllerZion_Get) == 0x000018, "Wrong size on PlayerControllerZion_Get");
static_assert(offsetof(PlayerControllerZion_Get, WorldContextObject) == 0x000000, "Member 'PlayerControllerZion_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_Get, PlayerIndex) == 0x000008, "Member 'PlayerControllerZion_Get::PlayerIndex' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_Get, ReturnValue) == 0x000010, "Member 'PlayerControllerZion_Get::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.AddRestEvent
// 0x0008 (0x0008 - 0x0000)
struct PlayerControllerZion_AddRestEvent final
{
public:
	class FName                                   RestEventID;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_AddRestEvent) == 0x000004, "Wrong alignment on PlayerControllerZion_AddRestEvent");
static_assert(sizeof(PlayerControllerZion_AddRestEvent) == 0x000008, "Wrong size on PlayerControllerZion_AddRestEvent");
static_assert(offsetof(PlayerControllerZion_AddRestEvent, RestEventID) == 0x000000, "Member 'PlayerControllerZion_AddRestEvent::RestEventID' has a wrong offset!");

// Function Zion.PlayerControllerZion.DBG_SetRestEventAvailable
// 0x000C (0x000C - 0x0000)
struct PlayerControllerZion_DBG_SetRestEventAvailable final
{
public:
	class FName                                   RestEventID;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailable;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerControllerZion_DBG_SetRestEventAvailable) == 0x000004, "Wrong alignment on PlayerControllerZion_DBG_SetRestEventAvailable");
static_assert(sizeof(PlayerControllerZion_DBG_SetRestEventAvailable) == 0x00000C, "Wrong size on PlayerControllerZion_DBG_SetRestEventAvailable");
static_assert(offsetof(PlayerControllerZion_DBG_SetRestEventAvailable, RestEventID) == 0x000000, "Member 'PlayerControllerZion_DBG_SetRestEventAvailable::RestEventID' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_DBG_SetRestEventAvailable, bAvailable) == 0x000008, "Member 'PlayerControllerZion_DBG_SetRestEventAvailable::bAvailable' has a wrong offset!");

// Function Zion.PlayerControllerZion.DebugMarkEventAsCleared
// 0x000C (0x000C - 0x0000)
struct PlayerControllerZion_DebugMarkEventAsCleared final
{
public:
	class FName                                   EventId;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCleared;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerControllerZion_DebugMarkEventAsCleared) == 0x000004, "Wrong alignment on PlayerControllerZion_DebugMarkEventAsCleared");
static_assert(sizeof(PlayerControllerZion_DebugMarkEventAsCleared) == 0x00000C, "Wrong size on PlayerControllerZion_DebugMarkEventAsCleared");
static_assert(offsetof(PlayerControllerZion_DebugMarkEventAsCleared, EventId) == 0x000000, "Member 'PlayerControllerZion_DebugMarkEventAsCleared::EventId' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_DebugMarkEventAsCleared, bCleared) == 0x000008, "Member 'PlayerControllerZion_DebugMarkEventAsCleared::bCleared' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_DebugMarkEventAsCleared, ReturnValue) == 0x000009, "Member 'PlayerControllerZion_DebugMarkEventAsCleared::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.DisplayAreaName
// 0x0008 (0x0008 - 0x0000)
struct PlayerControllerZion_DisplayAreaName final
{
public:
	class FName                                   AreaName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_DisplayAreaName) == 0x000004, "Wrong alignment on PlayerControllerZion_DisplayAreaName");
static_assert(sizeof(PlayerControllerZion_DisplayAreaName) == 0x000008, "Wrong size on PlayerControllerZion_DisplayAreaName");
static_assert(offsetof(PlayerControllerZion_DisplayAreaName, AreaName) == 0x000000, "Member 'PlayerControllerZion_DisplayAreaName::AreaName' has a wrong offset!");

// Function Zion.PlayerControllerZion.GetAvailableRestEvent
// 0x00A8 (0x00A8 - 0x0000)
struct PlayerControllerZion_GetAvailableRestEvent final
{
public:
	struct FDataTableRowHandle                    out_RestPointEventRowHandle;                       // 0x0000(0x0010)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FRestPointEventData                    out_RestPointEventData;                            // 0x0010(0x0090)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerControllerZion_GetAvailableRestEvent) == 0x000008, "Wrong alignment on PlayerControllerZion_GetAvailableRestEvent");
static_assert(sizeof(PlayerControllerZion_GetAvailableRestEvent) == 0x0000A8, "Wrong size on PlayerControllerZion_GetAvailableRestEvent");
static_assert(offsetof(PlayerControllerZion_GetAvailableRestEvent, out_RestPointEventRowHandle) == 0x000000, "Member 'PlayerControllerZion_GetAvailableRestEvent::out_RestPointEventRowHandle' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_GetAvailableRestEvent, out_RestPointEventData) == 0x000010, "Member 'PlayerControllerZion_GetAvailableRestEvent::out_RestPointEventData' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_GetAvailableRestEvent, ReturnValue) == 0x0000A0, "Member 'PlayerControllerZion_GetAvailableRestEvent::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.HidePlayerUI
// 0x0001 (0x0001 - 0x0000)
struct PlayerControllerZion_HidePlayerUI final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_HidePlayerUI) == 0x000001, "Wrong alignment on PlayerControllerZion_HidePlayerUI");
static_assert(sizeof(PlayerControllerZion_HidePlayerUI) == 0x000001, "Wrong size on PlayerControllerZion_HidePlayerUI");
static_assert(offsetof(PlayerControllerZion_HidePlayerUI, bInstant) == 0x000000, "Member 'PlayerControllerZion_HidePlayerUI::bInstant' has a wrong offset!");

// Function Zion.PlayerControllerZion.LaunchTutorialHook
// 0x0001 (0x0001 - 0x0000)
struct PlayerControllerZion_LaunchTutorialHook final
{
public:
	ETutorialHook                                 TutorialHook;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_LaunchTutorialHook) == 0x000001, "Wrong alignment on PlayerControllerZion_LaunchTutorialHook");
static_assert(sizeof(PlayerControllerZion_LaunchTutorialHook) == 0x000001, "Wrong size on PlayerControllerZion_LaunchTutorialHook");
static_assert(offsetof(PlayerControllerZion_LaunchTutorialHook, TutorialHook) == 0x000000, "Member 'PlayerControllerZion_LaunchTutorialHook::TutorialHook' has a wrong offset!");

// Function Zion.PlayerControllerZion.MarkEnemyAsKilled
// 0x0010 (0x0010 - 0x0000)
struct PlayerControllerZion_MarkEnemyAsKilled final
{
public:
	struct FDataTableRowHandle                    EnemyDataHandle;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_MarkEnemyAsKilled) == 0x000008, "Wrong alignment on PlayerControllerZion_MarkEnemyAsKilled");
static_assert(sizeof(PlayerControllerZion_MarkEnemyAsKilled) == 0x000010, "Wrong size on PlayerControllerZion_MarkEnemyAsKilled");
static_assert(offsetof(PlayerControllerZion_MarkEnemyAsKilled, EnemyDataHandle) == 0x000000, "Member 'PlayerControllerZion_MarkEnemyAsKilled::EnemyDataHandle' has a wrong offset!");

// Function Zion.PlayerControllerZion.MarkEventAsCleared
// 0x0008 (0x0008 - 0x0000)
struct PlayerControllerZion_MarkEventAsCleared final
{
public:
	const class UEventAsset*                      EventAsset;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_MarkEventAsCleared) == 0x000008, "Wrong alignment on PlayerControllerZion_MarkEventAsCleared");
static_assert(sizeof(PlayerControllerZion_MarkEventAsCleared) == 0x000008, "Wrong size on PlayerControllerZion_MarkEventAsCleared");
static_assert(offsetof(PlayerControllerZion_MarkEventAsCleared, EventAsset) == 0x000000, "Member 'PlayerControllerZion_MarkEventAsCleared::EventAsset' has a wrong offset!");

// Function Zion.PlayerControllerZion.MarkExtraEnemyInfoAsAvailable
// 0x0010 (0x0010 - 0x0000)
struct PlayerControllerZion_MarkExtraEnemyInfoAsAvailable final
{
public:
	struct FDataTableRowHandle                    ExtraEnemyInfoItem;                                // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_MarkExtraEnemyInfoAsAvailable) == 0x000008, "Wrong alignment on PlayerControllerZion_MarkExtraEnemyInfoAsAvailable");
static_assert(sizeof(PlayerControllerZion_MarkExtraEnemyInfoAsAvailable) == 0x000010, "Wrong size on PlayerControllerZion_MarkExtraEnemyInfoAsAvailable");
static_assert(offsetof(PlayerControllerZion_MarkExtraEnemyInfoAsAvailable, ExtraEnemyInfoItem) == 0x000000, "Member 'PlayerControllerZion_MarkExtraEnemyInfoAsAvailable::ExtraEnemyInfoItem' has a wrong offset!");

// Function Zion.PlayerControllerZion.MarkRecollectionItemAsChecked
// 0x0010 (0x0010 - 0x0000)
struct PlayerControllerZion_MarkRecollectionItemAsChecked final
{
public:
	struct FDataTableRowHandle                    RecollectionItem;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_MarkRecollectionItemAsChecked) == 0x000008, "Wrong alignment on PlayerControllerZion_MarkRecollectionItemAsChecked");
static_assert(sizeof(PlayerControllerZion_MarkRecollectionItemAsChecked) == 0x000010, "Wrong size on PlayerControllerZion_MarkRecollectionItemAsChecked");
static_assert(offsetof(PlayerControllerZion_MarkRecollectionItemAsChecked, RecollectionItem) == 0x000000, "Member 'PlayerControllerZion_MarkRecollectionItemAsChecked::RecollectionItem' has a wrong offset!");

// Function Zion.PlayerControllerZion.MarkRestEventAsSeen
// 0x0008 (0x0008 - 0x0000)
struct PlayerControllerZion_MarkRestEventAsSeen final
{
public:
	class FName                                   RestEventID;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_MarkRestEventAsSeen) == 0x000004, "Wrong alignment on PlayerControllerZion_MarkRestEventAsSeen");
static_assert(sizeof(PlayerControllerZion_MarkRestEventAsSeen) == 0x000008, "Wrong size on PlayerControllerZion_MarkRestEventAsSeen");
static_assert(offsetof(PlayerControllerZion_MarkRestEventAsSeen, RestEventID) == 0x000000, "Member 'PlayerControllerZion_MarkRestEventAsSeen::RestEventID' has a wrong offset!");

// Function Zion.PlayerControllerZion.OnAchievementUnlocked
// 0x0008 (0x0008 - 0x0000)
struct PlayerControllerZion_OnAchievementUnlocked final
{
public:
	class FName                                   AchievementID;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_OnAchievementUnlocked) == 0x000004, "Wrong alignment on PlayerControllerZion_OnAchievementUnlocked");
static_assert(sizeof(PlayerControllerZion_OnAchievementUnlocked) == 0x000008, "Wrong size on PlayerControllerZion_OnAchievementUnlocked");
static_assert(offsetof(PlayerControllerZion_OnAchievementUnlocked, AchievementID) == 0x000000, "Member 'PlayerControllerZion_OnAchievementUnlocked::AchievementID' has a wrong offset!");

// Function Zion.PlayerControllerZion.OnDisplayAreaName
// 0x0008 (0x0008 - 0x0000)
struct PlayerControllerZion_OnDisplayAreaName final
{
public:
	class FName                                   AreaName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_OnDisplayAreaName) == 0x000004, "Wrong alignment on PlayerControllerZion_OnDisplayAreaName");
static_assert(sizeof(PlayerControllerZion_OnDisplayAreaName) == 0x000008, "Wrong size on PlayerControllerZion_OnDisplayAreaName");
static_assert(offsetof(PlayerControllerZion_OnDisplayAreaName, AreaName) == 0x000000, "Member 'PlayerControllerZion_OnDisplayAreaName::AreaName' has a wrong offset!");

// Function Zion.PlayerControllerZion.OnGameMapChangeFinished
// 0x0008 (0x0008 - 0x0000)
struct PlayerControllerZion_OnGameMapChangeFinished final
{
public:
	class FName                                   GameMapID;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_OnGameMapChangeFinished) == 0x000004, "Wrong alignment on PlayerControllerZion_OnGameMapChangeFinished");
static_assert(sizeof(PlayerControllerZion_OnGameMapChangeFinished) == 0x000008, "Wrong size on PlayerControllerZion_OnGameMapChangeFinished");
static_assert(offsetof(PlayerControllerZion_OnGameMapChangeFinished, GameMapID) == 0x000000, "Member 'PlayerControllerZion_OnGameMapChangeFinished::GameMapID' has a wrong offset!");

// Function Zion.PlayerControllerZion.OnRequestTutorials
// 0x0010 (0x0010 - 0x0000)
struct PlayerControllerZion_OnRequestTutorials final
{
public:
	TArray<class FName>                           TutorialIDs;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_OnRequestTutorials) == 0x000008, "Wrong alignment on PlayerControllerZion_OnRequestTutorials");
static_assert(sizeof(PlayerControllerZion_OnRequestTutorials) == 0x000010, "Wrong size on PlayerControllerZion_OnRequestTutorials");
static_assert(offsetof(PlayerControllerZion_OnRequestTutorials, TutorialIDs) == 0x000000, "Member 'PlayerControllerZion_OnRequestTutorials::TutorialIDs' has a wrong offset!");

// Function Zion.PlayerControllerZion.OnRespawnCompleted
// 0x0001 (0x0001 - 0x0000)
struct PlayerControllerZion_OnRespawnCompleted final
{
public:
	ERespawnReason                                RespawnReason;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_OnRespawnCompleted) == 0x000001, "Wrong alignment on PlayerControllerZion_OnRespawnCompleted");
static_assert(sizeof(PlayerControllerZion_OnRespawnCompleted) == 0x000001, "Wrong size on PlayerControllerZion_OnRespawnCompleted");
static_assert(offsetof(PlayerControllerZion_OnRespawnCompleted, RespawnReason) == 0x000000, "Member 'PlayerControllerZion_OnRespawnCompleted::RespawnReason' has a wrong offset!");

// Function Zion.PlayerControllerZion.SetMinimapDisplayMode
// 0x0002 (0x0002 - 0x0000)
struct PlayerControllerZion_SetMinimapDisplayMode final
{
public:
	EWidgetMinimapDisplayMode                     NewMinimapDisplayMode;                             // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWidgetMinimapDisplayMode                     ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_SetMinimapDisplayMode) == 0x000001, "Wrong alignment on PlayerControllerZion_SetMinimapDisplayMode");
static_assert(sizeof(PlayerControllerZion_SetMinimapDisplayMode) == 0x000002, "Wrong size on PlayerControllerZion_SetMinimapDisplayMode");
static_assert(offsetof(PlayerControllerZion_SetMinimapDisplayMode, NewMinimapDisplayMode) == 0x000000, "Member 'PlayerControllerZion_SetMinimapDisplayMode::NewMinimapDisplayMode' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_SetMinimapDisplayMode, ReturnValue) == 0x000001, "Member 'PlayerControllerZion_SetMinimapDisplayMode::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.SetRespawnRestPoint
// 0x0008 (0x0008 - 0x0000)
struct PlayerControllerZion_SetRespawnRestPoint final
{
public:
	class FName                                   InRespawnRestPointID;                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_SetRespawnRestPoint) == 0x000004, "Wrong alignment on PlayerControllerZion_SetRespawnRestPoint");
static_assert(sizeof(PlayerControllerZion_SetRespawnRestPoint) == 0x000008, "Wrong size on PlayerControllerZion_SetRespawnRestPoint");
static_assert(offsetof(PlayerControllerZion_SetRespawnRestPoint, InRespawnRestPointID) == 0x000000, "Member 'PlayerControllerZion_SetRespawnRestPoint::InRespawnRestPointID' has a wrong offset!");

// Function Zion.PlayerControllerZion.SetRuntimeCheckpointData
// 0x0030 (0x0030 - 0x0000)
struct PlayerControllerZion_SetRuntimeCheckpointData final
{
public:
	struct FRuntimeCheckpointData                 NewRuntimeCheckpointData;                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FRuntimeCheckpointData                 ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_SetRuntimeCheckpointData) == 0x000008, "Wrong alignment on PlayerControllerZion_SetRuntimeCheckpointData");
static_assert(sizeof(PlayerControllerZion_SetRuntimeCheckpointData) == 0x000030, "Wrong size on PlayerControllerZion_SetRuntimeCheckpointData");
static_assert(offsetof(PlayerControllerZion_SetRuntimeCheckpointData, NewRuntimeCheckpointData) == 0x000000, "Member 'PlayerControllerZion_SetRuntimeCheckpointData::NewRuntimeCheckpointData' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_SetRuntimeCheckpointData, ReturnValue) == 0x000018, "Member 'PlayerControllerZion_SetRuntimeCheckpointData::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.GetMinimapDisplayMode
// 0x0001 (0x0001 - 0x0000)
struct PlayerControllerZion_GetMinimapDisplayMode final
{
public:
	EWidgetMinimapDisplayMode                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_GetMinimapDisplayMode) == 0x000001, "Wrong alignment on PlayerControllerZion_GetMinimapDisplayMode");
static_assert(sizeof(PlayerControllerZion_GetMinimapDisplayMode) == 0x000001, "Wrong size on PlayerControllerZion_GetMinimapDisplayMode");
static_assert(offsetof(PlayerControllerZion_GetMinimapDisplayMode, ReturnValue) == 0x000000, "Member 'PlayerControllerZion_GetMinimapDisplayMode::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.GetPlayerUI
// 0x0008 (0x0008 - 0x0000)
struct PlayerControllerZion_GetPlayerUI final
{
public:
	class UUserWidgetPlayerUI*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_GetPlayerUI) == 0x000008, "Wrong alignment on PlayerControllerZion_GetPlayerUI");
static_assert(sizeof(PlayerControllerZion_GetPlayerUI) == 0x000008, "Wrong size on PlayerControllerZion_GetPlayerUI");
static_assert(offsetof(PlayerControllerZion_GetPlayerUI, ReturnValue) == 0x000000, "Member 'PlayerControllerZion_GetPlayerUI::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.GetRespawnRestPointID
// 0x0008 (0x0008 - 0x0000)
struct PlayerControllerZion_GetRespawnRestPointID final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_GetRespawnRestPointID) == 0x000004, "Wrong alignment on PlayerControllerZion_GetRespawnRestPointID");
static_assert(sizeof(PlayerControllerZion_GetRespawnRestPointID) == 0x000008, "Wrong size on PlayerControllerZion_GetRespawnRestPointID");
static_assert(offsetof(PlayerControllerZion_GetRespawnRestPointID, ReturnValue) == 0x000000, "Member 'PlayerControllerZion_GetRespawnRestPointID::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.GetRuntimeCheckpointData
// 0x0018 (0x0018 - 0x0000)
struct PlayerControllerZion_GetRuntimeCheckpointData final
{
public:
	struct FRuntimeCheckpointData                 ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_GetRuntimeCheckpointData) == 0x000008, "Wrong alignment on PlayerControllerZion_GetRuntimeCheckpointData");
static_assert(sizeof(PlayerControllerZion_GetRuntimeCheckpointData) == 0x000018, "Wrong size on PlayerControllerZion_GetRuntimeCheckpointData");
static_assert(offsetof(PlayerControllerZion_GetRuntimeCheckpointData, ReturnValue) == 0x000000, "Member 'PlayerControllerZion_GetRuntimeCheckpointData::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.GetWidgetMap
// 0x0008 (0x0008 - 0x0000)
struct PlayerControllerZion_GetWidgetMap final
{
public:
	class UUserWidgetMap*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_GetWidgetMap) == 0x000008, "Wrong alignment on PlayerControllerZion_GetWidgetMap");
static_assert(sizeof(PlayerControllerZion_GetWidgetMap) == 0x000008, "Wrong size on PlayerControllerZion_GetWidgetMap");
static_assert(offsetof(PlayerControllerZion_GetWidgetMap, ReturnValue) == 0x000000, "Member 'PlayerControllerZion_GetWidgetMap::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.HasAvailableRestEvent
// 0x0001 (0x0001 - 0x0000)
struct PlayerControllerZion_HasAvailableRestEvent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_HasAvailableRestEvent) == 0x000001, "Wrong alignment on PlayerControllerZion_HasAvailableRestEvent");
static_assert(sizeof(PlayerControllerZion_HasAvailableRestEvent) == 0x000001, "Wrong size on PlayerControllerZion_HasAvailableRestEvent");
static_assert(offsetof(PlayerControllerZion_HasAvailableRestEvent, ReturnValue) == 0x000000, "Member 'PlayerControllerZion_HasAvailableRestEvent::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.IsAreaNameDisplayed
// 0x000C (0x000C - 0x0000)
struct PlayerControllerZion_IsAreaNameDisplayed final
{
public:
	class FName                                   AreaName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerControllerZion_IsAreaNameDisplayed) == 0x000004, "Wrong alignment on PlayerControllerZion_IsAreaNameDisplayed");
static_assert(sizeof(PlayerControllerZion_IsAreaNameDisplayed) == 0x00000C, "Wrong size on PlayerControllerZion_IsAreaNameDisplayed");
static_assert(offsetof(PlayerControllerZion_IsAreaNameDisplayed, AreaName) == 0x000000, "Member 'PlayerControllerZion_IsAreaNameDisplayed::AreaName' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_IsAreaNameDisplayed, ReturnValue) == 0x000008, "Member 'PlayerControllerZion_IsAreaNameDisplayed::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.IsAreaVisited
// 0x000C (0x000C - 0x0000)
struct PlayerControllerZion_IsAreaVisited final
{
public:
	class FName                                   AreaName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerControllerZion_IsAreaVisited) == 0x000004, "Wrong alignment on PlayerControllerZion_IsAreaVisited");
static_assert(sizeof(PlayerControllerZion_IsAreaVisited) == 0x00000C, "Wrong size on PlayerControllerZion_IsAreaVisited");
static_assert(offsetof(PlayerControllerZion_IsAreaVisited, AreaName) == 0x000000, "Member 'PlayerControllerZion_IsAreaVisited::AreaName' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_IsAreaVisited, ReturnValue) == 0x000008, "Member 'PlayerControllerZion_IsAreaVisited::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.IsBackToRestPointLocked
// 0x0001 (0x0001 - 0x0000)
struct PlayerControllerZion_IsBackToRestPointLocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_IsBackToRestPointLocked) == 0x000001, "Wrong alignment on PlayerControllerZion_IsBackToRestPointLocked");
static_assert(sizeof(PlayerControllerZion_IsBackToRestPointLocked) == 0x000001, "Wrong size on PlayerControllerZion_IsBackToRestPointLocked");
static_assert(offsetof(PlayerControllerZion_IsBackToRestPointLocked, ReturnValue) == 0x000000, "Member 'PlayerControllerZion_IsBackToRestPointLocked::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.IsEnemyKilled
// 0x0018 (0x0018 - 0x0000)
struct PlayerControllerZion_IsEnemyKilled final
{
public:
	struct FDataTableRowHandle                    EnemyDataHandle;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerControllerZion_IsEnemyKilled) == 0x000008, "Wrong alignment on PlayerControllerZion_IsEnemyKilled");
static_assert(sizeof(PlayerControllerZion_IsEnemyKilled) == 0x000018, "Wrong size on PlayerControllerZion_IsEnemyKilled");
static_assert(offsetof(PlayerControllerZion_IsEnemyKilled, EnemyDataHandle) == 0x000000, "Member 'PlayerControllerZion_IsEnemyKilled::EnemyDataHandle' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_IsEnemyKilled, ReturnValue) == 0x000010, "Member 'PlayerControllerZion_IsEnemyKilled::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.IsEventCleared
// 0x000C (0x000C - 0x0000)
struct PlayerControllerZion_IsEventCleared final
{
public:
	class FName                                   EventId;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEventClearedCheckMode                        CheckMode;                                         // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerControllerZion_IsEventCleared) == 0x000004, "Wrong alignment on PlayerControllerZion_IsEventCleared");
static_assert(sizeof(PlayerControllerZion_IsEventCleared) == 0x00000C, "Wrong size on PlayerControllerZion_IsEventCleared");
static_assert(offsetof(PlayerControllerZion_IsEventCleared, EventId) == 0x000000, "Member 'PlayerControllerZion_IsEventCleared::EventId' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_IsEventCleared, CheckMode) == 0x000008, "Member 'PlayerControllerZion_IsEventCleared::CheckMode' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_IsEventCleared, ReturnValue) == 0x000009, "Member 'PlayerControllerZion_IsEventCleared::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.IsExtraEnemyInfoAvailable
// 0x0018 (0x0018 - 0x0000)
struct PlayerControllerZion_IsExtraEnemyInfoAvailable final
{
public:
	struct FDataTableRowHandle                    ExtraEnemyInfoItem;                                // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerControllerZion_IsExtraEnemyInfoAvailable) == 0x000008, "Wrong alignment on PlayerControllerZion_IsExtraEnemyInfoAvailable");
static_assert(sizeof(PlayerControllerZion_IsExtraEnemyInfoAvailable) == 0x000018, "Wrong size on PlayerControllerZion_IsExtraEnemyInfoAvailable");
static_assert(offsetof(PlayerControllerZion_IsExtraEnemyInfoAvailable, ExtraEnemyInfoItem) == 0x000000, "Member 'PlayerControllerZion_IsExtraEnemyInfoAvailable::ExtraEnemyInfoItem' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_IsExtraEnemyInfoAvailable, ReturnValue) == 0x000010, "Member 'PlayerControllerZion_IsExtraEnemyInfoAvailable::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.IsFastTravelLocked
// 0x0001 (0x0001 - 0x0000)
struct PlayerControllerZion_IsFastTravelLocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_IsFastTravelLocked) == 0x000001, "Wrong alignment on PlayerControllerZion_IsFastTravelLocked");
static_assert(sizeof(PlayerControllerZion_IsFastTravelLocked) == 0x000001, "Wrong size on PlayerControllerZion_IsFastTravelLocked");
static_assert(offsetof(PlayerControllerZion_IsFastTravelLocked, ReturnValue) == 0x000000, "Member 'PlayerControllerZion_IsFastTravelLocked::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.IsInEvent
// 0x0001 (0x0001 - 0x0000)
struct PlayerControllerZion_IsInEvent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerZion_IsInEvent) == 0x000001, "Wrong alignment on PlayerControllerZion_IsInEvent");
static_assert(sizeof(PlayerControllerZion_IsInEvent) == 0x000001, "Wrong size on PlayerControllerZion_IsInEvent");
static_assert(offsetof(PlayerControllerZion_IsInEvent, ReturnValue) == 0x000000, "Member 'PlayerControllerZion_IsInEvent::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.IsMapTransitionSpawnPointUsed
// 0x0014 (0x0014 - 0x0000)
struct PlayerControllerZion_IsMapTransitionSpawnPointUsed final
{
public:
	struct FMapTransitionSpawnPointData           MapTransitionSpawnPointData;                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerControllerZion_IsMapTransitionSpawnPointUsed) == 0x000004, "Wrong alignment on PlayerControllerZion_IsMapTransitionSpawnPointUsed");
static_assert(sizeof(PlayerControllerZion_IsMapTransitionSpawnPointUsed) == 0x000014, "Wrong size on PlayerControllerZion_IsMapTransitionSpawnPointUsed");
static_assert(offsetof(PlayerControllerZion_IsMapTransitionSpawnPointUsed, MapTransitionSpawnPointData) == 0x000000, "Member 'PlayerControllerZion_IsMapTransitionSpawnPointUsed::MapTransitionSpawnPointData' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_IsMapTransitionSpawnPointUsed, ReturnValue) == 0x000010, "Member 'PlayerControllerZion_IsMapTransitionSpawnPointUsed::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.IsRecollectionItemChecked
// 0x0018 (0x0018 - 0x0000)
struct PlayerControllerZion_IsRecollectionItemChecked final
{
public:
	struct FDataTableRowHandle                    RecollectionItem;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerControllerZion_IsRecollectionItemChecked) == 0x000008, "Wrong alignment on PlayerControllerZion_IsRecollectionItemChecked");
static_assert(sizeof(PlayerControllerZion_IsRecollectionItemChecked) == 0x000018, "Wrong size on PlayerControllerZion_IsRecollectionItemChecked");
static_assert(offsetof(PlayerControllerZion_IsRecollectionItemChecked, RecollectionItem) == 0x000000, "Member 'PlayerControllerZion_IsRecollectionItemChecked::RecollectionItem' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_IsRecollectionItemChecked, ReturnValue) == 0x000010, "Member 'PlayerControllerZion_IsRecollectionItemChecked::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.IsRestEventAvailable
// 0x000C (0x000C - 0x0000)
struct PlayerControllerZion_IsRestEventAvailable final
{
public:
	class FName                                   RestEventID;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerControllerZion_IsRestEventAvailable) == 0x000004, "Wrong alignment on PlayerControllerZion_IsRestEventAvailable");
static_assert(sizeof(PlayerControllerZion_IsRestEventAvailable) == 0x00000C, "Wrong size on PlayerControllerZion_IsRestEventAvailable");
static_assert(offsetof(PlayerControllerZion_IsRestEventAvailable, RestEventID) == 0x000000, "Member 'PlayerControllerZion_IsRestEventAvailable::RestEventID' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_IsRestEventAvailable, ReturnValue) == 0x000008, "Member 'PlayerControllerZion_IsRestEventAvailable::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.IsSoftEventCleared
// 0x0030 (0x0030 - 0x0000)
struct PlayerControllerZion_IsSoftEventCleared final
{
public:
	TSoftObjectPtr<class UEventAsset>             EventAsset;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerControllerZion_IsSoftEventCleared) == 0x000008, "Wrong alignment on PlayerControllerZion_IsSoftEventCleared");
static_assert(sizeof(PlayerControllerZion_IsSoftEventCleared) == 0x000030, "Wrong size on PlayerControllerZion_IsSoftEventCleared");
static_assert(offsetof(PlayerControllerZion_IsSoftEventCleared, EventAsset) == 0x000000, "Member 'PlayerControllerZion_IsSoftEventCleared::EventAsset' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_IsSoftEventCleared, ReturnValue) == 0x000028, "Member 'PlayerControllerZion_IsSoftEventCleared::ReturnValue' has a wrong offset!");

// Function Zion.PlayerControllerZion.IsZoneVisited
// 0x0014 (0x0014 - 0x0000)
struct PlayerControllerZion_IsZoneVisited final
{
public:
	struct FClearActorData                        ZoneActorData;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerControllerZion_IsZoneVisited) == 0x000004, "Wrong alignment on PlayerControllerZion_IsZoneVisited");
static_assert(sizeof(PlayerControllerZion_IsZoneVisited) == 0x000014, "Wrong size on PlayerControllerZion_IsZoneVisited");
static_assert(offsetof(PlayerControllerZion_IsZoneVisited, ZoneActorData) == 0x000000, "Member 'PlayerControllerZion_IsZoneVisited::ZoneActorData' has a wrong offset!");
static_assert(offsetof(PlayerControllerZion_IsZoneVisited, ReturnValue) == 0x000010, "Member 'PlayerControllerZion_IsZoneVisited::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetInventoryItemData
// 0x0180 (0x0180 - 0x0000)
struct DataTableBPFLibrary_GetInventoryItemData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryItemData                     out_ItemData;                                      // 0x0010(0x0168)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0178(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetInventoryItemData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetInventoryItemData");
static_assert(sizeof(DataTableBPFLibrary_GetInventoryItemData) == 0x000180, "Wrong size on DataTableBPFLibrary_GetInventoryItemData");
static_assert(offsetof(DataTableBPFLibrary_GetInventoryItemData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetInventoryItemData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetInventoryItemData, out_ItemData) == 0x000010, "Member 'DataTableBPFLibrary_GetInventoryItemData::out_ItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetInventoryItemData, ReturnValue) == 0x000178, "Member 'DataTableBPFLibrary_GetInventoryItemData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetItemAptitudeDataFromType
// 0x0190 (0x0190 - 0x0000)
struct DataTableBPFLibrary_GetItemAptitudeDataFromType final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAptitudeType                                 AptitudeType;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryItemAptitudeData             out_AptitudeData;                                  // 0x0010(0x0178)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0188(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetItemAptitudeDataFromType) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetItemAptitudeDataFromType");
static_assert(sizeof(DataTableBPFLibrary_GetItemAptitudeDataFromType) == 0x000190, "Wrong size on DataTableBPFLibrary_GetItemAptitudeDataFromType");
static_assert(offsetof(DataTableBPFLibrary_GetItemAptitudeDataFromType, DataTable) == 0x000000, "Member 'DataTableBPFLibrary_GetItemAptitudeDataFromType::DataTable' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemAptitudeDataFromType, AptitudeType) == 0x000008, "Member 'DataTableBPFLibrary_GetItemAptitudeDataFromType::AptitudeType' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemAptitudeDataFromType, out_AptitudeData) == 0x000010, "Member 'DataTableBPFLibrary_GetItemAptitudeDataFromType::out_AptitudeData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemAptitudeDataFromType, ReturnValue) == 0x000188, "Member 'DataTableBPFLibrary_GetItemAptitudeDataFromType::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetItemAssistData
// 0x0220 (0x0220 - 0x0000)
struct DataTableBPFLibrary_GetItemAssistData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryItemAssistData               out_ItemData;                                      // 0x0010(0x0208)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0218(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetItemAssistData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetItemAssistData");
static_assert(sizeof(DataTableBPFLibrary_GetItemAssistData) == 0x000220, "Wrong size on DataTableBPFLibrary_GetItemAssistData");
static_assert(offsetof(DataTableBPFLibrary_GetItemAssistData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetItemAssistData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemAssistData, out_ItemData) == 0x000010, "Member 'DataTableBPFLibrary_GetItemAssistData::out_ItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemAssistData, ReturnValue) == 0x000218, "Member 'DataTableBPFLibrary_GetItemAssistData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetItemBaseEquipmentData
// 0x01D0 (0x01D0 - 0x0000)
struct DataTableBPFLibrary_GetItemBaseEquipmentData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryItemBaseEquipmentData        out_ItemData;                                      // 0x0010(0x01B8)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x01C8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x7];                                      // 0x01C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetItemBaseEquipmentData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetItemBaseEquipmentData");
static_assert(sizeof(DataTableBPFLibrary_GetItemBaseEquipmentData) == 0x0001D0, "Wrong size on DataTableBPFLibrary_GetItemBaseEquipmentData");
static_assert(offsetof(DataTableBPFLibrary_GetItemBaseEquipmentData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetItemBaseEquipmentData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemBaseEquipmentData, out_ItemData) == 0x000010, "Member 'DataTableBPFLibrary_GetItemBaseEquipmentData::out_ItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemBaseEquipmentData, ReturnValue) == 0x0001C8, "Member 'DataTableBPFLibrary_GetItemBaseEquipmentData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetItemCostumeData
// 0x0290 (0x0290 - 0x0000)
struct DataTableBPFLibrary_GetItemCostumeData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryItemCostumeData              out_ItemData;                                      // 0x0010(0x0278)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0288(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetItemCostumeData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetItemCostumeData");
static_assert(sizeof(DataTableBPFLibrary_GetItemCostumeData) == 0x000290, "Wrong size on DataTableBPFLibrary_GetItemCostumeData");
static_assert(offsetof(DataTableBPFLibrary_GetItemCostumeData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetItemCostumeData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemCostumeData, out_ItemData) == 0x000010, "Member 'DataTableBPFLibrary_GetItemCostumeData::out_ItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemCostumeData, ReturnValue) == 0x000288, "Member 'DataTableBPFLibrary_GetItemCostumeData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetItemEnemyInfoData
// 0x0258 (0x0258 - 0x0000)
struct DataTableBPFLibrary_GetItemEnemyInfoData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryItemEnemyInfoData            out_ItemData;                                      // 0x0010(0x0240)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0250(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetItemEnemyInfoData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetItemEnemyInfoData");
static_assert(sizeof(DataTableBPFLibrary_GetItemEnemyInfoData) == 0x000258, "Wrong size on DataTableBPFLibrary_GetItemEnemyInfoData");
static_assert(offsetof(DataTableBPFLibrary_GetItemEnemyInfoData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetItemEnemyInfoData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemEnemyInfoData, out_ItemData) == 0x000010, "Member 'DataTableBPFLibrary_GetItemEnemyInfoData::out_ItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemEnemyInfoData, ReturnValue) == 0x000250, "Member 'DataTableBPFLibrary_GetItemEnemyInfoData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetItemEquipmentData
// 0x0200 (0x0200 - 0x0000)
struct DataTableBPFLibrary_GetItemEquipmentData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryItemEquipmentData            out_ItemData;                                      // 0x0010(0x01E8)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x01F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetItemEquipmentData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetItemEquipmentData");
static_assert(sizeof(DataTableBPFLibrary_GetItemEquipmentData) == 0x000200, "Wrong size on DataTableBPFLibrary_GetItemEquipmentData");
static_assert(offsetof(DataTableBPFLibrary_GetItemEquipmentData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetItemEquipmentData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemEquipmentData, out_ItemData) == 0x000010, "Member 'DataTableBPFLibrary_GetItemEquipmentData::out_ItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemEquipmentData, ReturnValue) == 0x0001F8, "Member 'DataTableBPFLibrary_GetItemEquipmentData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetItemGalleryData
// 0x01F8 (0x01F8 - 0x0000)
struct DataTableBPFLibrary_GetItemGalleryData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryItemGalleryData              out_ItemData;                                      // 0x0010(0x01E0)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x01F0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetItemGalleryData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetItemGalleryData");
static_assert(sizeof(DataTableBPFLibrary_GetItemGalleryData) == 0x0001F8, "Wrong size on DataTableBPFLibrary_GetItemGalleryData");
static_assert(offsetof(DataTableBPFLibrary_GetItemGalleryData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetItemGalleryData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemGalleryData, out_ItemData) == 0x000010, "Member 'DataTableBPFLibrary_GetItemGalleryData::out_ItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemGalleryData, ReturnValue) == 0x0001F0, "Member 'DataTableBPFLibrary_GetItemGalleryData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetItemGenericInfoData
// 0x0250 (0x0250 - 0x0000)
struct DataTableBPFLibrary_GetItemGenericInfoData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryItemGenericInfoData          out_ItemData;                                      // 0x0010(0x0238)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0248(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetItemGenericInfoData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetItemGenericInfoData");
static_assert(sizeof(DataTableBPFLibrary_GetItemGenericInfoData) == 0x000250, "Wrong size on DataTableBPFLibrary_GetItemGenericInfoData");
static_assert(offsetof(DataTableBPFLibrary_GetItemGenericInfoData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetItemGenericInfoData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemGenericInfoData, out_ItemData) == 0x000010, "Member 'DataTableBPFLibrary_GetItemGenericInfoData::out_ItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemGenericInfoData, ReturnValue) == 0x000248, "Member 'DataTableBPFLibrary_GetItemGenericInfoData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetItemNPCInfoData
// 0x0288 (0x0288 - 0x0000)
struct DataTableBPFLibrary_GetItemNPCInfoData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryItemNPCInfoData              out_ItemData;                                      // 0x0010(0x0270)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0280(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetItemNPCInfoData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetItemNPCInfoData");
static_assert(sizeof(DataTableBPFLibrary_GetItemNPCInfoData) == 0x000288, "Wrong size on DataTableBPFLibrary_GetItemNPCInfoData");
static_assert(offsetof(DataTableBPFLibrary_GetItemNPCInfoData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetItemNPCInfoData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemNPCInfoData, out_ItemData) == 0x000010, "Member 'DataTableBPFLibrary_GetItemNPCInfoData::out_ItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemNPCInfoData, ReturnValue) == 0x000280, "Member 'DataTableBPFLibrary_GetItemNPCInfoData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetItemPassiveData
// 0x0280 (0x0280 - 0x0000)
struct DataTableBPFLibrary_GetItemPassiveData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryItemPassiveData              out_ItemData;                                      // 0x0010(0x0268)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0278(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetItemPassiveData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetItemPassiveData");
static_assert(sizeof(DataTableBPFLibrary_GetItemPassiveData) == 0x000280, "Wrong size on DataTableBPFLibrary_GetItemPassiveData");
static_assert(offsetof(DataTableBPFLibrary_GetItemPassiveData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetItemPassiveData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemPassiveData, out_ItemData) == 0x000010, "Member 'DataTableBPFLibrary_GetItemPassiveData::out_ItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemPassiveData, ReturnValue) == 0x000278, "Member 'DataTableBPFLibrary_GetItemPassiveData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetItemSkillData
// 0x02A0 (0x02A0 - 0x0000)
struct DataTableBPFLibrary_GetItemSkillData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryItemSkillData                out_ItemData;                                      // 0x0010(0x0288)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0298(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetItemSkillData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetItemSkillData");
static_assert(sizeof(DataTableBPFLibrary_GetItemSkillData) == 0x0002A0, "Wrong size on DataTableBPFLibrary_GetItemSkillData");
static_assert(offsetof(DataTableBPFLibrary_GetItemSkillData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetItemSkillData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemSkillData, out_ItemData) == 0x000010, "Member 'DataTableBPFLibrary_GetItemSkillData::out_ItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemSkillData, ReturnValue) == 0x000298, "Member 'DataTableBPFLibrary_GetItemSkillData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetItemSpiritData
// 0x0220 (0x0220 - 0x0000)
struct DataTableBPFLibrary_GetItemSpiritData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryItemSpiritData               out_ItemData;                                      // 0x0010(0x0208)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0218(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetItemSpiritData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetItemSpiritData");
static_assert(sizeof(DataTableBPFLibrary_GetItemSpiritData) == 0x000220, "Wrong size on DataTableBPFLibrary_GetItemSpiritData");
static_assert(offsetof(DataTableBPFLibrary_GetItemSpiritData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetItemSpiritData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemSpiritData, out_ItemData) == 0x000010, "Member 'DataTableBPFLibrary_GetItemSpiritData::out_ItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemSpiritData, ReturnValue) == 0x000218, "Member 'DataTableBPFLibrary_GetItemSpiritData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetItemTipData
// 0x0180 (0x0180 - 0x0000)
struct DataTableBPFLibrary_GetItemTipData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryItemTipData                  out_ItemData;                                      // 0x0010(0x0168)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0178(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetItemTipData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetItemTipData");
static_assert(sizeof(DataTableBPFLibrary_GetItemTipData) == 0x000180, "Wrong size on DataTableBPFLibrary_GetItemTipData");
static_assert(offsetof(DataTableBPFLibrary_GetItemTipData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetItemTipData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemTipData, out_ItemData) == 0x000010, "Member 'DataTableBPFLibrary_GetItemTipData::out_ItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemTipData, ReturnValue) == 0x000178, "Member 'DataTableBPFLibrary_GetItemTipData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetItemTutorialData
// 0x01A8 (0x01A8 - 0x0000)
struct DataTableBPFLibrary_GetItemTutorialData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryItemTutorialData             out_ItemData;                                      // 0x0010(0x0190)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x01A0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetItemTutorialData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetItemTutorialData");
static_assert(sizeof(DataTableBPFLibrary_GetItemTutorialData) == 0x0001A8, "Wrong size on DataTableBPFLibrary_GetItemTutorialData");
static_assert(offsetof(DataTableBPFLibrary_GetItemTutorialData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetItemTutorialData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemTutorialData, out_ItemData) == 0x000010, "Member 'DataTableBPFLibrary_GetItemTutorialData::out_ItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetItemTutorialData, ReturnValue) == 0x0001A0, "Member 'DataTableBPFLibrary_GetItemTutorialData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetMapTransitionRowHandleFromTransitionSpawnPointData
// 0x0030 (0x0030 - 0x0000)
struct DataTableBPFLibrary_GetMapTransitionRowHandleFromTransitionSpawnPointData final
{
public:
	const class UDataTable*                       MapTransitionDataTable;                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMapTransitionSpawnPointData           MapTransitionSpawnPointData;                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    out_MapTransitionRowHandle;                        // 0x0018(0x0010)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetMapTransitionRowHandleFromTransitionSpawnPointData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetMapTransitionRowHandleFromTransitionSpawnPointData");
static_assert(sizeof(DataTableBPFLibrary_GetMapTransitionRowHandleFromTransitionSpawnPointData) == 0x000030, "Wrong size on DataTableBPFLibrary_GetMapTransitionRowHandleFromTransitionSpawnPointData");
static_assert(offsetof(DataTableBPFLibrary_GetMapTransitionRowHandleFromTransitionSpawnPointData, MapTransitionDataTable) == 0x000000, "Member 'DataTableBPFLibrary_GetMapTransitionRowHandleFromTransitionSpawnPointData::MapTransitionDataTable' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetMapTransitionRowHandleFromTransitionSpawnPointData, MapTransitionSpawnPointData) == 0x000008, "Member 'DataTableBPFLibrary_GetMapTransitionRowHandleFromTransitionSpawnPointData::MapTransitionSpawnPointData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetMapTransitionRowHandleFromTransitionSpawnPointData, out_MapTransitionRowHandle) == 0x000018, "Member 'DataTableBPFLibrary_GetMapTransitionRowHandleFromTransitionSpawnPointData::out_MapTransitionRowHandle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetMapTransitionRowHandleFromTransitionSpawnPointData, ReturnValue) == 0x000028, "Member 'DataTableBPFLibrary_GetMapTransitionRowHandleFromTransitionSpawnPointData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetRecollectionItemData
// 0x0098 (0x0098 - 0x0000)
struct DataTableBPFLibrary_GetRecollectionItemData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	ERecollectionItemType                         RecollectionItemType;                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRecollectionItemData                  out_RecollectionItemData;                          // 0x0018(0x0078)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetRecollectionItemData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetRecollectionItemData");
static_assert(sizeof(DataTableBPFLibrary_GetRecollectionItemData) == 0x000098, "Wrong size on DataTableBPFLibrary_GetRecollectionItemData");
static_assert(offsetof(DataTableBPFLibrary_GetRecollectionItemData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetRecollectionItemData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetRecollectionItemData, RecollectionItemType) == 0x000010, "Member 'DataTableBPFLibrary_GetRecollectionItemData::RecollectionItemType' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetRecollectionItemData, out_RecollectionItemData) == 0x000018, "Member 'DataTableBPFLibrary_GetRecollectionItemData::out_RecollectionItemData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetRecollectionItemData, ReturnValue) == 0x000090, "Member 'DataTableBPFLibrary_GetRecollectionItemData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetRestPointData
// 0x00A0 (0x00A0 - 0x0000)
struct DataTableBPFLibrary_GetRestPointData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FRestPointData                         out_RestPointData;                                 // 0x0010(0x0088)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0098(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetRestPointData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetRestPointData");
static_assert(sizeof(DataTableBPFLibrary_GetRestPointData) == 0x0000A0, "Wrong size on DataTableBPFLibrary_GetRestPointData");
static_assert(offsetof(DataTableBPFLibrary_GetRestPointData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetRestPointData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetRestPointData, out_RestPointData) == 0x000010, "Member 'DataTableBPFLibrary_GetRestPointData::out_RestPointData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetRestPointData, ReturnValue) == 0x000098, "Member 'DataTableBPFLibrary_GetRestPointData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetRestPointEventData
// 0x00A8 (0x00A8 - 0x0000)
struct DataTableBPFLibrary_GetRestPointEventData final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FRestPointEventData                    out_RestPointEventData;                            // 0x0010(0x0090)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetRestPointEventData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetRestPointEventData");
static_assert(sizeof(DataTableBPFLibrary_GetRestPointEventData) == 0x0000A8, "Wrong size on DataTableBPFLibrary_GetRestPointEventData");
static_assert(offsetof(DataTableBPFLibrary_GetRestPointEventData, Handle) == 0x000000, "Member 'DataTableBPFLibrary_GetRestPointEventData::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetRestPointEventData, out_RestPointEventData) == 0x000010, "Member 'DataTableBPFLibrary_GetRestPointEventData::out_RestPointEventData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetRestPointEventData, ReturnValue) == 0x0000A0, "Member 'DataTableBPFLibrary_GetRestPointEventData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.GetSkillLevelDataFromItemSkillData
// 0x0380 (0x0380 - 0x0000)
struct DataTableBPFLibrary_GetSkillLevelDataFromItemSkillData final
{
public:
	struct FInventoryItemSkillData                ItemSkillData;                                     // 0x0000(0x0288)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0288(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkillLevelData                        out_SkillData;                                     // 0x0290(0x00E8)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0378(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_GetSkillLevelDataFromItemSkillData) == 0x000008, "Wrong alignment on DataTableBPFLibrary_GetSkillLevelDataFromItemSkillData");
static_assert(sizeof(DataTableBPFLibrary_GetSkillLevelDataFromItemSkillData) == 0x000380, "Wrong size on DataTableBPFLibrary_GetSkillLevelDataFromItemSkillData");
static_assert(offsetof(DataTableBPFLibrary_GetSkillLevelDataFromItemSkillData, ItemSkillData) == 0x000000, "Member 'DataTableBPFLibrary_GetSkillLevelDataFromItemSkillData::ItemSkillData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetSkillLevelDataFromItemSkillData, Level) == 0x000288, "Member 'DataTableBPFLibrary_GetSkillLevelDataFromItemSkillData::Level' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetSkillLevelDataFromItemSkillData, out_SkillData) == 0x000290, "Member 'DataTableBPFLibrary_GetSkillLevelDataFromItemSkillData::out_SkillData' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_GetSkillLevelDataFromItemSkillData, ReturnValue) == 0x000378, "Member 'DataTableBPFLibrary_GetSkillLevelDataFromItemSkillData::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.IsAllRecollectionItemsChecked
// 0x0018 (0x0018 - 0x0000)
struct DataTableBPFLibrary_IsAllRecollectionItemsChecked final
{
public:
	class APlayerControllerZion*                  PlayerControllerZion;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDataTable*                       DataTable;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERecollectionItemType                         RecollectionItemType;                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_IsAllRecollectionItemsChecked) == 0x000008, "Wrong alignment on DataTableBPFLibrary_IsAllRecollectionItemsChecked");
static_assert(sizeof(DataTableBPFLibrary_IsAllRecollectionItemsChecked) == 0x000018, "Wrong size on DataTableBPFLibrary_IsAllRecollectionItemsChecked");
static_assert(offsetof(DataTableBPFLibrary_IsAllRecollectionItemsChecked, PlayerControllerZion) == 0x000000, "Member 'DataTableBPFLibrary_IsAllRecollectionItemsChecked::PlayerControllerZion' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsAllRecollectionItemsChecked, DataTable) == 0x000008, "Member 'DataTableBPFLibrary_IsAllRecollectionItemsChecked::DataTable' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsAllRecollectionItemsChecked, RecollectionItemType) == 0x000010, "Member 'DataTableBPFLibrary_IsAllRecollectionItemsChecked::RecollectionItemType' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsAllRecollectionItemsChecked, ReturnValue) == 0x000011, "Member 'DataTableBPFLibrary_IsAllRecollectionItemsChecked::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.IsAnyRecollectionItemVisible
// 0x0018 (0x0018 - 0x0000)
struct DataTableBPFLibrary_IsAnyRecollectionItemVisible final
{
public:
	class APlayerControllerZion*                  PlayerControllerZion;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDataTable*                       DataTable;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERecollectionItemType                         RecollectionItemType;                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_IsAnyRecollectionItemVisible) == 0x000008, "Wrong alignment on DataTableBPFLibrary_IsAnyRecollectionItemVisible");
static_assert(sizeof(DataTableBPFLibrary_IsAnyRecollectionItemVisible) == 0x000018, "Wrong size on DataTableBPFLibrary_IsAnyRecollectionItemVisible");
static_assert(offsetof(DataTableBPFLibrary_IsAnyRecollectionItemVisible, PlayerControllerZion) == 0x000000, "Member 'DataTableBPFLibrary_IsAnyRecollectionItemVisible::PlayerControllerZion' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsAnyRecollectionItemVisible, DataTable) == 0x000008, "Member 'DataTableBPFLibrary_IsAnyRecollectionItemVisible::DataTable' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsAnyRecollectionItemVisible, RecollectionItemType) == 0x000010, "Member 'DataTableBPFLibrary_IsAnyRecollectionItemVisible::RecollectionItemType' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsAnyRecollectionItemVisible, ReturnValue) == 0x000011, "Member 'DataTableBPFLibrary_IsAnyRecollectionItemVisible::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.IsEqual
// 0x0028 (0x0028 - 0x0000)
struct DataTableBPFLibrary_IsEqual final
{
public:
	struct FDataTableRowHandle                    A;                                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    B;                                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_IsEqual) == 0x000008, "Wrong alignment on DataTableBPFLibrary_IsEqual");
static_assert(sizeof(DataTableBPFLibrary_IsEqual) == 0x000028, "Wrong size on DataTableBPFLibrary_IsEqual");
static_assert(offsetof(DataTableBPFLibrary_IsEqual, A) == 0x000000, "Member 'DataTableBPFLibrary_IsEqual::A' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsEqual, B) == 0x000010, "Member 'DataTableBPFLibrary_IsEqual::B' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsEqual, ReturnValue) == 0x000020, "Member 'DataTableBPFLibrary_IsEqual::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.IsItemEnemyInfoVisible
// 0x0020 (0x0020 - 0x0000)
struct DataTableBPFLibrary_IsItemEnemyInfoVisible final
{
public:
	const class APlayerControllerZion*            PlayerControllerZion;                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    Handle;                                            // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_IsItemEnemyInfoVisible) == 0x000008, "Wrong alignment on DataTableBPFLibrary_IsItemEnemyInfoVisible");
static_assert(sizeof(DataTableBPFLibrary_IsItemEnemyInfoVisible) == 0x000020, "Wrong size on DataTableBPFLibrary_IsItemEnemyInfoVisible");
static_assert(offsetof(DataTableBPFLibrary_IsItemEnemyInfoVisible, PlayerControllerZion) == 0x000000, "Member 'DataTableBPFLibrary_IsItemEnemyInfoVisible::PlayerControllerZion' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsItemEnemyInfoVisible, Handle) == 0x000008, "Member 'DataTableBPFLibrary_IsItemEnemyInfoVisible::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsItemEnemyInfoVisible, ReturnValue) == 0x000018, "Member 'DataTableBPFLibrary_IsItemEnemyInfoVisible::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.IsItemGalleryVisible
// 0x0020 (0x0020 - 0x0000)
struct DataTableBPFLibrary_IsItemGalleryVisible final
{
public:
	class APlayerControllerZion*                  PlayerControllerZion;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    Handle;                                            // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_IsItemGalleryVisible) == 0x000008, "Wrong alignment on DataTableBPFLibrary_IsItemGalleryVisible");
static_assert(sizeof(DataTableBPFLibrary_IsItemGalleryVisible) == 0x000020, "Wrong size on DataTableBPFLibrary_IsItemGalleryVisible");
static_assert(offsetof(DataTableBPFLibrary_IsItemGalleryVisible, PlayerControllerZion) == 0x000000, "Member 'DataTableBPFLibrary_IsItemGalleryVisible::PlayerControllerZion' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsItemGalleryVisible, Handle) == 0x000008, "Member 'DataTableBPFLibrary_IsItemGalleryVisible::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsItemGalleryVisible, ReturnValue) == 0x000018, "Member 'DataTableBPFLibrary_IsItemGalleryVisible::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.IsItemGenericAnimationVisible
// 0x0030 (0x0030 - 0x0000)
struct DataTableBPFLibrary_IsItemGenericAnimationVisible final
{
public:
	class APlayerControllerZion*                  PlayerControllerZion;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemGenericAnimationConditionData     AnimationConditions;                               // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_IsItemGenericAnimationVisible) == 0x000008, "Wrong alignment on DataTableBPFLibrary_IsItemGenericAnimationVisible");
static_assert(sizeof(DataTableBPFLibrary_IsItemGenericAnimationVisible) == 0x000030, "Wrong size on DataTableBPFLibrary_IsItemGenericAnimationVisible");
static_assert(offsetof(DataTableBPFLibrary_IsItemGenericAnimationVisible, PlayerControllerZion) == 0x000000, "Member 'DataTableBPFLibrary_IsItemGenericAnimationVisible::PlayerControllerZion' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsItemGenericAnimationVisible, AnimationConditions) == 0x000008, "Member 'DataTableBPFLibrary_IsItemGenericAnimationVisible::AnimationConditions' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsItemGenericAnimationVisible, ReturnValue) == 0x000028, "Member 'DataTableBPFLibrary_IsItemGenericAnimationVisible::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.IsItemNPCInfoVisible
// 0x0020 (0x0020 - 0x0000)
struct DataTableBPFLibrary_IsItemNPCInfoVisible final
{
public:
	class APlayerControllerZion*                  PlayerControllerZion;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    Handle;                                            // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_IsItemNPCInfoVisible) == 0x000008, "Wrong alignment on DataTableBPFLibrary_IsItemNPCInfoVisible");
static_assert(sizeof(DataTableBPFLibrary_IsItemNPCInfoVisible) == 0x000020, "Wrong size on DataTableBPFLibrary_IsItemNPCInfoVisible");
static_assert(offsetof(DataTableBPFLibrary_IsItemNPCInfoVisible, PlayerControllerZion) == 0x000000, "Member 'DataTableBPFLibrary_IsItemNPCInfoVisible::PlayerControllerZion' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsItemNPCInfoVisible, Handle) == 0x000008, "Member 'DataTableBPFLibrary_IsItemNPCInfoVisible::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsItemNPCInfoVisible, ReturnValue) == 0x000018, "Member 'DataTableBPFLibrary_IsItemNPCInfoVisible::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.IsProgressionItem
// 0x0018 (0x0018 - 0x0000)
struct DataTableBPFLibrary_IsProgressionItem final
{
public:
	struct FDataTableRowHandle                    ItemHandle;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_IsProgressionItem) == 0x000008, "Wrong alignment on DataTableBPFLibrary_IsProgressionItem");
static_assert(sizeof(DataTableBPFLibrary_IsProgressionItem) == 0x000018, "Wrong size on DataTableBPFLibrary_IsProgressionItem");
static_assert(offsetof(DataTableBPFLibrary_IsProgressionItem, ItemHandle) == 0x000000, "Member 'DataTableBPFLibrary_IsProgressionItem::ItemHandle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsProgressionItem, ReturnValue) == 0x000010, "Member 'DataTableBPFLibrary_IsProgressionItem::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.IsRecollectionItemVisible
// 0x0020 (0x0020 - 0x0000)
struct DataTableBPFLibrary_IsRecollectionItemVisible final
{
public:
	class APlayerControllerZion*                  PlayerControllerZion;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    Handle;                                            // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	ERecollectionItemType                         RecollectionItemType;                              // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_IsRecollectionItemVisible) == 0x000008, "Wrong alignment on DataTableBPFLibrary_IsRecollectionItemVisible");
static_assert(sizeof(DataTableBPFLibrary_IsRecollectionItemVisible) == 0x000020, "Wrong size on DataTableBPFLibrary_IsRecollectionItemVisible");
static_assert(offsetof(DataTableBPFLibrary_IsRecollectionItemVisible, PlayerControllerZion) == 0x000000, "Member 'DataTableBPFLibrary_IsRecollectionItemVisible::PlayerControllerZion' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsRecollectionItemVisible, Handle) == 0x000008, "Member 'DataTableBPFLibrary_IsRecollectionItemVisible::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsRecollectionItemVisible, RecollectionItemType) == 0x000018, "Member 'DataTableBPFLibrary_IsRecollectionItemVisible::RecollectionItemType' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsRecollectionItemVisible, ReturnValue) == 0x000019, "Member 'DataTableBPFLibrary_IsRecollectionItemVisible::ReturnValue' has a wrong offset!");

// Function Zion.DataTableBPFLibrary.IsValid
// 0x0018 (0x0018 - 0x0000)
struct DataTableBPFLibrary_IsValid final
{
public:
	struct FDataTableRowHandle                    Handle;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableBPFLibrary_IsValid) == 0x000008, "Wrong alignment on DataTableBPFLibrary_IsValid");
static_assert(sizeof(DataTableBPFLibrary_IsValid) == 0x000018, "Wrong size on DataTableBPFLibrary_IsValid");
static_assert(offsetof(DataTableBPFLibrary_IsValid, Handle) == 0x000000, "Member 'DataTableBPFLibrary_IsValid::Handle' has a wrong offset!");
static_assert(offsetof(DataTableBPFLibrary_IsValid, ReturnValue) == 0x000010, "Member 'DataTableBPFLibrary_IsValid::ReturnValue' has a wrong offset!");

// Function Zion.DeathProcess_SpineAnimation.OnAnimationFinished
// 0x0008 (0x0008 - 0x0000)
struct DeathProcess_SpineAnimation_OnAnimationFinished final
{
public:
	class UTrackEntry*                            TrackEntry;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeathProcess_SpineAnimation_OnAnimationFinished) == 0x000008, "Wrong alignment on DeathProcess_SpineAnimation_OnAnimationFinished");
static_assert(sizeof(DeathProcess_SpineAnimation_OnAnimationFinished) == 0x000008, "Wrong size on DeathProcess_SpineAnimation_OnAnimationFinished");
static_assert(offsetof(DeathProcess_SpineAnimation_OnAnimationFinished, TrackEntry) == 0x000000, "Member 'DeathProcess_SpineAnimation_OnAnimationFinished::TrackEntry' has a wrong offset!");

// Function Zion.DelayRealTimeAsyncAction.DelayRealTime
// 0x0018 (0x0018 - 0x0000)
struct DelayRealTimeAsyncAction_DelayRealTime final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayInSeconds;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDelayRealTimeAsyncAction*              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DelayRealTimeAsyncAction_DelayRealTime) == 0x000008, "Wrong alignment on DelayRealTimeAsyncAction_DelayRealTime");
static_assert(sizeof(DelayRealTimeAsyncAction_DelayRealTime) == 0x000018, "Wrong size on DelayRealTimeAsyncAction_DelayRealTime");
static_assert(offsetof(DelayRealTimeAsyncAction_DelayRealTime, WorldContextObject) == 0x000000, "Member 'DelayRealTimeAsyncAction_DelayRealTime::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DelayRealTimeAsyncAction_DelayRealTime, DelayInSeconds) == 0x000008, "Member 'DelayRealTimeAsyncAction_DelayRealTime::DelayInSeconds' has a wrong offset!");
static_assert(offsetof(DelayRealTimeAsyncAction_DelayRealTime, ReturnValue) == 0x000010, "Member 'DelayRealTimeAsyncAction_DelayRealTime::ReturnValue' has a wrong offset!");

// Function Zion.DelayUndilatedAsyncAction.DelayUndilated
// 0x0018 (0x0018 - 0x0000)
struct DelayUndilatedAsyncAction_DelayUndilated final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayInSeconds;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDelayUndilatedAsyncAction*             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DelayUndilatedAsyncAction_DelayUndilated) == 0x000008, "Wrong alignment on DelayUndilatedAsyncAction_DelayUndilated");
static_assert(sizeof(DelayUndilatedAsyncAction_DelayUndilated) == 0x000018, "Wrong size on DelayUndilatedAsyncAction_DelayUndilated");
static_assert(offsetof(DelayUndilatedAsyncAction_DelayUndilated, WorldContextObject) == 0x000000, "Member 'DelayUndilatedAsyncAction_DelayUndilated::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DelayUndilatedAsyncAction_DelayUndilated, DelayInSeconds) == 0x000008, "Member 'DelayUndilatedAsyncAction_DelayUndilated::DelayInSeconds' has a wrong offset!");
static_assert(offsetof(DelayUndilatedAsyncAction_DelayUndilated, ReturnValue) == 0x000010, "Member 'DelayUndilatedAsyncAction_DelayUndilated::ReturnValue' has a wrong offset!");

// Function Zion.DifficultySystemComponent.Get
// 0x0010 (0x0010 - 0x0000)
struct DifficultySystemComponent_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDifficultySystemComponent*             ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DifficultySystemComponent_Get) == 0x000008, "Wrong alignment on DifficultySystemComponent_Get");
static_assert(sizeof(DifficultySystemComponent_Get) == 0x000010, "Wrong size on DifficultySystemComponent_Get");
static_assert(offsetof(DifficultySystemComponent_Get, WorldContextObject) == 0x000000, "Member 'DifficultySystemComponent_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DifficultySystemComponent_Get, ReturnValue) == 0x000008, "Member 'DifficultySystemComponent_Get::ReturnValue' has a wrong offset!");

// Function Zion.DifficultySystemComponent.GetDifficultyPresetFromSettings
// 0x001C (0x001C - 0x0000)
struct DifficultySystemComponent_GetDifficultyPresetFromSettings final
{
public:
	struct FDifficultySettings                    InDifficultySettings;                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	EDifficultyPreset                             ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DifficultySystemComponent_GetDifficultyPresetFromSettings) == 0x000004, "Wrong alignment on DifficultySystemComponent_GetDifficultyPresetFromSettings");
static_assert(sizeof(DifficultySystemComponent_GetDifficultyPresetFromSettings) == 0x00001C, "Wrong size on DifficultySystemComponent_GetDifficultyPresetFromSettings");
static_assert(offsetof(DifficultySystemComponent_GetDifficultyPresetFromSettings, InDifficultySettings) == 0x000000, "Member 'DifficultySystemComponent_GetDifficultyPresetFromSettings::InDifficultySettings' has a wrong offset!");
static_assert(offsetof(DifficultySystemComponent_GetDifficultyPresetFromSettings, ReturnValue) == 0x000018, "Member 'DifficultySystemComponent_GetDifficultyPresetFromSettings::ReturnValue' has a wrong offset!");

// Function Zion.DifficultySystemComponent.SetDifficultyMode
// 0x0001 (0x0001 - 0x0000)
struct DifficultySystemComponent_SetDifficultyMode final
{
public:
	EDifficultyMode                               NewDifficultyMode;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DifficultySystemComponent_SetDifficultyMode) == 0x000001, "Wrong alignment on DifficultySystemComponent_SetDifficultyMode");
static_assert(sizeof(DifficultySystemComponent_SetDifficultyMode) == 0x000001, "Wrong size on DifficultySystemComponent_SetDifficultyMode");
static_assert(offsetof(DifficultySystemComponent_SetDifficultyMode, NewDifficultyMode) == 0x000000, "Member 'DifficultySystemComponent_SetDifficultyMode::NewDifficultyMode' has a wrong offset!");

// Function Zion.DifficultySystemComponent.SetDifficultyPresetAndSettings
// 0x001C (0x001C - 0x0000)
struct DifficultySystemComponent_SetDifficultyPresetAndSettings final
{
public:
	EDifficultyPreset                             NewDifficultyPreset;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDifficultySettings                    NewDifficultySettings;                             // 0x0004(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DifficultySystemComponent_SetDifficultyPresetAndSettings) == 0x000004, "Wrong alignment on DifficultySystemComponent_SetDifficultyPresetAndSettings");
static_assert(sizeof(DifficultySystemComponent_SetDifficultyPresetAndSettings) == 0x00001C, "Wrong size on DifficultySystemComponent_SetDifficultyPresetAndSettings");
static_assert(offsetof(DifficultySystemComponent_SetDifficultyPresetAndSettings, NewDifficultyPreset) == 0x000000, "Member 'DifficultySystemComponent_SetDifficultyPresetAndSettings::NewDifficultyPreset' has a wrong offset!");
static_assert(offsetof(DifficultySystemComponent_SetDifficultyPresetAndSettings, NewDifficultySettings) == 0x000004, "Member 'DifficultySystemComponent_SetDifficultyPresetAndSettings::NewDifficultySettings' has a wrong offset!");

// Function Zion.DifficultySystemComponent.GetCurrencyFactor
// 0x0004 (0x0004 - 0x0000)
struct DifficultySystemComponent_GetCurrencyFactor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DifficultySystemComponent_GetCurrencyFactor) == 0x000004, "Wrong alignment on DifficultySystemComponent_GetCurrencyFactor");
static_assert(sizeof(DifficultySystemComponent_GetCurrencyFactor) == 0x000004, "Wrong size on DifficultySystemComponent_GetCurrencyFactor");
static_assert(offsetof(DifficultySystemComponent_GetCurrencyFactor, ReturnValue) == 0x000000, "Member 'DifficultySystemComponent_GetCurrencyFactor::ReturnValue' has a wrong offset!");

// Function Zion.DifficultySystemComponent.GetCurrencyFactorRatio
// 0x0004 (0x0004 - 0x0000)
struct DifficultySystemComponent_GetCurrencyFactorRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DifficultySystemComponent_GetCurrencyFactorRatio) == 0x000004, "Wrong alignment on DifficultySystemComponent_GetCurrencyFactorRatio");
static_assert(sizeof(DifficultySystemComponent_GetCurrencyFactorRatio) == 0x000004, "Wrong size on DifficultySystemComponent_GetCurrencyFactorRatio");
static_assert(offsetof(DifficultySystemComponent_GetCurrencyFactorRatio, ReturnValue) == 0x000000, "Member 'DifficultySystemComponent_GetCurrencyFactorRatio::ReturnValue' has a wrong offset!");

// Function Zion.DifficultySystemComponent.GetDifficultyMode
// 0x0001 (0x0001 - 0x0000)
struct DifficultySystemComponent_GetDifficultyMode final
{
public:
	EDifficultyMode                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DifficultySystemComponent_GetDifficultyMode) == 0x000001, "Wrong alignment on DifficultySystemComponent_GetDifficultyMode");
static_assert(sizeof(DifficultySystemComponent_GetDifficultyMode) == 0x000001, "Wrong size on DifficultySystemComponent_GetDifficultyMode");
static_assert(offsetof(DifficultySystemComponent_GetDifficultyMode, ReturnValue) == 0x000000, "Member 'DifficultySystemComponent_GetDifficultyMode::ReturnValue' has a wrong offset!");

// Function Zion.DifficultySystemComponent.GetDifficultyPreset
// 0x0001 (0x0001 - 0x0000)
struct DifficultySystemComponent_GetDifficultyPreset final
{
public:
	EDifficultyPreset                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DifficultySystemComponent_GetDifficultyPreset) == 0x000001, "Wrong alignment on DifficultySystemComponent_GetDifficultyPreset");
static_assert(sizeof(DifficultySystemComponent_GetDifficultyPreset) == 0x000001, "Wrong size on DifficultySystemComponent_GetDifficultyPreset");
static_assert(offsetof(DifficultySystemComponent_GetDifficultyPreset, ReturnValue) == 0x000000, "Member 'DifficultySystemComponent_GetDifficultyPreset::ReturnValue' has a wrong offset!");

// Function Zion.DifficultySystemComponent.GetDifficultyPresetForMode
// 0x0002 (0x0002 - 0x0000)
struct DifficultySystemComponent_GetDifficultyPresetForMode final
{
public:
	EDifficultyMode                               InDifficultyMode;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDifficultyPreset                             ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DifficultySystemComponent_GetDifficultyPresetForMode) == 0x000001, "Wrong alignment on DifficultySystemComponent_GetDifficultyPresetForMode");
static_assert(sizeof(DifficultySystemComponent_GetDifficultyPresetForMode) == 0x000002, "Wrong size on DifficultySystemComponent_GetDifficultyPresetForMode");
static_assert(offsetof(DifficultySystemComponent_GetDifficultyPresetForMode, InDifficultyMode) == 0x000000, "Member 'DifficultySystemComponent_GetDifficultyPresetForMode::InDifficultyMode' has a wrong offset!");
static_assert(offsetof(DifficultySystemComponent_GetDifficultyPresetForMode, ReturnValue) == 0x000001, "Member 'DifficultySystemComponent_GetDifficultyPresetForMode::ReturnValue' has a wrong offset!");

// Function Zion.DifficultySystemComponent.GetDifficultySettings
// 0x0018 (0x0018 - 0x0000)
struct DifficultySystemComponent_GetDifficultySettings final
{
public:
	struct FDifficultySettings                    ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DifficultySystemComponent_GetDifficultySettings) == 0x000004, "Wrong alignment on DifficultySystemComponent_GetDifficultySettings");
static_assert(sizeof(DifficultySystemComponent_GetDifficultySettings) == 0x000018, "Wrong size on DifficultySystemComponent_GetDifficultySettings");
static_assert(offsetof(DifficultySystemComponent_GetDifficultySettings, ReturnValue) == 0x000000, "Member 'DifficultySystemComponent_GetDifficultySettings::ReturnValue' has a wrong offset!");

// Function Zion.DifficultySystemComponent.GetDifficultySettingsForMode
// 0x001C (0x001C - 0x0000)
struct DifficultySystemComponent_GetDifficultySettingsForMode final
{
public:
	EDifficultyMode                               InDifficultyMode;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDifficultySettings                    ReturnValue;                                       // 0x0004(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DifficultySystemComponent_GetDifficultySettingsForMode) == 0x000004, "Wrong alignment on DifficultySystemComponent_GetDifficultySettingsForMode");
static_assert(sizeof(DifficultySystemComponent_GetDifficultySettingsForMode) == 0x00001C, "Wrong size on DifficultySystemComponent_GetDifficultySettingsForMode");
static_assert(offsetof(DifficultySystemComponent_GetDifficultySettingsForMode, InDifficultyMode) == 0x000000, "Member 'DifficultySystemComponent_GetDifficultySettingsForMode::InDifficultyMode' has a wrong offset!");
static_assert(offsetof(DifficultySystemComponent_GetDifficultySettingsForMode, ReturnValue) == 0x000004, "Member 'DifficultySystemComponent_GetDifficultySettingsForMode::ReturnValue' has a wrong offset!");

// Function Zion.DifficultySystemComponent.GetDifficultySettingsForPreset
// 0x001C (0x001C - 0x0000)
struct DifficultySystemComponent_GetDifficultySettingsForPreset final
{
public:
	EDifficultyPreset                             InDifficultyPreset;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDifficultySettings                    ReturnValue;                                       // 0x0004(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DifficultySystemComponent_GetDifficultySettingsForPreset) == 0x000004, "Wrong alignment on DifficultySystemComponent_GetDifficultySettingsForPreset");
static_assert(sizeof(DifficultySystemComponent_GetDifficultySettingsForPreset) == 0x00001C, "Wrong size on DifficultySystemComponent_GetDifficultySettingsForPreset");
static_assert(offsetof(DifficultySystemComponent_GetDifficultySettingsForPreset, InDifficultyPreset) == 0x000000, "Member 'DifficultySystemComponent_GetDifficultySettingsForPreset::InDifficultyPreset' has a wrong offset!");
static_assert(offsetof(DifficultySystemComponent_GetDifficultySettingsForPreset, ReturnValue) == 0x000004, "Member 'DifficultySystemComponent_GetDifficultySettingsForPreset::ReturnValue' has a wrong offset!");

// Function Zion.DifficultySystemComponent.HasAnyChallengeEnabled
// 0x0001 (0x0001 - 0x0000)
struct DifficultySystemComponent_HasAnyChallengeEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DifficultySystemComponent_HasAnyChallengeEnabled) == 0x000001, "Wrong alignment on DifficultySystemComponent_HasAnyChallengeEnabled");
static_assert(sizeof(DifficultySystemComponent_HasAnyChallengeEnabled) == 0x000001, "Wrong size on DifficultySystemComponent_HasAnyChallengeEnabled");
static_assert(offsetof(DifficultySystemComponent_HasAnyChallengeEnabled, ReturnValue) == 0x000000, "Member 'DifficultySystemComponent_HasAnyChallengeEnabled::ReturnValue' has a wrong offset!");

// Function Zion.DropSystemComponent.Get
// 0x0010 (0x0010 - 0x0000)
struct DropSystemComponent_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDropSystemComponent*                   ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DropSystemComponent_Get) == 0x000008, "Wrong alignment on DropSystemComponent_Get");
static_assert(sizeof(DropSystemComponent_Get) == 0x000010, "Wrong size on DropSystemComponent_Get");
static_assert(offsetof(DropSystemComponent_Get, WorldContextObject) == 0x000000, "Member 'DropSystemComponent_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DropSystemComponent_Get, ReturnValue) == 0x000008, "Member 'DropSystemComponent_Get::ReturnValue' has a wrong offset!");

// Function Zion.DropSystemComponent.LaunchExperienceDrop
// 0x0070 (0x0070 - 0x0000)
struct DropSystemComponent_LaunchExperienceDrop final
{
public:
	int32                                         Experience;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Origin;                                            // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DropSystemComponent_LaunchExperienceDrop) == 0x000010, "Wrong alignment on DropSystemComponent_LaunchExperienceDrop");
static_assert(sizeof(DropSystemComponent_LaunchExperienceDrop) == 0x000070, "Wrong size on DropSystemComponent_LaunchExperienceDrop");
static_assert(offsetof(DropSystemComponent_LaunchExperienceDrop, Experience) == 0x000000, "Member 'DropSystemComponent_LaunchExperienceDrop::Experience' has a wrong offset!");
static_assert(offsetof(DropSystemComponent_LaunchExperienceDrop, Origin) == 0x000010, "Member 'DropSystemComponent_LaunchExperienceDrop::Origin' has a wrong offset!");

// Function Zion.ElevatorMovementComponent.GoToDestination
// 0x0001 (0x0001 - 0x0000)
struct ElevatorMovementComponent_GoToDestination final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ElevatorMovementComponent_GoToDestination) == 0x000001, "Wrong alignment on ElevatorMovementComponent_GoToDestination");
static_assert(sizeof(ElevatorMovementComponent_GoToDestination) == 0x000001, "Wrong size on ElevatorMovementComponent_GoToDestination");
static_assert(offsetof(ElevatorMovementComponent_GoToDestination, bInstant) == 0x000000, "Member 'ElevatorMovementComponent_GoToDestination::bInstant' has a wrong offset!");

// Function Zion.ElevatorMovementComponent.GoToOrigin
// 0x0001 (0x0001 - 0x0000)
struct ElevatorMovementComponent_GoToOrigin final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ElevatorMovementComponent_GoToOrigin) == 0x000001, "Wrong alignment on ElevatorMovementComponent_GoToOrigin");
static_assert(sizeof(ElevatorMovementComponent_GoToOrigin) == 0x000001, "Wrong size on ElevatorMovementComponent_GoToOrigin");
static_assert(offsetof(ElevatorMovementComponent_GoToOrigin, bInstant) == 0x000000, "Member 'ElevatorMovementComponent_GoToOrigin::bInstant' has a wrong offset!");

// Function Zion.ElevatorMovementComponent.SetAllowOutOfScreenSpeedFactor
// 0x0001 (0x0001 - 0x0000)
struct ElevatorMovementComponent_SetAllowOutOfScreenSpeedFactor final
{
public:
	bool                                          bAllowed;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ElevatorMovementComponent_SetAllowOutOfScreenSpeedFactor) == 0x000001, "Wrong alignment on ElevatorMovementComponent_SetAllowOutOfScreenSpeedFactor");
static_assert(sizeof(ElevatorMovementComponent_SetAllowOutOfScreenSpeedFactor) == 0x000001, "Wrong size on ElevatorMovementComponent_SetAllowOutOfScreenSpeedFactor");
static_assert(offsetof(ElevatorMovementComponent_SetAllowOutOfScreenSpeedFactor, bAllowed) == 0x000000, "Member 'ElevatorMovementComponent_SetAllowOutOfScreenSpeedFactor::bAllowed' has a wrong offset!");

// Function Zion.ElevatorMovementComponent.GetCurrentLocation
// 0x0018 (0x0018 - 0x0000)
struct ElevatorMovementComponent_GetCurrentLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ElevatorMovementComponent_GetCurrentLocation) == 0x000008, "Wrong alignment on ElevatorMovementComponent_GetCurrentLocation");
static_assert(sizeof(ElevatorMovementComponent_GetCurrentLocation) == 0x000018, "Wrong size on ElevatorMovementComponent_GetCurrentLocation");
static_assert(offsetof(ElevatorMovementComponent_GetCurrentLocation, ReturnValue) == 0x000000, "Member 'ElevatorMovementComponent_GetCurrentLocation::ReturnValue' has a wrong offset!");

// Function Zion.ElevatorMovementComponent.IsDirectionSetToDestination
// 0x0001 (0x0001 - 0x0000)
struct ElevatorMovementComponent_IsDirectionSetToDestination final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ElevatorMovementComponent_IsDirectionSetToDestination) == 0x000001, "Wrong alignment on ElevatorMovementComponent_IsDirectionSetToDestination");
static_assert(sizeof(ElevatorMovementComponent_IsDirectionSetToDestination) == 0x000001, "Wrong size on ElevatorMovementComponent_IsDirectionSetToDestination");
static_assert(offsetof(ElevatorMovementComponent_IsDirectionSetToDestination, ReturnValue) == 0x000000, "Member 'ElevatorMovementComponent_IsDirectionSetToDestination::ReturnValue' has a wrong offset!");

// Function Zion.ElevatorMovementComponent.IsMoving
// 0x0001 (0x0001 - 0x0000)
struct ElevatorMovementComponent_IsMoving final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ElevatorMovementComponent_IsMoving) == 0x000001, "Wrong alignment on ElevatorMovementComponent_IsMoving");
static_assert(sizeof(ElevatorMovementComponent_IsMoving) == 0x000001, "Wrong size on ElevatorMovementComponent_IsMoving");
static_assert(offsetof(ElevatorMovementComponent_IsMoving, ReturnValue) == 0x000000, "Member 'ElevatorMovementComponent_IsMoving::ReturnValue' has a wrong offset!");

// Function Zion.ElevatorStateManagerComponent.Get
// 0x0010 (0x0010 - 0x0000)
struct ElevatorStateManagerComponent_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UElevatorStateManagerComponent*         ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ElevatorStateManagerComponent_Get) == 0x000008, "Wrong alignment on ElevatorStateManagerComponent_Get");
static_assert(sizeof(ElevatorStateManagerComponent_Get) == 0x000010, "Wrong size on ElevatorStateManagerComponent_Get");
static_assert(offsetof(ElevatorStateManagerComponent_Get, WorldContextObject) == 0x000000, "Member 'ElevatorStateManagerComponent_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ElevatorStateManagerComponent_Get, ReturnValue) == 0x000008, "Member 'ElevatorStateManagerComponent_Get::ReturnValue' has a wrong offset!");

// Function Zion.ElevatorStateManagerComponent.RegisterElevatorState
// 0x0010 (0x0010 - 0x0000)
struct ElevatorStateManagerComponent_RegisterElevatorState final
{
public:
	const class AMovingPlatform_Elevator*         ElevatorActor;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EElevatorState                                ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ElevatorStateManagerComponent_RegisterElevatorState) == 0x000008, "Wrong alignment on ElevatorStateManagerComponent_RegisterElevatorState");
static_assert(sizeof(ElevatorStateManagerComponent_RegisterElevatorState) == 0x000010, "Wrong size on ElevatorStateManagerComponent_RegisterElevatorState");
static_assert(offsetof(ElevatorStateManagerComponent_RegisterElevatorState, ElevatorActor) == 0x000000, "Member 'ElevatorStateManagerComponent_RegisterElevatorState::ElevatorActor' has a wrong offset!");
static_assert(offsetof(ElevatorStateManagerComponent_RegisterElevatorState, ReturnValue) == 0x000008, "Member 'ElevatorStateManagerComponent_RegisterElevatorState::ReturnValue' has a wrong offset!");

// Function Zion.ElevatorStateManagerComponent.GetElevatorState
// 0x0010 (0x0010 - 0x0000)
struct ElevatorStateManagerComponent_GetElevatorState final
{
public:
	const class AMovingPlatform_Elevator*         ElevatorActor;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EElevatorState                                ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ElevatorStateManagerComponent_GetElevatorState) == 0x000008, "Wrong alignment on ElevatorStateManagerComponent_GetElevatorState");
static_assert(sizeof(ElevatorStateManagerComponent_GetElevatorState) == 0x000010, "Wrong size on ElevatorStateManagerComponent_GetElevatorState");
static_assert(offsetof(ElevatorStateManagerComponent_GetElevatorState, ElevatorActor) == 0x000000, "Member 'ElevatorStateManagerComponent_GetElevatorState::ElevatorActor' has a wrong offset!");
static_assert(offsetof(ElevatorStateManagerComponent_GetElevatorState, ReturnValue) == 0x000008, "Member 'ElevatorStateManagerComponent_GetElevatorState::ReturnValue' has a wrong offset!");

// Function Zion.EquipmentComponent.Equip
// 0x0010 (0x0010 - 0x0000)
struct EquipmentComponent_Equip final
{
public:
	EEquipmentSlot                                EquipmentSlot;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EquipmentID;                                       // 0x0004(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrentLoadout;                              // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EquipmentComponent_Equip) == 0x000004, "Wrong alignment on EquipmentComponent_Equip");
static_assert(sizeof(EquipmentComponent_Equip) == 0x000010, "Wrong size on EquipmentComponent_Equip");
static_assert(offsetof(EquipmentComponent_Equip, EquipmentSlot) == 0x000000, "Member 'EquipmentComponent_Equip::EquipmentSlot' has a wrong offset!");
static_assert(offsetof(EquipmentComponent_Equip, EquipmentID) == 0x000004, "Member 'EquipmentComponent_Equip::EquipmentID' has a wrong offset!");
static_assert(offsetof(EquipmentComponent_Equip, bAddToCurrentLoadout) == 0x00000C, "Member 'EquipmentComponent_Equip::bAddToCurrentLoadout' has a wrong offset!");

// Function Zion.EquipmentComponent.EquipEquipmentLoadout
// 0x0004 (0x0004 - 0x0000)
struct EquipmentComponent_EquipEquipmentLoadout final
{
public:
	int32                                         LoadoutIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentComponent_EquipEquipmentLoadout) == 0x000004, "Wrong alignment on EquipmentComponent_EquipEquipmentLoadout");
static_assert(sizeof(EquipmentComponent_EquipEquipmentLoadout) == 0x000004, "Wrong size on EquipmentComponent_EquipEquipmentLoadout");
static_assert(offsetof(EquipmentComponent_EquipEquipmentLoadout, LoadoutIndex) == 0x000000, "Member 'EquipmentComponent_EquipEquipmentLoadout::LoadoutIndex' has a wrong offset!");

// Function Zion.EquipmentComponent.OnPossessedPawnChanged
// 0x0010 (0x0010 - 0x0000)
struct EquipmentComponent_OnPossessedPawnChanged final
{
public:
	class APawn*                                  OldPawn;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  NewPawn;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentComponent_OnPossessedPawnChanged) == 0x000008, "Wrong alignment on EquipmentComponent_OnPossessedPawnChanged");
static_assert(sizeof(EquipmentComponent_OnPossessedPawnChanged) == 0x000010, "Wrong size on EquipmentComponent_OnPossessedPawnChanged");
static_assert(offsetof(EquipmentComponent_OnPossessedPawnChanged, OldPawn) == 0x000000, "Member 'EquipmentComponent_OnPossessedPawnChanged::OldPawn' has a wrong offset!");
static_assert(offsetof(EquipmentComponent_OnPossessedPawnChanged, NewPawn) == 0x000008, "Member 'EquipmentComponent_OnPossessedPawnChanged::NewPawn' has a wrong offset!");

// Function Zion.EquipmentComponent.UnEquip
// 0x0002 (0x0002 - 0x0000)
struct EquipmentComponent_UnEquip final
{
public:
	EEquipmentSlot                                EquipmentSlot;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveFromCurrentLoadout;                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentComponent_UnEquip) == 0x000001, "Wrong alignment on EquipmentComponent_UnEquip");
static_assert(sizeof(EquipmentComponent_UnEquip) == 0x000002, "Wrong size on EquipmentComponent_UnEquip");
static_assert(offsetof(EquipmentComponent_UnEquip, EquipmentSlot) == 0x000000, "Member 'EquipmentComponent_UnEquip::EquipmentSlot' has a wrong offset!");
static_assert(offsetof(EquipmentComponent_UnEquip, bRemoveFromCurrentLoadout) == 0x000001, "Member 'EquipmentComponent_UnEquip::bRemoveFromCurrentLoadout' has a wrong offset!");

// Function Zion.EquipmentComponent.UnEquipAll
// 0x0001 (0x0001 - 0x0000)
struct EquipmentComponent_UnEquipAll final
{
public:
	bool                                          bRemoveFromCurrentLoadout;                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentComponent_UnEquipAll) == 0x000001, "Wrong alignment on EquipmentComponent_UnEquipAll");
static_assert(sizeof(EquipmentComponent_UnEquipAll) == 0x000001, "Wrong size on EquipmentComponent_UnEquipAll");
static_assert(offsetof(EquipmentComponent_UnEquipAll, bRemoveFromCurrentLoadout) == 0x000000, "Member 'EquipmentComponent_UnEquipAll::bRemoveFromCurrentLoadout' has a wrong offset!");

// Function Zion.EquipmentComponent.GetCurrentEquipmentLoadoutIndex
// 0x0004 (0x0004 - 0x0000)
struct EquipmentComponent_GetCurrentEquipmentLoadoutIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentComponent_GetCurrentEquipmentLoadoutIndex) == 0x000004, "Wrong alignment on EquipmentComponent_GetCurrentEquipmentLoadoutIndex");
static_assert(sizeof(EquipmentComponent_GetCurrentEquipmentLoadoutIndex) == 0x000004, "Wrong size on EquipmentComponent_GetCurrentEquipmentLoadoutIndex");
static_assert(offsetof(EquipmentComponent_GetCurrentEquipmentLoadoutIndex, ReturnValue) == 0x000000, "Member 'EquipmentComponent_GetCurrentEquipmentLoadoutIndex::ReturnValue' has a wrong offset!");

// Function Zion.EquipmentComponent.GetEquipmentDataFromID
// 0x01F0 (0x01F0 - 0x0000)
struct EquipmentComponent_GetEquipmentDataFromID final
{
public:
	class FName                                   EquipmentID;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInventoryItemEquipmentData            ReturnValue;                                       // 0x0008(0x01E8)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentComponent_GetEquipmentDataFromID) == 0x000008, "Wrong alignment on EquipmentComponent_GetEquipmentDataFromID");
static_assert(sizeof(EquipmentComponent_GetEquipmentDataFromID) == 0x0001F0, "Wrong size on EquipmentComponent_GetEquipmentDataFromID");
static_assert(offsetof(EquipmentComponent_GetEquipmentDataFromID, EquipmentID) == 0x000000, "Member 'EquipmentComponent_GetEquipmentDataFromID::EquipmentID' has a wrong offset!");
static_assert(offsetof(EquipmentComponent_GetEquipmentDataFromID, ReturnValue) == 0x000008, "Member 'EquipmentComponent_GetEquipmentDataFromID::ReturnValue' has a wrong offset!");

// Function Zion.EquipmentComponent.GetEquipmentDataFromSlot
// 0x01F0 (0x01F0 - 0x0000)
struct EquipmentComponent_GetEquipmentDataFromSlot final
{
public:
	EEquipmentSlot                                EquipmentSlot;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryItemEquipmentData            ReturnValue;                                       // 0x0008(0x01E8)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentComponent_GetEquipmentDataFromSlot) == 0x000008, "Wrong alignment on EquipmentComponent_GetEquipmentDataFromSlot");
static_assert(sizeof(EquipmentComponent_GetEquipmentDataFromSlot) == 0x0001F0, "Wrong size on EquipmentComponent_GetEquipmentDataFromSlot");
static_assert(offsetof(EquipmentComponent_GetEquipmentDataFromSlot, EquipmentSlot) == 0x000000, "Member 'EquipmentComponent_GetEquipmentDataFromSlot::EquipmentSlot' has a wrong offset!");
static_assert(offsetof(EquipmentComponent_GetEquipmentDataFromSlot, ReturnValue) == 0x000008, "Member 'EquipmentComponent_GetEquipmentDataFromSlot::ReturnValue' has a wrong offset!");

// Function Zion.EquipmentComponent.GetEquipmentIDFromSlot
// 0x000C (0x000C - 0x0000)
struct EquipmentComponent_GetEquipmentIDFromSlot final
{
public:
	EEquipmentSlot                                EquipmentSlot;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentComponent_GetEquipmentIDFromSlot) == 0x000004, "Wrong alignment on EquipmentComponent_GetEquipmentIDFromSlot");
static_assert(sizeof(EquipmentComponent_GetEquipmentIDFromSlot) == 0x00000C, "Wrong size on EquipmentComponent_GetEquipmentIDFromSlot");
static_assert(offsetof(EquipmentComponent_GetEquipmentIDFromSlot, EquipmentSlot) == 0x000000, "Member 'EquipmentComponent_GetEquipmentIDFromSlot::EquipmentSlot' has a wrong offset!");
static_assert(offsetof(EquipmentComponent_GetEquipmentIDFromSlot, ReturnValue) == 0x000004, "Member 'EquipmentComponent_GetEquipmentIDFromSlot::ReturnValue' has a wrong offset!");

// Function Zion.EquipmentComponent.IsEquipped
// 0x000C (0x000C - 0x0000)
struct EquipmentComponent_IsEquipped final
{
public:
	class FName                                   EquipmentID;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EquipmentComponent_IsEquipped) == 0x000004, "Wrong alignment on EquipmentComponent_IsEquipped");
static_assert(sizeof(EquipmentComponent_IsEquipped) == 0x00000C, "Wrong size on EquipmentComponent_IsEquipped");
static_assert(offsetof(EquipmentComponent_IsEquipped, EquipmentID) == 0x000000, "Member 'EquipmentComponent_IsEquipped::EquipmentID' has a wrong offset!");
static_assert(offsetof(EquipmentComponent_IsEquipped, ReturnValue) == 0x000008, "Member 'EquipmentComponent_IsEquipped::ReturnValue' has a wrong offset!");

// Function Zion.EquipmentComponent.IsEquippedOnSlot
// 0x0010 (0x0010 - 0x0000)
struct EquipmentComponent_IsEquippedOnSlot final
{
public:
	EEquipmentSlot                                EquipmentSlot;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EquipmentID;                                       // 0x0004(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EquipmentComponent_IsEquippedOnSlot) == 0x000004, "Wrong alignment on EquipmentComponent_IsEquippedOnSlot");
static_assert(sizeof(EquipmentComponent_IsEquippedOnSlot) == 0x000010, "Wrong size on EquipmentComponent_IsEquippedOnSlot");
static_assert(offsetof(EquipmentComponent_IsEquippedOnSlot, EquipmentSlot) == 0x000000, "Member 'EquipmentComponent_IsEquippedOnSlot::EquipmentSlot' has a wrong offset!");
static_assert(offsetof(EquipmentComponent_IsEquippedOnSlot, EquipmentID) == 0x000004, "Member 'EquipmentComponent_IsEquippedOnSlot::EquipmentID' has a wrong offset!");
static_assert(offsetof(EquipmentComponent_IsEquippedOnSlot, ReturnValue) == 0x00000C, "Member 'EquipmentComponent_IsEquippedOnSlot::ReturnValue' has a wrong offset!");

// Function Zion.EventAction_PlayFX.OnSystemCompleted
// 0x0008 (0x0008 - 0x0000)
struct EventAction_PlayFX_OnSystemCompleted final
{
public:
	class UNiagaraComponent*                      PSystem;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EventAction_PlayFX_OnSystemCompleted) == 0x000008, "Wrong alignment on EventAction_PlayFX_OnSystemCompleted");
static_assert(sizeof(EventAction_PlayFX_OnSystemCompleted) == 0x000008, "Wrong size on EventAction_PlayFX_OnSystemCompleted");
static_assert(offsetof(EventAction_PlayFX_OnSystemCompleted, PSystem) == 0x000000, "Member 'EventAction_PlayFX_OnSystemCompleted::PSystem' has a wrong offset!");

// Function Zion.EventAction_SaveGame.OnSaveFinished
// 0x0001 (0x0001 - 0x0000)
struct EventAction_SaveGame_OnSaveFinished final
{
public:
	bool                                          bResult;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EventAction_SaveGame_OnSaveFinished) == 0x000001, "Wrong alignment on EventAction_SaveGame_OnSaveFinished");
static_assert(sizeof(EventAction_SaveGame_OnSaveFinished) == 0x000001, "Wrong size on EventAction_SaveGame_OnSaveFinished");
static_assert(offsetof(EventAction_SaveGame_OnSaveFinished, bResult) == 0x000000, "Member 'EventAction_SaveGame_OnSaveFinished::bResult' has a wrong offset!");

// Function Zion.EventAction_WaitMove.OnMoveCompleted
// 0x0008 (0x0008 - 0x0000)
struct EventAction_WaitMove_OnMoveCompleted final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EPathFollowingResult                          Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EventAction_WaitMove_OnMoveCompleted) == 0x000004, "Wrong alignment on EventAction_WaitMove_OnMoveCompleted");
static_assert(sizeof(EventAction_WaitMove_OnMoveCompleted) == 0x000008, "Wrong size on EventAction_WaitMove_OnMoveCompleted");
static_assert(offsetof(EventAction_WaitMove_OnMoveCompleted, RequestID) == 0x000000, "Member 'EventAction_WaitMove_OnMoveCompleted::RequestID' has a wrong offset!");
static_assert(offsetof(EventAction_WaitMove_OnMoveCompleted, Result) == 0x000004, "Member 'EventAction_WaitMove_OnMoveCompleted::Result' has a wrong offset!");

// Function Zion.EventBPFLibrary.AppendActorBindings
// 0x00A0 (0x00A0 - 0x0000)
struct EventBPFLibrary_AppendActorBindings final
{
public:
	TMap<class FName, class AActor*>              ActorBindings;                                     // 0x0000(0x0050)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TMap<class FName, class AActor*>              AdditionalBindings;                                // 0x0050(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EventBPFLibrary_AppendActorBindings) == 0x000008, "Wrong alignment on EventBPFLibrary_AppendActorBindings");
static_assert(sizeof(EventBPFLibrary_AppendActorBindings) == 0x0000A0, "Wrong size on EventBPFLibrary_AppendActorBindings");
static_assert(offsetof(EventBPFLibrary_AppendActorBindings, ActorBindings) == 0x000000, "Member 'EventBPFLibrary_AppendActorBindings::ActorBindings' has a wrong offset!");
static_assert(offsetof(EventBPFLibrary_AppendActorBindings, AdditionalBindings) == 0x000050, "Member 'EventBPFLibrary_AppendActorBindings::AdditionalBindings' has a wrong offset!");

// Function Zion.EventBPFLibrary.GenerateActorBindings
// 0x00F0 (0x00F0 - 0x0000)
struct EventBPFLibrary_GenerateActorBindings final
{
public:
	TMap<class FName, class AActor*>              ActorBindings;                                     // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TMap<class FName, class ASpawner*>            SpawnerBindings;                                   // 0x0050(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TMap<class FName, class AActor*>              ReturnValue;                                       // 0x00A0(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EventBPFLibrary_GenerateActorBindings) == 0x000008, "Wrong alignment on EventBPFLibrary_GenerateActorBindings");
static_assert(sizeof(EventBPFLibrary_GenerateActorBindings) == 0x0000F0, "Wrong size on EventBPFLibrary_GenerateActorBindings");
static_assert(offsetof(EventBPFLibrary_GenerateActorBindings, ActorBindings) == 0x000000, "Member 'EventBPFLibrary_GenerateActorBindings::ActorBindings' has a wrong offset!");
static_assert(offsetof(EventBPFLibrary_GenerateActorBindings, SpawnerBindings) == 0x000050, "Member 'EventBPFLibrary_GenerateActorBindings::SpawnerBindings' has a wrong offset!");
static_assert(offsetof(EventBPFLibrary_GenerateActorBindings, ReturnValue) == 0x0000A0, "Member 'EventBPFLibrary_GenerateActorBindings::ReturnValue' has a wrong offset!");

// Function Zion.EventBPFLibrary.GenerateActorBindingsFromSpawners
// 0x00A0 (0x00A0 - 0x0000)
struct EventBPFLibrary_GenerateActorBindingsFromSpawners final
{
public:
	TMap<class FName, class ASpawner*>            SpawnerBindings;                                   // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TMap<class FName, class AActor*>              ReturnValue;                                       // 0x0050(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EventBPFLibrary_GenerateActorBindingsFromSpawners) == 0x000008, "Wrong alignment on EventBPFLibrary_GenerateActorBindingsFromSpawners");
static_assert(sizeof(EventBPFLibrary_GenerateActorBindingsFromSpawners) == 0x0000A0, "Wrong size on EventBPFLibrary_GenerateActorBindingsFromSpawners");
static_assert(offsetof(EventBPFLibrary_GenerateActorBindingsFromSpawners, SpawnerBindings) == 0x000000, "Member 'EventBPFLibrary_GenerateActorBindingsFromSpawners::SpawnerBindings' has a wrong offset!");
static_assert(offsetof(EventBPFLibrary_GenerateActorBindingsFromSpawners, ReturnValue) == 0x000050, "Member 'EventBPFLibrary_GenerateActorBindingsFromSpawners::ReturnValue' has a wrong offset!");

// Function Zion.FadeSubsystem.LaunchFadeIn
// 0x0038 (0x0038 - 0x0000)
struct FadeSubsystem_LaunchFadeIn final
{
public:
	struct FFadeDescriptionData                   FadeDescription;                                   // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnFadeFinishedDelegate;                            // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFadeLayer                                    FadeLayer;                                         // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FadeSubsystem_LaunchFadeIn) == 0x000008, "Wrong alignment on FadeSubsystem_LaunchFadeIn");
static_assert(sizeof(FadeSubsystem_LaunchFadeIn) == 0x000038, "Wrong size on FadeSubsystem_LaunchFadeIn");
static_assert(offsetof(FadeSubsystem_LaunchFadeIn, FadeDescription) == 0x000000, "Member 'FadeSubsystem_LaunchFadeIn::FadeDescription' has a wrong offset!");
static_assert(offsetof(FadeSubsystem_LaunchFadeIn, OnFadeFinishedDelegate) == 0x000020, "Member 'FadeSubsystem_LaunchFadeIn::OnFadeFinishedDelegate' has a wrong offset!");
static_assert(offsetof(FadeSubsystem_LaunchFadeIn, FadeLayer) == 0x000030, "Member 'FadeSubsystem_LaunchFadeIn::FadeLayer' has a wrong offset!");

// Function Zion.FadeSubsystem.LaunchFadeOut
// 0x0038 (0x0038 - 0x0000)
struct FadeSubsystem_LaunchFadeOut final
{
public:
	struct FFadeDescriptionData                   FadeDescription;                                   // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnFadeFinishedDelegate;                            // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFadeLayer                                    FadeLayer;                                         // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FadeSubsystem_LaunchFadeOut) == 0x000008, "Wrong alignment on FadeSubsystem_LaunchFadeOut");
static_assert(sizeof(FadeSubsystem_LaunchFadeOut) == 0x000038, "Wrong size on FadeSubsystem_LaunchFadeOut");
static_assert(offsetof(FadeSubsystem_LaunchFadeOut, FadeDescription) == 0x000000, "Member 'FadeSubsystem_LaunchFadeOut::FadeDescription' has a wrong offset!");
static_assert(offsetof(FadeSubsystem_LaunchFadeOut, OnFadeFinishedDelegate) == 0x000020, "Member 'FadeSubsystem_LaunchFadeOut::OnFadeFinishedDelegate' has a wrong offset!");
static_assert(offsetof(FadeSubsystem_LaunchFadeOut, FadeLayer) == 0x000030, "Member 'FadeSubsystem_LaunchFadeOut::FadeLayer' has a wrong offset!");

// Function Zion.FadeSubsystem.SetupFadeIn
// 0x0028 (0x0028 - 0x0000)
struct FadeSubsystem_SetupFadeIn final
{
public:
	struct FFadeDescriptionData                   FadeDescription;                                   // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	EFadeLayer                                    FadeLayer;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FadeSubsystem_SetupFadeIn) == 0x000008, "Wrong alignment on FadeSubsystem_SetupFadeIn");
static_assert(sizeof(FadeSubsystem_SetupFadeIn) == 0x000028, "Wrong size on FadeSubsystem_SetupFadeIn");
static_assert(offsetof(FadeSubsystem_SetupFadeIn, FadeDescription) == 0x000000, "Member 'FadeSubsystem_SetupFadeIn::FadeDescription' has a wrong offset!");
static_assert(offsetof(FadeSubsystem_SetupFadeIn, FadeLayer) == 0x000020, "Member 'FadeSubsystem_SetupFadeIn::FadeLayer' has a wrong offset!");

// Function Zion.FadeSubsystem.GetFadeState
// 0x0002 (0x0002 - 0x0000)
struct FadeSubsystem_GetFadeState final
{
public:
	EFadeLayer                                    FadeLayer;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFadeState                                    ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FadeSubsystem_GetFadeState) == 0x000001, "Wrong alignment on FadeSubsystem_GetFadeState");
static_assert(sizeof(FadeSubsystem_GetFadeState) == 0x000002, "Wrong size on FadeSubsystem_GetFadeState");
static_assert(offsetof(FadeSubsystem_GetFadeState, FadeLayer) == 0x000000, "Member 'FadeSubsystem_GetFadeState::FadeLayer' has a wrong offset!");
static_assert(offsetof(FadeSubsystem_GetFadeState, ReturnValue) == 0x000001, "Member 'FadeSubsystem_GetFadeState::ReturnValue' has a wrong offset!");

// Function Zion.FadeSubsystem.IsAnyFadeVisible
// 0x0001 (0x0001 - 0x0000)
struct FadeSubsystem_IsAnyFadeVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FadeSubsystem_IsAnyFadeVisible) == 0x000001, "Wrong alignment on FadeSubsystem_IsAnyFadeVisible");
static_assert(sizeof(FadeSubsystem_IsAnyFadeVisible) == 0x000001, "Wrong size on FadeSubsystem_IsAnyFadeVisible");
static_assert(offsetof(FadeSubsystem_IsAnyFadeVisible, ReturnValue) == 0x000000, "Member 'FadeSubsystem_IsAnyFadeVisible::ReturnValue' has a wrong offset!");

// Function Zion.FadeSubsystem.IsFadeVisible
// 0x0002 (0x0002 - 0x0000)
struct FadeSubsystem_IsFadeVisible final
{
public:
	EFadeLayer                                    FadeLayer;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FadeSubsystem_IsFadeVisible) == 0x000001, "Wrong alignment on FadeSubsystem_IsFadeVisible");
static_assert(sizeof(FadeSubsystem_IsFadeVisible) == 0x000002, "Wrong size on FadeSubsystem_IsFadeVisible");
static_assert(offsetof(FadeSubsystem_IsFadeVisible, FadeLayer) == 0x000000, "Member 'FadeSubsystem_IsFadeVisible::FadeLayer' has a wrong offset!");
static_assert(offsetof(FadeSubsystem_IsFadeVisible, ReturnValue) == 0x000001, "Member 'FadeSubsystem_IsFadeVisible::ReturnValue' has a wrong offset!");

// Function Zion.FadeSubsystem.IsFading
// 0x0002 (0x0002 - 0x0000)
struct FadeSubsystem_IsFading final
{
public:
	EFadeLayer                                    FadeLayer;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FadeSubsystem_IsFading) == 0x000001, "Wrong alignment on FadeSubsystem_IsFading");
static_assert(sizeof(FadeSubsystem_IsFading) == 0x000002, "Wrong size on FadeSubsystem_IsFading");
static_assert(offsetof(FadeSubsystem_IsFading, FadeLayer) == 0x000000, "Member 'FadeSubsystem_IsFading::FadeLayer' has a wrong offset!");
static_assert(offsetof(FadeSubsystem_IsFading, ReturnValue) == 0x000001, "Member 'FadeSubsystem_IsFading::ReturnValue' has a wrong offset!");

// Function Zion.FakeWall.Hide
// 0x0001 (0x0001 - 0x0000)
struct FakeWall_Hide final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FakeWall_Hide) == 0x000001, "Wrong alignment on FakeWall_Hide");
static_assert(sizeof(FakeWall_Hide) == 0x000001, "Wrong size on FakeWall_Hide");
static_assert(offsetof(FakeWall_Hide, bInstant) == 0x000000, "Member 'FakeWall_Hide::bInstant' has a wrong offset!");

// Function Zion.FakeWall.OnClearStatusChecked
// 0x0001 (0x0001 - 0x0000)
struct FakeWall_OnClearStatusChecked final
{
public:
	EClearStatus                                  ClearStatus;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FakeWall_OnClearStatusChecked) == 0x000001, "Wrong alignment on FakeWall_OnClearStatusChecked");
static_assert(sizeof(FakeWall_OnClearStatusChecked) == 0x000001, "Wrong size on FakeWall_OnClearStatusChecked");
static_assert(offsetof(FakeWall_OnClearStatusChecked, ClearStatus) == 0x000000, "Member 'FakeWall_OnClearStatusChecked::ClearStatus' has a wrong offset!");

// Function Zion.FakeWall.IsCleared
// 0x0001 (0x0001 - 0x0000)
struct FakeWall_IsCleared final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FakeWall_IsCleared) == 0x000001, "Wrong alignment on FakeWall_IsCleared");
static_assert(sizeof(FakeWall_IsCleared) == 0x000001, "Wrong size on FakeWall_IsCleared");
static_assert(offsetof(FakeWall_IsCleared, ReturnValue) == 0x000000, "Member 'FakeWall_IsCleared::ReturnValue' has a wrong offset!");

// Function Zion.FallDamageComponent.OnLandedCallback
// 0x00F8 (0x00F8 - 0x0000)
struct FallDamageComponent_OnLandedCallback final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FallDamageComponent_OnLandedCallback) == 0x000008, "Wrong alignment on FallDamageComponent_OnLandedCallback");
static_assert(sizeof(FallDamageComponent_OnLandedCallback) == 0x0000F8, "Wrong size on FallDamageComponent_OnLandedCallback");
static_assert(offsetof(FallDamageComponent_OnLandedCallback, Hit) == 0x000000, "Member 'FallDamageComponent_OnLandedCallback::Hit' has a wrong offset!");

// Function Zion.FallThroughComponent.FallThroughOneWayPlatform
// 0x0008 (0x0008 - 0x0000)
struct FallThroughComponent_FallThroughOneWayPlatform final
{
public:
	class AOneWayPlatform*                        OneWayPlatform;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FallThroughComponent_FallThroughOneWayPlatform) == 0x000008, "Wrong alignment on FallThroughComponent_FallThroughOneWayPlatform");
static_assert(sizeof(FallThroughComponent_FallThroughOneWayPlatform) == 0x000008, "Wrong size on FallThroughComponent_FallThroughOneWayPlatform");
static_assert(offsetof(FallThroughComponent_FallThroughOneWayPlatform, OneWayPlatform) == 0x000000, "Member 'FallThroughComponent_FallThroughOneWayPlatform::OneWayPlatform' has a wrong offset!");

// Function Zion.FieldMessageComponent.LaunchFieldMessage
// 0x0010 (0x0010 - 0x0000)
struct FieldMessageComponent_LaunchFieldMessage final
{
public:
	class AActor*                                 InTargetActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FieldMessageComponent_LaunchFieldMessage) == 0x000008, "Wrong alignment on FieldMessageComponent_LaunchFieldMessage");
static_assert(sizeof(FieldMessageComponent_LaunchFieldMessage) == 0x000010, "Wrong size on FieldMessageComponent_LaunchFieldMessage");
static_assert(offsetof(FieldMessageComponent_LaunchFieldMessage, InTargetActor) == 0x000000, "Member 'FieldMessageComponent_LaunchFieldMessage::InTargetActor' has a wrong offset!");
static_assert(offsetof(FieldMessageComponent_LaunchFieldMessage, ReturnValue) == 0x000008, "Member 'FieldMessageComponent_LaunchFieldMessage::ReturnValue' has a wrong offset!");

// Function Zion.FieldMessageComponent.SetMessageData
// 0x0008 (0x0008 - 0x0000)
struct FieldMessageComponent_SetMessageData final
{
public:
	class UFieldMessageAsset*                     MessageDataAsset;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FieldMessageComponent_SetMessageData) == 0x000008, "Wrong alignment on FieldMessageComponent_SetMessageData");
static_assert(sizeof(FieldMessageComponent_SetMessageData) == 0x000008, "Wrong size on FieldMessageComponent_SetMessageData");
static_assert(offsetof(FieldMessageComponent_SetMessageData, MessageDataAsset) == 0x000000, "Member 'FieldMessageComponent_SetMessageData::MessageDataAsset' has a wrong offset!");

// Function Zion.FieldMessageComponent.GetFieldMessageAsset
// 0x0008 (0x0008 - 0x0000)
struct FieldMessageComponent_GetFieldMessageAsset final
{
public:
	class UFieldMessageAsset*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FieldMessageComponent_GetFieldMessageAsset) == 0x000008, "Wrong alignment on FieldMessageComponent_GetFieldMessageAsset");
static_assert(sizeof(FieldMessageComponent_GetFieldMessageAsset) == 0x000008, "Wrong size on FieldMessageComponent_GetFieldMessageAsset");
static_assert(offsetof(FieldMessageComponent_GetFieldMessageAsset, ReturnValue) == 0x000000, "Member 'FieldMessageComponent_GetFieldMessageAsset::ReturnValue' has a wrong offset!");

// Function Zion.FieldMessageComponent.IsProcessingFieldMessage
// 0x0001 (0x0001 - 0x0000)
struct FieldMessageComponent_IsProcessingFieldMessage final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FieldMessageComponent_IsProcessingFieldMessage) == 0x000001, "Wrong alignment on FieldMessageComponent_IsProcessingFieldMessage");
static_assert(sizeof(FieldMessageComponent_IsProcessingFieldMessage) == 0x000001, "Wrong size on FieldMessageComponent_IsProcessingFieldMessage");
static_assert(offsetof(FieldMessageComponent_IsProcessingFieldMessage, ReturnValue) == 0x000000, "Member 'FieldMessageComponent_IsProcessingFieldMessage::ReturnValue' has a wrong offset!");

// Function Zion.FieldTalkComponent.StartFieldTalk
// 0x0010 (0x0010 - 0x0000)
struct FieldTalkComponent_StartFieldTalk final
{
public:
	class UFieldTalkAsset*                        FieldTalkAsset;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipActiveFieldTalkAsset;                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FieldTalkComponent_StartFieldTalk) == 0x000008, "Wrong alignment on FieldTalkComponent_StartFieldTalk");
static_assert(sizeof(FieldTalkComponent_StartFieldTalk) == 0x000010, "Wrong size on FieldTalkComponent_StartFieldTalk");
static_assert(offsetof(FieldTalkComponent_StartFieldTalk, FieldTalkAsset) == 0x000000, "Member 'FieldTalkComponent_StartFieldTalk::FieldTalkAsset' has a wrong offset!");
static_assert(offsetof(FieldTalkComponent_StartFieldTalk, bSkipActiveFieldTalkAsset) == 0x000008, "Member 'FieldTalkComponent_StartFieldTalk::bSkipActiveFieldTalkAsset' has a wrong offset!");
static_assert(offsetof(FieldTalkComponent_StartFieldTalk, ReturnValue) == 0x000009, "Member 'FieldTalkComponent_StartFieldTalk::ReturnValue' has a wrong offset!");

// Function Zion.FieldTalkComponent.CanStartFieldTalk
// 0x0001 (0x0001 - 0x0000)
struct FieldTalkComponent_CanStartFieldTalk final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FieldTalkComponent_CanStartFieldTalk) == 0x000001, "Wrong alignment on FieldTalkComponent_CanStartFieldTalk");
static_assert(sizeof(FieldTalkComponent_CanStartFieldTalk) == 0x000001, "Wrong size on FieldTalkComponent_CanStartFieldTalk");
static_assert(offsetof(FieldTalkComponent_CanStartFieldTalk, ReturnValue) == 0x000000, "Member 'FieldTalkComponent_CanStartFieldTalk::ReturnValue' has a wrong offset!");

// Function Zion.FluidBody.GenerateSplash
// 0x0028 (0x0028 - 0x0000)
struct FluidBody_GenerateSplash final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizePercent;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEntering;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLaunchFX;                                         // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FluidBody_GenerateSplash) == 0x000008, "Wrong alignment on FluidBody_GenerateSplash");
static_assert(sizeof(FluidBody_GenerateSplash) == 0x000028, "Wrong size on FluidBody_GenerateSplash");
static_assert(offsetof(FluidBody_GenerateSplash, WorldLocation) == 0x000000, "Member 'FluidBody_GenerateSplash::WorldLocation' has a wrong offset!");
static_assert(offsetof(FluidBody_GenerateSplash, Strength) == 0x000018, "Member 'FluidBody_GenerateSplash::Strength' has a wrong offset!");
static_assert(offsetof(FluidBody_GenerateSplash, SizePercent) == 0x00001C, "Member 'FluidBody_GenerateSplash::SizePercent' has a wrong offset!");
static_assert(offsetof(FluidBody_GenerateSplash, bEntering) == 0x000020, "Member 'FluidBody_GenerateSplash::bEntering' has a wrong offset!");
static_assert(offsetof(FluidBody_GenerateSplash, bLaunchFX) == 0x000021, "Member 'FluidBody_GenerateSplash::bLaunchFX' has a wrong offset!");

// Function Zion.FluidBody.OnBeginOverlapSurface
// 0x0118 (0x0118 - 0x0000)
struct FluidBody_OnBeginOverlapSurface final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBFromSweep;                                       // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FluidBody_OnBeginOverlapSurface) == 0x000008, "Wrong alignment on FluidBody_OnBeginOverlapSurface");
static_assert(sizeof(FluidBody_OnBeginOverlapSurface) == 0x000118, "Wrong size on FluidBody_OnBeginOverlapSurface");
static_assert(offsetof(FluidBody_OnBeginOverlapSurface, OverlappedComponent) == 0x000000, "Member 'FluidBody_OnBeginOverlapSurface::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(FluidBody_OnBeginOverlapSurface, OtherActor) == 0x000008, "Member 'FluidBody_OnBeginOverlapSurface::OtherActor' has a wrong offset!");
static_assert(offsetof(FluidBody_OnBeginOverlapSurface, OtherComp) == 0x000010, "Member 'FluidBody_OnBeginOverlapSurface::OtherComp' has a wrong offset!");
static_assert(offsetof(FluidBody_OnBeginOverlapSurface, OtherBodyIndex) == 0x000018, "Member 'FluidBody_OnBeginOverlapSurface::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(FluidBody_OnBeginOverlapSurface, bBFromSweep) == 0x00001C, "Member 'FluidBody_OnBeginOverlapSurface::bBFromSweep' has a wrong offset!");
static_assert(offsetof(FluidBody_OnBeginOverlapSurface, SweepResult) == 0x000020, "Member 'FluidBody_OnBeginOverlapSurface::SweepResult' has a wrong offset!");

// Function Zion.FluidBody.OnEndOverlapSurface
// 0x0020 (0x0020 - 0x0000)
struct FluidBody_OnEndOverlapSurface final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FluidBody_OnEndOverlapSurface) == 0x000008, "Wrong alignment on FluidBody_OnEndOverlapSurface");
static_assert(sizeof(FluidBody_OnEndOverlapSurface) == 0x000020, "Wrong size on FluidBody_OnEndOverlapSurface");
static_assert(offsetof(FluidBody_OnEndOverlapSurface, OverlappedComponent) == 0x000000, "Member 'FluidBody_OnEndOverlapSurface::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(FluidBody_OnEndOverlapSurface, OtherActor) == 0x000008, "Member 'FluidBody_OnEndOverlapSurface::OtherActor' has a wrong offset!");
static_assert(offsetof(FluidBody_OnEndOverlapSurface, OtherComp) == 0x000010, "Member 'FluidBody_OnEndOverlapSurface::OtherComp' has a wrong offset!");
static_assert(offsetof(FluidBody_OnEndOverlapSurface, OtherBodyIndex) == 0x000018, "Member 'FluidBody_OnEndOverlapSurface::OtherBodyIndex' has a wrong offset!");

// Function Zion.FluidSimulationComponent.GenerateSplash
// 0x0020 (0x0020 - 0x0000)
struct FluidSimulationComponent_GenerateSplash final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizePercent;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FluidSimulationComponent_GenerateSplash) == 0x000008, "Wrong alignment on FluidSimulationComponent_GenerateSplash");
static_assert(sizeof(FluidSimulationComponent_GenerateSplash) == 0x000020, "Wrong size on FluidSimulationComponent_GenerateSplash");
static_assert(offsetof(FluidSimulationComponent_GenerateSplash, WorldLocation) == 0x000000, "Member 'FluidSimulationComponent_GenerateSplash::WorldLocation' has a wrong offset!");
static_assert(offsetof(FluidSimulationComponent_GenerateSplash, Strength) == 0x000018, "Member 'FluidSimulationComponent_GenerateSplash::Strength' has a wrong offset!");
static_assert(offsetof(FluidSimulationComponent_GenerateSplash, SizePercent) == 0x00001C, "Member 'FluidSimulationComponent_GenerateSplash::SizePercent' has a wrong offset!");

// Function Zion.FogOfWarComponent.ClearMapFogOfWar
// 0x0008 (0x0008 - 0x0000)
struct FogOfWarComponent_ClearMapFogOfWar final
{
public:
	class FName                                   MapName;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FogOfWarComponent_ClearMapFogOfWar) == 0x000004, "Wrong alignment on FogOfWarComponent_ClearMapFogOfWar");
static_assert(sizeof(FogOfWarComponent_ClearMapFogOfWar) == 0x000008, "Wrong size on FogOfWarComponent_ClearMapFogOfWar");
static_assert(offsetof(FogOfWarComponent_ClearMapFogOfWar, MapName) == 0x000000, "Member 'FogOfWarComponent_ClearMapFogOfWar::MapName' has a wrong offset!");

// Function Zion.FogOfWarComponent.ResetMapFogOfWar
// 0x0008 (0x0008 - 0x0000)
struct FogOfWarComponent_ResetMapFogOfWar final
{
public:
	class FName                                   MapName;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FogOfWarComponent_ResetMapFogOfWar) == 0x000004, "Wrong alignment on FogOfWarComponent_ResetMapFogOfWar");
static_assert(sizeof(FogOfWarComponent_ResetMapFogOfWar) == 0x000008, "Wrong size on FogOfWarComponent_ResetMapFogOfWar");
static_assert(offsetof(FogOfWarComponent_ResetMapFogOfWar, MapName) == 0x000000, "Member 'FogOfWarComponent_ResetMapFogOfWar::MapName' has a wrong offset!");

// Function Zion.FollowGeometryMovementComponent.SetSpeedFactor
// 0x0004 (0x0004 - 0x0000)
struct FollowGeometryMovementComponent_SetSpeedFactor final
{
public:
	float                                         NewSpeedFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FollowGeometryMovementComponent_SetSpeedFactor) == 0x000004, "Wrong alignment on FollowGeometryMovementComponent_SetSpeedFactor");
static_assert(sizeof(FollowGeometryMovementComponent_SetSpeedFactor) == 0x000004, "Wrong size on FollowGeometryMovementComponent_SetSpeedFactor");
static_assert(offsetof(FollowGeometryMovementComponent_SetSpeedFactor, NewSpeedFactor) == 0x000000, "Member 'FollowGeometryMovementComponent_SetSpeedFactor::NewSpeedFactor' has a wrong offset!");

// Function Zion.FollowGeometryMovementComponent.GetSpeedFactor
// 0x0004 (0x0004 - 0x0000)
struct FollowGeometryMovementComponent_GetSpeedFactor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FollowGeometryMovementComponent_GetSpeedFactor) == 0x000004, "Wrong alignment on FollowGeometryMovementComponent_GetSpeedFactor");
static_assert(sizeof(FollowGeometryMovementComponent_GetSpeedFactor) == 0x000004, "Wrong size on FollowGeometryMovementComponent_GetSpeedFactor");
static_assert(offsetof(FollowGeometryMovementComponent_GetSpeedFactor, ReturnValue) == 0x000000, "Member 'FollowGeometryMovementComponent_GetSpeedFactor::ReturnValue' has a wrong offset!");

// Function Zion.FollowGeometryMovementComponent.IsMoving
// 0x0001 (0x0001 - 0x0000)
struct FollowGeometryMovementComponent_IsMoving final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FollowGeometryMovementComponent_IsMoving) == 0x000001, "Wrong alignment on FollowGeometryMovementComponent_IsMoving");
static_assert(sizeof(FollowGeometryMovementComponent_IsMoving) == 0x000001, "Wrong size on FollowGeometryMovementComponent_IsMoving");
static_assert(offsetof(FollowGeometryMovementComponent_IsMoving, ReturnValue) == 0x000000, "Member 'FollowGeometryMovementComponent_IsMoving::ReturnValue' has a wrong offset!");

// Function Zion.FollowTargetComponent.SetFollowTarget
// 0x0010 (0x0010 - 0x0000)
struct FollowTargetComponent_SetFollowTarget final
{
public:
	class USceneComponent*                        NewFollowTarget;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapToTarget;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FollowTargetComponent_SetFollowTarget) == 0x000008, "Wrong alignment on FollowTargetComponent_SetFollowTarget");
static_assert(sizeof(FollowTargetComponent_SetFollowTarget) == 0x000010, "Wrong size on FollowTargetComponent_SetFollowTarget");
static_assert(offsetof(FollowTargetComponent_SetFollowTarget, NewFollowTarget) == 0x000000, "Member 'FollowTargetComponent_SetFollowTarget::NewFollowTarget' has a wrong offset!");
static_assert(offsetof(FollowTargetComponent_SetFollowTarget, bSnapToTarget) == 0x000008, "Member 'FollowTargetComponent_SetFollowTarget::bSnapToTarget' has a wrong offset!");

// Function Zion.FollowTargetComponent.GetFollowTarget
// 0x0008 (0x0008 - 0x0000)
struct FollowTargetComponent_GetFollowTarget final
{
public:
	class USceneComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FollowTargetComponent_GetFollowTarget) == 0x000008, "Wrong alignment on FollowTargetComponent_GetFollowTarget");
static_assert(sizeof(FollowTargetComponent_GetFollowTarget) == 0x000008, "Wrong size on FollowTargetComponent_GetFollowTarget");
static_assert(offsetof(FollowTargetComponent_GetFollowTarget, ReturnValue) == 0x000000, "Member 'FollowTargetComponent_GetFollowTarget::ReturnValue' has a wrong offset!");

// Function Zion.FollowTargetComponent.GetFollowTargetDeltaLocation
// 0x0018 (0x0018 - 0x0000)
struct FollowTargetComponent_GetFollowTargetDeltaLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FollowTargetComponent_GetFollowTargetDeltaLocation) == 0x000008, "Wrong alignment on FollowTargetComponent_GetFollowTargetDeltaLocation");
static_assert(sizeof(FollowTargetComponent_GetFollowTargetDeltaLocation) == 0x000018, "Wrong size on FollowTargetComponent_GetFollowTargetDeltaLocation");
static_assert(offsetof(FollowTargetComponent_GetFollowTargetDeltaLocation, ReturnValue) == 0x000000, "Member 'FollowTargetComponent_GetFollowTargetDeltaLocation::ReturnValue' has a wrong offset!");

// Function Zion.FollowTargetComponent.GetFollowTargetForward
// 0x0018 (0x0018 - 0x0000)
struct FollowTargetComponent_GetFollowTargetForward final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FollowTargetComponent_GetFollowTargetForward) == 0x000008, "Wrong alignment on FollowTargetComponent_GetFollowTargetForward");
static_assert(sizeof(FollowTargetComponent_GetFollowTargetForward) == 0x000018, "Wrong size on FollowTargetComponent_GetFollowTargetForward");
static_assert(offsetof(FollowTargetComponent_GetFollowTargetForward, ReturnValue) == 0x000000, "Member 'FollowTargetComponent_GetFollowTargetForward::ReturnValue' has a wrong offset!");

// Function Zion.FollowTargetComponent.GetFollowTargetLocation
// 0x0018 (0x0018 - 0x0000)
struct FollowTargetComponent_GetFollowTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FollowTargetComponent_GetFollowTargetLocation) == 0x000008, "Wrong alignment on FollowTargetComponent_GetFollowTargetLocation");
static_assert(sizeof(FollowTargetComponent_GetFollowTargetLocation) == 0x000018, "Wrong size on FollowTargetComponent_GetFollowTargetLocation");
static_assert(offsetof(FollowTargetComponent_GetFollowTargetLocation, ReturnValue) == 0x000000, "Member 'FollowTargetComponent_GetFollowTargetLocation::ReturnValue' has a wrong offset!");

// Function Zion.FollowTargetComponent.GetTargetLocation
// 0x0020 (0x0020 - 0x0000)
struct FollowTargetComponent_GetTargetLocation final
{
public:
	const class USceneComponent*                  PinnedTarget;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FollowTargetComponent_GetTargetLocation) == 0x000008, "Wrong alignment on FollowTargetComponent_GetTargetLocation");
static_assert(sizeof(FollowTargetComponent_GetTargetLocation) == 0x000020, "Wrong size on FollowTargetComponent_GetTargetLocation");
static_assert(offsetof(FollowTargetComponent_GetTargetLocation, PinnedTarget) == 0x000000, "Member 'FollowTargetComponent_GetTargetLocation::PinnedTarget' has a wrong offset!");
static_assert(offsetof(FollowTargetComponent_GetTargetLocation, ReturnValue) == 0x000008, "Member 'FollowTargetComponent_GetTargetLocation::ReturnValue' has a wrong offset!");

// Function Zion.FootIKComponent.OnAnimationStart
// 0x0008 (0x0008 - 0x0000)
struct FootIKComponent_OnAnimationStart final
{
public:
	class UTrackEntry*                            TrackEntry;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FootIKComponent_OnAnimationStart) == 0x000008, "Wrong alignment on FootIKComponent_OnAnimationStart");
static_assert(sizeof(FootIKComponent_OnAnimationStart) == 0x000008, "Wrong size on FootIKComponent_OnAnimationStart");
static_assert(offsetof(FootIKComponent_OnAnimationStart, TrackEntry) == 0x000000, "Member 'FootIKComponent_OnAnimationStart::TrackEntry' has a wrong offset!");

// Function Zion.FootIKComponent.OnBeforeUpdateWorldTransform
// 0x0008 (0x0008 - 0x0000)
struct FootIKComponent_OnBeforeUpdateWorldTransform final
{
public:
	class USpineSkeletonComponent*                Skeleton;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FootIKComponent_OnBeforeUpdateWorldTransform) == 0x000008, "Wrong alignment on FootIKComponent_OnBeforeUpdateWorldTransform");
static_assert(sizeof(FootIKComponent_OnBeforeUpdateWorldTransform) == 0x000008, "Wrong size on FootIKComponent_OnBeforeUpdateWorldTransform");
static_assert(offsetof(FootIKComponent_OnBeforeUpdateWorldTransform, Skeleton) == 0x000000, "Member 'FootIKComponent_OnBeforeUpdateWorldTransform::Skeleton' has a wrong offset!");

// Function Zion.GameEngineZion.Get
// 0x0008 (0x0008 - 0x0000)
struct GameEngineZion_Get final
{
public:
	class UGameEngineZion*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameEngineZion_Get) == 0x000008, "Wrong alignment on GameEngineZion_Get");
static_assert(sizeof(GameEngineZion_Get) == 0x000008, "Wrong size on GameEngineZion_Get");
static_assert(offsetof(GameEngineZion_Get, ReturnValue) == 0x000000, "Member 'GameEngineZion_Get::ReturnValue' has a wrong offset!");

// Function Zion.GameInstanceZion.Get
// 0x0010 (0x0010 - 0x0000)
struct GameInstanceZion_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameInstanceZion*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInstanceZion_Get) == 0x000008, "Wrong alignment on GameInstanceZion_Get");
static_assert(sizeof(GameInstanceZion_Get) == 0x000010, "Wrong size on GameInstanceZion_Get");
static_assert(offsetof(GameInstanceZion_Get, WorldContextObject) == 0x000000, "Member 'GameInstanceZion_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameInstanceZion_Get, ReturnValue) == 0x000008, "Member 'GameInstanceZion_Get::ReturnValue' has a wrong offset!");

// Function Zion.GameInstanceZion.HandleSettingsDelegate
// 0x0008 (0x0008 - 0x0000)
struct GameInstanceZion_HandleSettingsDelegate final
{
public:
	class USentrySettings*                        Settings;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInstanceZion_HandleSettingsDelegate) == 0x000008, "Wrong alignment on GameInstanceZion_HandleSettingsDelegate");
static_assert(sizeof(GameInstanceZion_HandleSettingsDelegate) == 0x000008, "Wrong size on GameInstanceZion_HandleSettingsDelegate");
static_assert(offsetof(GameInstanceZion_HandleSettingsDelegate, Settings) == 0x000000, "Member 'GameInstanceZion_HandleSettingsDelegate::Settings' has a wrong offset!");

// Function Zion.GameInstanceZion.SetLaunchGameIntent
// 0x0001 (0x0001 - 0x0000)
struct GameInstanceZion_SetLaunchGameIntent final
{
public:
	ELaunchGameIntent                             NewLaunchGameIntent;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInstanceZion_SetLaunchGameIntent) == 0x000001, "Wrong alignment on GameInstanceZion_SetLaunchGameIntent");
static_assert(sizeof(GameInstanceZion_SetLaunchGameIntent) == 0x000001, "Wrong size on GameInstanceZion_SetLaunchGameIntent");
static_assert(offsetof(GameInstanceZion_SetLaunchGameIntent, NewLaunchGameIntent) == 0x000000, "Member 'GameInstanceZion_SetLaunchGameIntent::NewLaunchGameIntent' has a wrong offset!");

// Function Zion.GameInstanceZion.GetLaunchGameIntent
// 0x0001 (0x0001 - 0x0000)
struct GameInstanceZion_GetLaunchGameIntent final
{
public:
	ELaunchGameIntent                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInstanceZion_GetLaunchGameIntent) == 0x000001, "Wrong alignment on GameInstanceZion_GetLaunchGameIntent");
static_assert(sizeof(GameInstanceZion_GetLaunchGameIntent) == 0x000001, "Wrong size on GameInstanceZion_GetLaunchGameIntent");
static_assert(offsetof(GameInstanceZion_GetLaunchGameIntent, ReturnValue) == 0x000000, "Member 'GameInstanceZion_GetLaunchGameIntent::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.CanUnlockAnySkillLevel
// 0x0010 (0x0010 - 0x0000)
struct GameLogicBPFLibrary_CanUnlockAnySkillLevel final
{
public:
	const class UInventoryComponent*              InventoryComponent;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_CanUnlockAnySkillLevel) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_CanUnlockAnySkillLevel");
static_assert(sizeof(GameLogicBPFLibrary_CanUnlockAnySkillLevel) == 0x000010, "Wrong size on GameLogicBPFLibrary_CanUnlockAnySkillLevel");
static_assert(offsetof(GameLogicBPFLibrary_CanUnlockAnySkillLevel, InventoryComponent) == 0x000000, "Member 'GameLogicBPFLibrary_CanUnlockAnySkillLevel::InventoryComponent' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_CanUnlockAnySkillLevel, ReturnValue) == 0x000008, "Member 'GameLogicBPFLibrary_CanUnlockAnySkillLevel::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.CanUnlockSkillLevel
// 0x0020 (0x0020 - 0x0000)
struct GameLogicBPFLibrary_CanUnlockSkillLevel final
{
public:
	const class UInventoryComponent*              InventoryComponent;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    SkillHandle;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillUnlockResultType                        ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_CanUnlockSkillLevel) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_CanUnlockSkillLevel");
static_assert(sizeof(GameLogicBPFLibrary_CanUnlockSkillLevel) == 0x000020, "Wrong size on GameLogicBPFLibrary_CanUnlockSkillLevel");
static_assert(offsetof(GameLogicBPFLibrary_CanUnlockSkillLevel, InventoryComponent) == 0x000000, "Member 'GameLogicBPFLibrary_CanUnlockSkillLevel::InventoryComponent' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_CanUnlockSkillLevel, SkillHandle) == 0x000008, "Member 'GameLogicBPFLibrary_CanUnlockSkillLevel::SkillHandle' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_CanUnlockSkillLevel, Level) == 0x000018, "Member 'GameLogicBPFLibrary_CanUnlockSkillLevel::Level' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_CanUnlockSkillLevel, ReturnValue) == 0x00001C, "Member 'GameLogicBPFLibrary_CanUnlockSkillLevel::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.CheckGameplayConditions
// 0x0028 (0x0028 - 0x0000)
struct GameLogicBPFLibrary_CheckGameplayConditions final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayConditionChecker              GameplayConditions;                                // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_CheckGameplayConditions) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_CheckGameplayConditions");
static_assert(sizeof(GameLogicBPFLibrary_CheckGameplayConditions) == 0x000028, "Wrong size on GameLogicBPFLibrary_CheckGameplayConditions");
static_assert(offsetof(GameLogicBPFLibrary_CheckGameplayConditions, PlayerController) == 0x000000, "Member 'GameLogicBPFLibrary_CheckGameplayConditions::PlayerController' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_CheckGameplayConditions, GameplayConditions) == 0x000008, "Member 'GameLogicBPFLibrary_CheckGameplayConditions::GameplayConditions' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_CheckGameplayConditions, ReturnValue) == 0x000020, "Member 'GameLogicBPFLibrary_CheckGameplayConditions::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.CheckItemConditions
// 0x0048 (0x0048 - 0x0000)
struct GameLogicBPFLibrary_CheckItemConditions final
{
public:
	class APlayerControllerZion*                  PlayerControllerZion;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemConditionData                     ItemConditionData;                                 // 0x0008(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_CheckItemConditions) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_CheckItemConditions");
static_assert(sizeof(GameLogicBPFLibrary_CheckItemConditions) == 0x000048, "Wrong size on GameLogicBPFLibrary_CheckItemConditions");
static_assert(offsetof(GameLogicBPFLibrary_CheckItemConditions, PlayerControllerZion) == 0x000000, "Member 'GameLogicBPFLibrary_CheckItemConditions::PlayerControllerZion' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_CheckItemConditions, ItemConditionData) == 0x000008, "Member 'GameLogicBPFLibrary_CheckItemConditions::ItemConditionData' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_CheckItemConditions, ReturnValue) == 0x000040, "Member 'GameLogicBPFLibrary_CheckItemConditions::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.GetEquipLoadoutCount
// 0x0004 (0x0004 - 0x0000)
struct GameLogicBPFLibrary_GetEquipLoadoutCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicBPFLibrary_GetEquipLoadoutCount) == 0x000004, "Wrong alignment on GameLogicBPFLibrary_GetEquipLoadoutCount");
static_assert(sizeof(GameLogicBPFLibrary_GetEquipLoadoutCount) == 0x000004, "Wrong size on GameLogicBPFLibrary_GetEquipLoadoutCount");
static_assert(offsetof(GameLogicBPFLibrary_GetEquipLoadoutCount, ReturnValue) == 0x000000, "Member 'GameLogicBPFLibrary_GetEquipLoadoutCount::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.GetNextLevelForSkill
// 0x0020 (0x0020 - 0x0000)
struct GameLogicBPFLibrary_GetNextLevelForSkill final
{
public:
	const class UInventoryComponent*              InventoryComponent;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    SkillHandle;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_GetNextLevelForSkill) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_GetNextLevelForSkill");
static_assert(sizeof(GameLogicBPFLibrary_GetNextLevelForSkill) == 0x000020, "Wrong size on GameLogicBPFLibrary_GetNextLevelForSkill");
static_assert(offsetof(GameLogicBPFLibrary_GetNextLevelForSkill, InventoryComponent) == 0x000000, "Member 'GameLogicBPFLibrary_GetNextLevelForSkill::InventoryComponent' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_GetNextLevelForSkill, SkillHandle) == 0x000008, "Member 'GameLogicBPFLibrary_GetNextLevelForSkill::SkillHandle' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_GetNextLevelForSkill, ReturnValue) == 0x000018, "Member 'GameLogicBPFLibrary_GetNextLevelForSkill::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.GetPlayerMaxAttackLimit
// 0x0010 (0x0010 - 0x0000)
struct GameLogicBPFLibrary_GetPlayerMaxAttackLimit final
{
public:
	const class APlayerControllerZion*            PlayerController;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_GetPlayerMaxAttackLimit) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_GetPlayerMaxAttackLimit");
static_assert(sizeof(GameLogicBPFLibrary_GetPlayerMaxAttackLimit) == 0x000010, "Wrong size on GameLogicBPFLibrary_GetPlayerMaxAttackLimit");
static_assert(offsetof(GameLogicBPFLibrary_GetPlayerMaxAttackLimit, PlayerController) == 0x000000, "Member 'GameLogicBPFLibrary_GetPlayerMaxAttackLimit::PlayerController' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_GetPlayerMaxAttackLimit, ReturnValue) == 0x000008, "Member 'GameLogicBPFLibrary_GetPlayerMaxAttackLimit::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.GetPlayerMaxDefenseLimit
// 0x0010 (0x0010 - 0x0000)
struct GameLogicBPFLibrary_GetPlayerMaxDefenseLimit final
{
public:
	const class APlayerControllerZion*            PlayerController;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_GetPlayerMaxDefenseLimit) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_GetPlayerMaxDefenseLimit");
static_assert(sizeof(GameLogicBPFLibrary_GetPlayerMaxDefenseLimit) == 0x000010, "Wrong size on GameLogicBPFLibrary_GetPlayerMaxDefenseLimit");
static_assert(offsetof(GameLogicBPFLibrary_GetPlayerMaxDefenseLimit, PlayerController) == 0x000000, "Member 'GameLogicBPFLibrary_GetPlayerMaxDefenseLimit::PlayerController' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_GetPlayerMaxDefenseLimit, ReturnValue) == 0x000008, "Member 'GameLogicBPFLibrary_GetPlayerMaxDefenseLimit::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.GetPlayerMaxHealCountLimit
// 0x0010 (0x0010 - 0x0000)
struct GameLogicBPFLibrary_GetPlayerMaxHealCountLimit final
{
public:
	const class APlayerControllerZion*            PlayerController;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_GetPlayerMaxHealCountLimit) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_GetPlayerMaxHealCountLimit");
static_assert(sizeof(GameLogicBPFLibrary_GetPlayerMaxHealCountLimit) == 0x000010, "Wrong size on GameLogicBPFLibrary_GetPlayerMaxHealCountLimit");
static_assert(offsetof(GameLogicBPFLibrary_GetPlayerMaxHealCountLimit, PlayerController) == 0x000000, "Member 'GameLogicBPFLibrary_GetPlayerMaxHealCountLimit::PlayerController' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_GetPlayerMaxHealCountLimit, ReturnValue) == 0x000008, "Member 'GameLogicBPFLibrary_GetPlayerMaxHealCountLimit::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.GetPlayerMaxHealPowerLimit
// 0x0010 (0x0010 - 0x0000)
struct GameLogicBPFLibrary_GetPlayerMaxHealPowerLimit final
{
public:
	const class APlayerControllerZion*            PlayerController;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_GetPlayerMaxHealPowerLimit) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_GetPlayerMaxHealPowerLimit");
static_assert(sizeof(GameLogicBPFLibrary_GetPlayerMaxHealPowerLimit) == 0x000010, "Wrong size on GameLogicBPFLibrary_GetPlayerMaxHealPowerLimit");
static_assert(offsetof(GameLogicBPFLibrary_GetPlayerMaxHealPowerLimit, PlayerController) == 0x000000, "Member 'GameLogicBPFLibrary_GetPlayerMaxHealPowerLimit::PlayerController' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_GetPlayerMaxHealPowerLimit, ReturnValue) == 0x000008, "Member 'GameLogicBPFLibrary_GetPlayerMaxHealPowerLimit::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.GetPlayerMaxHPLimit
// 0x0010 (0x0010 - 0x0000)
struct GameLogicBPFLibrary_GetPlayerMaxHPLimit final
{
public:
	const class APlayerControllerZion*            PlayerController;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_GetPlayerMaxHPLimit) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_GetPlayerMaxHPLimit");
static_assert(sizeof(GameLogicBPFLibrary_GetPlayerMaxHPLimit) == 0x000010, "Wrong size on GameLogicBPFLibrary_GetPlayerMaxHPLimit");
static_assert(offsetof(GameLogicBPFLibrary_GetPlayerMaxHPLimit, PlayerController) == 0x000000, "Member 'GameLogicBPFLibrary_GetPlayerMaxHPLimit::PlayerController' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_GetPlayerMaxHPLimit, ReturnValue) == 0x000008, "Member 'GameLogicBPFLibrary_GetPlayerMaxHPLimit::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.GetPlayerMaxPossibleStats
// 0x0058 (0x0058 - 0x0000)
struct GameLogicBPFLibrary_GetPlayerMaxPossibleStats final
{
public:
	const class APlayerControllerZion*            PlayerController;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FExtendedStatsData                     ReturnValue;                                       // 0x0008(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicBPFLibrary_GetPlayerMaxPossibleStats) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_GetPlayerMaxPossibleStats");
static_assert(sizeof(GameLogicBPFLibrary_GetPlayerMaxPossibleStats) == 0x000058, "Wrong size on GameLogicBPFLibrary_GetPlayerMaxPossibleStats");
static_assert(offsetof(GameLogicBPFLibrary_GetPlayerMaxPossibleStats, PlayerController) == 0x000000, "Member 'GameLogicBPFLibrary_GetPlayerMaxPossibleStats::PlayerController' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_GetPlayerMaxPossibleStats, ReturnValue) == 0x000008, "Member 'GameLogicBPFLibrary_GetPlayerMaxPossibleStats::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.GetPlayerMaxSPLimit
// 0x0010 (0x0010 - 0x0000)
struct GameLogicBPFLibrary_GetPlayerMaxSPLimit final
{
public:
	const class APlayerControllerZion*            PlayerController;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_GetPlayerMaxSPLimit) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_GetPlayerMaxSPLimit");
static_assert(sizeof(GameLogicBPFLibrary_GetPlayerMaxSPLimit) == 0x000010, "Wrong size on GameLogicBPFLibrary_GetPlayerMaxSPLimit");
static_assert(offsetof(GameLogicBPFLibrary_GetPlayerMaxSPLimit, PlayerController) == 0x000000, "Member 'GameLogicBPFLibrary_GetPlayerMaxSPLimit::PlayerController' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_GetPlayerMaxSPLimit, ReturnValue) == 0x000008, "Member 'GameLogicBPFLibrary_GetPlayerMaxSPLimit::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.GetSkillLevelFromHandle
// 0x0020 (0x0020 - 0x0000)
struct GameLogicBPFLibrary_GetSkillLevelFromHandle final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    SkillHandle;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_GetSkillLevelFromHandle) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_GetSkillLevelFromHandle");
static_assert(sizeof(GameLogicBPFLibrary_GetSkillLevelFromHandle) == 0x000020, "Wrong size on GameLogicBPFLibrary_GetSkillLevelFromHandle");
static_assert(offsetof(GameLogicBPFLibrary_GetSkillLevelFromHandle, WorldContextObject) == 0x000000, "Member 'GameLogicBPFLibrary_GetSkillLevelFromHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_GetSkillLevelFromHandle, SkillHandle) == 0x000008, "Member 'GameLogicBPFLibrary_GetSkillLevelFromHandle::SkillHandle' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_GetSkillLevelFromHandle, ReturnValue) == 0x000018, "Member 'GameLogicBPFLibrary_GetSkillLevelFromHandle::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.GetSkillLevelFromID
// 0x0018 (0x0018 - 0x0000)
struct GameLogicBPFLibrary_GetSkillLevelFromID final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillID;                                           // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_GetSkillLevelFromID) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_GetSkillLevelFromID");
static_assert(sizeof(GameLogicBPFLibrary_GetSkillLevelFromID) == 0x000018, "Wrong size on GameLogicBPFLibrary_GetSkillLevelFromID");
static_assert(offsetof(GameLogicBPFLibrary_GetSkillLevelFromID, WorldContextObject) == 0x000000, "Member 'GameLogicBPFLibrary_GetSkillLevelFromID::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_GetSkillLevelFromID, SkillID) == 0x000008, "Member 'GameLogicBPFLibrary_GetSkillLevelFromID::SkillID' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_GetSkillLevelFromID, ReturnValue) == 0x000010, "Member 'GameLogicBPFLibrary_GetSkillLevelFromID::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.GetSPGaugeValue
// 0x0004 (0x0004 - 0x0000)
struct GameLogicBPFLibrary_GetSPGaugeValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicBPFLibrary_GetSPGaugeValue) == 0x000004, "Wrong alignment on GameLogicBPFLibrary_GetSPGaugeValue");
static_assert(sizeof(GameLogicBPFLibrary_GetSPGaugeValue) == 0x000004, "Wrong size on GameLogicBPFLibrary_GetSPGaugeValue");
static_assert(offsetof(GameLogicBPFLibrary_GetSPGaugeValue, ReturnValue) == 0x000000, "Member 'GameLogicBPFLibrary_GetSPGaugeValue::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.LaunchForceFeedback
// 0x0020 (0x0020 - 0x0000)
struct GameLogicBPFLibrary_LaunchForceFeedback final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreTimeDilation;                               // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayWhilePaused;                                  // 0x001A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_LaunchForceFeedback) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_LaunchForceFeedback");
static_assert(sizeof(GameLogicBPFLibrary_LaunchForceFeedback) == 0x000020, "Wrong size on GameLogicBPFLibrary_LaunchForceFeedback");
static_assert(offsetof(GameLogicBPFLibrary_LaunchForceFeedback, PlayerController) == 0x000000, "Member 'GameLogicBPFLibrary_LaunchForceFeedback::PlayerController' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_LaunchForceFeedback, ForceFeedbackEffect) == 0x000008, "Member 'GameLogicBPFLibrary_LaunchForceFeedback::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_LaunchForceFeedback, Tag) == 0x000010, "Member 'GameLogicBPFLibrary_LaunchForceFeedback::Tag' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_LaunchForceFeedback, bLooping) == 0x000018, "Member 'GameLogicBPFLibrary_LaunchForceFeedback::bLooping' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_LaunchForceFeedback, bIgnoreTimeDilation) == 0x000019, "Member 'GameLogicBPFLibrary_LaunchForceFeedback::bIgnoreTimeDilation' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_LaunchForceFeedback, bPlayWhilePaused) == 0x00001A, "Member 'GameLogicBPFLibrary_LaunchForceFeedback::bPlayWhilePaused' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.StopForceFeedbackByTag
// 0x0010 (0x0010 - 0x0000)
struct GameLogicBPFLibrary_StopForceFeedbackByTag final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicBPFLibrary_StopForceFeedbackByTag) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_StopForceFeedbackByTag");
static_assert(sizeof(GameLogicBPFLibrary_StopForceFeedbackByTag) == 0x000010, "Wrong size on GameLogicBPFLibrary_StopForceFeedbackByTag");
static_assert(offsetof(GameLogicBPFLibrary_StopForceFeedbackByTag, PlayerController) == 0x000000, "Member 'GameLogicBPFLibrary_StopForceFeedbackByTag::PlayerController' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_StopForceFeedbackByTag, Tag) == 0x000008, "Member 'GameLogicBPFLibrary_StopForceFeedbackByTag::Tag' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.TryLaunchTutorialWidget
// 0x0030 (0x0030 - 0x0000)
struct GameLogicBPFLibrary_TryLaunchTutorialWidget final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidgetTutorial>        TutorialWidgetClass;                               // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    TutorialHandle;                                    // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	EUMGLayer                                     UMGLayer;                                          // 0x0020(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidgetTutorial*                    ReturnValue;                                       // 0x0028(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicBPFLibrary_TryLaunchTutorialWidget) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_TryLaunchTutorialWidget");
static_assert(sizeof(GameLogicBPFLibrary_TryLaunchTutorialWidget) == 0x000030, "Wrong size on GameLogicBPFLibrary_TryLaunchTutorialWidget");
static_assert(offsetof(GameLogicBPFLibrary_TryLaunchTutorialWidget, WorldContextObject) == 0x000000, "Member 'GameLogicBPFLibrary_TryLaunchTutorialWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_TryLaunchTutorialWidget, TutorialWidgetClass) == 0x000008, "Member 'GameLogicBPFLibrary_TryLaunchTutorialWidget::TutorialWidgetClass' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_TryLaunchTutorialWidget, TutorialHandle) == 0x000010, "Member 'GameLogicBPFLibrary_TryLaunchTutorialWidget::TutorialHandle' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_TryLaunchTutorialWidget, UMGLayer) == 0x000020, "Member 'GameLogicBPFLibrary_TryLaunchTutorialWidget::UMGLayer' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_TryLaunchTutorialWidget, ReturnValue) == 0x000028, "Member 'GameLogicBPFLibrary_TryLaunchTutorialWidget::ReturnValue' has a wrong offset!");

// Function Zion.GameLogicBPFLibrary.UnlockSkillLevel
// 0x0020 (0x0020 - 0x0000)
struct GameLogicBPFLibrary_UnlockSkillLevel final
{
public:
	class UInventoryComponent*                    InventoryComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    SkillHandle;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicBPFLibrary_UnlockSkillLevel) == 0x000008, "Wrong alignment on GameLogicBPFLibrary_UnlockSkillLevel");
static_assert(sizeof(GameLogicBPFLibrary_UnlockSkillLevel) == 0x000020, "Wrong size on GameLogicBPFLibrary_UnlockSkillLevel");
static_assert(offsetof(GameLogicBPFLibrary_UnlockSkillLevel, InventoryComponent) == 0x000000, "Member 'GameLogicBPFLibrary_UnlockSkillLevel::InventoryComponent' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_UnlockSkillLevel, SkillHandle) == 0x000008, "Member 'GameLogicBPFLibrary_UnlockSkillLevel::SkillHandle' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_UnlockSkillLevel, Level) == 0x000018, "Member 'GameLogicBPFLibrary_UnlockSkillLevel::Level' has a wrong offset!");
static_assert(offsetof(GameLogicBPFLibrary_UnlockSkillLevel, ReturnValue) == 0x00001C, "Member 'GameLogicBPFLibrary_UnlockSkillLevel::ReturnValue' has a wrong offset!");

// Function Zion.GameMapBPFLibrary.GetPixelPerMeter
// 0x0004 (0x0004 - 0x0000)
struct GameMapBPFLibrary_GetPixelPerMeter final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMapBPFLibrary_GetPixelPerMeter) == 0x000004, "Wrong alignment on GameMapBPFLibrary_GetPixelPerMeter");
static_assert(sizeof(GameMapBPFLibrary_GetPixelPerMeter) == 0x000004, "Wrong size on GameMapBPFLibrary_GetPixelPerMeter");
static_assert(offsetof(GameMapBPFLibrary_GetPixelPerMeter, ReturnValue) == 0x000000, "Member 'GameMapBPFLibrary_GetPixelPerMeter::ReturnValue' has a wrong offset!");

// Function Zion.GameMapBPFLibrary.WorldToPixelLocation
// 0x0030 (0x0030 - 0x0000)
struct GameMapBPFLibrary_WorldToPixelLocation final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMapBPFLibrary_WorldToPixelLocation) == 0x000008, "Wrong alignment on GameMapBPFLibrary_WorldToPixelLocation");
static_assert(sizeof(GameMapBPFLibrary_WorldToPixelLocation) == 0x000030, "Wrong size on GameMapBPFLibrary_WorldToPixelLocation");
static_assert(offsetof(GameMapBPFLibrary_WorldToPixelLocation, WorldLocation) == 0x000000, "Member 'GameMapBPFLibrary_WorldToPixelLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(GameMapBPFLibrary_WorldToPixelLocation, ReturnValue) == 0x000018, "Member 'GameMapBPFLibrary_WorldToPixelLocation::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.Get
// 0x0010 (0x0010 - 0x0000)
struct GameModeZion_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameModeZion*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_Get) == 0x000008, "Wrong alignment on GameModeZion_Get");
static_assert(sizeof(GameModeZion_Get) == 0x000010, "Wrong size on GameModeZion_Get");
static_assert(offsetof(GameModeZion_Get, WorldContextObject) == 0x000000, "Member 'GameModeZion_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameModeZion_Get, ReturnValue) == 0x000008, "Member 'GameModeZion_Get::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetMaxEnvironmentLevel
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetMaxEnvironmentLevel final
{
public:
	int32                                         NewGamePlusGeneration_0;                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetMaxEnvironmentLevel) == 0x000004, "Wrong alignment on GameModeZion_GetMaxEnvironmentLevel");
static_assert(sizeof(GameModeZion_GetMaxEnvironmentLevel) == 0x000008, "Wrong size on GameModeZion_GetMaxEnvironmentLevel");
static_assert(offsetof(GameModeZion_GetMaxEnvironmentLevel, NewGamePlusGeneration_0) == 0x000000, "Member 'GameModeZion_GetMaxEnvironmentLevel::NewGamePlusGeneration_0' has a wrong offset!");
static_assert(offsetof(GameModeZion_GetMaxEnvironmentLevel, ReturnValue) == 0x000004, "Member 'GameModeZion_GetMaxEnvironmentLevel::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.DBG_SetNewGamePlusGeneration
// 0x0004 (0x0004 - 0x0000)
struct GameModeZion_DBG_SetNewGamePlusGeneration final
{
public:
	int32                                         NewNewGamePlusGeneration;                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_DBG_SetNewGamePlusGeneration) == 0x000004, "Wrong alignment on GameModeZion_DBG_SetNewGamePlusGeneration");
static_assert(sizeof(GameModeZion_DBG_SetNewGamePlusGeneration) == 0x000004, "Wrong size on GameModeZion_DBG_SetNewGamePlusGeneration");
static_assert(offsetof(GameModeZion_DBG_SetNewGamePlusGeneration, NewNewGamePlusGeneration) == 0x000000, "Member 'GameModeZion_DBG_SetNewGamePlusGeneration::NewNewGamePlusGeneration' has a wrong offset!");

// Function Zion.GameModeZion.FastTravel
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_FastTravel final
{
public:
	class FName                                   RestPointID;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_FastTravel) == 0x000004, "Wrong alignment on GameModeZion_FastTravel");
static_assert(sizeof(GameModeZion_FastTravel) == 0x000008, "Wrong size on GameModeZion_FastTravel");
static_assert(offsetof(GameModeZion_FastTravel, RestPointID) == 0x000000, "Member 'GameModeZion_FastTravel::RestPointID' has a wrong offset!");

// Function Zion.GameModeZion.NotifyGameEndingReached
// 0x0001 (0x0001 - 0x0000)
struct GameModeZion_NotifyGameEndingReached final
{
public:
	EGameEndingType                               GameEndingType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_NotifyGameEndingReached) == 0x000001, "Wrong alignment on GameModeZion_NotifyGameEndingReached");
static_assert(sizeof(GameModeZion_NotifyGameEndingReached) == 0x000001, "Wrong size on GameModeZion_NotifyGameEndingReached");
static_assert(offsetof(GameModeZion_NotifyGameEndingReached, GameEndingType) == 0x000000, "Member 'GameModeZion_NotifyGameEndingReached::GameEndingType' has a wrong offset!");

// Function Zion.GameModeZion.RegisterBossRushComponent
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_RegisterBossRushComponent final
{
public:
	class URecollectionBossRushComponent*         NewBossRushComponent;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_RegisterBossRushComponent) == 0x000008, "Wrong alignment on GameModeZion_RegisterBossRushComponent");
static_assert(sizeof(GameModeZion_RegisterBossRushComponent) == 0x000008, "Wrong size on GameModeZion_RegisterBossRushComponent");
static_assert(offsetof(GameModeZion_RegisterBossRushComponent, NewBossRushComponent) == 0x000000, "Member 'GameModeZion_RegisterBossRushComponent::NewBossRushComponent' has a wrong offset!");

// Function Zion.GameModeZion.RegisterRecollectionBossComponent
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_RegisterRecollectionBossComponent final
{
public:
	class URecollectionBossComponent*             NewRecollectionBossComponent;                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_RegisterRecollectionBossComponent) == 0x000008, "Wrong alignment on GameModeZion_RegisterRecollectionBossComponent");
static_assert(sizeof(GameModeZion_RegisterRecollectionBossComponent) == 0x000008, "Wrong size on GameModeZion_RegisterRecollectionBossComponent");
static_assert(offsetof(GameModeZion_RegisterRecollectionBossComponent, NewRecollectionBossComponent) == 0x000000, "Member 'GameModeZion_RegisterRecollectionBossComponent::NewRecollectionBossComponent' has a wrong offset!");

// Function Zion.GameModeZion.RespawnPlayer
// 0x0001 (0x0001 - 0x0000)
struct GameModeZion_RespawnPlayer final
{
public:
	ERespawnReason                                Reason;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_RespawnPlayer) == 0x000001, "Wrong alignment on GameModeZion_RespawnPlayer");
static_assert(sizeof(GameModeZion_RespawnPlayer) == 0x000001, "Wrong size on GameModeZion_RespawnPlayer");
static_assert(offsetof(GameModeZion_RespawnPlayer, Reason) == 0x000000, "Member 'GameModeZion_RespawnPlayer::Reason' has a wrong offset!");

// Function Zion.GameModeZion.SetEnvironmentLevelOverride
// 0x0004 (0x0004 - 0x0000)
struct GameModeZion_SetEnvironmentLevelOverride final
{
public:
	int32                                         LevelOverride;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_SetEnvironmentLevelOverride) == 0x000004, "Wrong alignment on GameModeZion_SetEnvironmentLevelOverride");
static_assert(sizeof(GameModeZion_SetEnvironmentLevelOverride) == 0x000004, "Wrong size on GameModeZion_SetEnvironmentLevelOverride");
static_assert(offsetof(GameModeZion_SetEnvironmentLevelOverride, LevelOverride) == 0x000000, "Member 'GameModeZion_SetEnvironmentLevelOverride::LevelOverride' has a wrong offset!");

// Function Zion.GameModeZion.SetNewGamePlusGenerationOverride
// 0x0004 (0x0004 - 0x0000)
struct GameModeZion_SetNewGamePlusGenerationOverride final
{
public:
	int32                                         GenerationOverride;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_SetNewGamePlusGenerationOverride) == 0x000004, "Wrong alignment on GameModeZion_SetNewGamePlusGenerationOverride");
static_assert(sizeof(GameModeZion_SetNewGamePlusGenerationOverride) == 0x000004, "Wrong size on GameModeZion_SetNewGamePlusGenerationOverride");
static_assert(offsetof(GameModeZion_SetNewGamePlusGenerationOverride, GenerationOverride) == 0x000000, "Member 'GameModeZion_SetNewGamePlusGenerationOverride::GenerationOverride' has a wrong offset!");

// Function Zion.GameModeZion.StartRecollectionBoss
// 0x0010 (0x0010 - 0x0000)
struct GameModeZion_StartRecollectionBoss final
{
public:
	struct FDataTableRowHandle                    RecollectionBossDataHandle;                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_StartRecollectionBoss) == 0x000008, "Wrong alignment on GameModeZion_StartRecollectionBoss");
static_assert(sizeof(GameModeZion_StartRecollectionBoss) == 0x000010, "Wrong size on GameModeZion_StartRecollectionBoss");
static_assert(offsetof(GameModeZion_StartRecollectionBoss, RecollectionBossDataHandle) == 0x000000, "Member 'GameModeZion_StartRecollectionBoss::RecollectionBossDataHandle' has a wrong offset!");

// Function Zion.GameModeZion.CanLeaveRecollectionBoss
// 0x0001 (0x0001 - 0x0000)
struct GameModeZion_CanLeaveRecollectionBoss final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_CanLeaveRecollectionBoss) == 0x000001, "Wrong alignment on GameModeZion_CanLeaveRecollectionBoss");
static_assert(sizeof(GameModeZion_CanLeaveRecollectionBoss) == 0x000001, "Wrong size on GameModeZion_CanLeaveRecollectionBoss");
static_assert(offsetof(GameModeZion_CanLeaveRecollectionBoss, ReturnValue) == 0x000000, "Member 'GameModeZion_CanLeaveRecollectionBoss::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.DidReachGameEnding
// 0x0003 (0x0003 - 0x0000)
struct GameModeZion_DidReachGameEnding final
{
public:
	EGameEndingType                               GameEndingType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckPreviousGameGeneration;                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_DidReachGameEnding) == 0x000001, "Wrong alignment on GameModeZion_DidReachGameEnding");
static_assert(sizeof(GameModeZion_DidReachGameEnding) == 0x000003, "Wrong size on GameModeZion_DidReachGameEnding");
static_assert(offsetof(GameModeZion_DidReachGameEnding, GameEndingType) == 0x000000, "Member 'GameModeZion_DidReachGameEnding::GameEndingType' has a wrong offset!");
static_assert(offsetof(GameModeZion_DidReachGameEnding, bCheckPreviousGameGeneration) == 0x000001, "Member 'GameModeZion_DidReachGameEnding::bCheckPreviousGameGeneration' has a wrong offset!");
static_assert(offsetof(GameModeZion_DidReachGameEnding, ReturnValue) == 0x000002, "Member 'GameModeZion_DidReachGameEnding::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetAbilityFXMatrixData
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetAbilityFXMatrixData final
{
public:
	class UMaterialFXMatrixData*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetAbilityFXMatrixData) == 0x000008, "Wrong alignment on GameModeZion_GetAbilityFXMatrixData");
static_assert(sizeof(GameModeZion_GetAbilityFXMatrixData) == 0x000008, "Wrong size on GameModeZion_GetAbilityFXMatrixData");
static_assert(offsetof(GameModeZion_GetAbilityFXMatrixData, ReturnValue) == 0x000000, "Member 'GameModeZion_GetAbilityFXMatrixData::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetAbilitySEMatrixData
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetAbilitySEMatrixData final
{
public:
	class UMaterialSEMatrixData*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetAbilitySEMatrixData) == 0x000008, "Wrong alignment on GameModeZion_GetAbilitySEMatrixData");
static_assert(sizeof(GameModeZion_GetAbilitySEMatrixData) == 0x000008, "Wrong size on GameModeZion_GetAbilitySEMatrixData");
static_assert(offsetof(GameModeZion_GetAbilitySEMatrixData, ReturnValue) == 0x000000, "Member 'GameModeZion_GetAbilitySEMatrixData::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetCurrentRespawnReason
// 0x0001 (0x0001 - 0x0000)
struct GameModeZion_GetCurrentRespawnReason final
{
public:
	ERespawnReason                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetCurrentRespawnReason) == 0x000001, "Wrong alignment on GameModeZion_GetCurrentRespawnReason");
static_assert(sizeof(GameModeZion_GetCurrentRespawnReason) == 0x000001, "Wrong size on GameModeZion_GetCurrentRespawnReason");
static_assert(offsetof(GameModeZion_GetCurrentRespawnReason, ReturnValue) == 0x000000, "Member 'GameModeZion_GetCurrentRespawnReason::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableAchievements
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableAchievements final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableAchievements) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableAchievements");
static_assert(sizeof(GameModeZion_GetDataTableAchievements) == 0x000008, "Wrong size on GameModeZion_GetDataTableAchievements");
static_assert(offsetof(GameModeZion_GetDataTableAchievements, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableAchievements::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableEnemies
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableEnemies final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableEnemies) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableEnemies");
static_assert(sizeof(GameModeZion_GetDataTableEnemies) == 0x000008, "Wrong size on GameModeZion_GetDataTableEnemies");
static_assert(offsetof(GameModeZion_GetDataTableEnemies, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableEnemies::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableGameMaps
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableGameMaps final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableGameMaps) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableGameMaps");
static_assert(sizeof(GameModeZion_GetDataTableGameMaps) == 0x000008, "Wrong size on GameModeZion_GetDataTableGameMaps");
static_assert(offsetof(GameModeZion_GetDataTableGameMaps, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableGameMaps::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableGameMapTransitions
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableGameMapTransitions final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableGameMapTransitions) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableGameMapTransitions");
static_assert(sizeof(GameModeZion_GetDataTableGameMapTransitions) == 0x000008, "Wrong size on GameModeZion_GetDataTableGameMapTransitions");
static_assert(offsetof(GameModeZion_GetDataTableGameMapTransitions, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableGameMapTransitions::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemAptitudes
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemAptitudes final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemAptitudes) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemAptitudes");
static_assert(sizeof(GameModeZion_GetDataTableItemAptitudes) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemAptitudes");
static_assert(offsetof(GameModeZion_GetDataTableItemAptitudes, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemAptitudes::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemAssists
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemAssists final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemAssists) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemAssists");
static_assert(sizeof(GameModeZion_GetDataTableItemAssists) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemAssists");
static_assert(offsetof(GameModeZion_GetDataTableItemAssists, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemAssists::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemCostumes
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemCostumes final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemCostumes) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemCostumes");
static_assert(sizeof(GameModeZion_GetDataTableItemCostumes) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemCostumes");
static_assert(offsetof(GameModeZion_GetDataTableItemCostumes, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemCostumes::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemCurrencies
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemCurrencies final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemCurrencies) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemCurrencies");
static_assert(sizeof(GameModeZion_GetDataTableItemCurrencies) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemCurrencies");
static_assert(offsetof(GameModeZion_GetDataTableItemCurrencies, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemCurrencies::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemEnemyInfo
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemEnemyInfo final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemEnemyInfo) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemEnemyInfo");
static_assert(sizeof(GameModeZion_GetDataTableItemEnemyInfo) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemEnemyInfo");
static_assert(offsetof(GameModeZion_GetDataTableItemEnemyInfo, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemEnemyInfo::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemEquipments
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemEquipments final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemEquipments) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemEquipments");
static_assert(sizeof(GameModeZion_GetDataTableItemEquipments) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemEquipments");
static_assert(offsetof(GameModeZion_GetDataTableItemEquipments, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemEquipments::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemGallery
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemGallery final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemGallery) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemGallery");
static_assert(sizeof(GameModeZion_GetDataTableItemGallery) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemGallery");
static_assert(offsetof(GameModeZion_GetDataTableItemGallery, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemGallery::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemKeys
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemKeys final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemKeys) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemKeys");
static_assert(sizeof(GameModeZion_GetDataTableItemKeys) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemKeys");
static_assert(offsetof(GameModeZion_GetDataTableItemKeys, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemKeys::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemMaterials
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemMaterials final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemMaterials) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemMaterials");
static_assert(sizeof(GameModeZion_GetDataTableItemMaterials) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemMaterials");
static_assert(offsetof(GameModeZion_GetDataTableItemMaterials, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemMaterials::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemNPCInfo
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemNPCInfo final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemNPCInfo) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemNPCInfo");
static_assert(sizeof(GameModeZion_GetDataTableItemNPCInfo) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemNPCInfo");
static_assert(offsetof(GameModeZion_GetDataTableItemNPCInfo, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemNPCInfo::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemPassives
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemPassives final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemPassives) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemPassives");
static_assert(sizeof(GameModeZion_GetDataTableItemPassives) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemPassives");
static_assert(offsetof(GameModeZion_GetDataTableItemPassives, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemPassives::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemQuests
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemQuests final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemQuests) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemQuests");
static_assert(sizeof(GameModeZion_GetDataTableItemQuests) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemQuests");
static_assert(offsetof(GameModeZion_GetDataTableItemQuests, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemQuests::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemSkills
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemSkills final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemSkills) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemSkills");
static_assert(sizeof(GameModeZion_GetDataTableItemSkills) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemSkills");
static_assert(offsetof(GameModeZion_GetDataTableItemSkills, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemSkills::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemSpirits
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemSpirits final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemSpirits) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemSpirits");
static_assert(sizeof(GameModeZion_GetDataTableItemSpirits) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemSpirits");
static_assert(offsetof(GameModeZion_GetDataTableItemSpirits, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemSpirits::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemStats
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemStats final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemStats) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemStats");
static_assert(sizeof(GameModeZion_GetDataTableItemStats) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemStats");
static_assert(offsetof(GameModeZion_GetDataTableItemStats, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemStats::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemTips
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemTips final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemTips) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemTips");
static_assert(sizeof(GameModeZion_GetDataTableItemTips) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemTips");
static_assert(offsetof(GameModeZion_GetDataTableItemTips, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemTips::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableItemTutorials
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableItemTutorials final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableItemTutorials) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableItemTutorials");
static_assert(sizeof(GameModeZion_GetDataTableItemTutorials) == 0x000008, "Wrong size on GameModeZion_GetDataTableItemTutorials");
static_assert(offsetof(GameModeZion_GetDataTableItemTutorials, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableItemTutorials::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableRecollectionBosses
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableRecollectionBosses final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableRecollectionBosses) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableRecollectionBosses");
static_assert(sizeof(GameModeZion_GetDataTableRecollectionBosses) == 0x000008, "Wrong size on GameModeZion_GetDataTableRecollectionBosses");
static_assert(offsetof(GameModeZion_GetDataTableRecollectionBosses, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableRecollectionBosses::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableRestPointEvents
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableRestPointEvents final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableRestPointEvents) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableRestPointEvents");
static_assert(sizeof(GameModeZion_GetDataTableRestPointEvents) == 0x000008, "Wrong size on GameModeZion_GetDataTableRestPointEvents");
static_assert(offsetof(GameModeZion_GetDataTableRestPointEvents, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableRestPointEvents::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableRestPoints
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableRestPoints final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableRestPoints) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableRestPoints");
static_assert(sizeof(GameModeZion_GetDataTableRestPoints) == 0x000008, "Wrong size on GameModeZion_GetDataTableRestPoints");
static_assert(offsetof(GameModeZion_GetDataTableRestPoints, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableRestPoints::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetDataTableStoryLevels
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetDataTableStoryLevels final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetDataTableStoryLevels) == 0x000008, "Wrong alignment on GameModeZion_GetDataTableStoryLevels");
static_assert(sizeof(GameModeZion_GetDataTableStoryLevels) == 0x000008, "Wrong size on GameModeZion_GetDataTableStoryLevels");
static_assert(offsetof(GameModeZion_GetDataTableStoryLevels, ReturnValue) == 0x000000, "Member 'GameModeZion_GetDataTableStoryLevels::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetEnvironmentLevel
// 0x0004 (0x0004 - 0x0000)
struct GameModeZion_GetEnvironmentLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetEnvironmentLevel) == 0x000004, "Wrong alignment on GameModeZion_GetEnvironmentLevel");
static_assert(sizeof(GameModeZion_GetEnvironmentLevel) == 0x000004, "Wrong size on GameModeZion_GetEnvironmentLevel");
static_assert(offsetof(GameModeZion_GetEnvironmentLevel, ReturnValue) == 0x000000, "Member 'GameModeZion_GetEnvironmentLevel::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetEnvironmentLevelNewGamePlus
// 0x0004 (0x0004 - 0x0000)
struct GameModeZion_GetEnvironmentLevelNewGamePlus final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetEnvironmentLevelNewGamePlus) == 0x000004, "Wrong alignment on GameModeZion_GetEnvironmentLevelNewGamePlus");
static_assert(sizeof(GameModeZion_GetEnvironmentLevelNewGamePlus) == 0x000004, "Wrong size on GameModeZion_GetEnvironmentLevelNewGamePlus");
static_assert(offsetof(GameModeZion_GetEnvironmentLevelNewGamePlus, ReturnValue) == 0x000000, "Member 'GameModeZion_GetEnvironmentLevelNewGamePlus::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetEnvironmentLevelOverride
// 0x0004 (0x0004 - 0x0000)
struct GameModeZion_GetEnvironmentLevelOverride final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetEnvironmentLevelOverride) == 0x000004, "Wrong alignment on GameModeZion_GetEnvironmentLevelOverride");
static_assert(sizeof(GameModeZion_GetEnvironmentLevelOverride) == 0x000004, "Wrong size on GameModeZion_GetEnvironmentLevelOverride");
static_assert(offsetof(GameModeZion_GetEnvironmentLevelOverride, ReturnValue) == 0x000000, "Member 'GameModeZion_GetEnvironmentLevelOverride::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetGameClearCount
// 0x0004 (0x0004 - 0x0000)
struct GameModeZion_GetGameClearCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetGameClearCount) == 0x000004, "Wrong alignment on GameModeZion_GetGameClearCount");
static_assert(sizeof(GameModeZion_GetGameClearCount) == 0x000004, "Wrong size on GameModeZion_GetGameClearCount");
static_assert(offsetof(GameModeZion_GetGameClearCount, ReturnValue) == 0x000000, "Member 'GameModeZion_GetGameClearCount::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetGameEndingCountReached
// 0x0004 (0x0004 - 0x0000)
struct GameModeZion_GetGameEndingCountReached final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetGameEndingCountReached) == 0x000004, "Wrong alignment on GameModeZion_GetGameEndingCountReached");
static_assert(sizeof(GameModeZion_GetGameEndingCountReached) == 0x000004, "Wrong size on GameModeZion_GetGameEndingCountReached");
static_assert(offsetof(GameModeZion_GetGameEndingCountReached, ReturnValue) == 0x000000, "Member 'GameModeZion_GetGameEndingCountReached::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetGameModeType
// 0x0001 (0x0001 - 0x0000)
struct GameModeZion_GetGameModeType final
{
public:
	EGameModeType                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetGameModeType) == 0x000001, "Wrong alignment on GameModeZion_GetGameModeType");
static_assert(sizeof(GameModeZion_GetGameModeType) == 0x000001, "Wrong size on GameModeZion_GetGameModeType");
static_assert(offsetof(GameModeZion_GetGameModeType, ReturnValue) == 0x000000, "Member 'GameModeZion_GetGameModeType::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetLastBossRecollectionHandle
// 0x0010 (0x0010 - 0x0000)
struct GameModeZion_GetLastBossRecollectionHandle final
{
public:
	struct FDataTableRowHandle                    ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetLastBossRecollectionHandle) == 0x000008, "Wrong alignment on GameModeZion_GetLastBossRecollectionHandle");
static_assert(sizeof(GameModeZion_GetLastBossRecollectionHandle) == 0x000010, "Wrong size on GameModeZion_GetLastBossRecollectionHandle");
static_assert(offsetof(GameModeZion_GetLastBossRecollectionHandle, ReturnValue) == 0x000000, "Member 'GameModeZion_GetLastBossRecollectionHandle::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetNewGamePlusGeneration
// 0x0004 (0x0004 - 0x0000)
struct GameModeZion_GetNewGamePlusGeneration final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetNewGamePlusGeneration) == 0x000004, "Wrong alignment on GameModeZion_GetNewGamePlusGeneration");
static_assert(sizeof(GameModeZion_GetNewGamePlusGeneration) == 0x000004, "Wrong size on GameModeZion_GetNewGamePlusGeneration");
static_assert(offsetof(GameModeZion_GetNewGamePlusGeneration, ReturnValue) == 0x000000, "Member 'GameModeZion_GetNewGamePlusGeneration::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetNewGamePlusGenerationOverride
// 0x0004 (0x0004 - 0x0000)
struct GameModeZion_GetNewGamePlusGenerationOverride final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetNewGamePlusGenerationOverride) == 0x000004, "Wrong alignment on GameModeZion_GetNewGamePlusGenerationOverride");
static_assert(sizeof(GameModeZion_GetNewGamePlusGenerationOverride) == 0x000004, "Wrong size on GameModeZion_GetNewGamePlusGenerationOverride");
static_assert(offsetof(GameModeZion_GetNewGamePlusGenerationOverride, ReturnValue) == 0x000000, "Member 'GameModeZion_GetNewGamePlusGenerationOverride::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetPlayTimeAsString
// 0x0010 (0x0010 - 0x0000)
struct GameModeZion_GetPlayTimeAsString final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetPlayTimeAsString) == 0x000008, "Wrong alignment on GameModeZion_GetPlayTimeAsString");
static_assert(sizeof(GameModeZion_GetPlayTimeAsString) == 0x000010, "Wrong size on GameModeZion_GetPlayTimeAsString");
static_assert(offsetof(GameModeZion_GetPlayTimeAsString, ReturnValue) == 0x000000, "Member 'GameModeZion_GetPlayTimeAsString::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetRawEnvironmentLevel
// 0x0004 (0x0004 - 0x0000)
struct GameModeZion_GetRawEnvironmentLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetRawEnvironmentLevel) == 0x000004, "Wrong alignment on GameModeZion_GetRawEnvironmentLevel");
static_assert(sizeof(GameModeZion_GetRawEnvironmentLevel) == 0x000004, "Wrong size on GameModeZion_GetRawEnvironmentLevel");
static_assert(offsetof(GameModeZion_GetRawEnvironmentLevel, ReturnValue) == 0x000000, "Member 'GameModeZion_GetRawEnvironmentLevel::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.GetStepMatrixData
// 0x0008 (0x0008 - 0x0000)
struct GameModeZion_GetStepMatrixData final
{
public:
	class UStepMatrixData*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_GetStepMatrixData) == 0x000008, "Wrong alignment on GameModeZion_GetStepMatrixData");
static_assert(sizeof(GameModeZion_GetStepMatrixData) == 0x000008, "Wrong size on GameModeZion_GetStepMatrixData");
static_assert(offsetof(GameModeZion_GetStepMatrixData, ReturnValue) == 0x000000, "Member 'GameModeZion_GetStepMatrixData::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.IsDeathProcessingAllowed
// 0x0001 (0x0001 - 0x0000)
struct GameModeZion_IsDeathProcessingAllowed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_IsDeathProcessingAllowed) == 0x000001, "Wrong alignment on GameModeZion_IsDeathProcessingAllowed");
static_assert(sizeof(GameModeZion_IsDeathProcessingAllowed) == 0x000001, "Wrong size on GameModeZion_IsDeathProcessingAllowed");
static_assert(offsetof(GameModeZion_IsDeathProcessingAllowed, ReturnValue) == 0x000000, "Member 'GameModeZion_IsDeathProcessingAllowed::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.IsGameCleared
// 0x0001 (0x0001 - 0x0000)
struct GameModeZion_IsGameCleared final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_IsGameCleared) == 0x000001, "Wrong alignment on GameModeZion_IsGameCleared");
static_assert(sizeof(GameModeZion_IsGameCleared) == 0x000001, "Wrong size on GameModeZion_IsGameCleared");
static_assert(offsetof(GameModeZion_IsGameCleared, ReturnValue) == 0x000000, "Member 'GameModeZion_IsGameCleared::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.IsGameReady
// 0x0001 (0x0001 - 0x0000)
struct GameModeZion_IsGameReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_IsGameReady) == 0x000001, "Wrong alignment on GameModeZion_IsGameReady");
static_assert(sizeof(GameModeZion_IsGameReady) == 0x000001, "Wrong size on GameModeZion_IsGameReady");
static_assert(offsetof(GameModeZion_IsGameReady, ReturnValue) == 0x000000, "Member 'GameModeZion_IsGameReady::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.IsInNewGamePlus
// 0x0001 (0x0001 - 0x0000)
struct GameModeZion_IsInNewGamePlus final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_IsInNewGamePlus) == 0x000001, "Wrong alignment on GameModeZion_IsInNewGamePlus");
static_assert(sizeof(GameModeZion_IsInNewGamePlus) == 0x000001, "Wrong size on GameModeZion_IsInNewGamePlus");
static_assert(offsetof(GameModeZion_IsInNewGamePlus, ReturnValue) == 0x000000, "Member 'GameModeZion_IsInNewGamePlus::ReturnValue' has a wrong offset!");

// Function Zion.GameModeZion.IsInRespawnProcess
// 0x0001 (0x0001 - 0x0000)
struct GameModeZion_IsInRespawnProcess final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeZion_IsInRespawnProcess) == 0x000001, "Wrong alignment on GameModeZion_IsInRespawnProcess");
static_assert(sizeof(GameModeZion_IsInRespawnProcess) == 0x000001, "Wrong size on GameModeZion_IsInRespawnProcess");
static_assert(offsetof(GameModeZion_IsInRespawnProcess, ReturnValue) == 0x000000, "Member 'GameModeZion_IsInRespawnProcess::ReturnValue' has a wrong offset!");

// Function Zion.GameplayConditionCheckerAsset.CheckGameplayConditionAsset
// 0x0018 (0x0018 - 0x0000)
struct GameplayConditionCheckerAsset_CheckGameplayConditionAsset final
{
public:
	TSubclassOf<class UGameplayConditionCheckerAsset> GameplayConditionAssetClass;                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      PlayerController;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayConditionCheckerAsset_CheckGameplayConditionAsset) == 0x000008, "Wrong alignment on GameplayConditionCheckerAsset_CheckGameplayConditionAsset");
static_assert(sizeof(GameplayConditionCheckerAsset_CheckGameplayConditionAsset) == 0x000018, "Wrong size on GameplayConditionCheckerAsset_CheckGameplayConditionAsset");
static_assert(offsetof(GameplayConditionCheckerAsset_CheckGameplayConditionAsset, GameplayConditionAssetClass) == 0x000000, "Member 'GameplayConditionCheckerAsset_CheckGameplayConditionAsset::GameplayConditionAssetClass' has a wrong offset!");
static_assert(offsetof(GameplayConditionCheckerAsset_CheckGameplayConditionAsset, PlayerController) == 0x000008, "Member 'GameplayConditionCheckerAsset_CheckGameplayConditionAsset::PlayerController' has a wrong offset!");
static_assert(offsetof(GameplayConditionCheckerAsset_CheckGameplayConditionAsset, ReturnValue) == 0x000010, "Member 'GameplayConditionCheckerAsset_CheckGameplayConditionAsset::ReturnValue' has a wrong offset!");

// Function Zion.GameplayConditionCheckerAsset.CheckCondition
// 0x0010 (0x0010 - 0x0000)
struct GameplayConditionCheckerAsset_CheckCondition final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayConditionCheckerAsset_CheckCondition) == 0x000008, "Wrong alignment on GameplayConditionCheckerAsset_CheckCondition");
static_assert(sizeof(GameplayConditionCheckerAsset_CheckCondition) == 0x000010, "Wrong size on GameplayConditionCheckerAsset_CheckCondition");
static_assert(offsetof(GameplayConditionCheckerAsset_CheckCondition, PlayerController) == 0x000000, "Member 'GameplayConditionCheckerAsset_CheckCondition::PlayerController' has a wrong offset!");
static_assert(offsetof(GameplayConditionCheckerAsset_CheckCondition, ReturnValue) == 0x000008, "Member 'GameplayConditionCheckerAsset_CheckCondition::ReturnValue' has a wrong offset!");

// Function Zion.GameStatsComponent.SetPause
// 0x0004 (0x0004 - 0x0000)
struct GameStatsComponent_SetPause final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameStatsComponent_SetPause) == 0x000004, "Wrong alignment on GameStatsComponent_SetPause");
static_assert(sizeof(GameStatsComponent_SetPause) == 0x000004, "Wrong size on GameStatsComponent_SetPause");
static_assert(offsetof(GameStatsComponent_SetPause, ReturnValue) == 0x000000, "Member 'GameStatsComponent_SetPause::ReturnValue' has a wrong offset!");

// Function Zion.GameStatsComponent.UnsetPause
// 0x0004 (0x0004 - 0x0000)
struct GameStatsComponent_UnsetPause final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameStatsComponent_UnsetPause) == 0x000004, "Wrong alignment on GameStatsComponent_UnsetPause");
static_assert(sizeof(GameStatsComponent_UnsetPause) == 0x000004, "Wrong size on GameStatsComponent_UnsetPause");
static_assert(offsetof(GameStatsComponent_UnsetPause, ReturnValue) == 0x000000, "Member 'GameStatsComponent_UnsetPause::ReturnValue' has a wrong offset!");

// Function Zion.GameStatsComponent.GetPlayTimeAsString
// 0x0010 (0x0010 - 0x0000)
struct GameStatsComponent_GetPlayTimeAsString final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameStatsComponent_GetPlayTimeAsString) == 0x000008, "Wrong alignment on GameStatsComponent_GetPlayTimeAsString");
static_assert(sizeof(GameStatsComponent_GetPlayTimeAsString) == 0x000010, "Wrong size on GameStatsComponent_GetPlayTimeAsString");
static_assert(offsetof(GameStatsComponent_GetPlayTimeAsString, ReturnValue) == 0x000000, "Member 'GameStatsComponent_GetPlayTimeAsString::ReturnValue' has a wrong offset!");

// Function Zion.GuardComponent.OnGuarded
// 0x0010 (0x0010 - 0x0000)
struct GuardComponent_OnGuarded final
{
public:
	class AAbility*                               Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardComponent_OnGuarded) == 0x000008, "Wrong alignment on GuardComponent_OnGuarded");
static_assert(sizeof(GuardComponent_OnGuarded) == 0x000010, "Wrong size on GuardComponent_OnGuarded");
static_assert(offsetof(GuardComponent_OnGuarded, Ability) == 0x000000, "Member 'GuardComponent_OnGuarded::Ability' has a wrong offset!");
static_assert(offsetof(GuardComponent_OnGuarded, Source) == 0x000008, "Member 'GuardComponent_OnGuarded::Source' has a wrong offset!");

// Function Zion.HealComponent.AddHealCountBonus
// 0x0008 (0x0008 - 0x0000)
struct HealComponent_AddHealCountBonus final
{
public:
	int32                                         HealCountBonusToAdd;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealComponent_AddHealCountBonus) == 0x000004, "Wrong alignment on HealComponent_AddHealCountBonus");
static_assert(sizeof(HealComponent_AddHealCountBonus) == 0x000008, "Wrong size on HealComponent_AddHealCountBonus");
static_assert(offsetof(HealComponent_AddHealCountBonus, HealCountBonusToAdd) == 0x000000, "Member 'HealComponent_AddHealCountBonus::HealCountBonusToAdd' has a wrong offset!");
static_assert(offsetof(HealComponent_AddHealCountBonus, ReturnValue) == 0x000004, "Member 'HealComponent_AddHealCountBonus::ReturnValue' has a wrong offset!");

// Function Zion.HealComponent.AddHealPowerPercentageBonus
// 0x0008 (0x0008 - 0x0000)
struct HealComponent_AddHealPowerPercentageBonus final
{
public:
	int32                                         HealPercentBonusToAdd;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealComponent_AddHealPowerPercentageBonus) == 0x000004, "Wrong alignment on HealComponent_AddHealPowerPercentageBonus");
static_assert(sizeof(HealComponent_AddHealPowerPercentageBonus) == 0x000008, "Wrong size on HealComponent_AddHealPowerPercentageBonus");
static_assert(offsetof(HealComponent_AddHealPowerPercentageBonus, HealPercentBonusToAdd) == 0x000000, "Member 'HealComponent_AddHealPowerPercentageBonus::HealPercentBonusToAdd' has a wrong offset!");
static_assert(offsetof(HealComponent_AddHealPowerPercentageBonus, ReturnValue) == 0x000004, "Member 'HealComponent_AddHealPowerPercentageBonus::ReturnValue' has a wrong offset!");

// Function Zion.HealComponent.FullyRestoreHeals
// 0x0001 (0x0001 - 0x0000)
struct HealComponent_FullyRestoreHeals final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealComponent_FullyRestoreHeals) == 0x000001, "Wrong alignment on HealComponent_FullyRestoreHeals");
static_assert(sizeof(HealComponent_FullyRestoreHeals) == 0x000001, "Wrong size on HealComponent_FullyRestoreHeals");
static_assert(offsetof(HealComponent_FullyRestoreHeals, ReturnValue) == 0x000000, "Member 'HealComponent_FullyRestoreHeals::ReturnValue' has a wrong offset!");

// Function Zion.HealComponent.RestoreHeals
// 0x0008 (0x0008 - 0x0000)
struct HealComponent_RestoreHeals final
{
public:
	int32                                         RestoreCount;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealComponent_RestoreHeals) == 0x000004, "Wrong alignment on HealComponent_RestoreHeals");
static_assert(sizeof(HealComponent_RestoreHeals) == 0x000008, "Wrong size on HealComponent_RestoreHeals");
static_assert(offsetof(HealComponent_RestoreHeals, RestoreCount) == 0x000000, "Member 'HealComponent_RestoreHeals::RestoreCount' has a wrong offset!");
static_assert(offsetof(HealComponent_RestoreHeals, ReturnValue) == 0x000004, "Member 'HealComponent_RestoreHeals::ReturnValue' has a wrong offset!");

// Function Zion.HealComponent.SubHealCountBonus
// 0x0008 (0x0008 - 0x0000)
struct HealComponent_SubHealCountBonus final
{
public:
	int32                                         HealCountBonusToSub;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealComponent_SubHealCountBonus) == 0x000004, "Wrong alignment on HealComponent_SubHealCountBonus");
static_assert(sizeof(HealComponent_SubHealCountBonus) == 0x000008, "Wrong size on HealComponent_SubHealCountBonus");
static_assert(offsetof(HealComponent_SubHealCountBonus, HealCountBonusToSub) == 0x000000, "Member 'HealComponent_SubHealCountBonus::HealCountBonusToSub' has a wrong offset!");
static_assert(offsetof(HealComponent_SubHealCountBonus, ReturnValue) == 0x000004, "Member 'HealComponent_SubHealCountBonus::ReturnValue' has a wrong offset!");

// Function Zion.HealComponent.SubHealPowerPercentageBonus
// 0x0008 (0x0008 - 0x0000)
struct HealComponent_SubHealPowerPercentageBonus final
{
public:
	int32                                         HealPercentBonusToSub;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealComponent_SubHealPowerPercentageBonus) == 0x000004, "Wrong alignment on HealComponent_SubHealPowerPercentageBonus");
static_assert(sizeof(HealComponent_SubHealPowerPercentageBonus) == 0x000008, "Wrong size on HealComponent_SubHealPowerPercentageBonus");
static_assert(offsetof(HealComponent_SubHealPowerPercentageBonus, HealPercentBonusToSub) == 0x000000, "Member 'HealComponent_SubHealPowerPercentageBonus::HealPercentBonusToSub' has a wrong offset!");
static_assert(offsetof(HealComponent_SubHealPowerPercentageBonus, ReturnValue) == 0x000004, "Member 'HealComponent_SubHealPowerPercentageBonus::ReturnValue' has a wrong offset!");

// Function Zion.HealComponent.GetHealValue
// 0x0004 (0x0004 - 0x0000)
struct HealComponent_GetHealValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealComponent_GetHealValue) == 0x000004, "Wrong alignment on HealComponent_GetHealValue");
static_assert(sizeof(HealComponent_GetHealValue) == 0x000004, "Wrong size on HealComponent_GetHealValue");
static_assert(offsetof(HealComponent_GetHealValue, ReturnValue) == 0x000000, "Member 'HealComponent_GetHealValue::ReturnValue' has a wrong offset!");

// Function Zion.HealComponent.GetMaxHealCount
// 0x0004 (0x0004 - 0x0000)
struct HealComponent_GetMaxHealCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealComponent_GetMaxHealCount) == 0x000004, "Wrong alignment on HealComponent_GetMaxHealCount");
static_assert(sizeof(HealComponent_GetMaxHealCount) == 0x000004, "Wrong size on HealComponent_GetMaxHealCount");
static_assert(offsetof(HealComponent_GetMaxHealCount, ReturnValue) == 0x000000, "Member 'HealComponent_GetMaxHealCount::ReturnValue' has a wrong offset!");

// Function Zion.HealComponent.GetRemainingHealCount
// 0x0004 (0x0004 - 0x0000)
struct HealComponent_GetRemainingHealCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealComponent_GetRemainingHealCount) == 0x000004, "Wrong alignment on HealComponent_GetRemainingHealCount");
static_assert(sizeof(HealComponent_GetRemainingHealCount) == 0x000004, "Wrong size on HealComponent_GetRemainingHealCount");
static_assert(offsetof(HealComponent_GetRemainingHealCount, ReturnValue) == 0x000000, "Member 'HealComponent_GetRemainingHealCount::ReturnValue' has a wrong offset!");

// Function Zion.HealComponent.IsHealCountMax
// 0x0001 (0x0001 - 0x0000)
struct HealComponent_IsHealCountMax final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealComponent_IsHealCountMax) == 0x000001, "Wrong alignment on HealComponent_IsHealCountMax");
static_assert(sizeof(HealComponent_IsHealCountMax) == 0x000001, "Wrong size on HealComponent_IsHealCountMax");
static_assert(offsetof(HealComponent_IsHealCountMax, ReturnValue) == 0x000000, "Member 'HealComponent_IsHealCountMax::ReturnValue' has a wrong offset!");

// Function Zion.HitStopComponent.LaunchHitStop
// 0x0004 (0x0004 - 0x0000)
struct HitStopComponent_LaunchHitStop final
{
public:
	float                                         HitStopDuration;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitStopComponent_LaunchHitStop) == 0x000004, "Wrong alignment on HitStopComponent_LaunchHitStop");
static_assert(sizeof(HitStopComponent_LaunchHitStop) == 0x000004, "Wrong size on HitStopComponent_LaunchHitStop");
static_assert(offsetof(HitStopComponent_LaunchHitStop, HitStopDuration) == 0x000000, "Member 'HitStopComponent_LaunchHitStop::HitStopDuration' has a wrong offset!");

// Function Zion.HitStopComponent.IsInHitStop
// 0x0001 (0x0001 - 0x0000)
struct HitStopComponent_IsInHitStop final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitStopComponent_IsInHitStop) == 0x000001, "Wrong alignment on HitStopComponent_IsInHitStop");
static_assert(sizeof(HitStopComponent_IsInHitStop) == 0x000001, "Wrong size on HitStopComponent_IsInHitStop");
static_assert(offsetof(HitStopComponent_IsInHitStop, ReturnValue) == 0x000000, "Member 'HitStopComponent_IsInHitStop::ReturnValue' has a wrong offset!");

// Function Zion.HomingComponent.SetTarget
// 0x0010 (0x0010 - 0x0000)
struct HomingComponent_SetTarget final
{
public:
	const class AActor*                           TargetActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReset;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HomingComponent_SetTarget) == 0x000008, "Wrong alignment on HomingComponent_SetTarget");
static_assert(sizeof(HomingComponent_SetTarget) == 0x000010, "Wrong size on HomingComponent_SetTarget");
static_assert(offsetof(HomingComponent_SetTarget, TargetActor) == 0x000000, "Member 'HomingComponent_SetTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(HomingComponent_SetTarget, bReset) == 0x000008, "Member 'HomingComponent_SetTarget::bReset' has a wrong offset!");

// Function Zion.HomingComponent.DidReachTarget
// 0x0010 (0x0010 - 0x0000)
struct HomingComponent_DidReachTarget final
{
public:
	const class USceneComponent*                  PinnedTarget;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HomingComponent_DidReachTarget) == 0x000008, "Wrong alignment on HomingComponent_DidReachTarget");
static_assert(sizeof(HomingComponent_DidReachTarget) == 0x000010, "Wrong size on HomingComponent_DidReachTarget");
static_assert(offsetof(HomingComponent_DidReachTarget, PinnedTarget) == 0x000000, "Member 'HomingComponent_DidReachTarget::PinnedTarget' has a wrong offset!");
static_assert(offsetof(HomingComponent_DidReachTarget, ReturnValue) == 0x000008, "Member 'HomingComponent_DidReachTarget::ReturnValue' has a wrong offset!");

// Function Zion.HomingComponent.GetTarget
// 0x0008 (0x0008 - 0x0000)
struct HomingComponent_GetTarget final
{
public:
	const class USceneComponent*                  ReturnValue;                                       // 0x0000(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HomingComponent_GetTarget) == 0x000008, "Wrong alignment on HomingComponent_GetTarget");
static_assert(sizeof(HomingComponent_GetTarget) == 0x000008, "Wrong size on HomingComponent_GetTarget");
static_assert(offsetof(HomingComponent_GetTarget, ReturnValue) == 0x000000, "Member 'HomingComponent_GetTarget::ReturnValue' has a wrong offset!");

// Function Zion.IKBonesComponent.GetIKBone
// 0x0010 (0x0010 - 0x0000)
struct IKBonesComponent_GetIKBone final
{
public:
	EIKBoneDriver                                 IKBoneDriver;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(IKBonesComponent_GetIKBone) == 0x000008, "Wrong alignment on IKBonesComponent_GetIKBone");
static_assert(sizeof(IKBonesComponent_GetIKBone) == 0x000010, "Wrong size on IKBonesComponent_GetIKBone");
static_assert(offsetof(IKBonesComponent_GetIKBone, IKBoneDriver) == 0x000000, "Member 'IKBonesComponent_GetIKBone::IKBoneDriver' has a wrong offset!");
static_assert(offsetof(IKBonesComponent_GetIKBone, ReturnValue) == 0x000008, "Member 'IKBonesComponent_GetIKBone::ReturnValue' has a wrong offset!");

// Function Zion.IKBonesComponent.ResetIKBone
// 0x0002 (0x0002 - 0x0000)
struct IKBonesComponent_ResetIKBone final
{
public:
	EIKBoneDriver                                 IKBoneDriver;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetIKConstraint;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(IKBonesComponent_ResetIKBone) == 0x000001, "Wrong alignment on IKBonesComponent_ResetIKBone");
static_assert(sizeof(IKBonesComponent_ResetIKBone) == 0x000002, "Wrong size on IKBonesComponent_ResetIKBone");
static_assert(offsetof(IKBonesComponent_ResetIKBone, IKBoneDriver) == 0x000000, "Member 'IKBonesComponent_ResetIKBone::IKBoneDriver' has a wrong offset!");
static_assert(offsetof(IKBonesComponent_ResetIKBone, bResetIKConstraint) == 0x000001, "Member 'IKBonesComponent_ResetIKBone::bResetIKConstraint' has a wrong offset!");

// Function Zion.InputBPFLibrary.IsEqual
// 0x0178 (0x0178 - 0x0000)
struct InputBPFLibrary_IsEqual final
{
public:
	struct FInputSnapshot                         A;                                                 // 0x0000(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FInputSnapshot                         B;                                                 // 0x00B8(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0170(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputBPFLibrary_IsEqual) == 0x000008, "Wrong alignment on InputBPFLibrary_IsEqual");
static_assert(sizeof(InputBPFLibrary_IsEqual) == 0x000178, "Wrong size on InputBPFLibrary_IsEqual");
static_assert(offsetof(InputBPFLibrary_IsEqual, A) == 0x000000, "Member 'InputBPFLibrary_IsEqual::A' has a wrong offset!");
static_assert(offsetof(InputBPFLibrary_IsEqual, B) == 0x0000B8, "Member 'InputBPFLibrary_IsEqual::B' has a wrong offset!");
static_assert(offsetof(InputBPFLibrary_IsEqual, ReturnValue) == 0x000170, "Member 'InputBPFLibrary_IsEqual::ReturnValue' has a wrong offset!");

// Function Zion.InputBPFLibrary.IsInputActionJustTriggered
// 0x00C8 (0x00C8 - 0x0000)
struct InputBPFLibrary_IsInputActionJustTriggered final
{
public:
	struct FInputSnapshot                         InputSnapshot;                                     // 0x0000(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UInputAction*                     InputAction;                                       // 0x00B8(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00C0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputBPFLibrary_IsInputActionJustTriggered) == 0x000008, "Wrong alignment on InputBPFLibrary_IsInputActionJustTriggered");
static_assert(sizeof(InputBPFLibrary_IsInputActionJustTriggered) == 0x0000C8, "Wrong size on InputBPFLibrary_IsInputActionJustTriggered");
static_assert(offsetof(InputBPFLibrary_IsInputActionJustTriggered, InputSnapshot) == 0x000000, "Member 'InputBPFLibrary_IsInputActionJustTriggered::InputSnapshot' has a wrong offset!");
static_assert(offsetof(InputBPFLibrary_IsInputActionJustTriggered, InputAction) == 0x0000B8, "Member 'InputBPFLibrary_IsInputActionJustTriggered::InputAction' has a wrong offset!");
static_assert(offsetof(InputBPFLibrary_IsInputActionJustTriggered, ReturnValue) == 0x0000C0, "Member 'InputBPFLibrary_IsInputActionJustTriggered::ReturnValue' has a wrong offset!");

// Function Zion.InputBPFLibrary.IsInputActionTriggering
// 0x00C8 (0x00C8 - 0x0000)
struct InputBPFLibrary_IsInputActionTriggering final
{
public:
	struct FInputSnapshot                         InputSnapshot;                                     // 0x0000(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UInputAction*                     InputAction;                                       // 0x00B8(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00C0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputBPFLibrary_IsInputActionTriggering) == 0x000008, "Wrong alignment on InputBPFLibrary_IsInputActionTriggering");
static_assert(sizeof(InputBPFLibrary_IsInputActionTriggering) == 0x0000C8, "Wrong size on InputBPFLibrary_IsInputActionTriggering");
static_assert(offsetof(InputBPFLibrary_IsInputActionTriggering, InputSnapshot) == 0x000000, "Member 'InputBPFLibrary_IsInputActionTriggering::InputSnapshot' has a wrong offset!");
static_assert(offsetof(InputBPFLibrary_IsInputActionTriggering, InputAction) == 0x0000B8, "Member 'InputBPFLibrary_IsInputActionTriggering::InputAction' has a wrong offset!");
static_assert(offsetof(InputBPFLibrary_IsInputActionTriggering, ReturnValue) == 0x0000C0, "Member 'InputBPFLibrary_IsInputActionTriggering::ReturnValue' has a wrong offset!");

// Function Zion.InputBPFLibrary.IsSameHorizontalDirection
// 0x0004 (0x0004 - 0x0000)
struct InputBPFLibrary_IsSameHorizontalDirection final
{
public:
	EInputDirection                               DirectionA;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDirection                               DirectionB;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsiderNeutralAsSame;                            // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0003(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InputBPFLibrary_IsSameHorizontalDirection) == 0x000001, "Wrong alignment on InputBPFLibrary_IsSameHorizontalDirection");
static_assert(sizeof(InputBPFLibrary_IsSameHorizontalDirection) == 0x000004, "Wrong size on InputBPFLibrary_IsSameHorizontalDirection");
static_assert(offsetof(InputBPFLibrary_IsSameHorizontalDirection, DirectionA) == 0x000000, "Member 'InputBPFLibrary_IsSameHorizontalDirection::DirectionA' has a wrong offset!");
static_assert(offsetof(InputBPFLibrary_IsSameHorizontalDirection, DirectionB) == 0x000001, "Member 'InputBPFLibrary_IsSameHorizontalDirection::DirectionB' has a wrong offset!");
static_assert(offsetof(InputBPFLibrary_IsSameHorizontalDirection, bConsiderNeutralAsSame) == 0x000002, "Member 'InputBPFLibrary_IsSameHorizontalDirection::bConsiderNeutralAsSame' has a wrong offset!");
static_assert(offsetof(InputBPFLibrary_IsSameHorizontalDirection, ReturnValue) == 0x000003, "Member 'InputBPFLibrary_IsSameHorizontalDirection::ReturnValue' has a wrong offset!");

// Function Zion.InputBPFLibrary.IsSameVerticalDirection
// 0x0004 (0x0004 - 0x0000)
struct InputBPFLibrary_IsSameVerticalDirection final
{
public:
	EInputDirection                               DirectionA;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDirection                               DirectionB;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsiderNeutralAsSame;                            // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0003(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InputBPFLibrary_IsSameVerticalDirection) == 0x000001, "Wrong alignment on InputBPFLibrary_IsSameVerticalDirection");
static_assert(sizeof(InputBPFLibrary_IsSameVerticalDirection) == 0x000004, "Wrong size on InputBPFLibrary_IsSameVerticalDirection");
static_assert(offsetof(InputBPFLibrary_IsSameVerticalDirection, DirectionA) == 0x000000, "Member 'InputBPFLibrary_IsSameVerticalDirection::DirectionA' has a wrong offset!");
static_assert(offsetof(InputBPFLibrary_IsSameVerticalDirection, DirectionB) == 0x000001, "Member 'InputBPFLibrary_IsSameVerticalDirection::DirectionB' has a wrong offset!");
static_assert(offsetof(InputBPFLibrary_IsSameVerticalDirection, bConsiderNeutralAsSame) == 0x000002, "Member 'InputBPFLibrary_IsSameVerticalDirection::bConsiderNeutralAsSame' has a wrong offset!");
static_assert(offsetof(InputBPFLibrary_IsSameVerticalDirection, ReturnValue) == 0x000003, "Member 'InputBPFLibrary_IsSameVerticalDirection::ReturnValue' has a wrong offset!");

// Function Zion.InputBufferComponent.GetInputSnapshotAtIndex
// 0x0120 (0x0120 - 0x0000)
struct InputBufferComponent_GetInputSnapshotAtIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimedInputSnapshot                    ReturnValue;                                       // 0x0008(0x0118)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InputBufferComponent_GetInputSnapshotAtIndex) == 0x000008, "Wrong alignment on InputBufferComponent_GetInputSnapshotAtIndex");
static_assert(sizeof(InputBufferComponent_GetInputSnapshotAtIndex) == 0x000120, "Wrong size on InputBufferComponent_GetInputSnapshotAtIndex");
static_assert(offsetof(InputBufferComponent_GetInputSnapshotAtIndex, Index_0) == 0x000000, "Member 'InputBufferComponent_GetInputSnapshotAtIndex::Index_0' has a wrong offset!");
static_assert(offsetof(InputBufferComponent_GetInputSnapshotAtIndex, ReturnValue) == 0x000008, "Member 'InputBufferComponent_GetInputSnapshotAtIndex::ReturnValue' has a wrong offset!");

// Function Zion.InputBufferComponent.GetInputSnapshotCount
// 0x0004 (0x0004 - 0x0000)
struct InputBufferComponent_GetInputSnapshotCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InputBufferComponent_GetInputSnapshotCount) == 0x000004, "Wrong alignment on InputBufferComponent_GetInputSnapshotCount");
static_assert(sizeof(InputBufferComponent_GetInputSnapshotCount) == 0x000004, "Wrong size on InputBufferComponent_GetInputSnapshotCount");
static_assert(offsetof(InputBufferComponent_GetInputSnapshotCount, ReturnValue) == 0x000000, "Member 'InputBufferComponent_GetInputSnapshotCount::ReturnValue' has a wrong offset!");

// Function Zion.Interactable.OnActivateInteractable
// 0x0008 (0x0008 - 0x0000)
struct Interactable_OnActivateInteractable final
{
public:
	class APlayerController*                      Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_OnActivateInteractable) == 0x000008, "Wrong alignment on Interactable_OnActivateInteractable");
static_assert(sizeof(Interactable_OnActivateInteractable) == 0x000008, "Wrong size on Interactable_OnActivateInteractable");
static_assert(offsetof(Interactable_OnActivateInteractable, Controller) == 0x000000, "Member 'Interactable_OnActivateInteractable::Controller' has a wrong offset!");

// Function Zion.Interactable.OnDeactivateInteractable
// 0x0008 (0x0008 - 0x0000)
struct Interactable_OnDeactivateInteractable final
{
public:
	class APlayerController*                      Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_OnDeactivateInteractable) == 0x000008, "Wrong alignment on Interactable_OnDeactivateInteractable");
static_assert(sizeof(Interactable_OnDeactivateInteractable) == 0x000008, "Wrong size on Interactable_OnDeactivateInteractable");
static_assert(offsetof(Interactable_OnDeactivateInteractable, Controller) == 0x000000, "Member 'Interactable_OnDeactivateInteractable::Controller' has a wrong offset!");

// Function Zion.Interactable.OnInteract
// 0x0008 (0x0008 - 0x0000)
struct Interactable_OnInteract final
{
public:
	class APlayerController*                      Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_OnInteract) == 0x000008, "Wrong alignment on Interactable_OnInteract");
static_assert(sizeof(Interactable_OnInteract) == 0x000008, "Wrong size on Interactable_OnInteract");
static_assert(offsetof(Interactable_OnInteract, Controller) == 0x000000, "Member 'Interactable_OnInteract::Controller' has a wrong offset!");

// Function Zion.Interactable.OnInteract_ConditionCheckFailed
// 0x0008 (0x0008 - 0x0000)
struct Interactable_OnInteract_ConditionCheckFailed final
{
public:
	class APlayerController*                      Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_OnInteract_ConditionCheckFailed) == 0x000008, "Wrong alignment on Interactable_OnInteract_ConditionCheckFailed");
static_assert(sizeof(Interactable_OnInteract_ConditionCheckFailed) == 0x000008, "Wrong size on Interactable_OnInteract_ConditionCheckFailed");
static_assert(offsetof(Interactable_OnInteract_ConditionCheckFailed, Controller) == 0x000000, "Member 'Interactable_OnInteract_ConditionCheckFailed::Controller' has a wrong offset!");

// Function Zion.Interactable.SetCanBeInteracted
// 0x0001 (0x0001 - 0x0000)
struct Interactable_SetCanBeInteracted final
{
public:
	bool                                          bCanInteract;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_SetCanBeInteracted) == 0x000001, "Wrong alignment on Interactable_SetCanBeInteracted");
static_assert(sizeof(Interactable_SetCanBeInteracted) == 0x000001, "Wrong size on Interactable_SetCanBeInteracted");
static_assert(offsetof(Interactable_SetCanBeInteracted, bCanInteract) == 0x000000, "Member 'Interactable_SetCanBeInteracted::bCanInteract' has a wrong offset!");

// Function Zion.Interactable.CanBeInteracted
// 0x0001 (0x0001 - 0x0000)
struct Interactable_CanBeInteracted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_CanBeInteracted) == 0x000001, "Wrong alignment on Interactable_CanBeInteracted");
static_assert(sizeof(Interactable_CanBeInteracted) == 0x000001, "Wrong size on Interactable_CanBeInteracted");
static_assert(offsetof(Interactable_CanBeInteracted, ReturnValue) == 0x000000, "Member 'Interactable_CanBeInteracted::ReturnValue' has a wrong offset!");

// Function Zion.Interactable.ConditionsChecked
// 0x0001 (0x0001 - 0x0000)
struct Interactable_ConditionsChecked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_ConditionsChecked) == 0x000001, "Wrong alignment on Interactable_ConditionsChecked");
static_assert(sizeof(Interactable_ConditionsChecked) == 0x000001, "Wrong size on Interactable_ConditionsChecked");
static_assert(offsetof(Interactable_ConditionsChecked, ReturnValue) == 0x000000, "Member 'Interactable_ConditionsChecked::ReturnValue' has a wrong offset!");

// Function Zion.Interactable.GetInteractingController
// 0x0008 (0x0008 - 0x0000)
struct Interactable_GetInteractingController final
{
public:
	class APlayerController*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_GetInteractingController) == 0x000008, "Wrong alignment on Interactable_GetInteractingController");
static_assert(sizeof(Interactable_GetInteractingController) == 0x000008, "Wrong size on Interactable_GetInteractingController");
static_assert(offsetof(Interactable_GetInteractingController, ReturnValue) == 0x000000, "Member 'Interactable_GetInteractingController::ReturnValue' has a wrong offset!");

// Function Zion.Interactable.GetInteractionText
// 0x0010 (0x0010 - 0x0000)
struct Interactable_GetInteractionText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_GetInteractionText) == 0x000008, "Wrong alignment on Interactable_GetInteractionText");
static_assert(sizeof(Interactable_GetInteractionText) == 0x000010, "Wrong size on Interactable_GetInteractionText");
static_assert(offsetof(Interactable_GetInteractionText, ReturnValue) == 0x000000, "Member 'Interactable_GetInteractionText::ReturnValue' has a wrong offset!");

// Function Zion.Interactable.PlaySoundEvent
// 0x0008 (0x0008 - 0x0000)
struct Interactable_PlaySoundEvent final
{
public:
	class UFMODEvent*                             SoundEffect;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_PlaySoundEvent) == 0x000008, "Wrong alignment on Interactable_PlaySoundEvent");
static_assert(sizeof(Interactable_PlaySoundEvent) == 0x000008, "Wrong size on Interactable_PlaySoundEvent");
static_assert(offsetof(Interactable_PlaySoundEvent, SoundEffect) == 0x000000, "Member 'Interactable_PlaySoundEvent::SoundEffect' has a wrong offset!");

// Function Zion.Interactable_Event.OnClearStatusChecked
// 0x0001 (0x0001 - 0x0000)
struct Interactable_Event_OnClearStatusChecked final
{
public:
	EClearStatus                                  ClearStatus;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_Event_OnClearStatusChecked) == 0x000001, "Wrong alignment on Interactable_Event_OnClearStatusChecked");
static_assert(sizeof(Interactable_Event_OnClearStatusChecked) == 0x000001, "Wrong size on Interactable_Event_OnClearStatusChecked");
static_assert(offsetof(Interactable_Event_OnClearStatusChecked, ClearStatus) == 0x000000, "Member 'Interactable_Event_OnClearStatusChecked::ClearStatus' has a wrong offset!");

// Function Zion.Interactable_Event.OnEventFinished
// 0x0010 (0x0010 - 0x0000)
struct Interactable_Event_OnEventFinished final
{
public:
	class UEventPlayer*                           InEventPlayer;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompletedEvent;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEventPlayerResult                            EventResult;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Interactable_Event_OnEventFinished) == 0x000008, "Wrong alignment on Interactable_Event_OnEventFinished");
static_assert(sizeof(Interactable_Event_OnEventFinished) == 0x000010, "Wrong size on Interactable_Event_OnEventFinished");
static_assert(offsetof(Interactable_Event_OnEventFinished, InEventPlayer) == 0x000000, "Member 'Interactable_Event_OnEventFinished::InEventPlayer' has a wrong offset!");
static_assert(offsetof(Interactable_Event_OnEventFinished, bCompletedEvent) == 0x000008, "Member 'Interactable_Event_OnEventFinished::bCompletedEvent' has a wrong offset!");
static_assert(offsetof(Interactable_Event_OnEventFinished, EventResult) == 0x000009, "Member 'Interactable_Event_OnEventFinished::EventResult' has a wrong offset!");

// Function Zion.Interactable_Event.SetupAdditionalBindings
// 0x0050 (0x0050 - 0x0000)
struct Interactable_Event_SetupAdditionalBindings final
{
public:
	TMap<class FName, class AActor*>              AdditionalBindings;                                // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_Event_SetupAdditionalBindings) == 0x000008, "Wrong alignment on Interactable_Event_SetupAdditionalBindings");
static_assert(sizeof(Interactable_Event_SetupAdditionalBindings) == 0x000050, "Wrong size on Interactable_Event_SetupAdditionalBindings");
static_assert(offsetof(Interactable_Event_SetupAdditionalBindings, AdditionalBindings) == 0x000000, "Member 'Interactable_Event_SetupAdditionalBindings::AdditionalBindings' has a wrong offset!");

// Function Zion.Interactable_Event.SetupAdditionalBlackboardValues
// 0x0140 (0x0140 - 0x0000)
struct Interactable_Event_SetupAdditionalBlackboardValues final
{
public:
	struct FEventBlackboardInit                   EventBlackboardInit;                               // 0x0000(0x0140)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_Event_SetupAdditionalBlackboardValues) == 0x000008, "Wrong alignment on Interactable_Event_SetupAdditionalBlackboardValues");
static_assert(sizeof(Interactable_Event_SetupAdditionalBlackboardValues) == 0x000140, "Wrong size on Interactable_Event_SetupAdditionalBlackboardValues");
static_assert(offsetof(Interactable_Event_SetupAdditionalBlackboardValues, EventBlackboardInit) == 0x000000, "Member 'Interactable_Event_SetupAdditionalBlackboardValues::EventBlackboardInit' has a wrong offset!");

// Function Zion.Interactable_EventNPC.GetNPC
// 0x0008 (0x0008 - 0x0000)
struct Interactable_EventNPC_GetNPC final
{
public:
	class ACharacterZionNPC*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_EventNPC_GetNPC) == 0x000008, "Wrong alignment on Interactable_EventNPC_GetNPC");
static_assert(sizeof(Interactable_EventNPC_GetNPC) == 0x000008, "Wrong size on Interactable_EventNPC_GetNPC");
static_assert(offsetof(Interactable_EventNPC_GetNPC, ReturnValue) == 0x000000, "Member 'Interactable_EventNPC_GetNPC::ReturnValue' has a wrong offset!");

// Function Zion.Interactable_RestPoint.SetNextEventDataHandle
// 0x0010 (0x0010 - 0x0000)
struct Interactable_RestPoint_SetNextEventDataHandle final
{
public:
	struct FDataTableRowHandle                    InNextEventDataHandle;                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_RestPoint_SetNextEventDataHandle) == 0x000008, "Wrong alignment on Interactable_RestPoint_SetNextEventDataHandle");
static_assert(sizeof(Interactable_RestPoint_SetNextEventDataHandle) == 0x000010, "Wrong size on Interactable_RestPoint_SetNextEventDataHandle");
static_assert(offsetof(Interactable_RestPoint_SetNextEventDataHandle, InNextEventDataHandle) == 0x000000, "Member 'Interactable_RestPoint_SetNextEventDataHandle::InNextEventDataHandle' has a wrong offset!");

// Function Zion.Interactable_RestPoint.GetNextEventDataHandle
// 0x0010 (0x0010 - 0x0000)
struct Interactable_RestPoint_GetNextEventDataHandle final
{
public:
	struct FDataTableRowHandle                    ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_RestPoint_GetNextEventDataHandle) == 0x000008, "Wrong alignment on Interactable_RestPoint_GetNextEventDataHandle");
static_assert(sizeof(Interactable_RestPoint_GetNextEventDataHandle) == 0x000010, "Wrong size on Interactable_RestPoint_GetNextEventDataHandle");
static_assert(offsetof(Interactable_RestPoint_GetNextEventDataHandle, ReturnValue) == 0x000000, "Member 'Interactable_RestPoint_GetNextEventDataHandle::ReturnValue' has a wrong offset!");

// Function Zion.Interactable_RestPoint.GetRestPointDataHandle
// 0x0010 (0x0010 - 0x0000)
struct Interactable_RestPoint_GetRestPointDataHandle final
{
public:
	struct FDataTableRowHandle                    ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Interactable_RestPoint_GetRestPointDataHandle) == 0x000008, "Wrong alignment on Interactable_RestPoint_GetRestPointDataHandle");
static_assert(sizeof(Interactable_RestPoint_GetRestPointDataHandle) == 0x000010, "Wrong size on Interactable_RestPoint_GetRestPointDataHandle");
static_assert(offsetof(Interactable_RestPoint_GetRestPointDataHandle, ReturnValue) == 0x000000, "Member 'Interactable_RestPoint_GetRestPointDataHandle::ReturnValue' has a wrong offset!");

// Function Zion.InteractComponent.OnOverlapBegin
// 0x0118 (0x0118 - 0x0000)
struct InteractComponent_OnOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractComponent_OnOverlapBegin) == 0x000008, "Wrong alignment on InteractComponent_OnOverlapBegin");
static_assert(sizeof(InteractComponent_OnOverlapBegin) == 0x000118, "Wrong size on InteractComponent_OnOverlapBegin");
static_assert(offsetof(InteractComponent_OnOverlapBegin, OverlappedComponent) == 0x000000, "Member 'InteractComponent_OnOverlapBegin::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(InteractComponent_OnOverlapBegin, OtherActor) == 0x000008, "Member 'InteractComponent_OnOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(InteractComponent_OnOverlapBegin, OtherComp) == 0x000010, "Member 'InteractComponent_OnOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(InteractComponent_OnOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'InteractComponent_OnOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(InteractComponent_OnOverlapBegin, bFromSweep) == 0x00001C, "Member 'InteractComponent_OnOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(InteractComponent_OnOverlapBegin, SweepResult) == 0x000020, "Member 'InteractComponent_OnOverlapBegin::SweepResult' has a wrong offset!");

// Function Zion.InteractComponent.OnOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct InteractComponent_OnOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteractComponent_OnOverlapEnd) == 0x000008, "Wrong alignment on InteractComponent_OnOverlapEnd");
static_assert(sizeof(InteractComponent_OnOverlapEnd) == 0x000020, "Wrong size on InteractComponent_OnOverlapEnd");
static_assert(offsetof(InteractComponent_OnOverlapEnd, OverlappedComponent) == 0x000000, "Member 'InteractComponent_OnOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(InteractComponent_OnOverlapEnd, OtherActor) == 0x000008, "Member 'InteractComponent_OnOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(InteractComponent_OnOverlapEnd, OtherComp) == 0x000010, "Member 'InteractComponent_OnOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(InteractComponent_OnOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'InteractComponent_OnOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function Zion.Inventory.GetAllItemsAvailable
// 0x0050 (0x0050 - 0x0000)
struct Inventory_GetAllItemsAvailable final
{
public:
	TMap<class FName, int32>                      ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_GetAllItemsAvailable) == 0x000008, "Wrong alignment on Inventory_GetAllItemsAvailable");
static_assert(sizeof(Inventory_GetAllItemsAvailable) == 0x000050, "Wrong size on Inventory_GetAllItemsAvailable");
static_assert(offsetof(Inventory_GetAllItemsAvailable, ReturnValue) == 0x000000, "Member 'Inventory_GetAllItemsAvailable::ReturnValue' has a wrong offset!");

// Function Zion.Inventory.MarkItemAsChecked
// 0x0008 (0x0008 - 0x0000)
struct Inventory_MarkItemAsChecked final
{
public:
	class FName                                   ItemRowName;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_MarkItemAsChecked) == 0x000004, "Wrong alignment on Inventory_MarkItemAsChecked");
static_assert(sizeof(Inventory_MarkItemAsChecked) == 0x000008, "Wrong size on Inventory_MarkItemAsChecked");
static_assert(offsetof(Inventory_MarkItemAsChecked, ItemRowName) == 0x000000, "Member 'Inventory_MarkItemAsChecked::ItemRowName' has a wrong offset!");

// Function Zion.Inventory.GetAllItems
// 0x0050 (0x0050 - 0x0000)
struct Inventory_GetAllItems final
{
public:
	TMap<class FName, int32>                      ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_GetAllItems) == 0x000008, "Wrong alignment on Inventory_GetAllItems");
static_assert(sizeof(Inventory_GetAllItems) == 0x000050, "Wrong size on Inventory_GetAllItems");
static_assert(offsetof(Inventory_GetAllItems, ReturnValue) == 0x000000, "Member 'Inventory_GetAllItems::ReturnValue' has a wrong offset!");

// Function Zion.Inventory.GetCountOfItem
// 0x000C (0x000C - 0x0000)
struct Inventory_GetCountOfItem final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_GetCountOfItem) == 0x000004, "Wrong alignment on Inventory_GetCountOfItem");
static_assert(sizeof(Inventory_GetCountOfItem) == 0x00000C, "Wrong size on Inventory_GetCountOfItem");
static_assert(offsetof(Inventory_GetCountOfItem, ItemId) == 0x000000, "Member 'Inventory_GetCountOfItem::ItemId' has a wrong offset!");
static_assert(offsetof(Inventory_GetCountOfItem, ReturnValue) == 0x000008, "Member 'Inventory_GetCountOfItem::ReturnValue' has a wrong offset!");

// Function Zion.Inventory.GetDataTable
// 0x0008 (0x0008 - 0x0000)
struct Inventory_GetDataTable final
{
public:
	const class UDataTable*                       ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_GetDataTable) == 0x000008, "Wrong alignment on Inventory_GetDataTable");
static_assert(sizeof(Inventory_GetDataTable) == 0x000008, "Wrong size on Inventory_GetDataTable");
static_assert(offsetof(Inventory_GetDataTable, ReturnValue) == 0x000000, "Member 'Inventory_GetDataTable::ReturnValue' has a wrong offset!");

// Function Zion.Inventory.GetItemCount
// 0x0004 (0x0004 - 0x0000)
struct Inventory_GetItemCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_GetItemCount) == 0x000004, "Wrong alignment on Inventory_GetItemCount");
static_assert(sizeof(Inventory_GetItemCount) == 0x000004, "Wrong size on Inventory_GetItemCount");
static_assert(offsetof(Inventory_GetItemCount, ReturnValue) == 0x000000, "Member 'Inventory_GetItemCount::ReturnValue' has a wrong offset!");

// Function Zion.Inventory.HasItem
// 0x0010 (0x0010 - 0x0000)
struct Inventory_HasItem final
{
public:
	class FName                                   ItemRowName;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Inventory_HasItem) == 0x000004, "Wrong alignment on Inventory_HasItem");
static_assert(sizeof(Inventory_HasItem) == 0x000010, "Wrong size on Inventory_HasItem");
static_assert(offsetof(Inventory_HasItem, ItemRowName) == 0x000000, "Member 'Inventory_HasItem::ItemRowName' has a wrong offset!");
static_assert(offsetof(Inventory_HasItem, Count) == 0x000008, "Member 'Inventory_HasItem::Count' has a wrong offset!");
static_assert(offsetof(Inventory_HasItem, ReturnValue) == 0x00000C, "Member 'Inventory_HasItem::ReturnValue' has a wrong offset!");

// Function Zion.Inventory.HasNonCheckedItem
// 0x0001 (0x0001 - 0x0000)
struct Inventory_HasNonCheckedItem final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_HasNonCheckedItem) == 0x000001, "Wrong alignment on Inventory_HasNonCheckedItem");
static_assert(sizeof(Inventory_HasNonCheckedItem) == 0x000001, "Wrong size on Inventory_HasNonCheckedItem");
static_assert(offsetof(Inventory_HasNonCheckedItem, ReturnValue) == 0x000000, "Member 'Inventory_HasNonCheckedItem::ReturnValue' has a wrong offset!");

// Function Zion.Inventory.IsItemChecked
// 0x000C (0x000C - 0x0000)
struct Inventory_IsItemChecked final
{
public:
	class FName                                   ItemRowName;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Inventory_IsItemChecked) == 0x000004, "Wrong alignment on Inventory_IsItemChecked");
static_assert(sizeof(Inventory_IsItemChecked) == 0x00000C, "Wrong size on Inventory_IsItemChecked");
static_assert(offsetof(Inventory_IsItemChecked, ItemRowName) == 0x000000, "Member 'Inventory_IsItemChecked::ItemRowName' has a wrong offset!");
static_assert(offsetof(Inventory_IsItemChecked, ReturnValue) == 0x000008, "Member 'Inventory_IsItemChecked::ReturnValue' has a wrong offset!");

// Function Zion.InventorySkill.GetMaxSkillLevel
// 0x0004 (0x0004 - 0x0000)
struct InventorySkill_GetMaxSkillLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySkill_GetMaxSkillLevel) == 0x000004, "Wrong alignment on InventorySkill_GetMaxSkillLevel");
static_assert(sizeof(InventorySkill_GetMaxSkillLevel) == 0x000004, "Wrong size on InventorySkill_GetMaxSkillLevel");
static_assert(offsetof(InventorySkill_GetMaxSkillLevel, ReturnValue) == 0x000000, "Member 'InventorySkill_GetMaxSkillLevel::ReturnValue' has a wrong offset!");

// Function Zion.InventorySkill.GetMinSkillLevel
// 0x0004 (0x0004 - 0x0000)
struct InventorySkill_GetMinSkillLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySkill_GetMinSkillLevel) == 0x000004, "Wrong alignment on InventorySkill_GetMinSkillLevel");
static_assert(sizeof(InventorySkill_GetMinSkillLevel) == 0x000004, "Wrong size on InventorySkill_GetMinSkillLevel");
static_assert(offsetof(InventorySkill_GetMinSkillLevel, ReturnValue) == 0x000000, "Member 'InventorySkill_GetMinSkillLevel::ReturnValue' has a wrong offset!");

// Function Zion.InventorySkill.SetSkillLevel
// 0x0010 (0x0010 - 0x0000)
struct InventorySkill_SetSkillLevel final
{
public:
	class FName                                   SkillID;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewLevel;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySkill_SetSkillLevel) == 0x000004, "Wrong alignment on InventorySkill_SetSkillLevel");
static_assert(sizeof(InventorySkill_SetSkillLevel) == 0x000010, "Wrong size on InventorySkill_SetSkillLevel");
static_assert(offsetof(InventorySkill_SetSkillLevel, SkillID) == 0x000000, "Member 'InventorySkill_SetSkillLevel::SkillID' has a wrong offset!");
static_assert(offsetof(InventorySkill_SetSkillLevel, NewLevel) == 0x000008, "Member 'InventorySkill_SetSkillLevel::NewLevel' has a wrong offset!");
static_assert(offsetof(InventorySkill_SetSkillLevel, ReturnValue) == 0x00000C, "Member 'InventorySkill_SetSkillLevel::ReturnValue' has a wrong offset!");

// Function Zion.InventorySkill.GetInitialSkillLevel
// 0x000C (0x000C - 0x0000)
struct InventorySkill_GetInitialSkillLevel final
{
public:
	class FName                                   SkillID;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySkill_GetInitialSkillLevel) == 0x000004, "Wrong alignment on InventorySkill_GetInitialSkillLevel");
static_assert(sizeof(InventorySkill_GetInitialSkillLevel) == 0x00000C, "Wrong size on InventorySkill_GetInitialSkillLevel");
static_assert(offsetof(InventorySkill_GetInitialSkillLevel, SkillID) == 0x000000, "Member 'InventorySkill_GetInitialSkillLevel::SkillID' has a wrong offset!");
static_assert(offsetof(InventorySkill_GetInitialSkillLevel, ReturnValue) == 0x000008, "Member 'InventorySkill_GetInitialSkillLevel::ReturnValue' has a wrong offset!");

// Function Zion.InventorySkill.GetSkillLevel
// 0x0010 (0x0010 - 0x0000)
struct InventorySkill_GetSkillLevel final
{
public:
	class FName                                   SkillID;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFallbackInitialLevel;                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySkill_GetSkillLevel) == 0x000004, "Wrong alignment on InventorySkill_GetSkillLevel");
static_assert(sizeof(InventorySkill_GetSkillLevel) == 0x000010, "Wrong size on InventorySkill_GetSkillLevel");
static_assert(offsetof(InventorySkill_GetSkillLevel, SkillID) == 0x000000, "Member 'InventorySkill_GetSkillLevel::SkillID' has a wrong offset!");
static_assert(offsetof(InventorySkill_GetSkillLevel, bFallbackInitialLevel) == 0x000008, "Member 'InventorySkill_GetSkillLevel::bFallbackInitialLevel' has a wrong offset!");
static_assert(offsetof(InventorySkill_GetSkillLevel, ReturnValue) == 0x00000C, "Member 'InventorySkill_GetSkillLevel::ReturnValue' has a wrong offset!");

// Function Zion.InventorySkill.IsMaxSkillLevel
// 0x000C (0x000C - 0x0000)
struct InventorySkill_IsMaxSkillLevel final
{
public:
	class FName                                   SkillID;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventorySkill_IsMaxSkillLevel) == 0x000004, "Wrong alignment on InventorySkill_IsMaxSkillLevel");
static_assert(sizeof(InventorySkill_IsMaxSkillLevel) == 0x00000C, "Wrong size on InventorySkill_IsMaxSkillLevel");
static_assert(offsetof(InventorySkill_IsMaxSkillLevel, SkillID) == 0x000000, "Member 'InventorySkill_IsMaxSkillLevel::SkillID' has a wrong offset!");
static_assert(offsetof(InventorySkill_IsMaxSkillLevel, ReturnValue) == 0x000008, "Member 'InventorySkill_IsMaxSkillLevel::ReturnValue' has a wrong offset!");

// Function Zion.KnockbackComponent.OnPreStartCommand
// 0x0008 (0x0008 - 0x0000)
struct KnockbackComponent_OnPreStartCommand final
{
public:
	const class UCommand*                         Command;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnockbackComponent_OnPreStartCommand) == 0x000008, "Wrong alignment on KnockbackComponent_OnPreStartCommand");
static_assert(sizeof(KnockbackComponent_OnPreStartCommand) == 0x000008, "Wrong size on KnockbackComponent_OnPreStartCommand");
static_assert(offsetof(KnockbackComponent_OnPreStartCommand, Command) == 0x000000, "Member 'KnockbackComponent_OnPreStartCommand::Command' has a wrong offset!");

// Function Zion.KnockbackComponent.StartKnockback
// 0x0070 (0x0070 - 0x0000)
struct KnockbackComponent_StartKnockback final
{
public:
	struct FKnockbackData                         KnockbackData;                                     // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                KnockbackDirection;                                // 0x0058(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnockbackComponent_StartKnockback) == 0x000008, "Wrong alignment on KnockbackComponent_StartKnockback");
static_assert(sizeof(KnockbackComponent_StartKnockback) == 0x000070, "Wrong size on KnockbackComponent_StartKnockback");
static_assert(offsetof(KnockbackComponent_StartKnockback, KnockbackData) == 0x000000, "Member 'KnockbackComponent_StartKnockback::KnockbackData' has a wrong offset!");
static_assert(offsetof(KnockbackComponent_StartKnockback, KnockbackDirection) == 0x000058, "Member 'KnockbackComponent_StartKnockback::KnockbackDirection' has a wrong offset!");

// Function Zion.KnockbackComponent.IsInKnockback
// 0x0001 (0x0001 - 0x0000)
struct KnockbackComponent_IsInKnockback final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnockbackComponent_IsInKnockback) == 0x000001, "Wrong alignment on KnockbackComponent_IsInKnockback");
static_assert(sizeof(KnockbackComponent_IsInKnockback) == 0x000001, "Wrong size on KnockbackComponent_IsInKnockback");
static_assert(offsetof(KnockbackComponent_IsInKnockback, ReturnValue) == 0x000000, "Member 'KnockbackComponent_IsInKnockback::ReturnValue' has a wrong offset!");

// Function Zion.LocalizationBPFLibrary.GetAvailableLanguages
// 0x0010 (0x0010 - 0x0000)
struct LocalizationBPFLibrary_GetAvailableLanguages final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalizationBPFLibrary_GetAvailableLanguages) == 0x000008, "Wrong alignment on LocalizationBPFLibrary_GetAvailableLanguages");
static_assert(sizeof(LocalizationBPFLibrary_GetAvailableLanguages) == 0x000010, "Wrong size on LocalizationBPFLibrary_GetAvailableLanguages");
static_assert(offsetof(LocalizationBPFLibrary_GetAvailableLanguages, ReturnValue) == 0x000000, "Member 'LocalizationBPFLibrary_GetAvailableLanguages::ReturnValue' has a wrong offset!");

// Function Zion.LocalizationBPFLibrary.GetLanguage
// 0x0010 (0x0010 - 0x0000)
struct LocalizationBPFLibrary_GetLanguage final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalizationBPFLibrary_GetLanguage) == 0x000008, "Wrong alignment on LocalizationBPFLibrary_GetLanguage");
static_assert(sizeof(LocalizationBPFLibrary_GetLanguage) == 0x000010, "Wrong size on LocalizationBPFLibrary_GetLanguage");
static_assert(offsetof(LocalizationBPFLibrary_GetLanguage, ReturnValue) == 0x000000, "Member 'LocalizationBPFLibrary_GetLanguage::ReturnValue' has a wrong offset!");

// Function Zion.LocalizationBPFLibrary.SetLanguage
// 0x0010 (0x0010 - 0x0000)
struct LocalizationBPFLibrary_SetLanguage final
{
public:
	class FString                                 Language;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalizationBPFLibrary_SetLanguage) == 0x000008, "Wrong alignment on LocalizationBPFLibrary_SetLanguage");
static_assert(sizeof(LocalizationBPFLibrary_SetLanguage) == 0x000010, "Wrong size on LocalizationBPFLibrary_SetLanguage");
static_assert(offsetof(LocalizationBPFLibrary_SetLanguage, Language) == 0x000000, "Member 'LocalizationBPFLibrary_SetLanguage::Language' has a wrong offset!");

// Function Zion.MapIconProviderInterface.GetMapIconActorWithDependencies
// 0x0018 (0x0018 - 0x0000)
struct MapIconProviderInterface_GetMapIconActorWithDependencies final
{
public:
	struct FMapIconProviderData                   OutMapIconProviderData;                            // 0x0000(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapIconProviderInterface_GetMapIconActorWithDependencies) == 0x000008, "Wrong alignment on MapIconProviderInterface_GetMapIconActorWithDependencies");
static_assert(sizeof(MapIconProviderInterface_GetMapIconActorWithDependencies) == 0x000018, "Wrong size on MapIconProviderInterface_GetMapIconActorWithDependencies");
static_assert(offsetof(MapIconProviderInterface_GetMapIconActorWithDependencies, OutMapIconProviderData) == 0x000000, "Member 'MapIconProviderInterface_GetMapIconActorWithDependencies::OutMapIconProviderData' has a wrong offset!");

// Function Zion.MapIconProviderInterface.GetMapIconGameplayConditions
// 0x0020 (0x0020 - 0x0000)
struct MapIconProviderInterface_GetMapIconGameplayConditions final
{
public:
	struct FGameplayConditionChecker              OutConditionChecker;                               // 0x0000(0x0018)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MapIconProviderInterface_GetMapIconGameplayConditions) == 0x000008, "Wrong alignment on MapIconProviderInterface_GetMapIconGameplayConditions");
static_assert(sizeof(MapIconProviderInterface_GetMapIconGameplayConditions) == 0x000020, "Wrong size on MapIconProviderInterface_GetMapIconGameplayConditions");
static_assert(offsetof(MapIconProviderInterface_GetMapIconGameplayConditions, OutConditionChecker) == 0x000000, "Member 'MapIconProviderInterface_GetMapIconGameplayConditions::OutConditionChecker' has a wrong offset!");
static_assert(offsetof(MapIconProviderInterface_GetMapIconGameplayConditions, ReturnValue) == 0x000018, "Member 'MapIconProviderInterface_GetMapIconGameplayConditions::ReturnValue' has a wrong offset!");

// Function Zion.MathBPFLibrary.AngleBetweenAsDegree
// 0x0038 (0x0038 - 0x0000)
struct MathBPFLibrary_AngleBetweenAsDegree final
{
public:
	struct FVector                                VectorA;                                           // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VectorB;                                           // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MathBPFLibrary_AngleBetweenAsDegree) == 0x000008, "Wrong alignment on MathBPFLibrary_AngleBetweenAsDegree");
static_assert(sizeof(MathBPFLibrary_AngleBetweenAsDegree) == 0x000038, "Wrong size on MathBPFLibrary_AngleBetweenAsDegree");
static_assert(offsetof(MathBPFLibrary_AngleBetweenAsDegree, VectorA) == 0x000000, "Member 'MathBPFLibrary_AngleBetweenAsDegree::VectorA' has a wrong offset!");
static_assert(offsetof(MathBPFLibrary_AngleBetweenAsDegree, VectorB) == 0x000018, "Member 'MathBPFLibrary_AngleBetweenAsDegree::VectorB' has a wrong offset!");
static_assert(offsetof(MathBPFLibrary_AngleBetweenAsDegree, ReturnValue) == 0x000030, "Member 'MathBPFLibrary_AngleBetweenAsDegree::ReturnValue' has a wrong offset!");

// Function Zion.MathBPFLibrary.AngleBetweenAsRad
// 0x0038 (0x0038 - 0x0000)
struct MathBPFLibrary_AngleBetweenAsRad final
{
public:
	struct FVector                                VectorA;                                           // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VectorB;                                           // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MathBPFLibrary_AngleBetweenAsRad) == 0x000008, "Wrong alignment on MathBPFLibrary_AngleBetweenAsRad");
static_assert(sizeof(MathBPFLibrary_AngleBetweenAsRad) == 0x000038, "Wrong size on MathBPFLibrary_AngleBetweenAsRad");
static_assert(offsetof(MathBPFLibrary_AngleBetweenAsRad, VectorA) == 0x000000, "Member 'MathBPFLibrary_AngleBetweenAsRad::VectorA' has a wrong offset!");
static_assert(offsetof(MathBPFLibrary_AngleBetweenAsRad, VectorB) == 0x000018, "Member 'MathBPFLibrary_AngleBetweenAsRad::VectorB' has a wrong offset!");
static_assert(offsetof(MathBPFLibrary_AngleBetweenAsRad, ReturnValue) == 0x000030, "Member 'MathBPFLibrary_AngleBetweenAsRad::ReturnValue' has a wrong offset!");

// Function Zion.MathBPFLibrary.Evaluate
// 0x0090 (0x0090 - 0x0000)
struct MathBPFLibrary_Evaluate final
{
public:
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x008C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MathBPFLibrary_Evaluate) == 0x000008, "Wrong alignment on MathBPFLibrary_Evaluate");
static_assert(sizeof(MathBPFLibrary_Evaluate) == 0x000090, "Wrong size on MathBPFLibrary_Evaluate");
static_assert(offsetof(MathBPFLibrary_Evaluate, Curve) == 0x000000, "Member 'MathBPFLibrary_Evaluate::Curve' has a wrong offset!");
static_assert(offsetof(MathBPFLibrary_Evaluate, Time) == 0x000088, "Member 'MathBPFLibrary_Evaluate::Time' has a wrong offset!");
static_assert(offsetof(MathBPFLibrary_Evaluate, ReturnValue) == 0x00008C, "Member 'MathBPFLibrary_Evaluate::ReturnValue' has a wrong offset!");

// Function Zion.MathBPFLibrary.GetMaxTime
// 0x0090 (0x0090 - 0x0000)
struct MathBPFLibrary_GetMaxTime final
{
public:
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0088(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MathBPFLibrary_GetMaxTime) == 0x000008, "Wrong alignment on MathBPFLibrary_GetMaxTime");
static_assert(sizeof(MathBPFLibrary_GetMaxTime) == 0x000090, "Wrong size on MathBPFLibrary_GetMaxTime");
static_assert(offsetof(MathBPFLibrary_GetMaxTime, Curve) == 0x000000, "Member 'MathBPFLibrary_GetMaxTime::Curve' has a wrong offset!");
static_assert(offsetof(MathBPFLibrary_GetMaxTime, ReturnValue) == 0x000088, "Member 'MathBPFLibrary_GetMaxTime::ReturnValue' has a wrong offset!");

// Function Zion.MathBPFLibrary.GetMinTime
// 0x0090 (0x0090 - 0x0000)
struct MathBPFLibrary_GetMinTime final
{
public:
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0088(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MathBPFLibrary_GetMinTime) == 0x000008, "Wrong alignment on MathBPFLibrary_GetMinTime");
static_assert(sizeof(MathBPFLibrary_GetMinTime) == 0x000090, "Wrong size on MathBPFLibrary_GetMinTime");
static_assert(offsetof(MathBPFLibrary_GetMinTime, Curve) == 0x000000, "Member 'MathBPFLibrary_GetMinTime::Curve' has a wrong offset!");
static_assert(offsetof(MathBPFLibrary_GetMinTime, ReturnValue) == 0x000088, "Member 'MathBPFLibrary_GetMinTime::ReturnValue' has a wrong offset!");

// Function Zion.MathBPFLibrary.LoopAround
// 0x0010 (0x0010 - 0x0000)
struct MathBPFLibrary_LoopAround final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MathBPFLibrary_LoopAround) == 0x000004, "Wrong alignment on MathBPFLibrary_LoopAround");
static_assert(sizeof(MathBPFLibrary_LoopAround) == 0x000010, "Wrong size on MathBPFLibrary_LoopAround");
static_assert(offsetof(MathBPFLibrary_LoopAround, Value) == 0x000000, "Member 'MathBPFLibrary_LoopAround::Value' has a wrong offset!");
static_assert(offsetof(MathBPFLibrary_LoopAround, Min) == 0x000004, "Member 'MathBPFLibrary_LoopAround::Min' has a wrong offset!");
static_assert(offsetof(MathBPFLibrary_LoopAround, Max) == 0x000008, "Member 'MathBPFLibrary_LoopAround::Max' has a wrong offset!");
static_assert(offsetof(MathBPFLibrary_LoopAround, ReturnValue) == 0x00000C, "Member 'MathBPFLibrary_LoopAround::ReturnValue' has a wrong offset!");

// Function Zion.MovingBlock_Elevator.CallToDestination
// 0x0001 (0x0001 - 0x0000)
struct MovingBlock_Elevator_CallToDestination final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovingBlock_Elevator_CallToDestination) == 0x000001, "Wrong alignment on MovingBlock_Elevator_CallToDestination");
static_assert(sizeof(MovingBlock_Elevator_CallToDestination) == 0x000001, "Wrong size on MovingBlock_Elevator_CallToDestination");
static_assert(offsetof(MovingBlock_Elevator_CallToDestination, bInstant) == 0x000000, "Member 'MovingBlock_Elevator_CallToDestination::bInstant' has a wrong offset!");

// Function Zion.MovingBlock_Elevator.CallToOrigin
// 0x0001 (0x0001 - 0x0000)
struct MovingBlock_Elevator_CallToOrigin final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovingBlock_Elevator_CallToOrigin) == 0x000001, "Wrong alignment on MovingBlock_Elevator_CallToOrigin");
static_assert(sizeof(MovingBlock_Elevator_CallToOrigin) == 0x000001, "Wrong size on MovingBlock_Elevator_CallToOrigin");
static_assert(offsetof(MovingBlock_Elevator_CallToOrigin, bInstant) == 0x000000, "Member 'MovingBlock_Elevator_CallToOrigin::bInstant' has a wrong offset!");

// Function Zion.MovingBlock_Elevator.OnFinishMovement
// 0x0002 (0x0002 - 0x0000)
struct MovingBlock_Elevator_OnFinishMovement final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasMoving;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovingBlock_Elevator_OnFinishMovement) == 0x000001, "Wrong alignment on MovingBlock_Elevator_OnFinishMovement");
static_assert(sizeof(MovingBlock_Elevator_OnFinishMovement) == 0x000002, "Wrong size on MovingBlock_Elevator_OnFinishMovement");
static_assert(offsetof(MovingBlock_Elevator_OnFinishMovement, bInstant) == 0x000000, "Member 'MovingBlock_Elevator_OnFinishMovement::bInstant' has a wrong offset!");
static_assert(offsetof(MovingBlock_Elevator_OnFinishMovement, bWasMoving) == 0x000001, "Member 'MovingBlock_Elevator_OnFinishMovement::bWasMoving' has a wrong offset!");

// Function Zion.MovingBlock_Elevator.OnStartMovement
// 0x0002 (0x0002 - 0x0000)
struct MovingBlock_Elevator_OnStartMovement final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasMoving;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovingBlock_Elevator_OnStartMovement) == 0x000001, "Wrong alignment on MovingBlock_Elevator_OnStartMovement");
static_assert(sizeof(MovingBlock_Elevator_OnStartMovement) == 0x000002, "Wrong size on MovingBlock_Elevator_OnStartMovement");
static_assert(offsetof(MovingBlock_Elevator_OnStartMovement, bInstant) == 0x000000, "Member 'MovingBlock_Elevator_OnStartMovement::bInstant' has a wrong offset!");
static_assert(offsetof(MovingBlock_Elevator_OnStartMovement, bWasMoving) == 0x000001, "Member 'MovingBlock_Elevator_OnStartMovement::bWasMoving' has a wrong offset!");

// Function Zion.MovingPlatform_Elevator.OnFinishMovement
// 0x0002 (0x0002 - 0x0000)
struct MovingPlatform_Elevator_OnFinishMovement final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasMoving;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovingPlatform_Elevator_OnFinishMovement) == 0x000001, "Wrong alignment on MovingPlatform_Elevator_OnFinishMovement");
static_assert(sizeof(MovingPlatform_Elevator_OnFinishMovement) == 0x000002, "Wrong size on MovingPlatform_Elevator_OnFinishMovement");
static_assert(offsetof(MovingPlatform_Elevator_OnFinishMovement, bInstant) == 0x000000, "Member 'MovingPlatform_Elevator_OnFinishMovement::bInstant' has a wrong offset!");
static_assert(offsetof(MovingPlatform_Elevator_OnFinishMovement, bWasMoving) == 0x000001, "Member 'MovingPlatform_Elevator_OnFinishMovement::bWasMoving' has a wrong offset!");

// Function Zion.MovingPlatform_Elevator.OnPlayerDetectorOverlapBegin
// 0x0118 (0x0118 - 0x0000)
struct MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlapComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin) == 0x000008, "Wrong alignment on MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin");
static_assert(sizeof(MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin) == 0x000118, "Wrong size on MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin");
static_assert(offsetof(MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin, OverlapComponent) == 0x000000, "Member 'MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin::OverlapComponent' has a wrong offset!");
static_assert(offsetof(MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin, OtherActor) == 0x000008, "Member 'MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin, OtherComp) == 0x000010, "Member 'MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin, bFromSweep) == 0x00001C, "Member 'MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin, SweepResult) == 0x000020, "Member 'MovingPlatform_Elevator_OnPlayerDetectorOverlapBegin::SweepResult' has a wrong offset!");

// Function Zion.MovingPlatform_Elevator.OnPlayerDetectorOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct MovingPlatform_Elevator_OnPlayerDetectorOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlapComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovingPlatform_Elevator_OnPlayerDetectorOverlapEnd) == 0x000008, "Wrong alignment on MovingPlatform_Elevator_OnPlayerDetectorOverlapEnd");
static_assert(sizeof(MovingPlatform_Elevator_OnPlayerDetectorOverlapEnd) == 0x000020, "Wrong size on MovingPlatform_Elevator_OnPlayerDetectorOverlapEnd");
static_assert(offsetof(MovingPlatform_Elevator_OnPlayerDetectorOverlapEnd, OverlapComponent) == 0x000000, "Member 'MovingPlatform_Elevator_OnPlayerDetectorOverlapEnd::OverlapComponent' has a wrong offset!");
static_assert(offsetof(MovingPlatform_Elevator_OnPlayerDetectorOverlapEnd, OtherActor) == 0x000008, "Member 'MovingPlatform_Elevator_OnPlayerDetectorOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(MovingPlatform_Elevator_OnPlayerDetectorOverlapEnd, OtherComp) == 0x000010, "Member 'MovingPlatform_Elevator_OnPlayerDetectorOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(MovingPlatform_Elevator_OnPlayerDetectorOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'MovingPlatform_Elevator_OnPlayerDetectorOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function Zion.MovingPlatform_Elevator.OnStartMovement
// 0x0002 (0x0002 - 0x0000)
struct MovingPlatform_Elevator_OnStartMovement final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasMoving;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovingPlatform_Elevator_OnStartMovement) == 0x000001, "Wrong alignment on MovingPlatform_Elevator_OnStartMovement");
static_assert(sizeof(MovingPlatform_Elevator_OnStartMovement) == 0x000002, "Wrong size on MovingPlatform_Elevator_OnStartMovement");
static_assert(offsetof(MovingPlatform_Elevator_OnStartMovement, bInstant) == 0x000000, "Member 'MovingPlatform_Elevator_OnStartMovement::bInstant' has a wrong offset!");
static_assert(offsetof(MovingPlatform_Elevator_OnStartMovement, bWasMoving) == 0x000001, "Member 'MovingPlatform_Elevator_OnStartMovement::bWasMoving' has a wrong offset!");

// Function Zion.MovingPlatform_Elevator.GetPlayerDetectionRange
// 0x0004 (0x0004 - 0x0000)
struct MovingPlatform_Elevator_GetPlayerDetectionRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovingPlatform_Elevator_GetPlayerDetectionRange) == 0x000004, "Wrong alignment on MovingPlatform_Elevator_GetPlayerDetectionRange");
static_assert(sizeof(MovingPlatform_Elevator_GetPlayerDetectionRange) == 0x000004, "Wrong size on MovingPlatform_Elevator_GetPlayerDetectionRange");
static_assert(offsetof(MovingPlatform_Elevator_GetPlayerDetectionRange, ReturnValue) == 0x000000, "Member 'MovingPlatform_Elevator_GetPlayerDetectionRange::ReturnValue' has a wrong offset!");

// Function Zion.MovingPlatform_Elevator.IsMoving
// 0x0001 (0x0001 - 0x0000)
struct MovingPlatform_Elevator_IsMoving final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovingPlatform_Elevator_IsMoving) == 0x000001, "Wrong alignment on MovingPlatform_Elevator_IsMoving");
static_assert(sizeof(MovingPlatform_Elevator_IsMoving) == 0x000001, "Wrong size on MovingPlatform_Elevator_IsMoving");
static_assert(offsetof(MovingPlatform_Elevator_IsMoving, ReturnValue) == 0x000000, "Member 'MovingPlatform_Elevator_IsMoving::ReturnValue' has a wrong offset!");

// Function Zion.niagaraBPFLibrary.IsValid
// 0x0110 (0x0110 - 0x0000)
struct niagaraBPFLibrary_IsValid final
{
public:
	struct FSpineFXData                           FXData;                                            // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0100(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0xF];                                      // 0x0101(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(niagaraBPFLibrary_IsValid) == 0x000010, "Wrong alignment on niagaraBPFLibrary_IsValid");
static_assert(sizeof(niagaraBPFLibrary_IsValid) == 0x000110, "Wrong size on niagaraBPFLibrary_IsValid");
static_assert(offsetof(niagaraBPFLibrary_IsValid, FXData) == 0x000000, "Member 'niagaraBPFLibrary_IsValid::FXData' has a wrong offset!");
static_assert(offsetof(niagaraBPFLibrary_IsValid, ReturnValue) == 0x000100, "Member 'niagaraBPFLibrary_IsValid::ReturnValue' has a wrong offset!");

// Function Zion.niagaraBPFLibrary.TryReleaseToPool
// 0x0008 (0x0008 - 0x0000)
struct niagaraBPFLibrary_TryReleaseToPool final
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(niagaraBPFLibrary_TryReleaseToPool) == 0x000008, "Wrong alignment on niagaraBPFLibrary_TryReleaseToPool");
static_assert(sizeof(niagaraBPFLibrary_TryReleaseToPool) == 0x000008, "Wrong size on niagaraBPFLibrary_TryReleaseToPool");
static_assert(offsetof(niagaraBPFLibrary_TryReleaseToPool, NiagaraComponent) == 0x000000, "Member 'niagaraBPFLibrary_TryReleaseToPool::NiagaraComponent' has a wrong offset!");

// Function Zion.NotificationComponent.OnItemAdded
// 0x0018 (0x0018 - 0x0000)
struct NotificationComponent_OnItemAdded final
{
public:
	const class UInventory*                       Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId;                                            // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddedCount;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NotificationComponent_OnItemAdded) == 0x000008, "Wrong alignment on NotificationComponent_OnItemAdded");
static_assert(sizeof(NotificationComponent_OnItemAdded) == 0x000018, "Wrong size on NotificationComponent_OnItemAdded");
static_assert(offsetof(NotificationComponent_OnItemAdded, Inventory) == 0x000000, "Member 'NotificationComponent_OnItemAdded::Inventory' has a wrong offset!");
static_assert(offsetof(NotificationComponent_OnItemAdded, ItemId) == 0x000008, "Member 'NotificationComponent_OnItemAdded::ItemId' has a wrong offset!");
static_assert(offsetof(NotificationComponent_OnItemAdded, AddedCount) == 0x000010, "Member 'NotificationComponent_OnItemAdded::AddedCount' has a wrong offset!");

// Function Zion.NotificationComponent.CanStartNotification
// 0x0001 (0x0001 - 0x0000)
struct NotificationComponent_CanStartNotification final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NotificationComponent_CanStartNotification) == 0x000001, "Wrong alignment on NotificationComponent_CanStartNotification");
static_assert(sizeof(NotificationComponent_CanStartNotification) == 0x000001, "Wrong size on NotificationComponent_CanStartNotification");
static_assert(offsetof(NotificationComponent_CanStartNotification, ReturnValue) == 0x000000, "Member 'NotificationComponent_CanStartNotification::ReturnValue' has a wrong offset!");

// Function Zion.PassiveComponent.EquipPassive
// 0x0014 (0x0014 - 0x0000)
struct PassiveComponent_EquipPassive final
{
public:
	class FName                                   PassiveID;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrentLoadout;                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InsertIndex;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPassiveEquipResult                           ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PassiveComponent_EquipPassive) == 0x000004, "Wrong alignment on PassiveComponent_EquipPassive");
static_assert(sizeof(PassiveComponent_EquipPassive) == 0x000014, "Wrong size on PassiveComponent_EquipPassive");
static_assert(offsetof(PassiveComponent_EquipPassive, PassiveID) == 0x000000, "Member 'PassiveComponent_EquipPassive::PassiveID' has a wrong offset!");
static_assert(offsetof(PassiveComponent_EquipPassive, bAddToCurrentLoadout) == 0x000008, "Member 'PassiveComponent_EquipPassive::bAddToCurrentLoadout' has a wrong offset!");
static_assert(offsetof(PassiveComponent_EquipPassive, InsertIndex) == 0x00000C, "Member 'PassiveComponent_EquipPassive::InsertIndex' has a wrong offset!");
static_assert(offsetof(PassiveComponent_EquipPassive, ReturnValue) == 0x000010, "Member 'PassiveComponent_EquipPassive::ReturnValue' has a wrong offset!");

// Function Zion.PassiveComponent.EquipPassiveLoadout
// 0x0004 (0x0004 - 0x0000)
struct PassiveComponent_EquipPassiveLoadout final
{
public:
	int32                                         LoadoutIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PassiveComponent_EquipPassiveLoadout) == 0x000004, "Wrong alignment on PassiveComponent_EquipPassiveLoadout");
static_assert(sizeof(PassiveComponent_EquipPassiveLoadout) == 0x000004, "Wrong size on PassiveComponent_EquipPassiveLoadout");
static_assert(offsetof(PassiveComponent_EquipPassiveLoadout, LoadoutIndex) == 0x000000, "Member 'PassiveComponent_EquipPassiveLoadout::LoadoutIndex' has a wrong offset!");

// Function Zion.PassiveComponent.OnPossessedPawnChanged
// 0x0010 (0x0010 - 0x0000)
struct PassiveComponent_OnPossessedPawnChanged final
{
public:
	class APawn*                                  OldPawn;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  NewPawn;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PassiveComponent_OnPossessedPawnChanged) == 0x000008, "Wrong alignment on PassiveComponent_OnPossessedPawnChanged");
static_assert(sizeof(PassiveComponent_OnPossessedPawnChanged) == 0x000010, "Wrong size on PassiveComponent_OnPossessedPawnChanged");
static_assert(offsetof(PassiveComponent_OnPossessedPawnChanged, OldPawn) == 0x000000, "Member 'PassiveComponent_OnPossessedPawnChanged::OldPawn' has a wrong offset!");
static_assert(offsetof(PassiveComponent_OnPossessedPawnChanged, NewPawn) == 0x000008, "Member 'PassiveComponent_OnPossessedPawnChanged::NewPawn' has a wrong offset!");

// Function Zion.PassiveComponent.ReplacePassiveInAllLoadouts
// 0x0010 (0x0010 - 0x0000)
struct PassiveComponent_ReplacePassiveInAllLoadouts final
{
public:
	class FName                                   PassiveToRemove;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PassiveToAdd;                                      // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PassiveComponent_ReplacePassiveInAllLoadouts) == 0x000004, "Wrong alignment on PassiveComponent_ReplacePassiveInAllLoadouts");
static_assert(sizeof(PassiveComponent_ReplacePassiveInAllLoadouts) == 0x000010, "Wrong size on PassiveComponent_ReplacePassiveInAllLoadouts");
static_assert(offsetof(PassiveComponent_ReplacePassiveInAllLoadouts, PassiveToRemove) == 0x000000, "Member 'PassiveComponent_ReplacePassiveInAllLoadouts::PassiveToRemove' has a wrong offset!");
static_assert(offsetof(PassiveComponent_ReplacePassiveInAllLoadouts, PassiveToAdd) == 0x000008, "Member 'PassiveComponent_ReplacePassiveInAllLoadouts::PassiveToAdd' has a wrong offset!");

// Function Zion.PassiveComponent.UnequipPassive
// 0x0010 (0x0010 - 0x0000)
struct PassiveComponent_UnequipPassive final
{
public:
	class FName                                   PassiveID;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutPassiveIndex;                                   // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveFromCurrentLoadout;                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PassiveComponent_UnequipPassive) == 0x000004, "Wrong alignment on PassiveComponent_UnequipPassive");
static_assert(sizeof(PassiveComponent_UnequipPassive) == 0x000010, "Wrong size on PassiveComponent_UnequipPassive");
static_assert(offsetof(PassiveComponent_UnequipPassive, PassiveID) == 0x000000, "Member 'PassiveComponent_UnequipPassive::PassiveID' has a wrong offset!");
static_assert(offsetof(PassiveComponent_UnequipPassive, OutPassiveIndex) == 0x000008, "Member 'PassiveComponent_UnequipPassive::OutPassiveIndex' has a wrong offset!");
static_assert(offsetof(PassiveComponent_UnequipPassive, bRemoveFromCurrentLoadout) == 0x00000C, "Member 'PassiveComponent_UnequipPassive::bRemoveFromCurrentLoadout' has a wrong offset!");
static_assert(offsetof(PassiveComponent_UnequipPassive, ReturnValue) == 0x00000D, "Member 'PassiveComponent_UnequipPassive::ReturnValue' has a wrong offset!");

// Function Zion.PassiveComponent.CanEquipPassive
// 0x0270 (0x0270 - 0x0000)
struct PassiveComponent_CanEquipPassive final
{
public:
	struct FInventoryItemPassiveData              ItemPassiveData;                                   // 0x0000(0x0268)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	EPassiveEquipResult                           ReturnValue;                                       // 0x0268(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PassiveComponent_CanEquipPassive) == 0x000008, "Wrong alignment on PassiveComponent_CanEquipPassive");
static_assert(sizeof(PassiveComponent_CanEquipPassive) == 0x000270, "Wrong size on PassiveComponent_CanEquipPassive");
static_assert(offsetof(PassiveComponent_CanEquipPassive, ItemPassiveData) == 0x000000, "Member 'PassiveComponent_CanEquipPassive::ItemPassiveData' has a wrong offset!");
static_assert(offsetof(PassiveComponent_CanEquipPassive, ReturnValue) == 0x000268, "Member 'PassiveComponent_CanEquipPassive::ReturnValue' has a wrong offset!");

// Function Zion.PassiveComponent.GetAvailableSlotCount
// 0x0004 (0x0004 - 0x0000)
struct PassiveComponent_GetAvailableSlotCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PassiveComponent_GetAvailableSlotCount) == 0x000004, "Wrong alignment on PassiveComponent_GetAvailableSlotCount");
static_assert(sizeof(PassiveComponent_GetAvailableSlotCount) == 0x000004, "Wrong size on PassiveComponent_GetAvailableSlotCount");
static_assert(offsetof(PassiveComponent_GetAvailableSlotCount, ReturnValue) == 0x000000, "Member 'PassiveComponent_GetAvailableSlotCount::ReturnValue' has a wrong offset!");

// Function Zion.PassiveComponent.GetCurrentPassiveLoadoutIndex
// 0x0004 (0x0004 - 0x0000)
struct PassiveComponent_GetCurrentPassiveLoadoutIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PassiveComponent_GetCurrentPassiveLoadoutIndex) == 0x000004, "Wrong alignment on PassiveComponent_GetCurrentPassiveLoadoutIndex");
static_assert(sizeof(PassiveComponent_GetCurrentPassiveLoadoutIndex) == 0x000004, "Wrong size on PassiveComponent_GetCurrentPassiveLoadoutIndex");
static_assert(offsetof(PassiveComponent_GetCurrentPassiveLoadoutIndex, ReturnValue) == 0x000000, "Member 'PassiveComponent_GetCurrentPassiveLoadoutIndex::ReturnValue' has a wrong offset!");

// Function Zion.PassiveComponent.GetEquippedPassives
// 0x0010 (0x0010 - 0x0000)
struct PassiveComponent_GetEquippedPassives final
{
public:
	TArray<struct FPassiveRuntimeData>            ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PassiveComponent_GetEquippedPassives) == 0x000008, "Wrong alignment on PassiveComponent_GetEquippedPassives");
static_assert(sizeof(PassiveComponent_GetEquippedPassives) == 0x000010, "Wrong size on PassiveComponent_GetEquippedPassives");
static_assert(offsetof(PassiveComponent_GetEquippedPassives, ReturnValue) == 0x000000, "Member 'PassiveComponent_GetEquippedPassives::ReturnValue' has a wrong offset!");

// Function Zion.PassiveComponent.GetSlotCount
// 0x0004 (0x0004 - 0x0000)
struct PassiveComponent_GetSlotCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PassiveComponent_GetSlotCount) == 0x000004, "Wrong alignment on PassiveComponent_GetSlotCount");
static_assert(sizeof(PassiveComponent_GetSlotCount) == 0x000004, "Wrong size on PassiveComponent_GetSlotCount");
static_assert(offsetof(PassiveComponent_GetSlotCount, ReturnValue) == 0x000000, "Member 'PassiveComponent_GetSlotCount::ReturnValue' has a wrong offset!");

// Function Zion.PassiveComponent.GetUsedSlotCount
// 0x0004 (0x0004 - 0x0000)
struct PassiveComponent_GetUsedSlotCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PassiveComponent_GetUsedSlotCount) == 0x000004, "Wrong alignment on PassiveComponent_GetUsedSlotCount");
static_assert(sizeof(PassiveComponent_GetUsedSlotCount) == 0x000004, "Wrong size on PassiveComponent_GetUsedSlotCount");
static_assert(offsetof(PassiveComponent_GetUsedSlotCount, ReturnValue) == 0x000000, "Member 'PassiveComponent_GetUsedSlotCount::ReturnValue' has a wrong offset!");

// Function Zion.PassiveComponent.IsPassiveEquipped
// 0x000C (0x000C - 0x0000)
struct PassiveComponent_IsPassiveEquipped final
{
public:
	class FName                                   PassiveID;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PassiveComponent_IsPassiveEquipped) == 0x000004, "Wrong alignment on PassiveComponent_IsPassiveEquipped");
static_assert(sizeof(PassiveComponent_IsPassiveEquipped) == 0x00000C, "Wrong size on PassiveComponent_IsPassiveEquipped");
static_assert(offsetof(PassiveComponent_IsPassiveEquipped, PassiveID) == 0x000000, "Member 'PassiveComponent_IsPassiveEquipped::PassiveID' has a wrong offset!");
static_assert(offsetof(PassiveComponent_IsPassiveEquipped, ReturnValue) == 0x000008, "Member 'PassiveComponent_IsPassiveEquipped::ReturnValue' has a wrong offset!");

// Function Zion.PhysicsReactionComponent.OnGotAbilityApplied
// 0x02E0 (0x02E0 - 0x0000)
struct PhysicsReactionComponent_OnGotAbilityApplied final
{
public:
	class AAbility*                               Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitData                               HitData;                                           // 0x0010(0x02D0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsReactionComponent_OnGotAbilityApplied) == 0x000010, "Wrong alignment on PhysicsReactionComponent_OnGotAbilityApplied");
static_assert(sizeof(PhysicsReactionComponent_OnGotAbilityApplied) == 0x0002E0, "Wrong size on PhysicsReactionComponent_OnGotAbilityApplied");
static_assert(offsetof(PhysicsReactionComponent_OnGotAbilityApplied, Ability) == 0x000000, "Member 'PhysicsReactionComponent_OnGotAbilityApplied::Ability' has a wrong offset!");
static_assert(offsetof(PhysicsReactionComponent_OnGotAbilityApplied, Source) == 0x000008, "Member 'PhysicsReactionComponent_OnGotAbilityApplied::Source' has a wrong offset!");
static_assert(offsetof(PhysicsReactionComponent_OnGotAbilityApplied, HitData) == 0x000010, "Member 'PhysicsReactionComponent_OnGotAbilityApplied::HitData' has a wrong offset!");

// Function Zion.PhysicsReactionComponent.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct PhysicsReactionComponent_SetEnabled final
{
public:
	bool                                          bNewEnabled;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsReactionComponent_SetEnabled) == 0x000001, "Wrong alignment on PhysicsReactionComponent_SetEnabled");
static_assert(sizeof(PhysicsReactionComponent_SetEnabled) == 0x000001, "Wrong size on PhysicsReactionComponent_SetEnabled");
static_assert(offsetof(PhysicsReactionComponent_SetEnabled, bNewEnabled) == 0x000000, "Member 'PhysicsReactionComponent_SetEnabled::bNewEnabled' has a wrong offset!");

// Function Zion.PhysicsReactionComponent.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct PhysicsReactionComponent_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsReactionComponent_IsEnabled) == 0x000001, "Wrong alignment on PhysicsReactionComponent_IsEnabled");
static_assert(sizeof(PhysicsReactionComponent_IsEnabled) == 0x000001, "Wrong size on PhysicsReactionComponent_IsEnabled");
static_assert(offsetof(PhysicsReactionComponent_IsEnabled, ReturnValue) == 0x000000, "Member 'PhysicsReactionComponent_IsEnabled::ReturnValue' has a wrong offset!");

// Function Zion.PlayerCameraManagerZion.Get
// 0x0018 (0x0018 - 0x0000)
struct PlayerCameraManagerZion_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerControllerIndex;                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCameraManagerZion*               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManagerZion_Get) == 0x000008, "Wrong alignment on PlayerCameraManagerZion_Get");
static_assert(sizeof(PlayerCameraManagerZion_Get) == 0x000018, "Wrong size on PlayerCameraManagerZion_Get");
static_assert(offsetof(PlayerCameraManagerZion_Get, WorldContextObject) == 0x000000, "Member 'PlayerCameraManagerZion_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PlayerCameraManagerZion_Get, PlayerControllerIndex) == 0x000008, "Member 'PlayerCameraManagerZion_Get::PlayerControllerIndex' has a wrong offset!");
static_assert(offsetof(PlayerCameraManagerZion_Get, ReturnValue) == 0x000010, "Member 'PlayerCameraManagerZion_Get::ReturnValue' has a wrong offset!");

// Function Zion.PlayerCameraManagerZion.SetViewTargetToGameplayCamera
// 0x0014 (0x0014 - 0x0000)
struct PlayerCameraManagerZion_SetViewTargetToGameplayCamera final
{
public:
	struct FViewTargetTransitionParams            ViewTargetTransitionParams;                        // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bInterruptOnGoingBlend;                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerCameraManagerZion_SetViewTargetToGameplayCamera) == 0x000004, "Wrong alignment on PlayerCameraManagerZion_SetViewTargetToGameplayCamera");
static_assert(sizeof(PlayerCameraManagerZion_SetViewTargetToGameplayCamera) == 0x000014, "Wrong size on PlayerCameraManagerZion_SetViewTargetToGameplayCamera");
static_assert(offsetof(PlayerCameraManagerZion_SetViewTargetToGameplayCamera, ViewTargetTransitionParams) == 0x000000, "Member 'PlayerCameraManagerZion_SetViewTargetToGameplayCamera::ViewTargetTransitionParams' has a wrong offset!");
static_assert(offsetof(PlayerCameraManagerZion_SetViewTargetToGameplayCamera, bInterruptOnGoingBlend) == 0x000010, "Member 'PlayerCameraManagerZion_SetViewTargetToGameplayCamera::bInterruptOnGoingBlend' has a wrong offset!");

// Function Zion.PlayerCameraManagerZion.GetActiveCameraClampBox
// 0x0038 (0x0038 - 0x0000)
struct PlayerCameraManagerZion_GetActiveCameraClampBox final
{
public:
	struct FBox                                   ReturnValue;                                       // 0x0000(0x0038)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManagerZion_GetActiveCameraClampBox) == 0x000008, "Wrong alignment on PlayerCameraManagerZion_GetActiveCameraClampBox");
static_assert(sizeof(PlayerCameraManagerZion_GetActiveCameraClampBox) == 0x000038, "Wrong size on PlayerCameraManagerZion_GetActiveCameraClampBox");
static_assert(offsetof(PlayerCameraManagerZion_GetActiveCameraClampBox, ReturnValue) == 0x000000, "Member 'PlayerCameraManagerZion_GetActiveCameraClampBox::ReturnValue' has a wrong offset!");

// Function Zion.PlayerCameraManagerZion.GetGameplayCamera
// 0x0008 (0x0008 - 0x0000)
struct PlayerCameraManagerZion_GetGameplayCamera final
{
public:
	class AGameplayCamera*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManagerZion_GetGameplayCamera) == 0x000008, "Wrong alignment on PlayerCameraManagerZion_GetGameplayCamera");
static_assert(sizeof(PlayerCameraManagerZion_GetGameplayCamera) == 0x000008, "Wrong size on PlayerCameraManagerZion_GetGameplayCamera");
static_assert(offsetof(PlayerCameraManagerZion_GetGameplayCamera, ReturnValue) == 0x000000, "Member 'PlayerCameraManagerZion_GetGameplayCamera::ReturnValue' has a wrong offset!");

// Function Zion.PlayerCostumeComponent.EquipCostume
// 0x0008 (0x0008 - 0x0000)
struct PlayerCostumeComponent_EquipCostume final
{
public:
	class FName                                   InCostumeID;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCostumeComponent_EquipCostume) == 0x000004, "Wrong alignment on PlayerCostumeComponent_EquipCostume");
static_assert(sizeof(PlayerCostumeComponent_EquipCostume) == 0x000008, "Wrong size on PlayerCostumeComponent_EquipCostume");
static_assert(offsetof(PlayerCostumeComponent_EquipCostume, InCostumeID) == 0x000000, "Member 'PlayerCostumeComponent_EquipCostume::InCostumeID' has a wrong offset!");

// Function Zion.PlayerCostumeComponent.SetPendingCostumeID
// 0x0008 (0x0008 - 0x0000)
struct PlayerCostumeComponent_SetPendingCostumeID final
{
public:
	class FName                                   InCostumeID;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCostumeComponent_SetPendingCostumeID) == 0x000004, "Wrong alignment on PlayerCostumeComponent_SetPendingCostumeID");
static_assert(sizeof(PlayerCostumeComponent_SetPendingCostumeID) == 0x000008, "Wrong size on PlayerCostumeComponent_SetPendingCostumeID");
static_assert(offsetof(PlayerCostumeComponent_SetPendingCostumeID, InCostumeID) == 0x000000, "Member 'PlayerCostumeComponent_SetPendingCostumeID::InCostumeID' has a wrong offset!");

// Function Zion.PlayerCostumeComponent.GetEquippedCostumeID
// 0x0008 (0x0008 - 0x0000)
struct PlayerCostumeComponent_GetEquippedCostumeID final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCostumeComponent_GetEquippedCostumeID) == 0x000004, "Wrong alignment on PlayerCostumeComponent_GetEquippedCostumeID");
static_assert(sizeof(PlayerCostumeComponent_GetEquippedCostumeID) == 0x000008, "Wrong size on PlayerCostumeComponent_GetEquippedCostumeID");
static_assert(offsetof(PlayerCostumeComponent_GetEquippedCostumeID, ReturnValue) == 0x000000, "Member 'PlayerCostumeComponent_GetEquippedCostumeID::ReturnValue' has a wrong offset!");

// Function Zion.PlayerCostumeComponent.GetPendingOrEquippedCostumeID
// 0x0008 (0x0008 - 0x0000)
struct PlayerCostumeComponent_GetPendingOrEquippedCostumeID final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCostumeComponent_GetPendingOrEquippedCostumeID) == 0x000004, "Wrong alignment on PlayerCostumeComponent_GetPendingOrEquippedCostumeID");
static_assert(sizeof(PlayerCostumeComponent_GetPendingOrEquippedCostumeID) == 0x000008, "Wrong size on PlayerCostumeComponent_GetPendingOrEquippedCostumeID");
static_assert(offsetof(PlayerCostumeComponent_GetPendingOrEquippedCostumeID, ReturnValue) == 0x000000, "Member 'PlayerCostumeComponent_GetPendingOrEquippedCostumeID::ReturnValue' has a wrong offset!");

// Function Zion.PlayUMGAnimationAsyncAction.PlayUMGAnimation
// 0x0020 (0x0020 - 0x0000)
struct PlayUMGAnimationAsyncAction_PlayUMGAnimation final
{
public:
	class UUserWidget*                            Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       InAnimation;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockNavigation;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayUMGAnimationAsyncAction*           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayUMGAnimationAsyncAction_PlayUMGAnimation) == 0x000008, "Wrong alignment on PlayUMGAnimationAsyncAction_PlayUMGAnimation");
static_assert(sizeof(PlayUMGAnimationAsyncAction_PlayUMGAnimation) == 0x000020, "Wrong size on PlayUMGAnimationAsyncAction_PlayUMGAnimation");
static_assert(offsetof(PlayUMGAnimationAsyncAction_PlayUMGAnimation, Widget) == 0x000000, "Member 'PlayUMGAnimationAsyncAction_PlayUMGAnimation::Widget' has a wrong offset!");
static_assert(offsetof(PlayUMGAnimationAsyncAction_PlayUMGAnimation, InAnimation) == 0x000008, "Member 'PlayUMGAnimationAsyncAction_PlayUMGAnimation::InAnimation' has a wrong offset!");
static_assert(offsetof(PlayUMGAnimationAsyncAction_PlayUMGAnimation, bLockNavigation) == 0x000010, "Member 'PlayUMGAnimationAsyncAction_PlayUMGAnimation::bLockNavigation' has a wrong offset!");
static_assert(offsetof(PlayUMGAnimationAsyncAction_PlayUMGAnimation, ReturnValue) == 0x000018, "Member 'PlayUMGAnimationAsyncAction_PlayUMGAnimation::ReturnValue' has a wrong offset!");

// Function Zion.PoolSystemComponent.Get
// 0x0010 (0x0010 - 0x0000)
struct PoolSystemComponent_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoolSystemComponent*                   ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoolSystemComponent_Get) == 0x000008, "Wrong alignment on PoolSystemComponent_Get");
static_assert(sizeof(PoolSystemComponent_Get) == 0x000010, "Wrong size on PoolSystemComponent_Get");
static_assert(offsetof(PoolSystemComponent_Get, WorldContextObject) == 0x000000, "Member 'PoolSystemComponent_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PoolSystemComponent_Get, ReturnValue) == 0x000008, "Member 'PoolSystemComponent_Get::ReturnValue' has a wrong offset!");

// Function Zion.ProfileSubsystem.GetCurrentProfileName
// 0x0010 (0x0010 - 0x0000)
struct ProfileSubsystem_GetCurrentProfileName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProfileSubsystem_GetCurrentProfileName) == 0x000008, "Wrong alignment on ProfileSubsystem_GetCurrentProfileName");
static_assert(sizeof(ProfileSubsystem_GetCurrentProfileName) == 0x000010, "Wrong size on ProfileSubsystem_GetCurrentProfileName");
static_assert(offsetof(ProfileSubsystem_GetCurrentProfileName, ReturnValue) == 0x000000, "Member 'ProfileSubsystem_GetCurrentProfileName::ReturnValue' has a wrong offset!");

// Function Zion.ProfileSubsystem.IsUsingProfileSystem
// 0x0001 (0x0001 - 0x0000)
struct ProfileSubsystem_IsUsingProfileSystem final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProfileSubsystem_IsUsingProfileSystem) == 0x000001, "Wrong alignment on ProfileSubsystem_IsUsingProfileSystem");
static_assert(sizeof(ProfileSubsystem_IsUsingProfileSystem) == 0x000001, "Wrong size on ProfileSubsystem_IsUsingProfileSystem");
static_assert(offsetof(ProfileSubsystem_IsUsingProfileSystem, ReturnValue) == 0x000000, "Member 'ProfileSubsystem_IsUsingProfileSystem::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossRushComponent.GetMaxBossesDefeatedCount
// 0x0004 (0x0004 - 0x0000)
struct RecollectionBossRushComponent_GetMaxBossesDefeatedCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossRushComponent_GetMaxBossesDefeatedCount) == 0x000004, "Wrong alignment on RecollectionBossRushComponent_GetMaxBossesDefeatedCount");
static_assert(sizeof(RecollectionBossRushComponent_GetMaxBossesDefeatedCount) == 0x000004, "Wrong size on RecollectionBossRushComponent_GetMaxBossesDefeatedCount");
static_assert(offsetof(RecollectionBossRushComponent_GetMaxBossesDefeatedCount, ReturnValue) == 0x000000, "Member 'RecollectionBossRushComponent_GetMaxBossesDefeatedCount::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossRushComponent.GetRecordData
// 0x0008 (0x0008 - 0x0000)
struct RecollectionBossRushComponent_GetRecordData final
{
public:
	int32                                         RecordIndex;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRecollectionBossRushRecordData        ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossRushComponent_GetRecordData) == 0x000004, "Wrong alignment on RecollectionBossRushComponent_GetRecordData");
static_assert(sizeof(RecollectionBossRushComponent_GetRecordData) == 0x000008, "Wrong size on RecollectionBossRushComponent_GetRecordData");
static_assert(offsetof(RecollectionBossRushComponent_GetRecordData, RecordIndex) == 0x000000, "Member 'RecollectionBossRushComponent_GetRecordData::RecordIndex' has a wrong offset!");
static_assert(offsetof(RecollectionBossRushComponent_GetRecordData, ReturnValue) == 0x000004, "Member 'RecollectionBossRushComponent_GetRecordData::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossRushComponent.OnSetTimerPaused
// 0x0001 (0x0001 - 0x0000)
struct RecollectionBossRushComponent_OnSetTimerPaused final
{
public:
	bool                                          bIsPaused;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossRushComponent_OnSetTimerPaused) == 0x000001, "Wrong alignment on RecollectionBossRushComponent_OnSetTimerPaused");
static_assert(sizeof(RecollectionBossRushComponent_OnSetTimerPaused) == 0x000001, "Wrong size on RecollectionBossRushComponent_OnSetTimerPaused");
static_assert(offsetof(RecollectionBossRushComponent_OnSetTimerPaused, bIsPaused) == 0x000000, "Member 'RecollectionBossRushComponent_OnSetTimerPaused::bIsPaused' has a wrong offset!");

// Function Zion.RecollectionBossRushComponent.SetTimerPaused
// 0x0002 (0x0002 - 0x0000)
struct RecollectionBossRushComponent_SetTimerPaused final
{
public:
	bool                                          bIsPaused;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossRushComponent_SetTimerPaused) == 0x000001, "Wrong alignment on RecollectionBossRushComponent_SetTimerPaused");
static_assert(sizeof(RecollectionBossRushComponent_SetTimerPaused) == 0x000002, "Wrong size on RecollectionBossRushComponent_SetTimerPaused");
static_assert(offsetof(RecollectionBossRushComponent_SetTimerPaused, bIsPaused) == 0x000000, "Member 'RecollectionBossRushComponent_SetTimerPaused::bIsPaused' has a wrong offset!");
static_assert(offsetof(RecollectionBossRushComponent_SetTimerPaused, ReturnValue) == 0x000001, "Member 'RecollectionBossRushComponent_SetTimerPaused::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossRushComponent.TryAddNewRecord
// 0x0008 (0x0008 - 0x0000)
struct RecollectionBossRushComponent_TryAddNewRecord final
{
public:
	struct FRecollectionBossRushRecordData        NewRecordData;                                     // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossRushComponent_TryAddNewRecord) == 0x000004, "Wrong alignment on RecollectionBossRushComponent_TryAddNewRecord");
static_assert(sizeof(RecollectionBossRushComponent_TryAddNewRecord) == 0x000008, "Wrong size on RecollectionBossRushComponent_TryAddNewRecord");
static_assert(offsetof(RecollectionBossRushComponent_TryAddNewRecord, NewRecordData) == 0x000000, "Member 'RecollectionBossRushComponent_TryAddNewRecord::NewRecordData' has a wrong offset!");
static_assert(offsetof(RecollectionBossRushComponent_TryAddNewRecord, ReturnValue) == 0x000004, "Member 'RecollectionBossRushComponent_TryAddNewRecord::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossRushComponent.CanUpdateTime
// 0x0001 (0x0001 - 0x0000)
struct RecollectionBossRushComponent_CanUpdateTime final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossRushComponent_CanUpdateTime) == 0x000001, "Wrong alignment on RecollectionBossRushComponent_CanUpdateTime");
static_assert(sizeof(RecollectionBossRushComponent_CanUpdateTime) == 0x000001, "Wrong size on RecollectionBossRushComponent_CanUpdateTime");
static_assert(offsetof(RecollectionBossRushComponent_CanUpdateTime, ReturnValue) == 0x000000, "Member 'RecollectionBossRushComponent_CanUpdateTime::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossRushComponent.GetBossRushDifficultyPreset
// 0x0001 (0x0001 - 0x0000)
struct RecollectionBossRushComponent_GetBossRushDifficultyPreset final
{
public:
	EDifficultyPreset                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossRushComponent_GetBossRushDifficultyPreset) == 0x000001, "Wrong alignment on RecollectionBossRushComponent_GetBossRushDifficultyPreset");
static_assert(sizeof(RecollectionBossRushComponent_GetBossRushDifficultyPreset) == 0x000001, "Wrong size on RecollectionBossRushComponent_GetBossRushDifficultyPreset");
static_assert(offsetof(RecollectionBossRushComponent_GetBossRushDifficultyPreset, ReturnValue) == 0x000000, "Member 'RecollectionBossRushComponent_GetBossRushDifficultyPreset::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossRushComponent.GetBossRushTime
// 0x0004 (0x0004 - 0x0000)
struct RecollectionBossRushComponent_GetBossRushTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossRushComponent_GetBossRushTime) == 0x000004, "Wrong alignment on RecollectionBossRushComponent_GetBossRushTime");
static_assert(sizeof(RecollectionBossRushComponent_GetBossRushTime) == 0x000004, "Wrong size on RecollectionBossRushComponent_GetBossRushTime");
static_assert(offsetof(RecollectionBossRushComponent_GetBossRushTime, ReturnValue) == 0x000000, "Member 'RecollectionBossRushComponent_GetBossRushTime::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossRushComponent.GetCurrentBossIndex
// 0x0004 (0x0004 - 0x0000)
struct RecollectionBossRushComponent_GetCurrentBossIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossRushComponent_GetCurrentBossIndex) == 0x000004, "Wrong alignment on RecollectionBossRushComponent_GetCurrentBossIndex");
static_assert(sizeof(RecollectionBossRushComponent_GetCurrentBossIndex) == 0x000004, "Wrong size on RecollectionBossRushComponent_GetCurrentBossIndex");
static_assert(offsetof(RecollectionBossRushComponent_GetCurrentBossIndex, ReturnValue) == 0x000000, "Member 'RecollectionBossRushComponent_GetCurrentBossIndex::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossRushComponent.IsTimerPaused
// 0x0001 (0x0001 - 0x0000)
struct RecollectionBossRushComponent_IsTimerPaused final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossRushComponent_IsTimerPaused) == 0x000001, "Wrong alignment on RecollectionBossRushComponent_IsTimerPaused");
static_assert(sizeof(RecollectionBossRushComponent_IsTimerPaused) == 0x000001, "Wrong size on RecollectionBossRushComponent_IsTimerPaused");
static_assert(offsetof(RecollectionBossRushComponent_IsTimerPaused, ReturnValue) == 0x000000, "Member 'RecollectionBossRushComponent_IsTimerPaused::ReturnValue' has a wrong offset!");

// Function Zion.RecollectionBossRushComponent.ShouldDisplayRecollectionBossRush
// 0x0001 (0x0001 - 0x0000)
struct RecollectionBossRushComponent_ShouldDisplayRecollectionBossRush final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecollectionBossRushComponent_ShouldDisplayRecollectionBossRush) == 0x000001, "Wrong alignment on RecollectionBossRushComponent_ShouldDisplayRecollectionBossRush");
static_assert(sizeof(RecollectionBossRushComponent_ShouldDisplayRecollectionBossRush) == 0x000001, "Wrong size on RecollectionBossRushComponent_ShouldDisplayRecollectionBossRush");
static_assert(offsetof(RecollectionBossRushComponent_ShouldDisplayRecollectionBossRush, ReturnValue) == 0x000000, "Member 'RecollectionBossRushComponent_ShouldDisplayRecollectionBossRush::ReturnValue' has a wrong offset!");

// Function Zion.RenderStateComponent.SetNewBounds
// 0x0008 (0x0008 - 0x0000)
struct RenderStateComponent_SetNewBounds final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RenderStateComponent_SetNewBounds) == 0x000008, "Wrong alignment on RenderStateComponent_SetNewBounds");
static_assert(sizeof(RenderStateComponent_SetNewBounds) == 0x000008, "Wrong size on RenderStateComponent_SetNewBounds");
static_assert(offsetof(RenderStateComponent_SetNewBounds, Actor) == 0x000000, "Member 'RenderStateComponent_SetNewBounds::Actor' has a wrong offset!");

// Function Zion.RenderStateComponent.SetVisible
// 0x0002 (0x0002 - 0x0000)
struct RenderStateComponent_SetVisible final
{
public:
	bool                                          bIsVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RenderStateComponent_SetVisible) == 0x000001, "Wrong alignment on RenderStateComponent_SetVisible");
static_assert(sizeof(RenderStateComponent_SetVisible) == 0x000002, "Wrong size on RenderStateComponent_SetVisible");
static_assert(offsetof(RenderStateComponent_SetVisible, bIsVisible) == 0x000000, "Member 'RenderStateComponent_SetVisible::bIsVisible' has a wrong offset!");
static_assert(offsetof(RenderStateComponent_SetVisible, ReturnValue) == 0x000001, "Member 'RenderStateComponent_SetVisible::ReturnValue' has a wrong offset!");

// Function Zion.RenderStateComponent.IsVisible
// 0x0001 (0x0001 - 0x0000)
struct RenderStateComponent_IsVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RenderStateComponent_IsVisible) == 0x000001, "Wrong alignment on RenderStateComponent_IsVisible");
static_assert(sizeof(RenderStateComponent_IsVisible) == 0x000001, "Wrong size on RenderStateComponent_IsVisible");
static_assert(offsetof(RenderStateComponent_IsVisible, ReturnValue) == 0x000000, "Member 'RenderStateComponent_IsVisible::ReturnValue' has a wrong offset!");

// Function Zion.RenderStateManagerComponent.Get
// 0x0010 (0x0010 - 0x0000)
struct RenderStateManagerComponent_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URenderStateManagerComponent*           ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RenderStateManagerComponent_Get) == 0x000008, "Wrong alignment on RenderStateManagerComponent_Get");
static_assert(sizeof(RenderStateManagerComponent_Get) == 0x000010, "Wrong size on RenderStateManagerComponent_Get");
static_assert(offsetof(RenderStateManagerComponent_Get, WorldContextObject) == 0x000000, "Member 'RenderStateManagerComponent_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(RenderStateManagerComponent_Get, ReturnValue) == 0x000008, "Member 'RenderStateManagerComponent_Get::ReturnValue' has a wrong offset!");

// Function Zion.RepulsionEnemyComponent.OnComponentOverlapBegin
// 0x0118 (0x0118 - 0x0000)
struct RepulsionEnemyComponent_OnComponentOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlapComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(RepulsionEnemyComponent_OnComponentOverlapBegin) == 0x000008, "Wrong alignment on RepulsionEnemyComponent_OnComponentOverlapBegin");
static_assert(sizeof(RepulsionEnemyComponent_OnComponentOverlapBegin) == 0x000118, "Wrong size on RepulsionEnemyComponent_OnComponentOverlapBegin");
static_assert(offsetof(RepulsionEnemyComponent_OnComponentOverlapBegin, OverlapComponent) == 0x000000, "Member 'RepulsionEnemyComponent_OnComponentOverlapBegin::OverlapComponent' has a wrong offset!");
static_assert(offsetof(RepulsionEnemyComponent_OnComponentOverlapBegin, OtherActor) == 0x000008, "Member 'RepulsionEnemyComponent_OnComponentOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(RepulsionEnemyComponent_OnComponentOverlapBegin, OtherComp) == 0x000010, "Member 'RepulsionEnemyComponent_OnComponentOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(RepulsionEnemyComponent_OnComponentOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'RepulsionEnemyComponent_OnComponentOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(RepulsionEnemyComponent_OnComponentOverlapBegin, bFromSweep) == 0x00001C, "Member 'RepulsionEnemyComponent_OnComponentOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(RepulsionEnemyComponent_OnComponentOverlapBegin, SweepResult) == 0x000020, "Member 'RepulsionEnemyComponent_OnComponentOverlapBegin::SweepResult' has a wrong offset!");

// Function Zion.RepulsionEnemyComponent.OnComponentOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct RepulsionEnemyComponent_OnComponentOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlapComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RepulsionEnemyComponent_OnComponentOverlapEnd) == 0x000008, "Wrong alignment on RepulsionEnemyComponent_OnComponentOverlapEnd");
static_assert(sizeof(RepulsionEnemyComponent_OnComponentOverlapEnd) == 0x000020, "Wrong size on RepulsionEnemyComponent_OnComponentOverlapEnd");
static_assert(offsetof(RepulsionEnemyComponent_OnComponentOverlapEnd, OverlapComponent) == 0x000000, "Member 'RepulsionEnemyComponent_OnComponentOverlapEnd::OverlapComponent' has a wrong offset!");
static_assert(offsetof(RepulsionEnemyComponent_OnComponentOverlapEnd, OtherActor) == 0x000008, "Member 'RepulsionEnemyComponent_OnComponentOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(RepulsionEnemyComponent_OnComponentOverlapEnd, OtherComp) == 0x000010, "Member 'RepulsionEnemyComponent_OnComponentOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(RepulsionEnemyComponent_OnComponentOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'RepulsionEnemyComponent_OnComponentOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function Zion.RepulsionPlayerComponent.AddRepulsionEnemyComponent
// 0x0010 (0x0010 - 0x0000)
struct RepulsionPlayerComponent_AddRepulsionEnemyComponent final
{
public:
	class URepulsionEnemyComponent*               RepulsionEnemyComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    Collider;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RepulsionPlayerComponent_AddRepulsionEnemyComponent) == 0x000008, "Wrong alignment on RepulsionPlayerComponent_AddRepulsionEnemyComponent");
static_assert(sizeof(RepulsionPlayerComponent_AddRepulsionEnemyComponent) == 0x000010, "Wrong size on RepulsionPlayerComponent_AddRepulsionEnemyComponent");
static_assert(offsetof(RepulsionPlayerComponent_AddRepulsionEnemyComponent, RepulsionEnemyComponent) == 0x000000, "Member 'RepulsionPlayerComponent_AddRepulsionEnemyComponent::RepulsionEnemyComponent' has a wrong offset!");
static_assert(offsetof(RepulsionPlayerComponent_AddRepulsionEnemyComponent, Collider) == 0x000008, "Member 'RepulsionPlayerComponent_AddRepulsionEnemyComponent::Collider' has a wrong offset!");

// Function Zion.RepulsionPlayerComponent.RemoveRepulsionEnemyComponent
// 0x0010 (0x0010 - 0x0000)
struct RepulsionPlayerComponent_RemoveRepulsionEnemyComponent final
{
public:
	class URepulsionEnemyComponent*               RepulsionEnemyComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    Collider;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RepulsionPlayerComponent_RemoveRepulsionEnemyComponent) == 0x000008, "Wrong alignment on RepulsionPlayerComponent_RemoveRepulsionEnemyComponent");
static_assert(sizeof(RepulsionPlayerComponent_RemoveRepulsionEnemyComponent) == 0x000010, "Wrong size on RepulsionPlayerComponent_RemoveRepulsionEnemyComponent");
static_assert(offsetof(RepulsionPlayerComponent_RemoveRepulsionEnemyComponent, RepulsionEnemyComponent) == 0x000000, "Member 'RepulsionPlayerComponent_RemoveRepulsionEnemyComponent::RepulsionEnemyComponent' has a wrong offset!");
static_assert(offsetof(RepulsionPlayerComponent_RemoveRepulsionEnemyComponent, Collider) == 0x000008, "Member 'RepulsionPlayerComponent_RemoveRepulsionEnemyComponent::Collider' has a wrong offset!");

// Function Zion.SaveSubsystem.CheckCurrentSlotExistence
// 0x0001 (0x0001 - 0x0000)
struct SaveSubsystem_CheckCurrentSlotExistence final
{
public:
	ESaveExistsType                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveSubsystem_CheckCurrentSlotExistence) == 0x000001, "Wrong alignment on SaveSubsystem_CheckCurrentSlotExistence");
static_assert(sizeof(SaveSubsystem_CheckCurrentSlotExistence) == 0x000001, "Wrong size on SaveSubsystem_CheckCurrentSlotExistence");
static_assert(offsetof(SaveSubsystem_CheckCurrentSlotExistence, ReturnValue) == 0x000000, "Member 'SaveSubsystem_CheckCurrentSlotExistence::ReturnValue' has a wrong offset!");

// Function Zion.SaveSubsystem.CheckSlotExistence
// 0x0008 (0x0008 - 0x0000)
struct SaveSubsystem_CheckSlotExistence final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESaveExistsType                               ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SaveSubsystem_CheckSlotExistence) == 0x000004, "Wrong alignment on SaveSubsystem_CheckSlotExistence");
static_assert(sizeof(SaveSubsystem_CheckSlotExistence) == 0x000008, "Wrong size on SaveSubsystem_CheckSlotExistence");
static_assert(offsetof(SaveSubsystem_CheckSlotExistence, SlotIndex) == 0x000000, "Member 'SaveSubsystem_CheckSlotExistence::SlotIndex' has a wrong offset!");
static_assert(offsetof(SaveSubsystem_CheckSlotExistence, ReturnValue) == 0x000004, "Member 'SaveSubsystem_CheckSlotExistence::ReturnValue' has a wrong offset!");

// Function Zion.SaveSubsystem.CopyGameDataToEmptySlot
// 0x000C (0x000C - 0x0000)
struct SaveSubsystem_CopyGameDataToEmptySlot final
{
public:
	int32                                         SlotToCopy;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         out_TargetSlot;                                    // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESaveCopyResult                               ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SaveSubsystem_CopyGameDataToEmptySlot) == 0x000004, "Wrong alignment on SaveSubsystem_CopyGameDataToEmptySlot");
static_assert(sizeof(SaveSubsystem_CopyGameDataToEmptySlot) == 0x00000C, "Wrong size on SaveSubsystem_CopyGameDataToEmptySlot");
static_assert(offsetof(SaveSubsystem_CopyGameDataToEmptySlot, SlotToCopy) == 0x000000, "Member 'SaveSubsystem_CopyGameDataToEmptySlot::SlotToCopy' has a wrong offset!");
static_assert(offsetof(SaveSubsystem_CopyGameDataToEmptySlot, out_TargetSlot) == 0x000004, "Member 'SaveSubsystem_CopyGameDataToEmptySlot::out_TargetSlot' has a wrong offset!");
static_assert(offsetof(SaveSubsystem_CopyGameDataToEmptySlot, ReturnValue) == 0x000008, "Member 'SaveSubsystem_CopyGameDataToEmptySlot::ReturnValue' has a wrong offset!");

// Function Zion.SaveSubsystem.DeleteSaveDataAtSlotIndex
// 0x0004 (0x0004 - 0x0000)
struct SaveSubsystem_DeleteSaveDataAtSlotIndex final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveSubsystem_DeleteSaveDataAtSlotIndex) == 0x000004, "Wrong alignment on SaveSubsystem_DeleteSaveDataAtSlotIndex");
static_assert(sizeof(SaveSubsystem_DeleteSaveDataAtSlotIndex) == 0x000004, "Wrong size on SaveSubsystem_DeleteSaveDataAtSlotIndex");
static_assert(offsetof(SaveSubsystem_DeleteSaveDataAtSlotIndex, SlotIndex) == 0x000000, "Member 'SaveSubsystem_DeleteSaveDataAtSlotIndex::SlotIndex' has a wrong offset!");

// Function Zion.SaveSubsystem.LoadGameFromCurrentSlot
// 0x0010 (0x0010 - 0x0000)
struct SaveSubsystem_LoadGameFromCurrentSlot final
{
public:
	class USaveGameZion*                          out_GameData;                                      // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESaveExistsType                               ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SaveSubsystem_LoadGameFromCurrentSlot) == 0x000008, "Wrong alignment on SaveSubsystem_LoadGameFromCurrentSlot");
static_assert(sizeof(SaveSubsystem_LoadGameFromCurrentSlot) == 0x000010, "Wrong size on SaveSubsystem_LoadGameFromCurrentSlot");
static_assert(offsetof(SaveSubsystem_LoadGameFromCurrentSlot, out_GameData) == 0x000000, "Member 'SaveSubsystem_LoadGameFromCurrentSlot::out_GameData' has a wrong offset!");
static_assert(offsetof(SaveSubsystem_LoadGameFromCurrentSlot, ReturnValue) == 0x000008, "Member 'SaveSubsystem_LoadGameFromCurrentSlot::ReturnValue' has a wrong offset!");

// Function Zion.SaveSubsystem.LoadGameFromCurrentSlotAsync
// 0x0010 (0x0010 - 0x0000)
struct SaveSubsystem_LoadGameFromCurrentSlotAsync final
{
public:
	TDelegate<void(ESaveExistsType Result, class USaveGameZion* LoadedData)> OnLoadFinished;         // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveSubsystem_LoadGameFromCurrentSlotAsync) == 0x000004, "Wrong alignment on SaveSubsystem_LoadGameFromCurrentSlotAsync");
static_assert(sizeof(SaveSubsystem_LoadGameFromCurrentSlotAsync) == 0x000010, "Wrong size on SaveSubsystem_LoadGameFromCurrentSlotAsync");
static_assert(offsetof(SaveSubsystem_LoadGameFromCurrentSlotAsync, OnLoadFinished) == 0x000000, "Member 'SaveSubsystem_LoadGameFromCurrentSlotAsync::OnLoadFinished' has a wrong offset!");

// Function Zion.SaveSubsystem.LoadGameFromSlotAsync
// 0x0014 (0x0014 - 0x0000)
struct SaveSubsystem_LoadGameFromSlotAsync final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(ESaveExistsType Result, class USaveGameZion* LoadedData)> OnLoadFinished;         // 0x0004(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveSubsystem_LoadGameFromSlotAsync) == 0x000004, "Wrong alignment on SaveSubsystem_LoadGameFromSlotAsync");
static_assert(sizeof(SaveSubsystem_LoadGameFromSlotAsync) == 0x000014, "Wrong size on SaveSubsystem_LoadGameFromSlotAsync");
static_assert(offsetof(SaveSubsystem_LoadGameFromSlotAsync, SlotIndex) == 0x000000, "Member 'SaveSubsystem_LoadGameFromSlotAsync::SlotIndex' has a wrong offset!");
static_assert(offsetof(SaveSubsystem_LoadGameFromSlotAsync, OnLoadFinished) == 0x000004, "Member 'SaveSubsystem_LoadGameFromSlotAsync::OnLoadFinished' has a wrong offset!");

// Function Zion.SaveSubsystem.LoadSettings
// 0x0002 (0x0002 - 0x0000)
struct SaveSubsystem_LoadSettings final
{
public:
	bool                                          bForceReload;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESaveExistsType                               ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveSubsystem_LoadSettings) == 0x000001, "Wrong alignment on SaveSubsystem_LoadSettings");
static_assert(sizeof(SaveSubsystem_LoadSettings) == 0x000002, "Wrong size on SaveSubsystem_LoadSettings");
static_assert(offsetof(SaveSubsystem_LoadSettings, bForceReload) == 0x000000, "Member 'SaveSubsystem_LoadSettings::bForceReload' has a wrong offset!");
static_assert(offsetof(SaveSubsystem_LoadSettings, ReturnValue) == 0x000001, "Member 'SaveSubsystem_LoadSettings::ReturnValue' has a wrong offset!");

// Function Zion.SaveSubsystem.SaveGameInCurrentSlot
// 0x0001 (0x0001 - 0x0000)
struct SaveSubsystem_SaveGameInCurrentSlot final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveSubsystem_SaveGameInCurrentSlot) == 0x000001, "Wrong alignment on SaveSubsystem_SaveGameInCurrentSlot");
static_assert(sizeof(SaveSubsystem_SaveGameInCurrentSlot) == 0x000001, "Wrong size on SaveSubsystem_SaveGameInCurrentSlot");
static_assert(offsetof(SaveSubsystem_SaveGameInCurrentSlot, ReturnValue) == 0x000000, "Member 'SaveSubsystem_SaveGameInCurrentSlot::ReturnValue' has a wrong offset!");

// Function Zion.SaveSubsystem.SaveGameInCurrentSlotAsync
// 0x0010 (0x0010 - 0x0000)
struct SaveSubsystem_SaveGameInCurrentSlotAsync final
{
public:
	TDelegate<void(bool Result)>                  OnSaveFinished;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveSubsystem_SaveGameInCurrentSlotAsync) == 0x000004, "Wrong alignment on SaveSubsystem_SaveGameInCurrentSlotAsync");
static_assert(sizeof(SaveSubsystem_SaveGameInCurrentSlotAsync) == 0x000010, "Wrong size on SaveSubsystem_SaveGameInCurrentSlotAsync");
static_assert(offsetof(SaveSubsystem_SaveGameInCurrentSlotAsync, OnSaveFinished) == 0x000000, "Member 'SaveSubsystem_SaveGameInCurrentSlotAsync::OnSaveFinished' has a wrong offset!");

// Function Zion.SaveSubsystem.SaveSettings
// 0x0001 (0x0001 - 0x0000)
struct SaveSubsystem_SaveSettings final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveSubsystem_SaveSettings) == 0x000001, "Wrong alignment on SaveSubsystem_SaveSettings");
static_assert(sizeof(SaveSubsystem_SaveSettings) == 0x000001, "Wrong size on SaveSubsystem_SaveSettings");
static_assert(offsetof(SaveSubsystem_SaveSettings, ReturnValue) == 0x000000, "Member 'SaveSubsystem_SaveSettings::ReturnValue' has a wrong offset!");

// Function Zion.SaveSubsystem.SetCurrentSlotIndex
// 0x0004 (0x0004 - 0x0000)
struct SaveSubsystem_SetCurrentSlotIndex final
{
public:
	int32                                         NewSlotIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveSubsystem_SetCurrentSlotIndex) == 0x000004, "Wrong alignment on SaveSubsystem_SetCurrentSlotIndex");
static_assert(sizeof(SaveSubsystem_SetCurrentSlotIndex) == 0x000004, "Wrong size on SaveSubsystem_SetCurrentSlotIndex");
static_assert(offsetof(SaveSubsystem_SetCurrentSlotIndex, NewSlotIndex) == 0x000000, "Member 'SaveSubsystem_SetCurrentSlotIndex::NewSlotIndex' has a wrong offset!");

// Function Zion.SaveSubsystem.GetTimeSinceLastGameSave
// 0x0004 (0x0004 - 0x0000)
struct SaveSubsystem_GetTimeSinceLastGameSave final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveSubsystem_GetTimeSinceLastGameSave) == 0x000004, "Wrong alignment on SaveSubsystem_GetTimeSinceLastGameSave");
static_assert(sizeof(SaveSubsystem_GetTimeSinceLastGameSave) == 0x000004, "Wrong size on SaveSubsystem_GetTimeSinceLastGameSave");
static_assert(offsetof(SaveSubsystem_GetTimeSinceLastGameSave, ReturnValue) == 0x000000, "Member 'SaveSubsystem_GetTimeSinceLastGameSave::ReturnValue' has a wrong offset!");

// Function Zion.SaveSubsystem.IsLoadingGameData
// 0x0001 (0x0001 - 0x0000)
struct SaveSubsystem_IsLoadingGameData final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveSubsystem_IsLoadingGameData) == 0x000001, "Wrong alignment on SaveSubsystem_IsLoadingGameData");
static_assert(sizeof(SaveSubsystem_IsLoadingGameData) == 0x000001, "Wrong size on SaveSubsystem_IsLoadingGameData");
static_assert(offsetof(SaveSubsystem_IsLoadingGameData, ReturnValue) == 0x000000, "Member 'SaveSubsystem_IsLoadingGameData::ReturnValue' has a wrong offset!");

// Function Zion.ZionCharacterMovementComponent.SetMovementModeCustom
// 0x0001 (0x0001 - 0x0000)
struct ZionCharacterMovementComponent_SetMovementModeCustom final
{
public:
	EMovementModeCustom                           NewMovementModeCustom;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionCharacterMovementComponent_SetMovementModeCustom) == 0x000001, "Wrong alignment on ZionCharacterMovementComponent_SetMovementModeCustom");
static_assert(sizeof(ZionCharacterMovementComponent_SetMovementModeCustom) == 0x000001, "Wrong size on ZionCharacterMovementComponent_SetMovementModeCustom");
static_assert(offsetof(ZionCharacterMovementComponent_SetMovementModeCustom, NewMovementModeCustom) == 0x000000, "Member 'ZionCharacterMovementComponent_SetMovementModeCustom::NewMovementModeCustom' has a wrong offset!");

// Function Zion.ZionCharacterMovementComponent.SetMovementSpeedMode
// 0x0001 (0x0001 - 0x0000)
struct ZionCharacterMovementComponent_SetMovementSpeedMode final
{
public:
	EMovementSpeedMode                            NewMovementSpeedMode;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionCharacterMovementComponent_SetMovementSpeedMode) == 0x000001, "Wrong alignment on ZionCharacterMovementComponent_SetMovementSpeedMode");
static_assert(sizeof(ZionCharacterMovementComponent_SetMovementSpeedMode) == 0x000001, "Wrong size on ZionCharacterMovementComponent_SetMovementSpeedMode");
static_assert(offsetof(ZionCharacterMovementComponent_SetMovementSpeedMode, NewMovementSpeedMode) == 0x000000, "Member 'ZionCharacterMovementComponent_SetMovementSpeedMode::NewMovementSpeedMode' has a wrong offset!");

// Function Zion.ZionCharacterMovementComponent.ComputeLaunchVelocityToDestination
// 0x0038 (0x0038 - 0x0000)
struct ZionCharacterMovementComponent_ComputeLaunchVelocityToDestination final
{
public:
	struct FVector                                DestinationLocation;                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionCharacterMovementComponent_ComputeLaunchVelocityToDestination) == 0x000008, "Wrong alignment on ZionCharacterMovementComponent_ComputeLaunchVelocityToDestination");
static_assert(sizeof(ZionCharacterMovementComponent_ComputeLaunchVelocityToDestination) == 0x000038, "Wrong size on ZionCharacterMovementComponent_ComputeLaunchVelocityToDestination");
static_assert(offsetof(ZionCharacterMovementComponent_ComputeLaunchVelocityToDestination, DestinationLocation) == 0x000000, "Member 'ZionCharacterMovementComponent_ComputeLaunchVelocityToDestination::DestinationLocation' has a wrong offset!");
static_assert(offsetof(ZionCharacterMovementComponent_ComputeLaunchVelocityToDestination, Duration) == 0x000018, "Member 'ZionCharacterMovementComponent_ComputeLaunchVelocityToDestination::Duration' has a wrong offset!");
static_assert(offsetof(ZionCharacterMovementComponent_ComputeLaunchVelocityToDestination, ReturnValue) == 0x000020, "Member 'ZionCharacterMovementComponent_ComputeLaunchVelocityToDestination::ReturnValue' has a wrong offset!");

// Function Zion.ZionCharacterMovementComponent.GetLastNonFallingLocation
// 0x0018 (0x0018 - 0x0000)
struct ZionCharacterMovementComponent_GetLastNonFallingLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionCharacterMovementComponent_GetLastNonFallingLocation) == 0x000008, "Wrong alignment on ZionCharacterMovementComponent_GetLastNonFallingLocation");
static_assert(sizeof(ZionCharacterMovementComponent_GetLastNonFallingLocation) == 0x000018, "Wrong size on ZionCharacterMovementComponent_GetLastNonFallingLocation");
static_assert(offsetof(ZionCharacterMovementComponent_GetLastNonFallingLocation, ReturnValue) == 0x000000, "Member 'ZionCharacterMovementComponent_GetLastNonFallingLocation::ReturnValue' has a wrong offset!");

// Function Zion.ZionCharacterMovementComponent.GetMovementSpeedMode
// 0x0001 (0x0001 - 0x0000)
struct ZionCharacterMovementComponent_GetMovementSpeedMode final
{
public:
	EMovementSpeedMode                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionCharacterMovementComponent_GetMovementSpeedMode) == 0x000001, "Wrong alignment on ZionCharacterMovementComponent_GetMovementSpeedMode");
static_assert(sizeof(ZionCharacterMovementComponent_GetMovementSpeedMode) == 0x000001, "Wrong size on ZionCharacterMovementComponent_GetMovementSpeedMode");
static_assert(offsetof(ZionCharacterMovementComponent_GetMovementSpeedMode, ReturnValue) == 0x000000, "Member 'ZionCharacterMovementComponent_GetMovementSpeedMode::ReturnValue' has a wrong offset!");

// Function Zion.ZionCharacterMovementComponent.GetTimeSinceLastGrounded
// 0x0004 (0x0004 - 0x0000)
struct ZionCharacterMovementComponent_GetTimeSinceLastGrounded final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionCharacterMovementComponent_GetTimeSinceLastGrounded) == 0x000004, "Wrong alignment on ZionCharacterMovementComponent_GetTimeSinceLastGrounded");
static_assert(sizeof(ZionCharacterMovementComponent_GetTimeSinceLastGrounded) == 0x000004, "Wrong size on ZionCharacterMovementComponent_GetTimeSinceLastGrounded");
static_assert(offsetof(ZionCharacterMovementComponent_GetTimeSinceLastGrounded, ReturnValue) == 0x000000, "Member 'ZionCharacterMovementComponent_GetTimeSinceLastGrounded::ReturnValue' has a wrong offset!");

// Function Zion.ZionCharacterMovementComponent.GetTimeSinceLastHookAttach
// 0x0004 (0x0004 - 0x0000)
struct ZionCharacterMovementComponent_GetTimeSinceLastHookAttach final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionCharacterMovementComponent_GetTimeSinceLastHookAttach) == 0x000004, "Wrong alignment on ZionCharacterMovementComponent_GetTimeSinceLastHookAttach");
static_assert(sizeof(ZionCharacterMovementComponent_GetTimeSinceLastHookAttach) == 0x000004, "Wrong size on ZionCharacterMovementComponent_GetTimeSinceLastHookAttach");
static_assert(offsetof(ZionCharacterMovementComponent_GetTimeSinceLastHookAttach, ReturnValue) == 0x000000, "Member 'ZionCharacterMovementComponent_GetTimeSinceLastHookAttach::ReturnValue' has a wrong offset!");

// Function Zion.ZionCharacterMovementComponent.GetTimeSinceLastWallGrab
// 0x0004 (0x0004 - 0x0000)
struct ZionCharacterMovementComponent_GetTimeSinceLastWallGrab final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionCharacterMovementComponent_GetTimeSinceLastWallGrab) == 0x000004, "Wrong alignment on ZionCharacterMovementComponent_GetTimeSinceLastWallGrab");
static_assert(sizeof(ZionCharacterMovementComponent_GetTimeSinceLastWallGrab) == 0x000004, "Wrong size on ZionCharacterMovementComponent_GetTimeSinceLastWallGrab");
static_assert(offsetof(ZionCharacterMovementComponent_GetTimeSinceLastWallGrab, ReturnValue) == 0x000000, "Member 'ZionCharacterMovementComponent_GetTimeSinceLastWallGrab::ReturnValue' has a wrong offset!");

// Function Zion.ZionCharacterMovementComponent.IsAirborne
// 0x0001 (0x0001 - 0x0000)
struct ZionCharacterMovementComponent_IsAirborne final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionCharacterMovementComponent_IsAirborne) == 0x000001, "Wrong alignment on ZionCharacterMovementComponent_IsAirborne");
static_assert(sizeof(ZionCharacterMovementComponent_IsAirborne) == 0x000001, "Wrong size on ZionCharacterMovementComponent_IsAirborne");
static_assert(offsetof(ZionCharacterMovementComponent_IsAirborne, ReturnValue) == 0x000000, "Member 'ZionCharacterMovementComponent_IsAirborne::ReturnValue' has a wrong offset!");

// Function Zion.ZionCharacterMovementComponent.IsHookAttached
// 0x0001 (0x0001 - 0x0000)
struct ZionCharacterMovementComponent_IsHookAttached final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionCharacterMovementComponent_IsHookAttached) == 0x000001, "Wrong alignment on ZionCharacterMovementComponent_IsHookAttached");
static_assert(sizeof(ZionCharacterMovementComponent_IsHookAttached) == 0x000001, "Wrong size on ZionCharacterMovementComponent_IsHookAttached");
static_assert(offsetof(ZionCharacterMovementComponent_IsHookAttached, ReturnValue) == 0x000000, "Member 'ZionCharacterMovementComponent_IsHookAttached::ReturnValue' has a wrong offset!");

// Function Zion.ZionCharacterMovementComponent.IsSliding
// 0x0001 (0x0001 - 0x0000)
struct ZionCharacterMovementComponent_IsSliding final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionCharacterMovementComponent_IsSliding) == 0x000001, "Wrong alignment on ZionCharacterMovementComponent_IsSliding");
static_assert(sizeof(ZionCharacterMovementComponent_IsSliding) == 0x000001, "Wrong size on ZionCharacterMovementComponent_IsSliding");
static_assert(offsetof(ZionCharacterMovementComponent_IsSliding, ReturnValue) == 0x000000, "Member 'ZionCharacterMovementComponent_IsSliding::ReturnValue' has a wrong offset!");

// Function Zion.ZionCharacterMovementComponent.IsWallGrabbing
// 0x0001 (0x0001 - 0x0000)
struct ZionCharacterMovementComponent_IsWallGrabbing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionCharacterMovementComponent_IsWallGrabbing) == 0x000001, "Wrong alignment on ZionCharacterMovementComponent_IsWallGrabbing");
static_assert(sizeof(ZionCharacterMovementComponent_IsWallGrabbing) == 0x000001, "Wrong size on ZionCharacterMovementComponent_IsWallGrabbing");
static_assert(offsetof(ZionCharacterMovementComponent_IsWallGrabbing, ReturnValue) == 0x000000, "Member 'ZionCharacterMovementComponent_IsWallGrabbing::ReturnValue' has a wrong offset!");

// Function Zion.ZionCharacterMovementComponent.IsWallScaling
// 0x0001 (0x0001 - 0x0000)
struct ZionCharacterMovementComponent_IsWallScaling final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionCharacterMovementComponent_IsWallScaling) == 0x000001, "Wrong alignment on ZionCharacterMovementComponent_IsWallScaling");
static_assert(sizeof(ZionCharacterMovementComponent_IsWallScaling) == 0x000001, "Wrong size on ZionCharacterMovementComponent_IsWallScaling");
static_assert(offsetof(ZionCharacterMovementComponent_IsWallScaling, ReturnValue) == 0x000000, "Member 'ZionCharacterMovementComponent_IsWallScaling::ReturnValue' has a wrong offset!");

// Function Zion.ScrollBoxZion.CopyWidgetNavigation
// 0x0008 (0x0008 - 0x0000)
struct ScrollBoxZion_CopyWidgetNavigation final
{
public:
	class UWidgetNavigation*                      WidgetNavigation;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScrollBoxZion_CopyWidgetNavigation) == 0x000008, "Wrong alignment on ScrollBoxZion_CopyWidgetNavigation");
static_assert(sizeof(ScrollBoxZion_CopyWidgetNavigation) == 0x000008, "Wrong size on ScrollBoxZion_CopyWidgetNavigation");
static_assert(offsetof(ScrollBoxZion_CopyWidgetNavigation, WidgetNavigation) == 0x000000, "Member 'ScrollBoxZion_CopyWidgetNavigation::WidgetNavigation' has a wrong offset!");

// Function Zion.ScrollBoxZion.ScrollWidgetHostIntoView
// 0x0010 (0x0010 - 0x0000)
struct ScrollBoxZion_ScrollWidgetHostIntoView final
{
public:
	class UNativeWidgetHost*                      NativeWidgetHost;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InAnimateScroll;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDescendantScrollDestination                  InDestination;                                     // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InScrollPadding;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScrollBoxZion_ScrollWidgetHostIntoView) == 0x000008, "Wrong alignment on ScrollBoxZion_ScrollWidgetHostIntoView");
static_assert(sizeof(ScrollBoxZion_ScrollWidgetHostIntoView) == 0x000010, "Wrong size on ScrollBoxZion_ScrollWidgetHostIntoView");
static_assert(offsetof(ScrollBoxZion_ScrollWidgetHostIntoView, NativeWidgetHost) == 0x000000, "Member 'ScrollBoxZion_ScrollWidgetHostIntoView::NativeWidgetHost' has a wrong offset!");
static_assert(offsetof(ScrollBoxZion_ScrollWidgetHostIntoView, InAnimateScroll) == 0x000008, "Member 'ScrollBoxZion_ScrollWidgetHostIntoView::InAnimateScroll' has a wrong offset!");
static_assert(offsetof(ScrollBoxZion_ScrollWidgetHostIntoView, InDestination) == 0x000009, "Member 'ScrollBoxZion_ScrollWidgetHostIntoView::InDestination' has a wrong offset!");
static_assert(offsetof(ScrollBoxZion_ScrollWidgetHostIntoView, InScrollPadding) == 0x00000C, "Member 'ScrollBoxZion_ScrollWidgetHostIntoView::InScrollPadding' has a wrong offset!");

// Function Zion.ScrollBoxZion.SetElementCountPerLine
// 0x0004 (0x0004 - 0x0000)
struct ScrollBoxZion_SetElementCountPerLine final
{
public:
	int32                                         NewElementCountsPerLine;                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScrollBoxZion_SetElementCountPerLine) == 0x000004, "Wrong alignment on ScrollBoxZion_SetElementCountPerLine");
static_assert(sizeof(ScrollBoxZion_SetElementCountPerLine) == 0x000004, "Wrong size on ScrollBoxZion_SetElementCountPerLine");
static_assert(offsetof(ScrollBoxZion_SetElementCountPerLine, NewElementCountsPerLine) == 0x000000, "Member 'ScrollBoxZion_SetElementCountPerLine::NewElementCountsPerLine' has a wrong offset!");

// Function Zion.ScrollBoxZion.SetNavigationOrientation
// 0x0001 (0x0001 - 0x0000)
struct ScrollBoxZion_SetNavigationOrientation final
{
public:
	EOrientation                                  NewNavigationOrientation;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScrollBoxZion_SetNavigationOrientation) == 0x000001, "Wrong alignment on ScrollBoxZion_SetNavigationOrientation");
static_assert(sizeof(ScrollBoxZion_SetNavigationOrientation) == 0x000001, "Wrong size on ScrollBoxZion_SetNavigationOrientation");
static_assert(offsetof(ScrollBoxZion_SetNavigationOrientation, NewNavigationOrientation) == 0x000000, "Member 'ScrollBoxZion_SetNavigationOrientation::NewNavigationOrientation' has a wrong offset!");

// Function Zion.ScrollBoxZion.SimulateNavigation
// 0x0001 (0x0001 - 0x0000)
struct ScrollBoxZion_SimulateNavigation final
{
public:
	EUINavigation                                 InNavigation;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScrollBoxZion_SimulateNavigation) == 0x000001, "Wrong alignment on ScrollBoxZion_SimulateNavigation");
static_assert(sizeof(ScrollBoxZion_SimulateNavigation) == 0x000001, "Wrong size on ScrollBoxZion_SimulateNavigation");
static_assert(offsetof(ScrollBoxZion_SimulateNavigation, InNavigation) == 0x000000, "Member 'ScrollBoxZion_SimulateNavigation::InNavigation' has a wrong offset!");

// Function Zion.ShakeComponent.LaunchShake
// 0x0030 (0x0030 - 0x0000)
struct ShakeComponent_LaunchShake final
{
public:
	struct FShakeData                             ShakeData;                                         // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShakeComponent_LaunchShake) == 0x000004, "Wrong alignment on ShakeComponent_LaunchShake");
static_assert(sizeof(ShakeComponent_LaunchShake) == 0x000030, "Wrong size on ShakeComponent_LaunchShake");
static_assert(offsetof(ShakeComponent_LaunchShake, ShakeData) == 0x000000, "Member 'ShakeComponent_LaunchShake::ShakeData' has a wrong offset!");

// Function Zion.ShopInfoComponent.AddShopHistory
// 0x0018 (0x0018 - 0x0000)
struct ShopInfoComponent_AddShopHistory final
{
public:
	EShopType                                     ShopType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    BoughtItem;                                        // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShopInfoComponent_AddShopHistory) == 0x000008, "Wrong alignment on ShopInfoComponent_AddShopHistory");
static_assert(sizeof(ShopInfoComponent_AddShopHistory) == 0x000018, "Wrong size on ShopInfoComponent_AddShopHistory");
static_assert(offsetof(ShopInfoComponent_AddShopHistory, ShopType) == 0x000000, "Member 'ShopInfoComponent_AddShopHistory::ShopType' has a wrong offset!");
static_assert(offsetof(ShopInfoComponent_AddShopHistory, BoughtItem) == 0x000008, "Member 'ShopInfoComponent_AddShopHistory::BoughtItem' has a wrong offset!");

// Function Zion.ShopInfoComponent.GetItemsForShop
// 0x0020 (0x0020 - 0x0000)
struct ShopInfoComponent_GetItemsForShop final
{
public:
	EShopType                                     ShopType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDataTable*                       ShopDataTable;                                     // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FShopItemData>                  ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShopInfoComponent_GetItemsForShop) == 0x000008, "Wrong alignment on ShopInfoComponent_GetItemsForShop");
static_assert(sizeof(ShopInfoComponent_GetItemsForShop) == 0x000020, "Wrong size on ShopInfoComponent_GetItemsForShop");
static_assert(offsetof(ShopInfoComponent_GetItemsForShop, ShopType) == 0x000000, "Member 'ShopInfoComponent_GetItemsForShop::ShopType' has a wrong offset!");
static_assert(offsetof(ShopInfoComponent_GetItemsForShop, ShopDataTable) == 0x000008, "Member 'ShopInfoComponent_GetItemsForShop::ShopDataTable' has a wrong offset!");
static_assert(offsetof(ShopInfoComponent_GetItemsForShop, ReturnValue) == 0x000010, "Member 'ShopInfoComponent_GetItemsForShop::ReturnValue' has a wrong offset!");

// Function Zion.ShopInfoComponent.MarkSeen
// 0x0028 (0x0028 - 0x0000)
struct ShopInfoComponent_MarkSeen final
{
public:
	EShopType                                     ShopType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FShopItemData                          ShopItemData;                                      // 0x0008(0x0020)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShopInfoComponent_MarkSeen) == 0x000008, "Wrong alignment on ShopInfoComponent_MarkSeen");
static_assert(sizeof(ShopInfoComponent_MarkSeen) == 0x000028, "Wrong size on ShopInfoComponent_MarkSeen");
static_assert(offsetof(ShopInfoComponent_MarkSeen, ShopType) == 0x000000, "Member 'ShopInfoComponent_MarkSeen::ShopType' has a wrong offset!");
static_assert(offsetof(ShopInfoComponent_MarkSeen, ShopItemData) == 0x000008, "Member 'ShopInfoComponent_MarkSeen::ShopItemData' has a wrong offset!");

// Function Zion.ShopInfoComponent.SetLevel
// 0x0008 (0x0008 - 0x0000)
struct ShopInfoComponent_SetLevel final
{
public:
	int32                                         NewLevel;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShopInfoComponent_SetLevel) == 0x000004, "Wrong alignment on ShopInfoComponent_SetLevel");
static_assert(sizeof(ShopInfoComponent_SetLevel) == 0x000008, "Wrong size on ShopInfoComponent_SetLevel");
static_assert(offsetof(ShopInfoComponent_SetLevel, NewLevel) == 0x000000, "Member 'ShopInfoComponent_SetLevel::NewLevel' has a wrong offset!");
static_assert(offsetof(ShopInfoComponent_SetLevel, ReturnValue) == 0x000004, "Member 'ShopInfoComponent_SetLevel::ReturnValue' has a wrong offset!");

// Function Zion.ShopInfoComponent.GetItemCost
// 0x0020 (0x0020 - 0x0000)
struct ShopInfoComponent_GetItemCost final
{
public:
	EShopType                                     ShopType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    Item;                                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FCurrencyValue                         ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShopInfoComponent_GetItemCost) == 0x000008, "Wrong alignment on ShopInfoComponent_GetItemCost");
static_assert(sizeof(ShopInfoComponent_GetItemCost) == 0x000020, "Wrong size on ShopInfoComponent_GetItemCost");
static_assert(offsetof(ShopInfoComponent_GetItemCost, ShopType) == 0x000000, "Member 'ShopInfoComponent_GetItemCost::ShopType' has a wrong offset!");
static_assert(offsetof(ShopInfoComponent_GetItemCost, Item) == 0x000008, "Member 'ShopInfoComponent_GetItemCost::Item' has a wrong offset!");
static_assert(offsetof(ShopInfoComponent_GetItemCost, ReturnValue) == 0x000018, "Member 'ShopInfoComponent_GetItemCost::ReturnValue' has a wrong offset!");

// Function Zion.ShopInfoComponent.GetLevel
// 0x0004 (0x0004 - 0x0000)
struct ShopInfoComponent_GetLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShopInfoComponent_GetLevel) == 0x000004, "Wrong alignment on ShopInfoComponent_GetLevel");
static_assert(sizeof(ShopInfoComponent_GetLevel) == 0x000004, "Wrong size on ShopInfoComponent_GetLevel");
static_assert(offsetof(ShopInfoComponent_GetLevel, ReturnValue) == 0x000000, "Member 'ShopInfoComponent_GetLevel::ReturnValue' has a wrong offset!");

// Function Zion.ShopInfoComponent.GetMaxLevel
// 0x0004 (0x0004 - 0x0000)
struct ShopInfoComponent_GetMaxLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShopInfoComponent_GetMaxLevel) == 0x000004, "Wrong alignment on ShopInfoComponent_GetMaxLevel");
static_assert(sizeof(ShopInfoComponent_GetMaxLevel) == 0x000004, "Wrong size on ShopInfoComponent_GetMaxLevel");
static_assert(offsetof(ShopInfoComponent_GetMaxLevel, ReturnValue) == 0x000000, "Member 'ShopInfoComponent_GetMaxLevel::ReturnValue' has a wrong offset!");

// Function Zion.ShopInfoComponent.GetMinLevel
// 0x0004 (0x0004 - 0x0000)
struct ShopInfoComponent_GetMinLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShopInfoComponent_GetMinLevel) == 0x000004, "Wrong alignment on ShopInfoComponent_GetMinLevel");
static_assert(sizeof(ShopInfoComponent_GetMinLevel) == 0x000004, "Wrong size on ShopInfoComponent_GetMinLevel");
static_assert(offsetof(ShopInfoComponent_GetMinLevel, ReturnValue) == 0x000000, "Member 'ShopInfoComponent_GetMinLevel::ReturnValue' has a wrong offset!");

// Function Zion.SleepActivatorComponent.OnWakeTriggerOverlapBegin
// 0x0118 (0x0118 - 0x0000)
struct SleepActivatorComponent_OnWakeTriggerOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SleepActivatorComponent_OnWakeTriggerOverlapBegin) == 0x000008, "Wrong alignment on SleepActivatorComponent_OnWakeTriggerOverlapBegin");
static_assert(sizeof(SleepActivatorComponent_OnWakeTriggerOverlapBegin) == 0x000118, "Wrong size on SleepActivatorComponent_OnWakeTriggerOverlapBegin");
static_assert(offsetof(SleepActivatorComponent_OnWakeTriggerOverlapBegin, OverlappedComponent) == 0x000000, "Member 'SleepActivatorComponent_OnWakeTriggerOverlapBegin::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(SleepActivatorComponent_OnWakeTriggerOverlapBegin, OtherActor) == 0x000008, "Member 'SleepActivatorComponent_OnWakeTriggerOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(SleepActivatorComponent_OnWakeTriggerOverlapBegin, OtherComp) == 0x000010, "Member 'SleepActivatorComponent_OnWakeTriggerOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(SleepActivatorComponent_OnWakeTriggerOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'SleepActivatorComponent_OnWakeTriggerOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(SleepActivatorComponent_OnWakeTriggerOverlapBegin, bFromSweep) == 0x00001C, "Member 'SleepActivatorComponent_OnWakeTriggerOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(SleepActivatorComponent_OnWakeTriggerOverlapBegin, SweepResult) == 0x000020, "Member 'SleepActivatorComponent_OnWakeTriggerOverlapBegin::SweepResult' has a wrong offset!");

// Function Zion.SleepActivatorComponent.OnWakeTriggerOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct SleepActivatorComponent_OnWakeTriggerOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SleepActivatorComponent_OnWakeTriggerOverlapEnd) == 0x000008, "Wrong alignment on SleepActivatorComponent_OnWakeTriggerOverlapEnd");
static_assert(sizeof(SleepActivatorComponent_OnWakeTriggerOverlapEnd) == 0x000020, "Wrong size on SleepActivatorComponent_OnWakeTriggerOverlapEnd");
static_assert(offsetof(SleepActivatorComponent_OnWakeTriggerOverlapEnd, OverlappedComponent) == 0x000000, "Member 'SleepActivatorComponent_OnWakeTriggerOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(SleepActivatorComponent_OnWakeTriggerOverlapEnd, OtherActor) == 0x000008, "Member 'SleepActivatorComponent_OnWakeTriggerOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(SleepActivatorComponent_OnWakeTriggerOverlapEnd, OtherComp) == 0x000010, "Member 'SleepActivatorComponent_OnWakeTriggerOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(SleepActivatorComponent_OnWakeTriggerOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'SleepActivatorComponent_OnWakeTriggerOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function Zion.SoundComponent.OnMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct SoundComponent_OnMovementModeChanged final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SoundComponent_OnMovementModeChanged) == 0x000008, "Wrong alignment on SoundComponent_OnMovementModeChanged");
static_assert(sizeof(SoundComponent_OnMovementModeChanged) == 0x000010, "Wrong size on SoundComponent_OnMovementModeChanged");
static_assert(offsetof(SoundComponent_OnMovementModeChanged, Character) == 0x000000, "Member 'SoundComponent_OnMovementModeChanged::Character' has a wrong offset!");
static_assert(offsetof(SoundComponent_OnMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'SoundComponent_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(SoundComponent_OnMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'SoundComponent_OnMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function Zion.SoundSubsystem.DisableSnapshot
// 0x0008 (0x0008 - 0x0000)
struct SoundSubsystem_DisableSnapshot final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_DisableSnapshot) == 0x000004, "Wrong alignment on SoundSubsystem_DisableSnapshot");
static_assert(sizeof(SoundSubsystem_DisableSnapshot) == 0x000008, "Wrong size on SoundSubsystem_DisableSnapshot");
static_assert(offsetof(SoundSubsystem_DisableSnapshot, Tag) == 0x000000, "Member 'SoundSubsystem_DisableSnapshot::Tag' has a wrong offset!");

// Function Zion.SoundSubsystem.EnableSnapshot
// 0x0010 (0x0010 - 0x0000)
struct SoundSubsystem_EnableSnapshot final
{
public:
	class UFMODEvent*                             Snapshot;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_EnableSnapshot) == 0x000008, "Wrong alignment on SoundSubsystem_EnableSnapshot");
static_assert(sizeof(SoundSubsystem_EnableSnapshot) == 0x000010, "Wrong size on SoundSubsystem_EnableSnapshot");
static_assert(offsetof(SoundSubsystem_EnableSnapshot, Snapshot) == 0x000000, "Member 'SoundSubsystem_EnableSnapshot::Snapshot' has a wrong offset!");
static_assert(offsetof(SoundSubsystem_EnableSnapshot, Tag) == 0x000008, "Member 'SoundSubsystem_EnableSnapshot::Tag' has a wrong offset!");

// Function Zion.SoundSubsystem.PauseFamily
// 0x0001 (0x0001 - 0x0000)
struct SoundSubsystem_PauseFamily final
{
public:
	ESoundFamily                                  SoundFamily;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_PauseFamily) == 0x000001, "Wrong alignment on SoundSubsystem_PauseFamily");
static_assert(sizeof(SoundSubsystem_PauseFamily) == 0x000001, "Wrong size on SoundSubsystem_PauseFamily");
static_assert(offsetof(SoundSubsystem_PauseFamily, SoundFamily) == 0x000000, "Member 'SoundSubsystem_PauseFamily::SoundFamily' has a wrong offset!");

// Function Zion.SoundSubsystem.PlayAmbience
// 0x0008 (0x0008 - 0x0000)
struct SoundSubsystem_PlayAmbience final
{
public:
	class UFMODEvent*                             SoundEvent;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_PlayAmbience) == 0x000008, "Wrong alignment on SoundSubsystem_PlayAmbience");
static_assert(sizeof(SoundSubsystem_PlayAmbience) == 0x000008, "Wrong size on SoundSubsystem_PlayAmbience");
static_assert(offsetof(SoundSubsystem_PlayAmbience, SoundEvent) == 0x000000, "Member 'SoundSubsystem_PlayAmbience::SoundEvent' has a wrong offset!");

// Function Zion.SoundSubsystem.PlayBGM
// 0x0008 (0x0008 - 0x0000)
struct SoundSubsystem_PlayBGM final
{
public:
	class UFMODEvent*                             SoundEvent;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_PlayBGM) == 0x000008, "Wrong alignment on SoundSubsystem_PlayBGM");
static_assert(sizeof(SoundSubsystem_PlayBGM) == 0x000008, "Wrong size on SoundSubsystem_PlayBGM");
static_assert(offsetof(SoundSubsystem_PlayBGM, SoundEvent) == 0x000000, "Member 'SoundSubsystem_PlayBGM::SoundEvent' has a wrong offset!");

// Function Zion.SoundSubsystem.PlaySoundEvent
// 0x0010 (0x0010 - 0x0000)
struct SoundSubsystem_PlaySoundEvent final
{
public:
	class UFMODEvent*                             SoundEvent;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFMODEventInstance                     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_PlaySoundEvent) == 0x000008, "Wrong alignment on SoundSubsystem_PlaySoundEvent");
static_assert(sizeof(SoundSubsystem_PlaySoundEvent) == 0x000010, "Wrong size on SoundSubsystem_PlaySoundEvent");
static_assert(offsetof(SoundSubsystem_PlaySoundEvent, SoundEvent) == 0x000000, "Member 'SoundSubsystem_PlaySoundEvent::SoundEvent' has a wrong offset!");
static_assert(offsetof(SoundSubsystem_PlaySoundEvent, ReturnValue) == 0x000008, "Member 'SoundSubsystem_PlaySoundEvent::ReturnValue' has a wrong offset!");

// Function Zion.SoundSubsystem.PlaySoundEventAttached
// 0x0018 (0x0018 - 0x0000)
struct SoundSubsystem_PlaySoundEventAttached final
{
public:
	class UFMODEvent*                             SoundEvent;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachToComponent;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_PlaySoundEventAttached) == 0x000008, "Wrong alignment on SoundSubsystem_PlaySoundEventAttached");
static_assert(sizeof(SoundSubsystem_PlaySoundEventAttached) == 0x000018, "Wrong size on SoundSubsystem_PlaySoundEventAttached");
static_assert(offsetof(SoundSubsystem_PlaySoundEventAttached, SoundEvent) == 0x000000, "Member 'SoundSubsystem_PlaySoundEventAttached::SoundEvent' has a wrong offset!");
static_assert(offsetof(SoundSubsystem_PlaySoundEventAttached, AttachToComponent) == 0x000008, "Member 'SoundSubsystem_PlaySoundEventAttached::AttachToComponent' has a wrong offset!");
static_assert(offsetof(SoundSubsystem_PlaySoundEventAttached, ReturnValue) == 0x000010, "Member 'SoundSubsystem_PlaySoundEventAttached::ReturnValue' has a wrong offset!");

// Function Zion.SoundSubsystem.PlaySoundEventAtWorldLocation
// 0x0028 (0x0028 - 0x0000)
struct SoundSubsystem_PlaySoundEventAtWorldLocation final
{
public:
	class UFMODEvent*                             SoundEvent;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFMODEventInstance                     ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_PlaySoundEventAtWorldLocation) == 0x000008, "Wrong alignment on SoundSubsystem_PlaySoundEventAtWorldLocation");
static_assert(sizeof(SoundSubsystem_PlaySoundEventAtWorldLocation) == 0x000028, "Wrong size on SoundSubsystem_PlaySoundEventAtWorldLocation");
static_assert(offsetof(SoundSubsystem_PlaySoundEventAtWorldLocation, SoundEvent) == 0x000000, "Member 'SoundSubsystem_PlaySoundEventAtWorldLocation::SoundEvent' has a wrong offset!");
static_assert(offsetof(SoundSubsystem_PlaySoundEventAtWorldLocation, WorldLocation) == 0x000008, "Member 'SoundSubsystem_PlaySoundEventAtWorldLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(SoundSubsystem_PlaySoundEventAtWorldLocation, ReturnValue) == 0x000020, "Member 'SoundSubsystem_PlaySoundEventAtWorldLocation::ReturnValue' has a wrong offset!");

// Function Zion.SoundSubsystem.PlayVoice
// 0x0018 (0x0018 - 0x0000)
struct SoundSubsystem_PlayVoice final
{
public:
	class FString                                 VoiceID;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_PlayVoice) == 0x000008, "Wrong alignment on SoundSubsystem_PlayVoice");
static_assert(sizeof(SoundSubsystem_PlayVoice) == 0x000018, "Wrong size on SoundSubsystem_PlayVoice");
static_assert(offsetof(SoundSubsystem_PlayVoice, VoiceID) == 0x000000, "Member 'SoundSubsystem_PlayVoice::VoiceID' has a wrong offset!");
static_assert(offsetof(SoundSubsystem_PlayVoice, ReturnValue) == 0x000010, "Member 'SoundSubsystem_PlayVoice::ReturnValue' has a wrong offset!");

// Function Zion.SoundSubsystem.PlayVoiceFromText
// 0x0020 (0x0020 - 0x0000)
struct SoundSubsystem_PlayVoiceFromText final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 Speaker;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_PlayVoiceFromText) == 0x000008, "Wrong alignment on SoundSubsystem_PlayVoiceFromText");
static_assert(sizeof(SoundSubsystem_PlayVoiceFromText) == 0x000020, "Wrong size on SoundSubsystem_PlayVoiceFromText");
static_assert(offsetof(SoundSubsystem_PlayVoiceFromText, Text) == 0x000000, "Member 'SoundSubsystem_PlayVoiceFromText::Text' has a wrong offset!");
static_assert(offsetof(SoundSubsystem_PlayVoiceFromText, Speaker) == 0x000010, "Member 'SoundSubsystem_PlayVoiceFromText::Speaker' has a wrong offset!");
static_assert(offsetof(SoundSubsystem_PlayVoiceFromText, ReturnValue) == 0x000018, "Member 'SoundSubsystem_PlayVoiceFromText::ReturnValue' has a wrong offset!");

// Function Zion.SoundSubsystem.PlayVoiceOnActor
// 0x0020 (0x0020 - 0x0000)
struct SoundSubsystem_PlayVoiceOnActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VoiceID;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_PlayVoiceOnActor) == 0x000008, "Wrong alignment on SoundSubsystem_PlayVoiceOnActor");
static_assert(sizeof(SoundSubsystem_PlayVoiceOnActor) == 0x000020, "Wrong size on SoundSubsystem_PlayVoiceOnActor");
static_assert(offsetof(SoundSubsystem_PlayVoiceOnActor, Actor) == 0x000000, "Member 'SoundSubsystem_PlayVoiceOnActor::Actor' has a wrong offset!");
static_assert(offsetof(SoundSubsystem_PlayVoiceOnActor, VoiceID) == 0x000008, "Member 'SoundSubsystem_PlayVoiceOnActor::VoiceID' has a wrong offset!");
static_assert(offsetof(SoundSubsystem_PlayVoiceOnActor, ReturnValue) == 0x000018, "Member 'SoundSubsystem_PlayVoiceOnActor::ReturnValue' has a wrong offset!");

// Function Zion.SoundSubsystem.ResumeFamily
// 0x0001 (0x0001 - 0x0000)
struct SoundSubsystem_ResumeFamily final
{
public:
	ESoundFamily                                  SoundFamily;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_ResumeFamily) == 0x000001, "Wrong alignment on SoundSubsystem_ResumeFamily");
static_assert(sizeof(SoundSubsystem_ResumeFamily) == 0x000001, "Wrong size on SoundSubsystem_ResumeFamily");
static_assert(offsetof(SoundSubsystem_ResumeFamily, SoundFamily) == 0x000000, "Member 'SoundSubsystem_ResumeFamily::SoundFamily' has a wrong offset!");

// Function Zion.SoundSubsystem.SetParameter
// 0x000C (0x000C - 0x0000)
struct SoundSubsystem_SetParameter final
{
public:
	class FName                                   Parameter;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_SetParameter) == 0x000004, "Wrong alignment on SoundSubsystem_SetParameter");
static_assert(sizeof(SoundSubsystem_SetParameter) == 0x00000C, "Wrong size on SoundSubsystem_SetParameter");
static_assert(offsetof(SoundSubsystem_SetParameter, Parameter) == 0x000000, "Member 'SoundSubsystem_SetParameter::Parameter' has a wrong offset!");
static_assert(offsetof(SoundSubsystem_SetParameter, Value) == 0x000008, "Member 'SoundSubsystem_SetParameter::Value' has a wrong offset!");

// Function Zion.SoundSubsystem.SetPauseGameFamilies
// 0x0001 (0x0001 - 0x0000)
struct SoundSubsystem_SetPauseGameFamilies final
{
public:
	bool                                          bPause;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_SetPauseGameFamilies) == 0x000001, "Wrong alignment on SoundSubsystem_SetPauseGameFamilies");
static_assert(sizeof(SoundSubsystem_SetPauseGameFamilies) == 0x000001, "Wrong size on SoundSubsystem_SetPauseGameFamilies");
static_assert(offsetof(SoundSubsystem_SetPauseGameFamilies, bPause) == 0x000000, "Member 'SoundSubsystem_SetPauseGameFamilies::bPause' has a wrong offset!");

// Function Zion.SoundSubsystem.SetVoiceLanguage
// 0x0010 (0x0010 - 0x0000)
struct SoundSubsystem_SetVoiceLanguage final
{
public:
	class FString                                 Locale;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_SetVoiceLanguage) == 0x000008, "Wrong alignment on SoundSubsystem_SetVoiceLanguage");
static_assert(sizeof(SoundSubsystem_SetVoiceLanguage) == 0x000010, "Wrong size on SoundSubsystem_SetVoiceLanguage");
static_assert(offsetof(SoundSubsystem_SetVoiceLanguage, Locale) == 0x000000, "Member 'SoundSubsystem_SetVoiceLanguage::Locale' has a wrong offset!");

// Function Zion.SoundSubsystem.SetVolume
// 0x0008 (0x0008 - 0x0000)
struct SoundSubsystem_SetVolume final
{
public:
	ESoundFamily                                  SoundFamily;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NewVolume;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_SetVolume) == 0x000004, "Wrong alignment on SoundSubsystem_SetVolume");
static_assert(sizeof(SoundSubsystem_SetVolume) == 0x000008, "Wrong size on SoundSubsystem_SetVolume");
static_assert(offsetof(SoundSubsystem_SetVolume, SoundFamily) == 0x000000, "Member 'SoundSubsystem_SetVolume::SoundFamily' has a wrong offset!");
static_assert(offsetof(SoundSubsystem_SetVolume, NewVolume) == 0x000004, "Member 'SoundSubsystem_SetVolume::NewVolume' has a wrong offset!");

// Function Zion.SoundSubsystem.StopBGM
// 0x0004 (0x0004 - 0x0000)
struct SoundSubsystem_StopBGM final
{
public:
	float                                         FadeOutTime;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_StopBGM) == 0x000004, "Wrong alignment on SoundSubsystem_StopBGM");
static_assert(sizeof(SoundSubsystem_StopBGM) == 0x000004, "Wrong size on SoundSubsystem_StopBGM");
static_assert(offsetof(SoundSubsystem_StopBGM, FadeOutTime) == 0x000000, "Member 'SoundSubsystem_StopBGM::FadeOutTime' has a wrong offset!");

// Function Zion.SoundSubsystem.StopSoundEventInstance
// 0x0008 (0x0008 - 0x0000)
struct SoundSubsystem_StopSoundEventInstance final
{
public:
	struct FFMODEventInstance                     SoundInstance;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_StopSoundEventInstance) == 0x000008, "Wrong alignment on SoundSubsystem_StopSoundEventInstance");
static_assert(sizeof(SoundSubsystem_StopSoundEventInstance) == 0x000008, "Wrong size on SoundSubsystem_StopSoundEventInstance");
static_assert(offsetof(SoundSubsystem_StopSoundEventInstance, SoundInstance) == 0x000000, "Member 'SoundSubsystem_StopSoundEventInstance::SoundInstance' has a wrong offset!");

// Function Zion.SoundSubsystem.GetCurrentAmbience
// 0x0008 (0x0008 - 0x0000)
struct SoundSubsystem_GetCurrentAmbience final
{
public:
	class UFMODEvent*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_GetCurrentAmbience) == 0x000008, "Wrong alignment on SoundSubsystem_GetCurrentAmbience");
static_assert(sizeof(SoundSubsystem_GetCurrentAmbience) == 0x000008, "Wrong size on SoundSubsystem_GetCurrentAmbience");
static_assert(offsetof(SoundSubsystem_GetCurrentAmbience, ReturnValue) == 0x000000, "Member 'SoundSubsystem_GetCurrentAmbience::ReturnValue' has a wrong offset!");

// Function Zion.SoundSubsystem.GetCurrentBGM
// 0x0008 (0x0008 - 0x0000)
struct SoundSubsystem_GetCurrentBGM final
{
public:
	class UFMODEvent*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_GetCurrentBGM) == 0x000008, "Wrong alignment on SoundSubsystem_GetCurrentBGM");
static_assert(sizeof(SoundSubsystem_GetCurrentBGM) == 0x000008, "Wrong size on SoundSubsystem_GetCurrentBGM");
static_assert(offsetof(SoundSubsystem_GetCurrentBGM, ReturnValue) == 0x000000, "Member 'SoundSubsystem_GetCurrentBGM::ReturnValue' has a wrong offset!");

// Function Zion.SoundSubsystem.GetVoiceLanguage
// 0x0010 (0x0010 - 0x0000)
struct SoundSubsystem_GetVoiceLanguage final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_GetVoiceLanguage) == 0x000008, "Wrong alignment on SoundSubsystem_GetVoiceLanguage");
static_assert(sizeof(SoundSubsystem_GetVoiceLanguage) == 0x000010, "Wrong size on SoundSubsystem_GetVoiceLanguage");
static_assert(offsetof(SoundSubsystem_GetVoiceLanguage, ReturnValue) == 0x000000, "Member 'SoundSubsystem_GetVoiceLanguage::ReturnValue' has a wrong offset!");

// Function Zion.SoundSubsystem.GetVolume
// 0x0008 (0x0008 - 0x0000)
struct SoundSubsystem_GetVolume final
{
public:
	ESoundFamily                                  SoundFamily;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundSubsystem_GetVolume) == 0x000004, "Wrong alignment on SoundSubsystem_GetVolume");
static_assert(sizeof(SoundSubsystem_GetVolume) == 0x000008, "Wrong size on SoundSubsystem_GetVolume");
static_assert(offsetof(SoundSubsystem_GetVolume, SoundFamily) == 0x000000, "Member 'SoundSubsystem_GetVolume::SoundFamily' has a wrong offset!");
static_assert(offsetof(SoundSubsystem_GetVolume, ReturnValue) == 0x000004, "Member 'SoundSubsystem_GetVolume::ReturnValue' has a wrong offset!");

// Function Zion.SpawnerComponent.OnEntityDestroyed
// 0x0008 (0x0008 - 0x0000)
struct SpawnerComponent_OnEntityDestroyed final
{
public:
	class AActor*                                 EntityActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerComponent_OnEntityDestroyed) == 0x000008, "Wrong alignment on SpawnerComponent_OnEntityDestroyed");
static_assert(sizeof(SpawnerComponent_OnEntityDestroyed) == 0x000008, "Wrong size on SpawnerComponent_OnEntityDestroyed");
static_assert(offsetof(SpawnerComponent_OnEntityDestroyed, EntityActor) == 0x000000, "Member 'SpawnerComponent_OnEntityDestroyed::EntityActor' has a wrong offset!");

// Function Zion.SpawnerComponent.Spawn
// 0x0090 (0x0090 - 0x0000)
struct SpawnerComponent_Spawn final
{
public:
	struct FSpawnData                             SpawnData;                                         // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerComponent_Spawn) == 0x000010, "Wrong alignment on SpawnerComponent_Spawn");
static_assert(sizeof(SpawnerComponent_Spawn) == 0x000090, "Wrong size on SpawnerComponent_Spawn");
static_assert(offsetof(SpawnerComponent_Spawn, SpawnData) == 0x000000, "Member 'SpawnerComponent_Spawn::SpawnData' has a wrong offset!");

// Function Zion.SpawnerComponent.GetSpawnedEntityCount
// 0x0004 (0x0004 - 0x0000)
struct SpawnerComponent_GetSpawnedEntityCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerComponent_GetSpawnedEntityCount) == 0x000004, "Wrong alignment on SpawnerComponent_GetSpawnedEntityCount");
static_assert(sizeof(SpawnerComponent_GetSpawnedEntityCount) == 0x000004, "Wrong size on SpawnerComponent_GetSpawnedEntityCount");
static_assert(offsetof(SpawnerComponent_GetSpawnedEntityCount, ReturnValue) == 0x000000, "Member 'SpawnerComponent_GetSpawnedEntityCount::ReturnValue' has a wrong offset!");

// Function Zion.SpineActor.Activate
// 0x0010 (0x0010 - 0x0000)
struct SpineActor_Activate final
{
public:
	TArray<struct FSpineSimpleAnimationDefinition> AnimationDefinitions;                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineActor_Activate) == 0x000008, "Wrong alignment on SpineActor_Activate");
static_assert(sizeof(SpineActor_Activate) == 0x000010, "Wrong size on SpineActor_Activate");
static_assert(offsetof(SpineActor_Activate, AnimationDefinitions) == 0x000000, "Member 'SpineActor_Activate::AnimationDefinitions' has a wrong offset!");

// Function Zion.SpineAdditiveAccessoryComponent.OnAnimationStart
// 0x0008 (0x0008 - 0x0000)
struct SpineAdditiveAccessoryComponent_OnAnimationStart final
{
public:
	class UTrackEntry*                            Entry;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAdditiveAccessoryComponent_OnAnimationStart) == 0x000008, "Wrong alignment on SpineAdditiveAccessoryComponent_OnAnimationStart");
static_assert(sizeof(SpineAdditiveAccessoryComponent_OnAnimationStart) == 0x000008, "Wrong size on SpineAdditiveAccessoryComponent_OnAnimationStart");
static_assert(offsetof(SpineAdditiveAccessoryComponent_OnAnimationStart, Entry) == 0x000000, "Member 'SpineAdditiveAccessoryComponent_OnAnimationStart::Entry' has a wrong offset!");

// Function Zion.SpineAdditiveComponent.OnAnimationStart
// 0x0008 (0x0008 - 0x0000)
struct SpineAdditiveComponent_OnAnimationStart final
{
public:
	class UTrackEntry*                            TrackEntry;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAdditiveComponent_OnAnimationStart) == 0x000008, "Wrong alignment on SpineAdditiveComponent_OnAnimationStart");
static_assert(sizeof(SpineAdditiveComponent_OnAnimationStart) == 0x000008, "Wrong size on SpineAdditiveComponent_OnAnimationStart");
static_assert(offsetof(SpineAdditiveComponent_OnAnimationStart, TrackEntry) == 0x000000, "Member 'SpineAdditiveComponent_OnAnimationStart::TrackEntry' has a wrong offset!");

// Function Zion.SpineAnimationTransitionCondition.Evaluate
// 0x0030 (0x0030 - 0x0000)
struct SpineAnimationTransitionCondition_Evaluate final
{
public:
	const class USpineAnimatorComponent*          Animator;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrAnimationName;                                 // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NextAnimationName;                                 // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SpineAnimationTransitionCondition_Evaluate) == 0x000008, "Wrong alignment on SpineAnimationTransitionCondition_Evaluate");
static_assert(sizeof(SpineAnimationTransitionCondition_Evaluate) == 0x000030, "Wrong size on SpineAnimationTransitionCondition_Evaluate");
static_assert(offsetof(SpineAnimationTransitionCondition_Evaluate, Animator) == 0x000000, "Member 'SpineAnimationTransitionCondition_Evaluate::Animator' has a wrong offset!");
static_assert(offsetof(SpineAnimationTransitionCondition_Evaluate, CurrAnimationName) == 0x000008, "Member 'SpineAnimationTransitionCondition_Evaluate::CurrAnimationName' has a wrong offset!");
static_assert(offsetof(SpineAnimationTransitionCondition_Evaluate, NextAnimationName) == 0x000018, "Member 'SpineAnimationTransitionCondition_Evaluate::NextAnimationName' has a wrong offset!");
static_assert(offsetof(SpineAnimationTransitionCondition_Evaluate, ReturnValue) == 0x000028, "Member 'SpineAnimationTransitionCondition_Evaluate::ReturnValue' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.OnAnimationComplete
// 0x0008 (0x0008 - 0x0000)
struct SpineAnimatorComponent_OnAnimationComplete final
{
public:
	class UTrackEntry*                            TrackEntry;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_OnAnimationComplete) == 0x000008, "Wrong alignment on SpineAnimatorComponent_OnAnimationComplete");
static_assert(sizeof(SpineAnimatorComponent_OnAnimationComplete) == 0x000008, "Wrong size on SpineAnimatorComponent_OnAnimationComplete");
static_assert(offsetof(SpineAnimatorComponent_OnAnimationComplete, TrackEntry) == 0x000000, "Member 'SpineAnimatorComponent_OnAnimationComplete::TrackEntry' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.OnAnimationInterrupt
// 0x0008 (0x0008 - 0x0000)
struct SpineAnimatorComponent_OnAnimationInterrupt final
{
public:
	class UTrackEntry*                            TrackEntry;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_OnAnimationInterrupt) == 0x000008, "Wrong alignment on SpineAnimatorComponent_OnAnimationInterrupt");
static_assert(sizeof(SpineAnimatorComponent_OnAnimationInterrupt) == 0x000008, "Wrong size on SpineAnimatorComponent_OnAnimationInterrupt");
static_assert(offsetof(SpineAnimatorComponent_OnAnimationInterrupt, TrackEntry) == 0x000000, "Member 'SpineAnimatorComponent_OnAnimationInterrupt::TrackEntry' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.OnAnyAnimationComplete
// 0x0008 (0x0008 - 0x0000)
struct SpineAnimatorComponent_OnAnyAnimationComplete final
{
public:
	class UTrackEntry*                            TrackEntry;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_OnAnyAnimationComplete) == 0x000008, "Wrong alignment on SpineAnimatorComponent_OnAnyAnimationComplete");
static_assert(sizeof(SpineAnimatorComponent_OnAnyAnimationComplete) == 0x000008, "Wrong size on SpineAnimatorComponent_OnAnyAnimationComplete");
static_assert(offsetof(SpineAnimatorComponent_OnAnyAnimationComplete, TrackEntry) == 0x000000, "Member 'SpineAnimatorComponent_OnAnyAnimationComplete::TrackEntry' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.OnAnyAnimationInterrupt
// 0x0008 (0x0008 - 0x0000)
struct SpineAnimatorComponent_OnAnyAnimationInterrupt final
{
public:
	class UTrackEntry*                            TrackEntry;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_OnAnyAnimationInterrupt) == 0x000008, "Wrong alignment on SpineAnimatorComponent_OnAnyAnimationInterrupt");
static_assert(sizeof(SpineAnimatorComponent_OnAnyAnimationInterrupt) == 0x000008, "Wrong size on SpineAnimatorComponent_OnAnyAnimationInterrupt");
static_assert(offsetof(SpineAnimatorComponent_OnAnyAnimationInterrupt, TrackEntry) == 0x000000, "Member 'SpineAnimatorComponent_OnAnyAnimationInterrupt::TrackEntry' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.OnLayerComplete
// 0x0008 (0x0008 - 0x0000)
struct SpineAnimatorComponent_OnLayerComplete final
{
public:
	class UTrackEntry*                            TrackEntry;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_OnLayerComplete) == 0x000008, "Wrong alignment on SpineAnimatorComponent_OnLayerComplete");
static_assert(sizeof(SpineAnimatorComponent_OnLayerComplete) == 0x000008, "Wrong size on SpineAnimatorComponent_OnLayerComplete");
static_assert(offsetof(SpineAnimatorComponent_OnLayerComplete, TrackEntry) == 0x000000, "Member 'SpineAnimatorComponent_OnLayerComplete::TrackEntry' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.OnLayerInterrupt
// 0x0008 (0x0008 - 0x0000)
struct SpineAnimatorComponent_OnLayerInterrupt final
{
public:
	class UTrackEntry*                            TrackEntry;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_OnLayerInterrupt) == 0x000008, "Wrong alignment on SpineAnimatorComponent_OnLayerInterrupt");
static_assert(sizeof(SpineAnimatorComponent_OnLayerInterrupt) == 0x000008, "Wrong size on SpineAnimatorComponent_OnLayerInterrupt");
static_assert(offsetof(SpineAnimatorComponent_OnLayerInterrupt, TrackEntry) == 0x000000, "Member 'SpineAnimatorComponent_OnLayerInterrupt::TrackEntry' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.PlayActionAnimation
// 0x0068 (0x0068 - 0x0000)
struct SpineAnimatorComponent_PlayActionAnimation final
{
public:
	struct FSpineAnimationDefinition              AnimationDefinition;                               // 0x0000(0x0068)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_PlayActionAnimation) == 0x000008, "Wrong alignment on SpineAnimatorComponent_PlayActionAnimation");
static_assert(sizeof(SpineAnimatorComponent_PlayActionAnimation) == 0x000068, "Wrong size on SpineAnimatorComponent_PlayActionAnimation");
static_assert(offsetof(SpineAnimatorComponent_PlayActionAnimation, AnimationDefinition) == 0x000000, "Member 'SpineAnimatorComponent_PlayActionAnimation::AnimationDefinition' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.PlayActionAnimations
// 0x0010 (0x0010 - 0x0000)
struct SpineAnimatorComponent_PlayActionAnimations final
{
public:
	TArray<struct FSpineAnimationDefinition>      AnimationDefinitions;                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_PlayActionAnimations) == 0x000008, "Wrong alignment on SpineAnimatorComponent_PlayActionAnimations");
static_assert(sizeof(SpineAnimatorComponent_PlayActionAnimations) == 0x000010, "Wrong size on SpineAnimatorComponent_PlayActionAnimations");
static_assert(offsetof(SpineAnimatorComponent_PlayActionAnimations, AnimationDefinitions) == 0x000000, "Member 'SpineAnimatorComponent_PlayActionAnimations::AnimationDefinitions' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.PlayActionAnimationsWithDelegate
// 0x0020 (0x0020 - 0x0000)
struct SpineAnimatorComponent_PlayActionAnimationsWithDelegate final
{
public:
	TArray<struct FSpineAnimationDefinition>      AnimationDefinitions;                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnLayerEnd;                                        // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_PlayActionAnimationsWithDelegate) == 0x000008, "Wrong alignment on SpineAnimatorComponent_PlayActionAnimationsWithDelegate");
static_assert(sizeof(SpineAnimatorComponent_PlayActionAnimationsWithDelegate) == 0x000020, "Wrong size on SpineAnimatorComponent_PlayActionAnimationsWithDelegate");
static_assert(offsetof(SpineAnimatorComponent_PlayActionAnimationsWithDelegate, AnimationDefinitions) == 0x000000, "Member 'SpineAnimatorComponent_PlayActionAnimationsWithDelegate::AnimationDefinitions' has a wrong offset!");
static_assert(offsetof(SpineAnimatorComponent_PlayActionAnimationsWithDelegate, OnLayerEnd) == 0x000010, "Member 'SpineAnimatorComponent_PlayActionAnimationsWithDelegate::OnLayerEnd' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.PlayActionAnimationWithDelegate
// 0x0078 (0x0078 - 0x0000)
struct SpineAnimatorComponent_PlayActionAnimationWithDelegate final
{
public:
	struct FSpineAnimationDefinition              AnimationDefinition;                               // 0x0000(0x0068)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnLayerEnd;                                        // 0x0068(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_PlayActionAnimationWithDelegate) == 0x000008, "Wrong alignment on SpineAnimatorComponent_PlayActionAnimationWithDelegate");
static_assert(sizeof(SpineAnimatorComponent_PlayActionAnimationWithDelegate) == 0x000078, "Wrong size on SpineAnimatorComponent_PlayActionAnimationWithDelegate");
static_assert(offsetof(SpineAnimatorComponent_PlayActionAnimationWithDelegate, AnimationDefinition) == 0x000000, "Member 'SpineAnimatorComponent_PlayActionAnimationWithDelegate::AnimationDefinition' has a wrong offset!");
static_assert(offsetof(SpineAnimatorComponent_PlayActionAnimationWithDelegate, OnLayerEnd) == 0x000068, "Member 'SpineAnimatorComponent_PlayActionAnimationWithDelegate::OnLayerEnd' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.PlayAnimations
// 0x0018 (0x0018 - 0x0000)
struct SpineAnimatorComponent_PlayAnimations final
{
public:
	ESpineAnimatorLayer                           AnimatorLayer;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      AnimationDefinitions;                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_PlayAnimations) == 0x000008, "Wrong alignment on SpineAnimatorComponent_PlayAnimations");
static_assert(sizeof(SpineAnimatorComponent_PlayAnimations) == 0x000018, "Wrong size on SpineAnimatorComponent_PlayAnimations");
static_assert(offsetof(SpineAnimatorComponent_PlayAnimations, AnimatorLayer) == 0x000000, "Member 'SpineAnimatorComponent_PlayAnimations::AnimatorLayer' has a wrong offset!");
static_assert(offsetof(SpineAnimatorComponent_PlayAnimations, AnimationDefinitions) == 0x000008, "Member 'SpineAnimatorComponent_PlayAnimations::AnimationDefinitions' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.PlayAnimationsWithDelegate
// 0x0028 (0x0028 - 0x0000)
struct SpineAnimatorComponent_PlayAnimationsWithDelegate final
{
public:
	ESpineAnimatorLayer                           AnimatorLayer;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpineAnimationDefinition>      AnimationDefinitions;                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnLayerEnd;                                        // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_PlayAnimationsWithDelegate) == 0x000008, "Wrong alignment on SpineAnimatorComponent_PlayAnimationsWithDelegate");
static_assert(sizeof(SpineAnimatorComponent_PlayAnimationsWithDelegate) == 0x000028, "Wrong size on SpineAnimatorComponent_PlayAnimationsWithDelegate");
static_assert(offsetof(SpineAnimatorComponent_PlayAnimationsWithDelegate, AnimatorLayer) == 0x000000, "Member 'SpineAnimatorComponent_PlayAnimationsWithDelegate::AnimatorLayer' has a wrong offset!");
static_assert(offsetof(SpineAnimatorComponent_PlayAnimationsWithDelegate, AnimationDefinitions) == 0x000008, "Member 'SpineAnimatorComponent_PlayAnimationsWithDelegate::AnimationDefinitions' has a wrong offset!");
static_assert(offsetof(SpineAnimatorComponent_PlayAnimationsWithDelegate, OnLayerEnd) == 0x000018, "Member 'SpineAnimatorComponent_PlayAnimationsWithDelegate::OnLayerEnd' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.PlayTurnAnimations
// 0x0010 (0x0010 - 0x0000)
struct SpineAnimatorComponent_PlayTurnAnimations final
{
public:
	TArray<struct FSpineAnimationDefinition>      AnimationDefinitions;                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_PlayTurnAnimations) == 0x000008, "Wrong alignment on SpineAnimatorComponent_PlayTurnAnimations");
static_assert(sizeof(SpineAnimatorComponent_PlayTurnAnimations) == 0x000010, "Wrong size on SpineAnimatorComponent_PlayTurnAnimations");
static_assert(offsetof(SpineAnimatorComponent_PlayTurnAnimations, AnimationDefinitions) == 0x000000, "Member 'SpineAnimatorComponent_PlayTurnAnimations::AnimationDefinitions' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.StopAnimationAtLayer
// 0x0001 (0x0001 - 0x0000)
struct SpineAnimatorComponent_StopAnimationAtLayer final
{
public:
	ESpineAnimatorLayer                           Layer;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_StopAnimationAtLayer) == 0x000001, "Wrong alignment on SpineAnimatorComponent_StopAnimationAtLayer");
static_assert(sizeof(SpineAnimatorComponent_StopAnimationAtLayer) == 0x000001, "Wrong size on SpineAnimatorComponent_StopAnimationAtLayer");
static_assert(offsetof(SpineAnimatorComponent_StopAnimationAtLayer, Layer) == 0x000000, "Member 'SpineAnimatorComponent_StopAnimationAtLayer::Layer' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.GetCurrentAnimationName
// 0x0010 (0x0010 - 0x0000)
struct SpineAnimatorComponent_GetCurrentAnimationName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_GetCurrentAnimationName) == 0x000008, "Wrong alignment on SpineAnimatorComponent_GetCurrentAnimationName");
static_assert(sizeof(SpineAnimatorComponent_GetCurrentAnimationName) == 0x000010, "Wrong size on SpineAnimatorComponent_GetCurrentAnimationName");
static_assert(offsetof(SpineAnimatorComponent_GetCurrentAnimationName, ReturnValue) == 0x000000, "Member 'SpineAnimatorComponent_GetCurrentAnimationName::ReturnValue' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.GetCurrentAnimationPlayTime
// 0x0004 (0x0004 - 0x0000)
struct SpineAnimatorComponent_GetCurrentAnimationPlayTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_GetCurrentAnimationPlayTime) == 0x000004, "Wrong alignment on SpineAnimatorComponent_GetCurrentAnimationPlayTime");
static_assert(sizeof(SpineAnimatorComponent_GetCurrentAnimationPlayTime) == 0x000004, "Wrong size on SpineAnimatorComponent_GetCurrentAnimationPlayTime");
static_assert(offsetof(SpineAnimatorComponent_GetCurrentAnimationPlayTime, ReturnValue) == 0x000000, "Member 'SpineAnimatorComponent_GetCurrentAnimationPlayTime::ReturnValue' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.GetCurrentLayer
// 0x0001 (0x0001 - 0x0000)
struct SpineAnimatorComponent_GetCurrentLayer final
{
public:
	ESpineAnimatorLayer                           ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_GetCurrentLayer) == 0x000001, "Wrong alignment on SpineAnimatorComponent_GetCurrentLayer");
static_assert(sizeof(SpineAnimatorComponent_GetCurrentLayer) == 0x000001, "Wrong size on SpineAnimatorComponent_GetCurrentLayer");
static_assert(offsetof(SpineAnimatorComponent_GetCurrentLayer, ReturnValue) == 0x000000, "Member 'SpineAnimatorComponent_GetCurrentLayer::ReturnValue' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.GetCurrentTrackEntry
// 0x0008 (0x0008 - 0x0000)
struct SpineAnimatorComponent_GetCurrentTrackEntry final
{
public:
	class UTrackEntry*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_GetCurrentTrackEntry) == 0x000008, "Wrong alignment on SpineAnimatorComponent_GetCurrentTrackEntry");
static_assert(sizeof(SpineAnimatorComponent_GetCurrentTrackEntry) == 0x000008, "Wrong size on SpineAnimatorComponent_GetCurrentTrackEntry");
static_assert(offsetof(SpineAnimatorComponent_GetCurrentTrackEntry, ReturnValue) == 0x000000, "Member 'SpineAnimatorComponent_GetCurrentTrackEntry::ReturnValue' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.GetHistoryDataAtIndex
// 0x0028 (0x0028 - 0x0000)
struct SpineAnimatorComponent_GetHistoryDataAtIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineAnimatorHistoryData              out_Result;                                        // 0x0008(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SpineAnimatorComponent_GetHistoryDataAtIndex) == 0x000008, "Wrong alignment on SpineAnimatorComponent_GetHistoryDataAtIndex");
static_assert(sizeof(SpineAnimatorComponent_GetHistoryDataAtIndex) == 0x000028, "Wrong size on SpineAnimatorComponent_GetHistoryDataAtIndex");
static_assert(offsetof(SpineAnimatorComponent_GetHistoryDataAtIndex, Index_0) == 0x000000, "Member 'SpineAnimatorComponent_GetHistoryDataAtIndex::Index_0' has a wrong offset!");
static_assert(offsetof(SpineAnimatorComponent_GetHistoryDataAtIndex, out_Result) == 0x000008, "Member 'SpineAnimatorComponent_GetHistoryDataAtIndex::out_Result' has a wrong offset!");
static_assert(offsetof(SpineAnimatorComponent_GetHistoryDataAtIndex, ReturnValue) == 0x000020, "Member 'SpineAnimatorComponent_GetHistoryDataAtIndex::ReturnValue' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.GetLastVelocity
// 0x0018 (0x0018 - 0x0000)
struct SpineAnimatorComponent_GetLastVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_GetLastVelocity) == 0x000008, "Wrong alignment on SpineAnimatorComponent_GetLastVelocity");
static_assert(sizeof(SpineAnimatorComponent_GetLastVelocity) == 0x000018, "Wrong size on SpineAnimatorComponent_GetLastVelocity");
static_assert(offsetof(SpineAnimatorComponent_GetLastVelocity, ReturnValue) == 0x000000, "Member 'SpineAnimatorComponent_GetLastVelocity::ReturnValue' has a wrong offset!");

// Function Zion.SpineAnimatorComponent.IsPlayingAnimationOnLayer
// 0x0002 (0x0002 - 0x0000)
struct SpineAnimatorComponent_IsPlayingAnimationOnLayer final
{
public:
	ESpineAnimatorLayer                           Layer;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineAnimatorComponent_IsPlayingAnimationOnLayer) == 0x000001, "Wrong alignment on SpineAnimatorComponent_IsPlayingAnimationOnLayer");
static_assert(sizeof(SpineAnimatorComponent_IsPlayingAnimationOnLayer) == 0x000002, "Wrong size on SpineAnimatorComponent_IsPlayingAnimationOnLayer");
static_assert(offsetof(SpineAnimatorComponent_IsPlayingAnimationOnLayer, Layer) == 0x000000, "Member 'SpineAnimatorComponent_IsPlayingAnimationOnLayer::Layer' has a wrong offset!");
static_assert(offsetof(SpineAnimatorComponent_IsPlayingAnimationOnLayer, ReturnValue) == 0x000001, "Member 'SpineAnimatorComponent_IsPlayingAnimationOnLayer::ReturnValue' has a wrong offset!");

// Function Zion.SpineColorComponent.ClearColor
// 0x0004 (0x0004 - 0x0000)
struct SpineColorComponent_ClearColor final
{
public:
	float                                         LerpDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineColorComponent_ClearColor) == 0x000004, "Wrong alignment on SpineColorComponent_ClearColor");
static_assert(sizeof(SpineColorComponent_ClearColor) == 0x000004, "Wrong size on SpineColorComponent_ClearColor");
static_assert(offsetof(SpineColorComponent_ClearColor, LerpDuration) == 0x000000, "Member 'SpineColorComponent_ClearColor::LerpDuration' has a wrong offset!");

// Function Zion.SpineColorComponent.FlashColor
// 0x0018 (0x0018 - 0x0000)
struct SpineColorComponent_FlashColor final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlashDuration;                                     // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineColorComponent_FlashColor) == 0x000004, "Wrong alignment on SpineColorComponent_FlashColor");
static_assert(sizeof(SpineColorComponent_FlashColor) == 0x000018, "Wrong size on SpineColorComponent_FlashColor");
static_assert(offsetof(SpineColorComponent_FlashColor, Color) == 0x000000, "Member 'SpineColorComponent_FlashColor::Color' has a wrong offset!");
static_assert(offsetof(SpineColorComponent_FlashColor, Alpha) == 0x000010, "Member 'SpineColorComponent_FlashColor::Alpha' has a wrong offset!");
static_assert(offsetof(SpineColorComponent_FlashColor, FlashDuration) == 0x000014, "Member 'SpineColorComponent_FlashColor::FlashDuration' has a wrong offset!");

// Function Zion.SpineColorComponent.OnGotAbilityApplied
// 0x02E0 (0x02E0 - 0x0000)
struct SpineColorComponent_OnGotAbilityApplied final
{
public:
	class AAbility*                               Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitData                               HitData;                                           // 0x0010(0x02D0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineColorComponent_OnGotAbilityApplied) == 0x000010, "Wrong alignment on SpineColorComponent_OnGotAbilityApplied");
static_assert(sizeof(SpineColorComponent_OnGotAbilityApplied) == 0x0002E0, "Wrong size on SpineColorComponent_OnGotAbilityApplied");
static_assert(offsetof(SpineColorComponent_OnGotAbilityApplied, Ability) == 0x000000, "Member 'SpineColorComponent_OnGotAbilityApplied::Ability' has a wrong offset!");
static_assert(offsetof(SpineColorComponent_OnGotAbilityApplied, Source) == 0x000008, "Member 'SpineColorComponent_OnGotAbilityApplied::Source' has a wrong offset!");
static_assert(offsetof(SpineColorComponent_OnGotAbilityApplied, HitData) == 0x000010, "Member 'SpineColorComponent_OnGotAbilityApplied::HitData' has a wrong offset!");

// Function Zion.SpineColorComponent.SetColor
// 0x0018 (0x0018 - 0x0000)
struct SpineColorComponent_SetColor final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpDuration;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineColorComponent_SetColor) == 0x000004, "Wrong alignment on SpineColorComponent_SetColor");
static_assert(sizeof(SpineColorComponent_SetColor) == 0x000018, "Wrong size on SpineColorComponent_SetColor");
static_assert(offsetof(SpineColorComponent_SetColor, Color) == 0x000000, "Member 'SpineColorComponent_SetColor::Color' has a wrong offset!");
static_assert(offsetof(SpineColorComponent_SetColor, Alpha) == 0x000010, "Member 'SpineColorComponent_SetColor::Alpha' has a wrong offset!");
static_assert(offsetof(SpineColorComponent_SetColor, LerpDuration) == 0x000014, "Member 'SpineColorComponent_SetColor::LerpDuration' has a wrong offset!");

// Function Zion.SpineHighlightComponent.OnAnimationStart
// 0x0008 (0x0008 - 0x0000)
struct SpineHighlightComponent_OnAnimationStart final
{
public:
	class UTrackEntry*                            Entry;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpineHighlightComponent_OnAnimationStart) == 0x000008, "Wrong alignment on SpineHighlightComponent_OnAnimationStart");
static_assert(sizeof(SpineHighlightComponent_OnAnimationStart) == 0x000008, "Wrong size on SpineHighlightComponent_OnAnimationStart");
static_assert(offsetof(SpineHighlightComponent_OnAnimationStart, Entry) == 0x000000, "Member 'SpineHighlightComponent_OnAnimationStart::Entry' has a wrong offset!");

// Function Zion.UserWidgetWorldSpaceText_Talk.OnTalk
// 0x0028 (0x0028 - 0x0000)
struct UserWidgetWorldSpaceText_Talk_OnTalk final
{
public:
	struct FTalkParameters                        TalkParameters;                                    // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetWorldSpaceText_Talk_OnTalk) == 0x000008, "Wrong alignment on UserWidgetWorldSpaceText_Talk_OnTalk");
static_assert(sizeof(UserWidgetWorldSpaceText_Talk_OnTalk) == 0x000028, "Wrong size on UserWidgetWorldSpaceText_Talk_OnTalk");
static_assert(offsetof(UserWidgetWorldSpaceText_Talk_OnTalk, TalkParameters) == 0x000000, "Member 'UserWidgetWorldSpaceText_Talk_OnTalk::TalkParameters' has a wrong offset!");

// Function Zion.UserWidgetWorldSpaceText_Talk.SetSpeakerName
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetWorldSpaceText_Talk_SetSpeakerName final
{
public:
	class FText                                   SpeakerName;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetWorldSpaceText_Talk_SetSpeakerName) == 0x000008, "Wrong alignment on UserWidgetWorldSpaceText_Talk_SetSpeakerName");
static_assert(sizeof(UserWidgetWorldSpaceText_Talk_SetSpeakerName) == 0x000010, "Wrong size on UserWidgetWorldSpaceText_Talk_SetSpeakerName");
static_assert(offsetof(UserWidgetWorldSpaceText_Talk_SetSpeakerName, SpeakerName) == 0x000000, "Member 'UserWidgetWorldSpaceText_Talk_SetSpeakerName::SpeakerName' has a wrong offset!");

// Function Zion.SpiritCooldown.OnCommandFinishCooldown
// 0x0010 (0x0010 - 0x0000)
struct SpiritCooldown_OnCommandFinishCooldown final
{
public:
	const class UCommandSet*                      CommandSetFinished;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReset;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SpiritCooldown_OnCommandFinishCooldown) == 0x000008, "Wrong alignment on SpiritCooldown_OnCommandFinishCooldown");
static_assert(sizeof(SpiritCooldown_OnCommandFinishCooldown) == 0x000010, "Wrong size on SpiritCooldown_OnCommandFinishCooldown");
static_assert(offsetof(SpiritCooldown_OnCommandFinishCooldown, CommandSetFinished) == 0x000000, "Member 'SpiritCooldown_OnCommandFinishCooldown::CommandSetFinished' has a wrong offset!");
static_assert(offsetof(SpiritCooldown_OnCommandFinishCooldown, bReset) == 0x000008, "Member 'SpiritCooldown_OnCommandFinishCooldown::bReset' has a wrong offset!");

// Function Zion.SpiritCooldown.OnNiagaraSystemFinished
// 0x0008 (0x0008 - 0x0000)
struct SpiritCooldown_OnNiagaraSystemFinished final
{
public:
	class UNiagaraComponent*                      PSystem;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpiritCooldown_OnNiagaraSystemFinished) == 0x000008, "Wrong alignment on SpiritCooldown_OnNiagaraSystemFinished");
static_assert(sizeof(SpiritCooldown_OnNiagaraSystemFinished) == 0x000008, "Wrong size on SpiritCooldown_OnNiagaraSystemFinished");
static_assert(offsetof(SpiritCooldown_OnNiagaraSystemFinished, PSystem) == 0x000000, "Member 'SpiritCooldown_OnNiagaraSystemFinished::PSystem' has a wrong offset!");

// Function Zion.SpiritCooldown.OnUnPossessPlayer
// 0x0008 (0x0008 - 0x0000)
struct SpiritCooldown_OnUnPossessPlayer final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpiritCooldown_OnUnPossessPlayer) == 0x000008, "Wrong alignment on SpiritCooldown_OnUnPossessPlayer");
static_assert(sizeof(SpiritCooldown_OnUnPossessPlayer) == 0x000008, "Wrong size on SpiritCooldown_OnUnPossessPlayer");
static_assert(offsetof(SpiritCooldown_OnUnPossessPlayer, Pawn) == 0x000000, "Member 'SpiritCooldown_OnUnPossessPlayer::Pawn' has a wrong offset!");

// Function Zion.WallAttachComponent.OnMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct WallAttachComponent_OnMovementModeChanged final
{
public:
	class ACharacter*                             InCharacter;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WallAttachComponent_OnMovementModeChanged) == 0x000008, "Wrong alignment on WallAttachComponent_OnMovementModeChanged");
static_assert(sizeof(WallAttachComponent_OnMovementModeChanged) == 0x000010, "Wrong size on WallAttachComponent_OnMovementModeChanged");
static_assert(offsetof(WallAttachComponent_OnMovementModeChanged, InCharacter) == 0x000000, "Member 'WallAttachComponent_OnMovementModeChanged::InCharacter' has a wrong offset!");
static_assert(offsetof(WallAttachComponent_OnMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'WallAttachComponent_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(WallAttachComponent_OnMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'WallAttachComponent_OnMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function Zion.StatComponent.Add
// 0x0008 (0x0008 - 0x0000)
struct StatComponent_Add final
{
public:
	int32                                         ValueToAdd;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatComponent_Add) == 0x000004, "Wrong alignment on StatComponent_Add");
static_assert(sizeof(StatComponent_Add) == 0x000008, "Wrong size on StatComponent_Add");
static_assert(offsetof(StatComponent_Add, ValueToAdd) == 0x000000, "Member 'StatComponent_Add::ValueToAdd' has a wrong offset!");
static_assert(offsetof(StatComponent_Add, ReturnValue) == 0x000004, "Member 'StatComponent_Add::ReturnValue' has a wrong offset!");

// Function Zion.StatComponent.SetMaxValue
// 0x0004 (0x0004 - 0x0000)
struct StatComponent_SetMaxValue final
{
public:
	int32                                         NewMaxValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatComponent_SetMaxValue) == 0x000004, "Wrong alignment on StatComponent_SetMaxValue");
static_assert(sizeof(StatComponent_SetMaxValue) == 0x000004, "Wrong size on StatComponent_SetMaxValue");
static_assert(offsetof(StatComponent_SetMaxValue, NewMaxValue) == 0x000000, "Member 'StatComponent_SetMaxValue::NewMaxValue' has a wrong offset!");

// Function Zion.StatComponent.Subtract
// 0x0008 (0x0008 - 0x0000)
struct StatComponent_Subtract final
{
public:
	int32                                         ValueToSubtract;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatComponent_Subtract) == 0x000004, "Wrong alignment on StatComponent_Subtract");
static_assert(sizeof(StatComponent_Subtract) == 0x000008, "Wrong size on StatComponent_Subtract");
static_assert(offsetof(StatComponent_Subtract, ValueToSubtract) == 0x000000, "Member 'StatComponent_Subtract::ValueToSubtract' has a wrong offset!");
static_assert(offsetof(StatComponent_Subtract, ReturnValue) == 0x000004, "Member 'StatComponent_Subtract::ReturnValue' has a wrong offset!");

// Function Zion.StatComponent.GetCurrRatio
// 0x0004 (0x0004 - 0x0000)
struct StatComponent_GetCurrRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatComponent_GetCurrRatio) == 0x000004, "Wrong alignment on StatComponent_GetCurrRatio");
static_assert(sizeof(StatComponent_GetCurrRatio) == 0x000004, "Wrong size on StatComponent_GetCurrRatio");
static_assert(offsetof(StatComponent_GetCurrRatio, ReturnValue) == 0x000000, "Member 'StatComponent_GetCurrRatio::ReturnValue' has a wrong offset!");

// Function Zion.StatComponent.GetCurrValue
// 0x0004 (0x0004 - 0x0000)
struct StatComponent_GetCurrValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatComponent_GetCurrValue) == 0x000004, "Wrong alignment on StatComponent_GetCurrValue");
static_assert(sizeof(StatComponent_GetCurrValue) == 0x000004, "Wrong size on StatComponent_GetCurrValue");
static_assert(offsetof(StatComponent_GetCurrValue, ReturnValue) == 0x000000, "Member 'StatComponent_GetCurrValue::ReturnValue' has a wrong offset!");

// Function Zion.StatComponent.GetMaxValue
// 0x0004 (0x0004 - 0x0000)
struct StatComponent_GetMaxValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatComponent_GetMaxValue) == 0x000004, "Wrong alignment on StatComponent_GetMaxValue");
static_assert(sizeof(StatComponent_GetMaxValue) == 0x000004, "Wrong size on StatComponent_GetMaxValue");
static_assert(offsetof(StatComponent_GetMaxValue, ReturnValue) == 0x000000, "Member 'StatComponent_GetMaxValue::ReturnValue' has a wrong offset!");

// Function Zion.StatBreakableComponent.SetIsImmune
// 0x0002 (0x0002 - 0x0000)
struct StatBreakableComponent_SetIsImmune final
{
public:
	bool                                          bImmune;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatBreakableComponent_SetIsImmune) == 0x000001, "Wrong alignment on StatBreakableComponent_SetIsImmune");
static_assert(sizeof(StatBreakableComponent_SetIsImmune) == 0x000002, "Wrong size on StatBreakableComponent_SetIsImmune");
static_assert(offsetof(StatBreakableComponent_SetIsImmune, bImmune) == 0x000000, "Member 'StatBreakableComponent_SetIsImmune::bImmune' has a wrong offset!");
static_assert(offsetof(StatBreakableComponent_SetIsImmune, ReturnValue) == 0x000001, "Member 'StatBreakableComponent_SetIsImmune::ReturnValue' has a wrong offset!");

// Function Zion.StatBreakableComponent.IsBroken
// 0x0001 (0x0001 - 0x0000)
struct StatBreakableComponent_IsBroken final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatBreakableComponent_IsBroken) == 0x000001, "Wrong alignment on StatBreakableComponent_IsBroken");
static_assert(sizeof(StatBreakableComponent_IsBroken) == 0x000001, "Wrong size on StatBreakableComponent_IsBroken");
static_assert(offsetof(StatBreakableComponent_IsBroken, ReturnValue) == 0x000000, "Member 'StatBreakableComponent_IsBroken::ReturnValue' has a wrong offset!");

// Function Zion.StatBreakableComponent.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct StatBreakableComponent_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatBreakableComponent_IsEnabled) == 0x000001, "Wrong alignment on StatBreakableComponent_IsEnabled");
static_assert(sizeof(StatBreakableComponent_IsEnabled) == 0x000001, "Wrong size on StatBreakableComponent_IsEnabled");
static_assert(offsetof(StatBreakableComponent_IsEnabled, ReturnValue) == 0x000000, "Member 'StatBreakableComponent_IsEnabled::ReturnValue' has a wrong offset!");

// Function Zion.StatBreakableComponent.IsInvincible
// 0x0001 (0x0001 - 0x0000)
struct StatBreakableComponent_IsInvincible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatBreakableComponent_IsInvincible) == 0x000001, "Wrong alignment on StatBreakableComponent_IsInvincible");
static_assert(sizeof(StatBreakableComponent_IsInvincible) == 0x000001, "Wrong size on StatBreakableComponent_IsInvincible");
static_assert(offsetof(StatBreakableComponent_IsInvincible, ReturnValue) == 0x000000, "Member 'StatBreakableComponent_IsInvincible::ReturnValue' has a wrong offset!");

// Function Zion.StateComponent.AddState
// 0x0008 (0x0008 - 0x0000)
struct StateComponent_AddState final
{
public:
	TSubclassOf<class UState>                     State;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StateComponent_AddState) == 0x000008, "Wrong alignment on StateComponent_AddState");
static_assert(sizeof(StateComponent_AddState) == 0x000008, "Wrong size on StateComponent_AddState");
static_assert(offsetof(StateComponent_AddState, State) == 0x000000, "Member 'StateComponent_AddState::State' has a wrong offset!");

// Function Zion.StateComponent.AddStates
// 0x0010 (0x0010 - 0x0000)
struct StateComponent_AddStates final
{
public:
	TArray<TSubclassOf<class UState>>             States;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(StateComponent_AddStates) == 0x000008, "Wrong alignment on StateComponent_AddStates");
static_assert(sizeof(StateComponent_AddStates) == 0x000010, "Wrong size on StateComponent_AddStates");
static_assert(offsetof(StateComponent_AddStates, States) == 0x000000, "Member 'StateComponent_AddStates::States' has a wrong offset!");

// Function Zion.StateComponent.AddStatesForDuration
// 0x0018 (0x0018 - 0x0000)
struct StateComponent_AddStatesForDuration final
{
public:
	TArray<TSubclassOf<class UState>>             States;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StateComponent_AddStatesForDuration) == 0x000008, "Wrong alignment on StateComponent_AddStatesForDuration");
static_assert(sizeof(StateComponent_AddStatesForDuration) == 0x000018, "Wrong size on StateComponent_AddStatesForDuration");
static_assert(offsetof(StateComponent_AddStatesForDuration, States) == 0x000000, "Member 'StateComponent_AddStatesForDuration::States' has a wrong offset!");
static_assert(offsetof(StateComponent_AddStatesForDuration, Duration) == 0x000010, "Member 'StateComponent_AddStatesForDuration::Duration' has a wrong offset!");

// Function Zion.StateComponent.AddStatesForFrameCount
// 0x0018 (0x0018 - 0x0000)
struct StateComponent_AddStatesForFrameCount final
{
public:
	TArray<TSubclassOf<class UState>>             States;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         FrameCount;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StateComponent_AddStatesForFrameCount) == 0x000008, "Wrong alignment on StateComponent_AddStatesForFrameCount");
static_assert(sizeof(StateComponent_AddStatesForFrameCount) == 0x000018, "Wrong size on StateComponent_AddStatesForFrameCount");
static_assert(offsetof(StateComponent_AddStatesForFrameCount, States) == 0x000000, "Member 'StateComponent_AddStatesForFrameCount::States' has a wrong offset!");
static_assert(offsetof(StateComponent_AddStatesForFrameCount, FrameCount) == 0x000010, "Member 'StateComponent_AddStatesForFrameCount::FrameCount' has a wrong offset!");

// Function Zion.StateComponent.RemoveState
// 0x0008 (0x0008 - 0x0000)
struct StateComponent_RemoveState final
{
public:
	TSubclassOf<class UState>                     State;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StateComponent_RemoveState) == 0x000008, "Wrong alignment on StateComponent_RemoveState");
static_assert(sizeof(StateComponent_RemoveState) == 0x000008, "Wrong size on StateComponent_RemoveState");
static_assert(offsetof(StateComponent_RemoveState, State) == 0x000000, "Member 'StateComponent_RemoveState::State' has a wrong offset!");

// Function Zion.StateComponent.RemoveStates
// 0x0010 (0x0010 - 0x0000)
struct StateComponent_RemoveStates final
{
public:
	TArray<TSubclassOf<class UState>>             States;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(StateComponent_RemoveStates) == 0x000008, "Wrong alignment on StateComponent_RemoveStates");
static_assert(sizeof(StateComponent_RemoveStates) == 0x000010, "Wrong size on StateComponent_RemoveStates");
static_assert(offsetof(StateComponent_RemoveStates, States) == 0x000000, "Member 'StateComponent_RemoveStates::States' has a wrong offset!");

// Function Zion.StateComponent.HasAllStates
// 0x0018 (0x0018 - 0x0000)
struct StateComponent_HasAllStates final
{
public:
	TArray<TSubclassOf<class UState>>             States;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StateComponent_HasAllStates) == 0x000008, "Wrong alignment on StateComponent_HasAllStates");
static_assert(sizeof(StateComponent_HasAllStates) == 0x000018, "Wrong size on StateComponent_HasAllStates");
static_assert(offsetof(StateComponent_HasAllStates, States) == 0x000000, "Member 'StateComponent_HasAllStates::States' has a wrong offset!");
static_assert(offsetof(StateComponent_HasAllStates, ReturnValue) == 0x000010, "Member 'StateComponent_HasAllStates::ReturnValue' has a wrong offset!");

// Function Zion.StateComponent.HasAnyState
// 0x0018 (0x0018 - 0x0000)
struct StateComponent_HasAnyState final
{
public:
	TArray<TSubclassOf<class UState>>             States;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StateComponent_HasAnyState) == 0x000008, "Wrong alignment on StateComponent_HasAnyState");
static_assert(sizeof(StateComponent_HasAnyState) == 0x000018, "Wrong size on StateComponent_HasAnyState");
static_assert(offsetof(StateComponent_HasAnyState, States) == 0x000000, "Member 'StateComponent_HasAnyState::States' has a wrong offset!");
static_assert(offsetof(StateComponent_HasAnyState, ReturnValue) == 0x000010, "Member 'StateComponent_HasAnyState::ReturnValue' has a wrong offset!");

// Function Zion.StateComponent.HasBusyState
// 0x0001 (0x0001 - 0x0000)
struct StateComponent_HasBusyState final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StateComponent_HasBusyState) == 0x000001, "Wrong alignment on StateComponent_HasBusyState");
static_assert(sizeof(StateComponent_HasBusyState) == 0x000001, "Wrong size on StateComponent_HasBusyState");
static_assert(offsetof(StateComponent_HasBusyState, ReturnValue) == 0x000000, "Member 'StateComponent_HasBusyState::ReturnValue' has a wrong offset!");

// Function Zion.StateComponent.HasState
// 0x0010 (0x0010 - 0x0000)
struct StateComponent_HasState final
{
public:
	TSubclassOf<class UState>                     State;                                             // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StateComponent_HasState) == 0x000008, "Wrong alignment on StateComponent_HasState");
static_assert(sizeof(StateComponent_HasState) == 0x000010, "Wrong size on StateComponent_HasState");
static_assert(offsetof(StateComponent_HasState, State) == 0x000000, "Member 'StateComponent_HasState::State' has a wrong offset!");
static_assert(offsetof(StateComponent_HasState, ReturnValue) == 0x000008, "Member 'StateComponent_HasState::ReturnValue' has a wrong offset!");

// Function Zion.StateComponent.IsDebuffed
// 0x0001 (0x0001 - 0x0000)
struct StateComponent_IsDebuffed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StateComponent_IsDebuffed) == 0x000001, "Wrong alignment on StateComponent_IsDebuffed");
static_assert(sizeof(StateComponent_IsDebuffed) == 0x000001, "Wrong size on StateComponent_IsDebuffed");
static_assert(offsetof(StateComponent_IsDebuffed, ReturnValue) == 0x000000, "Member 'StateComponent_IsDebuffed::ReturnValue' has a wrong offset!");

// Function Zion.StateComponent.IsFacingLocked
// 0x0001 (0x0001 - 0x0000)
struct StateComponent_IsFacingLocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StateComponent_IsFacingLocked) == 0x000001, "Wrong alignment on StateComponent_IsFacingLocked");
static_assert(sizeof(StateComponent_IsFacingLocked) == 0x000001, "Wrong size on StateComponent_IsFacingLocked");
static_assert(offsetof(StateComponent_IsFacingLocked, ReturnValue) == 0x000000, "Member 'StateComponent_IsFacingLocked::ReturnValue' has a wrong offset!");

// Function Zion.StateComponent.IsFreeCommandLayerLocked
// 0x0001 (0x0001 - 0x0000)
struct StateComponent_IsFreeCommandLayerLocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StateComponent_IsFreeCommandLayerLocked) == 0x000001, "Wrong alignment on StateComponent_IsFreeCommandLayerLocked");
static_assert(sizeof(StateComponent_IsFreeCommandLayerLocked) == 0x000001, "Wrong size on StateComponent_IsFreeCommandLayerLocked");
static_assert(offsetof(StateComponent_IsFreeCommandLayerLocked, ReturnValue) == 0x000000, "Member 'StateComponent_IsFreeCommandLayerLocked::ReturnValue' has a wrong offset!");

// Function Zion.StateComponent.IsInFreezeCritical
// 0x0001 (0x0001 - 0x0000)
struct StateComponent_IsInFreezeCritical final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StateComponent_IsInFreezeCritical) == 0x000001, "Wrong alignment on StateComponent_IsInFreezeCritical");
static_assert(sizeof(StateComponent_IsInFreezeCritical) == 0x000001, "Wrong size on StateComponent_IsInFreezeCritical");
static_assert(offsetof(StateComponent_IsInFreezeCritical, ReturnValue) == 0x000000, "Member 'StateComponent_IsInFreezeCritical::ReturnValue' has a wrong offset!");

// Function Zion.StateComponent.IsInputActionLocked
// 0x0010 (0x0010 - 0x0000)
struct StateComponent_IsInputActionLocked final
{
public:
	const class UInputAction*                     InputAction;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StateComponent_IsInputActionLocked) == 0x000008, "Wrong alignment on StateComponent_IsInputActionLocked");
static_assert(sizeof(StateComponent_IsInputActionLocked) == 0x000010, "Wrong size on StateComponent_IsInputActionLocked");
static_assert(offsetof(StateComponent_IsInputActionLocked, InputAction) == 0x000000, "Member 'StateComponent_IsInputActionLocked::InputAction' has a wrong offset!");
static_assert(offsetof(StateComponent_IsInputActionLocked, ReturnValue) == 0x000008, "Member 'StateComponent_IsInputActionLocked::ReturnValue' has a wrong offset!");

// Function Zion.StateComponent.IsMovementLocked
// 0x0001 (0x0001 - 0x0000)
struct StateComponent_IsMovementLocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StateComponent_IsMovementLocked) == 0x000001, "Wrong alignment on StateComponent_IsMovementLocked");
static_assert(sizeof(StateComponent_IsMovementLocked) == 0x000001, "Wrong size on StateComponent_IsMovementLocked");
static_assert(offsetof(StateComponent_IsMovementLocked, ReturnValue) == 0x000000, "Member 'StateComponent_IsMovementLocked::ReturnValue' has a wrong offset!");

// Function Zion.StateComponent.IsStunned
// 0x0001 (0x0001 - 0x0000)
struct StateComponent_IsStunned final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StateComponent_IsStunned) == 0x000001, "Wrong alignment on StateComponent_IsStunned");
static_assert(sizeof(StateComponent_IsStunned) == 0x000001, "Wrong size on StateComponent_IsStunned");
static_assert(offsetof(StateComponent_IsStunned, ReturnValue) == 0x000000, "Member 'StateComponent_IsStunned::ReturnValue' has a wrong offset!");

// Function Zion.StatHPComponent.DoDamage
// 0x0068 (0x0068 - 0x0000)
struct StatHPComponent_DoDamage final
{
public:
	class AActor*                                 Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageData                            DamageData;                                        // 0x0008(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StatHPComponent_DoDamage) == 0x000008, "Wrong alignment on StatHPComponent_DoDamage");
static_assert(sizeof(StatHPComponent_DoDamage) == 0x000068, "Wrong size on StatHPComponent_DoDamage");
static_assert(offsetof(StatHPComponent_DoDamage, Source) == 0x000000, "Member 'StatHPComponent_DoDamage::Source' has a wrong offset!");
static_assert(offsetof(StatHPComponent_DoDamage, DamageData) == 0x000008, "Member 'StatHPComponent_DoDamage::DamageData' has a wrong offset!");
static_assert(offsetof(StatHPComponent_DoDamage, ReturnValue) == 0x000060, "Member 'StatHPComponent_DoDamage::ReturnValue' has a wrong offset!");

// Function Zion.StatHPComponent.DoHeal
// 0x0010 (0x0010 - 0x0000)
struct StatHPComponent_DoHeal final
{
public:
	class AActor*                                 Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StatHPComponent_DoHeal) == 0x000008, "Wrong alignment on StatHPComponent_DoHeal");
static_assert(sizeof(StatHPComponent_DoHeal) == 0x000010, "Wrong size on StatHPComponent_DoHeal");
static_assert(offsetof(StatHPComponent_DoHeal, Source) == 0x000000, "Member 'StatHPComponent_DoHeal::Source' has a wrong offset!");
static_assert(offsetof(StatHPComponent_DoHeal, Value) == 0x000008, "Member 'StatHPComponent_DoHeal::Value' has a wrong offset!");
static_assert(offsetof(StatHPComponent_DoHeal, ReturnValue) == 0x00000C, "Member 'StatHPComponent_DoHeal::ReturnValue' has a wrong offset!");

// Function Zion.StatHPComponent.GetLastDamageSource
// 0x0008 (0x0008 - 0x0000)
struct StatHPComponent_GetLastDamageSource final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatHPComponent_GetLastDamageSource) == 0x000008, "Wrong alignment on StatHPComponent_GetLastDamageSource");
static_assert(sizeof(StatHPComponent_GetLastDamageSource) == 0x000008, "Wrong size on StatHPComponent_GetLastDamageSource");
static_assert(offsetof(StatHPComponent_GetLastDamageSource, ReturnValue) == 0x000000, "Member 'StatHPComponent_GetLastDamageSource::ReturnValue' has a wrong offset!");

// Function Zion.StaticVolume_AddForce.OnCharacterMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct StaticVolume_AddForce_OnCharacterMovementModeChanged final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StaticVolume_AddForce_OnCharacterMovementModeChanged) == 0x000008, "Wrong alignment on StaticVolume_AddForce_OnCharacterMovementModeChanged");
static_assert(sizeof(StaticVolume_AddForce_OnCharacterMovementModeChanged) == 0x000010, "Wrong size on StaticVolume_AddForce_OnCharacterMovementModeChanged");
static_assert(offsetof(StaticVolume_AddForce_OnCharacterMovementModeChanged, Character) == 0x000000, "Member 'StaticVolume_AddForce_OnCharacterMovementModeChanged::Character' has a wrong offset!");
static_assert(offsetof(StaticVolume_AddForce_OnCharacterMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'StaticVolume_AddForce_OnCharacterMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(StaticVolume_AddForce_OnCharacterMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'StaticVolume_AddForce_OnCharacterMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function Zion.StaticVolume_Audio.IsInfiniteExtent
// 0x0001 (0x0001 - 0x0000)
struct StaticVolume_Audio_IsInfiniteExtent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticVolume_Audio_IsInfiniteExtent) == 0x000001, "Wrong alignment on StaticVolume_Audio_IsInfiniteExtent");
static_assert(sizeof(StaticVolume_Audio_IsInfiniteExtent) == 0x000001, "Wrong size on StaticVolume_Audio_IsInfiniteExtent");
static_assert(offsetof(StaticVolume_Audio_IsInfiniteExtent, ReturnValue) == 0x000000, "Member 'StaticVolume_Audio_IsInfiniteExtent::ReturnValue' has a wrong offset!");

// Function Zion.StaticVolume_CameraModifier.OnActivationBeginOverlap
// 0x0118 (0x0118 - 0x0000)
struct StaticVolume_CameraModifier_OnActivationBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticVolume_CameraModifier_OnActivationBeginOverlap) == 0x000008, "Wrong alignment on StaticVolume_CameraModifier_OnActivationBeginOverlap");
static_assert(sizeof(StaticVolume_CameraModifier_OnActivationBeginOverlap) == 0x000118, "Wrong size on StaticVolume_CameraModifier_OnActivationBeginOverlap");
static_assert(offsetof(StaticVolume_CameraModifier_OnActivationBeginOverlap, OverlappedComponent) == 0x000000, "Member 'StaticVolume_CameraModifier_OnActivationBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(StaticVolume_CameraModifier_OnActivationBeginOverlap, OtherActor) == 0x000008, "Member 'StaticVolume_CameraModifier_OnActivationBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(StaticVolume_CameraModifier_OnActivationBeginOverlap, OtherComp) == 0x000010, "Member 'StaticVolume_CameraModifier_OnActivationBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(StaticVolume_CameraModifier_OnActivationBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'StaticVolume_CameraModifier_OnActivationBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(StaticVolume_CameraModifier_OnActivationBeginOverlap, bFromSweep) == 0x00001C, "Member 'StaticVolume_CameraModifier_OnActivationBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(StaticVolume_CameraModifier_OnActivationBeginOverlap, SweepResult) == 0x000020, "Member 'StaticVolume_CameraModifier_OnActivationBeginOverlap::SweepResult' has a wrong offset!");

// Function Zion.StaticVolume_CameraModifier.OnActivationEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct StaticVolume_CameraModifier_OnActivationEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StaticVolume_CameraModifier_OnActivationEndOverlap) == 0x000008, "Wrong alignment on StaticVolume_CameraModifier_OnActivationEndOverlap");
static_assert(sizeof(StaticVolume_CameraModifier_OnActivationEndOverlap) == 0x000020, "Wrong size on StaticVolume_CameraModifier_OnActivationEndOverlap");
static_assert(offsetof(StaticVolume_CameraModifier_OnActivationEndOverlap, OverlappedComponent) == 0x000000, "Member 'StaticVolume_CameraModifier_OnActivationEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(StaticVolume_CameraModifier_OnActivationEndOverlap, OtherActor) == 0x000008, "Member 'StaticVolume_CameraModifier_OnActivationEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(StaticVolume_CameraModifier_OnActivationEndOverlap, OtherComp) == 0x000010, "Member 'StaticVolume_CameraModifier_OnActivationEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(StaticVolume_CameraModifier_OnActivationEndOverlap, OtherBodyIndex) == 0x000018, "Member 'StaticVolume_CameraModifier_OnActivationEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function Zion.StaticVolume_CameraModifier.IsActive
// 0x0001 (0x0001 - 0x0000)
struct StaticVolume_CameraModifier_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticVolume_CameraModifier_IsActive) == 0x000001, "Wrong alignment on StaticVolume_CameraModifier_IsActive");
static_assert(sizeof(StaticVolume_CameraModifier_IsActive) == 0x000001, "Wrong size on StaticVolume_CameraModifier_IsActive");
static_assert(offsetof(StaticVolume_CameraModifier_IsActive, ReturnValue) == 0x000000, "Member 'StaticVolume_CameraModifier_IsActive::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapLegend.OnLegendInitialized
// 0x0050 (0x0050 - 0x0000)
struct UserWidgetMapLegend_OnLegendInitialized final
{
public:
	TSet<EMapIconType>                            VisibleIconTypes;                                  // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapLegend_OnLegendInitialized) == 0x000008, "Wrong alignment on UserWidgetMapLegend_OnLegendInitialized");
static_assert(sizeof(UserWidgetMapLegend_OnLegendInitialized) == 0x000050, "Wrong size on UserWidgetMapLegend_OnLegendInitialized");
static_assert(offsetof(UserWidgetMapLegend_OnLegendInitialized, VisibleIconTypes) == 0x000000, "Member 'UserWidgetMapLegend_OnLegendInitialized::VisibleIconTypes' has a wrong offset!");

// Function Zion.StaticVolume_Zone.SetZoneLevel
// 0x0008 (0x0008 - 0x0000)
struct StaticVolume_Zone_SetZoneLevel final
{
public:
	class UWorld*                                 InZoneLevel;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticVolume_Zone_SetZoneLevel) == 0x000008, "Wrong alignment on StaticVolume_Zone_SetZoneLevel");
static_assert(sizeof(StaticVolume_Zone_SetZoneLevel) == 0x000008, "Wrong size on StaticVolume_Zone_SetZoneLevel");
static_assert(offsetof(StaticVolume_Zone_SetZoneLevel, InZoneLevel) == 0x000000, "Member 'StaticVolume_Zone_SetZoneLevel::InZoneLevel' has a wrong offset!");

// Function Zion.StatsControllerComponent.GetAppliedLevel
// 0x0004 (0x0004 - 0x0000)
struct StatsControllerComponent_GetAppliedLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsControllerComponent_GetAppliedLevel) == 0x000004, "Wrong alignment on StatsControllerComponent_GetAppliedLevel");
static_assert(sizeof(StatsControllerComponent_GetAppliedLevel) == 0x000004, "Wrong size on StatsControllerComponent_GetAppliedLevel");
static_assert(offsetof(StatsControllerComponent_GetAppliedLevel, ReturnValue) == 0x000000, "Member 'StatsControllerComponent_GetAppliedLevel::ReturnValue' has a wrong offset!");

// Function Zion.StatsControllerComponent.GetLevel
// 0x0004 (0x0004 - 0x0000)
struct StatsControllerComponent_GetLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsControllerComponent_GetLevel) == 0x000004, "Wrong alignment on StatsControllerComponent_GetLevel");
static_assert(sizeof(StatsControllerComponent_GetLevel) == 0x000004, "Wrong size on StatsControllerComponent_GetLevel");
static_assert(offsetof(StatsControllerComponent_GetLevel, ReturnValue) == 0x000000, "Member 'StatsControllerComponent_GetLevel::ReturnValue' has a wrong offset!");

// Function Zion.StatsControllerComponent.GetStatsLevelData
// 0x0040 (0x0040 - 0x0000)
struct StatsControllerComponent_GetStatsLevelData final
{
public:
	struct FStatsLevelData                        ReturnValue;                                       // 0x0000(0x0040)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsControllerComponent_GetStatsLevelData) == 0x000008, "Wrong alignment on StatsControllerComponent_GetStatsLevelData");
static_assert(sizeof(StatsControllerComponent_GetStatsLevelData) == 0x000040, "Wrong size on StatsControllerComponent_GetStatsLevelData");
static_assert(offsetof(StatsControllerComponent_GetStatsLevelData, ReturnValue) == 0x000000, "Member 'StatsControllerComponent_GetStatsLevelData::ReturnValue' has a wrong offset!");

// Function Zion.StatsControllerAIComponent.IncrementPhaseLevel
// 0x0004 (0x0004 - 0x0000)
struct StatsControllerAIComponent_IncrementPhaseLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsControllerAIComponent_IncrementPhaseLevel) == 0x000004, "Wrong alignment on StatsControllerAIComponent_IncrementPhaseLevel");
static_assert(sizeof(StatsControllerAIComponent_IncrementPhaseLevel) == 0x000004, "Wrong size on StatsControllerAIComponent_IncrementPhaseLevel");
static_assert(offsetof(StatsControllerAIComponent_IncrementPhaseLevel, ReturnValue) == 0x000000, "Member 'StatsControllerAIComponent_IncrementPhaseLevel::ReturnValue' has a wrong offset!");

// Function Zion.StatsControllerAIComponent.GetPhaseLevel
// 0x0004 (0x0004 - 0x0000)
struct StatsControllerAIComponent_GetPhaseLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsControllerAIComponent_GetPhaseLevel) == 0x000004, "Wrong alignment on StatsControllerAIComponent_GetPhaseLevel");
static_assert(sizeof(StatsControllerAIComponent_GetPhaseLevel) == 0x000004, "Wrong size on StatsControllerAIComponent_GetPhaseLevel");
static_assert(offsetof(StatsControllerAIComponent_GetPhaseLevel, ReturnValue) == 0x000000, "Member 'StatsControllerAIComponent_GetPhaseLevel::ReturnValue' has a wrong offset!");

// Function Zion.StatsControllerPlayerComponent.SetLevel
// 0x0004 (0x0004 - 0x0000)
struct StatsControllerPlayerComponent_SetLevel final
{
public:
	int32                                         NewLevel;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsControllerPlayerComponent_SetLevel) == 0x000004, "Wrong alignment on StatsControllerPlayerComponent_SetLevel");
static_assert(sizeof(StatsControllerPlayerComponent_SetLevel) == 0x000004, "Wrong size on StatsControllerPlayerComponent_SetLevel");
static_assert(offsetof(StatsControllerPlayerComponent_SetLevel, NewLevel) == 0x000000, "Member 'StatsControllerPlayerComponent_SetLevel::NewLevel' has a wrong offset!");

// Function Zion.StatsControllerPlayerComponent.GetExperiencePoints
// 0x0004 (0x0004 - 0x0000)
struct StatsControllerPlayerComponent_GetExperiencePoints final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsControllerPlayerComponent_GetExperiencePoints) == 0x000004, "Wrong alignment on StatsControllerPlayerComponent_GetExperiencePoints");
static_assert(sizeof(StatsControllerPlayerComponent_GetExperiencePoints) == 0x000004, "Wrong size on StatsControllerPlayerComponent_GetExperiencePoints");
static_assert(offsetof(StatsControllerPlayerComponent_GetExperiencePoints, ReturnValue) == 0x000000, "Member 'StatsControllerPlayerComponent_GetExperiencePoints::ReturnValue' has a wrong offset!");

// Function Zion.StatsControllerPlayerComponent.GetExperiencePointsRatio
// 0x0004 (0x0004 - 0x0000)
struct StatsControllerPlayerComponent_GetExperiencePointsRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsControllerPlayerComponent_GetExperiencePointsRatio) == 0x000004, "Wrong alignment on StatsControllerPlayerComponent_GetExperiencePointsRatio");
static_assert(sizeof(StatsControllerPlayerComponent_GetExperiencePointsRatio) == 0x000004, "Wrong size on StatsControllerPlayerComponent_GetExperiencePointsRatio");
static_assert(offsetof(StatsControllerPlayerComponent_GetExperiencePointsRatio, ReturnValue) == 0x000000, "Member 'StatsControllerPlayerComponent_GetExperiencePointsRatio::ReturnValue' has a wrong offset!");

// Function Zion.StatsControllerPlayerComponent.GetExtendedStatsLevelDataWithBonuses
// 0x0050 (0x0050 - 0x0000)
struct StatsControllerPlayerComponent_GetExtendedStatsLevelDataWithBonuses final
{
public:
	struct FExtendedStatsData                     ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsControllerPlayerComponent_GetExtendedStatsLevelDataWithBonuses) == 0x000008, "Wrong alignment on StatsControllerPlayerComponent_GetExtendedStatsLevelDataWithBonuses");
static_assert(sizeof(StatsControllerPlayerComponent_GetExtendedStatsLevelDataWithBonuses) == 0x000050, "Wrong size on StatsControllerPlayerComponent_GetExtendedStatsLevelDataWithBonuses");
static_assert(offsetof(StatsControllerPlayerComponent_GetExtendedStatsLevelDataWithBonuses, ReturnValue) == 0x000000, "Member 'StatsControllerPlayerComponent_GetExtendedStatsLevelDataWithBonuses::ReturnValue' has a wrong offset!");

// Function Zion.StatsControllerPlayerComponent.GetNecessaryExperiencePointsForLevelUp
// 0x0004 (0x0004 - 0x0000)
struct StatsControllerPlayerComponent_GetNecessaryExperiencePointsForLevelUp final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsControllerPlayerComponent_GetNecessaryExperiencePointsForLevelUp) == 0x000004, "Wrong alignment on StatsControllerPlayerComponent_GetNecessaryExperiencePointsForLevelUp");
static_assert(sizeof(StatsControllerPlayerComponent_GetNecessaryExperiencePointsForLevelUp) == 0x000004, "Wrong size on StatsControllerPlayerComponent_GetNecessaryExperiencePointsForLevelUp");
static_assert(offsetof(StatsControllerPlayerComponent_GetNecessaryExperiencePointsForLevelUp, ReturnValue) == 0x000000, "Member 'StatsControllerPlayerComponent_GetNecessaryExperiencePointsForLevelUp::ReturnValue' has a wrong offset!");

// Function Zion.StatsControllerPlayerComponent.GetStatsLevelDataWithBonuses
// 0x0040 (0x0040 - 0x0000)
struct StatsControllerPlayerComponent_GetStatsLevelDataWithBonuses final
{
public:
	struct FStatsLevelData                        ReturnValue;                                       // 0x0000(0x0040)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsControllerPlayerComponent_GetStatsLevelDataWithBonuses) == 0x000008, "Wrong alignment on StatsControllerPlayerComponent_GetStatsLevelDataWithBonuses");
static_assert(sizeof(StatsControllerPlayerComponent_GetStatsLevelDataWithBonuses) == 0x000040, "Wrong size on StatsControllerPlayerComponent_GetStatsLevelDataWithBonuses");
static_assert(offsetof(StatsControllerPlayerComponent_GetStatsLevelDataWithBonuses, ReturnValue) == 0x000000, "Member 'StatsControllerPlayerComponent_GetStatsLevelDataWithBonuses::ReturnValue' has a wrong offset!");

// Function Zion.StatsControllerPlayerComponent.IsMaxLevel
// 0x0001 (0x0001 - 0x0000)
struct StatsControllerPlayerComponent_IsMaxLevel final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatsControllerPlayerComponent_IsMaxLevel) == 0x000001, "Wrong alignment on StatsControllerPlayerComponent_IsMaxLevel");
static_assert(sizeof(StatsControllerPlayerComponent_IsMaxLevel) == 0x000001, "Wrong size on StatsControllerPlayerComponent_IsMaxLevel");
static_assert(offsetof(StatsControllerPlayerComponent_IsMaxLevel, ReturnValue) == 0x000000, "Member 'StatsControllerPlayerComponent_IsMaxLevel::ReturnValue' has a wrong offset!");

// Function Zion.StatSPComponent.AddSPRegenPercentageBonus
// 0x0008 (0x0008 - 0x0000)
struct StatSPComponent_AddSPRegenPercentageBonus final
{
public:
	int32                                         SPRegenPercentBonusToAdd;                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatSPComponent_AddSPRegenPercentageBonus) == 0x000004, "Wrong alignment on StatSPComponent_AddSPRegenPercentageBonus");
static_assert(sizeof(StatSPComponent_AddSPRegenPercentageBonus) == 0x000008, "Wrong size on StatSPComponent_AddSPRegenPercentageBonus");
static_assert(offsetof(StatSPComponent_AddSPRegenPercentageBonus, SPRegenPercentBonusToAdd) == 0x000000, "Member 'StatSPComponent_AddSPRegenPercentageBonus::SPRegenPercentBonusToAdd' has a wrong offset!");
static_assert(offsetof(StatSPComponent_AddSPRegenPercentageBonus, ReturnValue) == 0x000004, "Member 'StatSPComponent_AddSPRegenPercentageBonus::ReturnValue' has a wrong offset!");

// Function Zion.StatSPComponent.SubSPRegenPercentageBonus
// 0x0008 (0x0008 - 0x0000)
struct StatSPComponent_SubSPRegenPercentageBonus final
{
public:
	int32                                         SPRegenPercentBonusToSub;                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatSPComponent_SubSPRegenPercentageBonus) == 0x000004, "Wrong alignment on StatSPComponent_SubSPRegenPercentageBonus");
static_assert(sizeof(StatSPComponent_SubSPRegenPercentageBonus) == 0x000008, "Wrong size on StatSPComponent_SubSPRegenPercentageBonus");
static_assert(offsetof(StatSPComponent_SubSPRegenPercentageBonus, SPRegenPercentBonusToSub) == 0x000000, "Member 'StatSPComponent_SubSPRegenPercentageBonus::SPRegenPercentBonusToSub' has a wrong offset!");
static_assert(offsetof(StatSPComponent_SubSPRegenPercentageBonus, ReturnValue) == 0x000004, "Member 'StatSPComponent_SubSPRegenPercentageBonus::ReturnValue' has a wrong offset!");

// Function Zion.StatSPComponent.GetFilledGaugeCount
// 0x0004 (0x0004 - 0x0000)
struct StatSPComponent_GetFilledGaugeCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatSPComponent_GetFilledGaugeCount) == 0x000004, "Wrong alignment on StatSPComponent_GetFilledGaugeCount");
static_assert(sizeof(StatSPComponent_GetFilledGaugeCount) == 0x000004, "Wrong size on StatSPComponent_GetFilledGaugeCount");
static_assert(offsetof(StatSPComponent_GetFilledGaugeCount, ReturnValue) == 0x000000, "Member 'StatSPComponent_GetFilledGaugeCount::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetRestPointListEntry.InitializeEntry
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetRestPointListEntry_InitializeEntry final
{
public:
	class UUserWidgetMapIcon_RestPoint*           RestPointIcon;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetRestPointListEntry_InitializeEntry) == 0x000008, "Wrong alignment on UserWidgetRestPointListEntry_InitializeEntry");
static_assert(sizeof(UserWidgetRestPointListEntry_InitializeEntry) == 0x000008, "Wrong size on UserWidgetRestPointListEntry_InitializeEntry");
static_assert(offsetof(UserWidgetRestPointListEntry_InitializeEntry, RestPointIcon) == 0x000000, "Member 'UserWidgetRestPointListEntry_InitializeEntry::RestPointIcon' has a wrong offset!");

// Function Zion.UserWidgetRestPointListEntry.IsRestPointIcon
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetRestPointListEntry_IsRestPointIcon final
{
public:
	class UUserWidgetMapIcon_RestPoint*           RestPointIcon;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserWidgetRestPointListEntry_IsRestPointIcon) == 0x000008, "Wrong alignment on UserWidgetRestPointListEntry_IsRestPointIcon");
static_assert(sizeof(UserWidgetRestPointListEntry_IsRestPointIcon) == 0x000010, "Wrong size on UserWidgetRestPointListEntry_IsRestPointIcon");
static_assert(offsetof(UserWidgetRestPointListEntry_IsRestPointIcon, RestPointIcon) == 0x000000, "Member 'UserWidgetRestPointListEntry_IsRestPointIcon::RestPointIcon' has a wrong offset!");
static_assert(offsetof(UserWidgetRestPointListEntry_IsRestPointIcon, ReturnValue) == 0x000008, "Member 'UserWidgetRestPointListEntry_IsRestPointIcon::ReturnValue' has a wrong offset!");

// Function Zion.StatusEffect.GetDuration
// 0x0004 (0x0004 - 0x0000)
struct StatusEffect_GetDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatusEffect_GetDuration) == 0x000004, "Wrong alignment on StatusEffect_GetDuration");
static_assert(sizeof(StatusEffect_GetDuration) == 0x000004, "Wrong size on StatusEffect_GetDuration");
static_assert(offsetof(StatusEffect_GetDuration, ReturnValue) == 0x000000, "Member 'StatusEffect_GetDuration::ReturnValue' has a wrong offset!");

// Function Zion.StatusEffect.GetStatusEffectType
// 0x0001 (0x0001 - 0x0000)
struct StatusEffect_GetStatusEffectType final
{
public:
	EStatusEffectType                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatusEffect_GetStatusEffectType) == 0x000001, "Wrong alignment on StatusEffect_GetStatusEffectType");
static_assert(sizeof(StatusEffect_GetStatusEffectType) == 0x000001, "Wrong size on StatusEffect_GetStatusEffectType");
static_assert(offsetof(StatusEffect_GetStatusEffectType, ReturnValue) == 0x000000, "Member 'StatusEffect_GetStatusEffectType::ReturnValue' has a wrong offset!");

// Function Zion.StatusEffect_BurnPlayer.OnMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct StatusEffect_BurnPlayer_OnMovementModeChanged final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StatusEffect_BurnPlayer_OnMovementModeChanged) == 0x000008, "Wrong alignment on StatusEffect_BurnPlayer_OnMovementModeChanged");
static_assert(sizeof(StatusEffect_BurnPlayer_OnMovementModeChanged) == 0x000010, "Wrong size on StatusEffect_BurnPlayer_OnMovementModeChanged");
static_assert(offsetof(StatusEffect_BurnPlayer_OnMovementModeChanged, Character) == 0x000000, "Member 'StatusEffect_BurnPlayer_OnMovementModeChanged::Character' has a wrong offset!");
static_assert(offsetof(StatusEffect_BurnPlayer_OnMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'StatusEffect_BurnPlayer_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(StatusEffect_BurnPlayer_OnMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'StatusEffect_BurnPlayer_OnMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function Zion.StoryLevelComponent.GetStoryLevel
// 0x0004 (0x0004 - 0x0000)
struct StoryLevelComponent_GetStoryLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StoryLevelComponent_GetStoryLevel) == 0x000004, "Wrong alignment on StoryLevelComponent_GetStoryLevel");
static_assert(sizeof(StoryLevelComponent_GetStoryLevel) == 0x000004, "Wrong size on StoryLevelComponent_GetStoryLevel");
static_assert(offsetof(StoryLevelComponent_GetStoryLevel, ReturnValue) == 0x000000, "Member 'StoryLevelComponent_GetStoryLevel::ReturnValue' has a wrong offset!");

// Function Zion.StoryLevelComponent.GetStoryLevelData
// 0x0050 (0x0050 - 0x0000)
struct StoryLevelComponent_GetStoryLevelData final
{
public:
	struct FStoryLevelData                        ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StoryLevelComponent_GetStoryLevelData) == 0x000008, "Wrong alignment on StoryLevelComponent_GetStoryLevelData");
static_assert(sizeof(StoryLevelComponent_GetStoryLevelData) == 0x000050, "Wrong size on StoryLevelComponent_GetStoryLevelData");
static_assert(offsetof(StoryLevelComponent_GetStoryLevelData, ReturnValue) == 0x000000, "Member 'StoryLevelComponent_GetStoryLevelData::ReturnValue' has a wrong offset!");

// Function Zion.StringBPFLibrary.BossRushRecordTimeSecondsToString
// 0x0018 (0x0018 - 0x0000)
struct StringBPFLibrary_BossRushRecordTimeSecondsToString final
{
public:
	float                                         TimeInSeconds;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StringBPFLibrary_BossRushRecordTimeSecondsToString) == 0x000008, "Wrong alignment on StringBPFLibrary_BossRushRecordTimeSecondsToString");
static_assert(sizeof(StringBPFLibrary_BossRushRecordTimeSecondsToString) == 0x000018, "Wrong size on StringBPFLibrary_BossRushRecordTimeSecondsToString");
static_assert(offsetof(StringBPFLibrary_BossRushRecordTimeSecondsToString, TimeInSeconds) == 0x000000, "Member 'StringBPFLibrary_BossRushRecordTimeSecondsToString::TimeInSeconds' has a wrong offset!");
static_assert(offsetof(StringBPFLibrary_BossRushRecordTimeSecondsToString, ReturnValue) == 0x000008, "Member 'StringBPFLibrary_BossRushRecordTimeSecondsToString::ReturnValue' has a wrong offset!");

// Function Zion.StringBPFLibrary.ProcessSubtitle
// 0x0030 (0x0030 - 0x0000)
struct StringBPFLibrary_ProcessSubtitle final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Name_0;                                            // 0x0010(0x0010)(Parm, OutParm, NativeAccessSpecifierPublic)
	class FText                                   Message;                                           // 0x0020(0x0010)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StringBPFLibrary_ProcessSubtitle) == 0x000008, "Wrong alignment on StringBPFLibrary_ProcessSubtitle");
static_assert(sizeof(StringBPFLibrary_ProcessSubtitle) == 0x000030, "Wrong size on StringBPFLibrary_ProcessSubtitle");
static_assert(offsetof(StringBPFLibrary_ProcessSubtitle, Text) == 0x000000, "Member 'StringBPFLibrary_ProcessSubtitle::Text' has a wrong offset!");
static_assert(offsetof(StringBPFLibrary_ProcessSubtitle, Name_0) == 0x000010, "Member 'StringBPFLibrary_ProcessSubtitle::Name_0' has a wrong offset!");
static_assert(offsetof(StringBPFLibrary_ProcessSubtitle, Message) == 0x000020, "Member 'StringBPFLibrary_ProcessSubtitle::Message' has a wrong offset!");

// Function Zion.StringBPFLibrary.Sort
// 0x0020 (0x0020 - 0x0000)
struct StringBPFLibrary_Sort final
{
public:
	TArray<class FString>                         Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StringBPFLibrary_Sort) == 0x000008, "Wrong alignment on StringBPFLibrary_Sort");
static_assert(sizeof(StringBPFLibrary_Sort) == 0x000020, "Wrong size on StringBPFLibrary_Sort");
static_assert(offsetof(StringBPFLibrary_Sort, Array) == 0x000000, "Member 'StringBPFLibrary_Sort::Array' has a wrong offset!");
static_assert(offsetof(StringBPFLibrary_Sort, ReturnValue) == 0x000010, "Member 'StringBPFLibrary_Sort::ReturnValue' has a wrong offset!");

// Function Zion.StringBPFLibrary.TimeSecondsToString
// 0x0018 (0x0018 - 0x0000)
struct StringBPFLibrary_TimeSecondsToString final
{
public:
	float                                         TimeInSeconds;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StringBPFLibrary_TimeSecondsToString) == 0x000008, "Wrong alignment on StringBPFLibrary_TimeSecondsToString");
static_assert(sizeof(StringBPFLibrary_TimeSecondsToString) == 0x000018, "Wrong size on StringBPFLibrary_TimeSecondsToString");
static_assert(offsetof(StringBPFLibrary_TimeSecondsToString, TimeInSeconds) == 0x000000, "Member 'StringBPFLibrary_TimeSecondsToString::TimeInSeconds' has a wrong offset!");
static_assert(offsetof(StringBPFLibrary_TimeSecondsToString, ReturnValue) == 0x000008, "Member 'StringBPFLibrary_TimeSecondsToString::ReturnValue' has a wrong offset!");

// Function Zion.StructBPFLibrary.ExtendedStatsData_Add
// 0x00F0 (0x00F0 - 0x0000)
struct StructBPFLibrary_ExtendedStatsData_Add final
{
public:
	struct FExtendedStatsData                     A;                                                 // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FExtendedStatsData                     B;                                                 // 0x0050(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FExtendedStatsData                     ReturnValue;                                       // 0x00A0(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StructBPFLibrary_ExtendedStatsData_Add) == 0x000008, "Wrong alignment on StructBPFLibrary_ExtendedStatsData_Add");
static_assert(sizeof(StructBPFLibrary_ExtendedStatsData_Add) == 0x0000F0, "Wrong size on StructBPFLibrary_ExtendedStatsData_Add");
static_assert(offsetof(StructBPFLibrary_ExtendedStatsData_Add, A) == 0x000000, "Member 'StructBPFLibrary_ExtendedStatsData_Add::A' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_ExtendedStatsData_Add, B) == 0x000050, "Member 'StructBPFLibrary_ExtendedStatsData_Add::B' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_ExtendedStatsData_Add, ReturnValue) == 0x0000A0, "Member 'StructBPFLibrary_ExtendedStatsData_Add::ReturnValue' has a wrong offset!");

// Function Zion.StructBPFLibrary.ExtendedStatsData_ClampToZero
// 0x0050 (0x0050 - 0x0000)
struct StructBPFLibrary_ExtendedStatsData_ClampToZero final
{
public:
	struct FExtendedStatsData                     ExtendedStatsData;                                 // 0x0000(0x0050)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StructBPFLibrary_ExtendedStatsData_ClampToZero) == 0x000008, "Wrong alignment on StructBPFLibrary_ExtendedStatsData_ClampToZero");
static_assert(sizeof(StructBPFLibrary_ExtendedStatsData_ClampToZero) == 0x000050, "Wrong size on StructBPFLibrary_ExtendedStatsData_ClampToZero");
static_assert(offsetof(StructBPFLibrary_ExtendedStatsData_ClampToZero, ExtendedStatsData) == 0x000000, "Member 'StructBPFLibrary_ExtendedStatsData_ClampToZero::ExtendedStatsData' has a wrong offset!");

// Function Zion.StructBPFLibrary.ExtendedStatsData_Subtract
// 0x00F0 (0x00F0 - 0x0000)
struct StructBPFLibrary_ExtendedStatsData_Subtract final
{
public:
	struct FExtendedStatsData                     A;                                                 // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FExtendedStatsData                     B;                                                 // 0x0050(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FExtendedStatsData                     ReturnValue;                                       // 0x00A0(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StructBPFLibrary_ExtendedStatsData_Subtract) == 0x000008, "Wrong alignment on StructBPFLibrary_ExtendedStatsData_Subtract");
static_assert(sizeof(StructBPFLibrary_ExtendedStatsData_Subtract) == 0x0000F0, "Wrong size on StructBPFLibrary_ExtendedStatsData_Subtract");
static_assert(offsetof(StructBPFLibrary_ExtendedStatsData_Subtract, A) == 0x000000, "Member 'StructBPFLibrary_ExtendedStatsData_Subtract::A' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_ExtendedStatsData_Subtract, B) == 0x000050, "Member 'StructBPFLibrary_ExtendedStatsData_Subtract::B' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_ExtendedStatsData_Subtract, ReturnValue) == 0x0000A0, "Member 'StructBPFLibrary_ExtendedStatsData_Subtract::ReturnValue' has a wrong offset!");

// Function Zion.StructBPFLibrary.GetTutorialVideo
// 0x01A0 (0x01A0 - 0x0000)
struct StructBPFLibrary_GetTutorialVideo final
{
public:
	struct FInventoryItemTutorialData             ItemTutorialData;                                  // 0x0000(0x0190)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class APlayerControllerZion*                  PlayerControllerZion;                              // 0x0190(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlatformMediaSource*                   ReturnValue;                                       // 0x0198(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StructBPFLibrary_GetTutorialVideo) == 0x000008, "Wrong alignment on StructBPFLibrary_GetTutorialVideo");
static_assert(sizeof(StructBPFLibrary_GetTutorialVideo) == 0x0001A0, "Wrong size on StructBPFLibrary_GetTutorialVideo");
static_assert(offsetof(StructBPFLibrary_GetTutorialVideo, ItemTutorialData) == 0x000000, "Member 'StructBPFLibrary_GetTutorialVideo::ItemTutorialData' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_GetTutorialVideo, PlayerControllerZion) == 0x000190, "Member 'StructBPFLibrary_GetTutorialVideo::PlayerControllerZion' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_GetTutorialVideo, ReturnValue) == 0x000198, "Member 'StructBPFLibrary_GetTutorialVideo::ReturnValue' has a wrong offset!");

// Function Zion.StructBPFLibrary.IsAbilityDataValid
// 0x00F0 (0x00F0 - 0x0000)
struct StructBPFLibrary_IsAbilityDataValid final
{
public:
	struct FAbilityData                           AbilityData;                                       // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00E0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0xF];                                       // 0x00E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StructBPFLibrary_IsAbilityDataValid) == 0x000010, "Wrong alignment on StructBPFLibrary_IsAbilityDataValid");
static_assert(sizeof(StructBPFLibrary_IsAbilityDataValid) == 0x0000F0, "Wrong size on StructBPFLibrary_IsAbilityDataValid");
static_assert(offsetof(StructBPFLibrary_IsAbilityDataValid, AbilityData) == 0x000000, "Member 'StructBPFLibrary_IsAbilityDataValid::AbilityData' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_IsAbilityDataValid, ReturnValue) == 0x0000E0, "Member 'StructBPFLibrary_IsAbilityDataValid::ReturnValue' has a wrong offset!");

// Function Zion.StructBPFLibrary.IsItemSkillDataValid
// 0x0290 (0x0290 - 0x0000)
struct StructBPFLibrary_IsItemSkillDataValid final
{
public:
	struct FInventoryItemSkillData                ItemData;                                          // 0x0000(0x0288)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0288(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StructBPFLibrary_IsItemSkillDataValid) == 0x000008, "Wrong alignment on StructBPFLibrary_IsItemSkillDataValid");
static_assert(sizeof(StructBPFLibrary_IsItemSkillDataValid) == 0x000290, "Wrong size on StructBPFLibrary_IsItemSkillDataValid");
static_assert(offsetof(StructBPFLibrary_IsItemSkillDataValid, ItemData) == 0x000000, "Member 'StructBPFLibrary_IsItemSkillDataValid::ItemData' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_IsItemSkillDataValid, ReturnValue) == 0x000288, "Member 'StructBPFLibrary_IsItemSkillDataValid::ReturnValue' has a wrong offset!");

// Function Zion.StructBPFLibrary.MovementModeMatch
// 0x0010 (0x0010 - 0x0000)
struct StructBPFLibrary_MovementModeMatch final
{
public:
	const class UCharacterMovementComponent*      CharacterMovementComponent;                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovementModeData                      MovementModeData;                                  // 0x0008(0x0002)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StructBPFLibrary_MovementModeMatch) == 0x000008, "Wrong alignment on StructBPFLibrary_MovementModeMatch");
static_assert(sizeof(StructBPFLibrary_MovementModeMatch) == 0x000010, "Wrong size on StructBPFLibrary_MovementModeMatch");
static_assert(offsetof(StructBPFLibrary_MovementModeMatch, CharacterMovementComponent) == 0x000000, "Member 'StructBPFLibrary_MovementModeMatch::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_MovementModeMatch, MovementModeData) == 0x000008, "Member 'StructBPFLibrary_MovementModeMatch::MovementModeData' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_MovementModeMatch, ReturnValue) == 0x00000A, "Member 'StructBPFLibrary_MovementModeMatch::ReturnValue' has a wrong offset!");

// Function Zion.StructBPFLibrary.MovementModeMatchAny
// 0x0020 (0x0020 - 0x0000)
struct StructBPFLibrary_MovementModeMatchAny final
{
public:
	const class UCharacterMovementComponent*      CharacterMovementComponent;                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMovementModeData>              MovementModeDataList;                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StructBPFLibrary_MovementModeMatchAny) == 0x000008, "Wrong alignment on StructBPFLibrary_MovementModeMatchAny");
static_assert(sizeof(StructBPFLibrary_MovementModeMatchAny) == 0x000020, "Wrong size on StructBPFLibrary_MovementModeMatchAny");
static_assert(offsetof(StructBPFLibrary_MovementModeMatchAny, CharacterMovementComponent) == 0x000000, "Member 'StructBPFLibrary_MovementModeMatchAny::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_MovementModeMatchAny, MovementModeDataList) == 0x000008, "Member 'StructBPFLibrary_MovementModeMatchAny::MovementModeDataList' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_MovementModeMatchAny, ReturnValue) == 0x000018, "Member 'StructBPFLibrary_MovementModeMatchAny::ReturnValue' has a wrong offset!");

// Function Zion.StructBPFLibrary.StatsLevelData_Add
// 0x00C0 (0x00C0 - 0x0000)
struct StructBPFLibrary_StatsLevelData_Add final
{
public:
	struct FStatsLevelData                        A;                                                 // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FStatsLevelData                        B;                                                 // 0x0040(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FStatsLevelData                        ReturnValue;                                       // 0x0080(0x0040)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StructBPFLibrary_StatsLevelData_Add) == 0x000008, "Wrong alignment on StructBPFLibrary_StatsLevelData_Add");
static_assert(sizeof(StructBPFLibrary_StatsLevelData_Add) == 0x0000C0, "Wrong size on StructBPFLibrary_StatsLevelData_Add");
static_assert(offsetof(StructBPFLibrary_StatsLevelData_Add, A) == 0x000000, "Member 'StructBPFLibrary_StatsLevelData_Add::A' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_StatsLevelData_Add, B) == 0x000040, "Member 'StructBPFLibrary_StatsLevelData_Add::B' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_StatsLevelData_Add, ReturnValue) == 0x000080, "Member 'StructBPFLibrary_StatsLevelData_Add::ReturnValue' has a wrong offset!");

// Function Zion.StructBPFLibrary.StatsLevelData_Subtract
// 0x00C0 (0x00C0 - 0x0000)
struct StructBPFLibrary_StatsLevelData_Subtract final
{
public:
	struct FStatsLevelData                        A;                                                 // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FStatsLevelData                        B;                                                 // 0x0040(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FStatsLevelData                        ReturnValue;                                       // 0x0080(0x0040)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StructBPFLibrary_StatsLevelData_Subtract) == 0x000008, "Wrong alignment on StructBPFLibrary_StatsLevelData_Subtract");
static_assert(sizeof(StructBPFLibrary_StatsLevelData_Subtract) == 0x0000C0, "Wrong size on StructBPFLibrary_StatsLevelData_Subtract");
static_assert(offsetof(StructBPFLibrary_StatsLevelData_Subtract, A) == 0x000000, "Member 'StructBPFLibrary_StatsLevelData_Subtract::A' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_StatsLevelData_Subtract, B) == 0x000040, "Member 'StructBPFLibrary_StatsLevelData_Subtract::B' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_StatsLevelData_Subtract, ReturnValue) == 0x000080, "Member 'StructBPFLibrary_StatsLevelData_Subtract::ReturnValue' has a wrong offset!");

// Function Zion.StructBPFLibrary.ToCurrencyValue
// 0x00A0 (0x00A0 - 0x0000)
struct StructBPFLibrary_ToCurrencyValue final
{
public:
	struct FCurrencyTransactionInfos              Info;                                              // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         AlreadyBoughtCount;                                // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurrencyValue                         ReturnValue;                                       // 0x0094(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StructBPFLibrary_ToCurrencyValue) == 0x000008, "Wrong alignment on StructBPFLibrary_ToCurrencyValue");
static_assert(sizeof(StructBPFLibrary_ToCurrencyValue) == 0x0000A0, "Wrong size on StructBPFLibrary_ToCurrencyValue");
static_assert(offsetof(StructBPFLibrary_ToCurrencyValue, Info) == 0x000000, "Member 'StructBPFLibrary_ToCurrencyValue::Info' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_ToCurrencyValue, AlreadyBoughtCount) == 0x000090, "Member 'StructBPFLibrary_ToCurrencyValue::AlreadyBoughtCount' has a wrong offset!");
static_assert(offsetof(StructBPFLibrary_ToCurrencyValue, ReturnValue) == 0x000094, "Member 'StructBPFLibrary_ToCurrencyValue::ReturnValue' has a wrong offset!");

// Function Zion.SummonComponent.GetOrSpawnSpirit
// 0x0010 (0x0010 - 0x0000)
struct SummonComponent_GetOrSpawnSpirit final
{
public:
	TSubclassOf<class ACharacterZionSpirit>       SpiritClass;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterZionSpirit*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SummonComponent_GetOrSpawnSpirit) == 0x000008, "Wrong alignment on SummonComponent_GetOrSpawnSpirit");
static_assert(sizeof(SummonComponent_GetOrSpawnSpirit) == 0x000010, "Wrong size on SummonComponent_GetOrSpawnSpirit");
static_assert(offsetof(SummonComponent_GetOrSpawnSpirit, SpiritClass) == 0x000000, "Member 'SummonComponent_GetOrSpawnSpirit::SpiritClass' has a wrong offset!");
static_assert(offsetof(SummonComponent_GetOrSpawnSpirit, ReturnValue) == 0x000008, "Member 'SummonComponent_GetOrSpawnSpirit::ReturnValue' has a wrong offset!");

// Function Zion.SummonComponent.IsSpiritSummoned
// 0x0010 (0x0010 - 0x0000)
struct SummonComponent_IsSpiritSummoned final
{
public:
	TSubclassOf<class ACharacterZionSpirit>       SpiritClass;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SummonComponent_IsSpiritSummoned) == 0x000008, "Wrong alignment on SummonComponent_IsSpiritSummoned");
static_assert(sizeof(SummonComponent_IsSpiritSummoned) == 0x000010, "Wrong size on SummonComponent_IsSpiritSummoned");
static_assert(offsetof(SummonComponent_IsSpiritSummoned, SpiritClass) == 0x000000, "Member 'SummonComponent_IsSpiritSummoned::SpiritClass' has a wrong offset!");
static_assert(offsetof(SummonComponent_IsSpiritSummoned, ReturnValue) == 0x000008, "Member 'SummonComponent_IsSpiritSummoned::ReturnValue' has a wrong offset!");

// Function Zion.SummonComponent.OnControllerChanged
// 0x0018 (0x0018 - 0x0000)
struct SummonComponent_OnControllerChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            OldController;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            NewController;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SummonComponent_OnControllerChanged) == 0x000008, "Wrong alignment on SummonComponent_OnControllerChanged");
static_assert(sizeof(SummonComponent_OnControllerChanged) == 0x000018, "Wrong size on SummonComponent_OnControllerChanged");
static_assert(offsetof(SummonComponent_OnControllerChanged, Pawn) == 0x000000, "Member 'SummonComponent_OnControllerChanged::Pawn' has a wrong offset!");
static_assert(offsetof(SummonComponent_OnControllerChanged, OldController) == 0x000008, "Member 'SummonComponent_OnControllerChanged::OldController' has a wrong offset!");
static_assert(offsetof(SummonComponent_OnControllerChanged, NewController) == 0x000010, "Member 'SummonComponent_OnControllerChanged::NewController' has a wrong offset!");

// Function Zion.SummonComponent.SummonSpirit
// 0x0070 (0x0070 - 0x0000)
struct SummonComponent_SummonSpirit final
{
public:
	TSubclassOf<class ACharacterZionSpirit>       SpiritClass;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FSpiritSummonParameters                SummonParameters;                                  // 0x0018(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	const class UInputAction*                     InvokedByInputAction;                              // 0x0050(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommandLayerType                             CommandLayerType;                                  // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UCommandSet*                      FallbackCommandSet;                                // 0x0060(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterZionSpirit*                   ReturnValue;                                       // 0x0068(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SummonComponent_SummonSpirit) == 0x000008, "Wrong alignment on SummonComponent_SummonSpirit");
static_assert(sizeof(SummonComponent_SummonSpirit) == 0x000070, "Wrong size on SummonComponent_SummonSpirit");
static_assert(offsetof(SummonComponent_SummonSpirit, SpiritClass) == 0x000000, "Member 'SummonComponent_SummonSpirit::SpiritClass' has a wrong offset!");
static_assert(offsetof(SummonComponent_SummonSpirit, CommandClasses) == 0x000008, "Member 'SummonComponent_SummonSpirit::CommandClasses' has a wrong offset!");
static_assert(offsetof(SummonComponent_SummonSpirit, SummonParameters) == 0x000018, "Member 'SummonComponent_SummonSpirit::SummonParameters' has a wrong offset!");
static_assert(offsetof(SummonComponent_SummonSpirit, InvokedByInputAction) == 0x000050, "Member 'SummonComponent_SummonSpirit::InvokedByInputAction' has a wrong offset!");
static_assert(offsetof(SummonComponent_SummonSpirit, CommandLayerType) == 0x000058, "Member 'SummonComponent_SummonSpirit::CommandLayerType' has a wrong offset!");
static_assert(offsetof(SummonComponent_SummonSpirit, FallbackCommandSet) == 0x000060, "Member 'SummonComponent_SummonSpirit::FallbackCommandSet' has a wrong offset!");
static_assert(offsetof(SummonComponent_SummonSpirit, ReturnValue) == 0x000068, "Member 'SummonComponent_SummonSpirit::ReturnValue' has a wrong offset!");

// Function Zion.SummonComponent.SummonSpiritFromCommand
// 0x0060 (0x0060 - 0x0000)
struct SummonComponent_SummonSpiritFromCommand final
{
public:
	TSubclassOf<class ACharacterZionSpirit>       SpiritClass;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCommand>>           CommandClasses;                                    // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FSpiritSummonParameters                SummonParameters;                                  // 0x0018(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	const class UCommand*                         SourceCommand;                                     // 0x0050(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterZionSpirit*                   ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SummonComponent_SummonSpiritFromCommand) == 0x000008, "Wrong alignment on SummonComponent_SummonSpiritFromCommand");
static_assert(sizeof(SummonComponent_SummonSpiritFromCommand) == 0x000060, "Wrong size on SummonComponent_SummonSpiritFromCommand");
static_assert(offsetof(SummonComponent_SummonSpiritFromCommand, SpiritClass) == 0x000000, "Member 'SummonComponent_SummonSpiritFromCommand::SpiritClass' has a wrong offset!");
static_assert(offsetof(SummonComponent_SummonSpiritFromCommand, CommandClasses) == 0x000008, "Member 'SummonComponent_SummonSpiritFromCommand::CommandClasses' has a wrong offset!");
static_assert(offsetof(SummonComponent_SummonSpiritFromCommand, SummonParameters) == 0x000018, "Member 'SummonComponent_SummonSpiritFromCommand::SummonParameters' has a wrong offset!");
static_assert(offsetof(SummonComponent_SummonSpiritFromCommand, SourceCommand) == 0x000050, "Member 'SummonComponent_SummonSpiritFromCommand::SourceCommand' has a wrong offset!");
static_assert(offsetof(SummonComponent_SummonSpiritFromCommand, ReturnValue) == 0x000058, "Member 'SummonComponent_SummonSpiritFromCommand::ReturnValue' has a wrong offset!");

// Function Zion.SummonIdleSpiritComponent.OnControllerChanged
// 0x0018 (0x0018 - 0x0000)
struct SummonIdleSpiritComponent_OnControllerChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            OldController;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            NewController;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SummonIdleSpiritComponent_OnControllerChanged) == 0x000008, "Wrong alignment on SummonIdleSpiritComponent_OnControllerChanged");
static_assert(sizeof(SummonIdleSpiritComponent_OnControllerChanged) == 0x000018, "Wrong size on SummonIdleSpiritComponent_OnControllerChanged");
static_assert(offsetof(SummonIdleSpiritComponent_OnControllerChanged, Pawn) == 0x000000, "Member 'SummonIdleSpiritComponent_OnControllerChanged::Pawn' has a wrong offset!");
static_assert(offsetof(SummonIdleSpiritComponent_OnControllerChanged, OldController) == 0x000008, "Member 'SummonIdleSpiritComponent_OnControllerChanged::OldController' has a wrong offset!");
static_assert(offsetof(SummonIdleSpiritComponent_OnControllerChanged, NewController) == 0x000010, "Member 'SummonIdleSpiritComponent_OnControllerChanged::NewController' has a wrong offset!");

// Function Zion.SummonIdleSpiritComponent.OnJustTriggeredInputAction
// 0x0008 (0x0008 - 0x0000)
struct SummonIdleSpiritComponent_OnJustTriggeredInputAction final
{
public:
	const class UInputAction*                     InputAction;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SummonIdleSpiritComponent_OnJustTriggeredInputAction) == 0x000008, "Wrong alignment on SummonIdleSpiritComponent_OnJustTriggeredInputAction");
static_assert(sizeof(SummonIdleSpiritComponent_OnJustTriggeredInputAction) == 0x000008, "Wrong size on SummonIdleSpiritComponent_OnJustTriggeredInputAction");
static_assert(offsetof(SummonIdleSpiritComponent_OnJustTriggeredInputAction, InputAction) == 0x000000, "Member 'SummonIdleSpiritComponent_OnJustTriggeredInputAction::InputAction' has a wrong offset!");

// Function Zion.SummonIdleSpiritComponent.OnPostStartCommand
// 0x0008 (0x0008 - 0x0000)
struct SummonIdleSpiritComponent_OnPostStartCommand final
{
public:
	const class UCommand*                         Command;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SummonIdleSpiritComponent_OnPostStartCommand) == 0x000008, "Wrong alignment on SummonIdleSpiritComponent_OnPostStartCommand");
static_assert(sizeof(SummonIdleSpiritComponent_OnPostStartCommand) == 0x000008, "Wrong size on SummonIdleSpiritComponent_OnPostStartCommand");
static_assert(offsetof(SummonIdleSpiritComponent_OnPostStartCommand, Command) == 0x000000, "Member 'SummonIdleSpiritComponent_OnPostStartCommand::Command' has a wrong offset!");

// Function Zion.SummonRestPointSpiritComponent.OnControllerChanged
// 0x0018 (0x0018 - 0x0000)
struct SummonRestPointSpiritComponent_OnControllerChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            OldController;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            NewController;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SummonRestPointSpiritComponent_OnControllerChanged) == 0x000008, "Wrong alignment on SummonRestPointSpiritComponent_OnControllerChanged");
static_assert(sizeof(SummonRestPointSpiritComponent_OnControllerChanged) == 0x000018, "Wrong size on SummonRestPointSpiritComponent_OnControllerChanged");
static_assert(offsetof(SummonRestPointSpiritComponent_OnControllerChanged, Pawn) == 0x000000, "Member 'SummonRestPointSpiritComponent_OnControllerChanged::Pawn' has a wrong offset!");
static_assert(offsetof(SummonRestPointSpiritComponent_OnControllerChanged, OldController) == 0x000008, "Member 'SummonRestPointSpiritComponent_OnControllerChanged::OldController' has a wrong offset!");
static_assert(offsetof(SummonRestPointSpiritComponent_OnControllerChanged, NewController) == 0x000010, "Member 'SummonRestPointSpiritComponent_OnControllerChanged::NewController' has a wrong offset!");

// Function Zion.SystemBPFLibrary.DoesGameVersionMatchesPakVersion
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_DoesGameVersionMatchesPakVersion final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_DoesGameVersionMatchesPakVersion) == 0x000001, "Wrong alignment on SystemBPFLibrary_DoesGameVersionMatchesPakVersion");
static_assert(sizeof(SystemBPFLibrary_DoesGameVersionMatchesPakVersion) == 0x000001, "Wrong size on SystemBPFLibrary_DoesGameVersionMatchesPakVersion");
static_assert(offsetof(SystemBPFLibrary_DoesGameVersionMatchesPakVersion, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_DoesGameVersionMatchesPakVersion::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.FlushTextureStreaming
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_FlushTextureStreaming final
{
public:
	bool                                          bDeferToEndFrame;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_FlushTextureStreaming) == 0x000001, "Wrong alignment on SystemBPFLibrary_FlushTextureStreaming");
static_assert(sizeof(SystemBPFLibrary_FlushTextureStreaming) == 0x000001, "Wrong size on SystemBPFLibrary_FlushTextureStreaming");
static_assert(offsetof(SystemBPFLibrary_FlushTextureStreaming, bDeferToEndFrame) == 0x000000, "Member 'SystemBPFLibrary_FlushTextureStreaming::bDeferToEndFrame' has a wrong offset!");

// Function Zion.SystemBPFLibrary.GetBinkURLFromPlatformMediaSource
// 0x0018 (0x0018 - 0x0000)
struct SystemBPFLibrary_GetBinkURLFromPlatformMediaSource final
{
public:
	const class UPlatformMediaSource*             PlatformMediaSource;                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_GetBinkURLFromPlatformMediaSource) == 0x000008, "Wrong alignment on SystemBPFLibrary_GetBinkURLFromPlatformMediaSource");
static_assert(sizeof(SystemBPFLibrary_GetBinkURLFromPlatformMediaSource) == 0x000018, "Wrong size on SystemBPFLibrary_GetBinkURLFromPlatformMediaSource");
static_assert(offsetof(SystemBPFLibrary_GetBinkURLFromPlatformMediaSource, PlatformMediaSource) == 0x000000, "Member 'SystemBPFLibrary_GetBinkURLFromPlatformMediaSource::PlatformMediaSource' has a wrong offset!");
static_assert(offsetof(SystemBPFLibrary_GetBinkURLFromPlatformMediaSource, ReturnValue) == 0x000008, "Member 'SystemBPFLibrary_GetBinkURLFromPlatformMediaSource::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.GetBuildPlatformType
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_GetBuildPlatformType final
{
public:
	EBuildPlatformType                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_GetBuildPlatformType) == 0x000001, "Wrong alignment on SystemBPFLibrary_GetBuildPlatformType");
static_assert(sizeof(SystemBPFLibrary_GetBuildPlatformType) == 0x000001, "Wrong size on SystemBPFLibrary_GetBuildPlatformType");
static_assert(offsetof(SystemBPFLibrary_GetBuildPlatformType, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_GetBuildPlatformType::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.GetGameBuildNumber
// 0x0004 (0x0004 - 0x0000)
struct SystemBPFLibrary_GetGameBuildNumber final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_GetGameBuildNumber) == 0x000004, "Wrong alignment on SystemBPFLibrary_GetGameBuildNumber");
static_assert(sizeof(SystemBPFLibrary_GetGameBuildNumber) == 0x000004, "Wrong size on SystemBPFLibrary_GetGameBuildNumber");
static_assert(offsetof(SystemBPFLibrary_GetGameBuildNumber, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_GetGameBuildNumber::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.GetGameVersion
// 0x0010 (0x0010 - 0x0000)
struct SystemBPFLibrary_GetGameVersion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_GetGameVersion) == 0x000008, "Wrong alignment on SystemBPFLibrary_GetGameVersion");
static_assert(sizeof(SystemBPFLibrary_GetGameVersion) == 0x000010, "Wrong size on SystemBPFLibrary_GetGameVersion");
static_assert(offsetof(SystemBPFLibrary_GetGameVersion, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_GetGameVersion::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.GetMoviePathFromMovieName
// 0x0020 (0x0020 - 0x0000)
struct SystemBPFLibrary_GetMoviePathFromMovieName final
{
public:
	class FString                                 MovieName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_GetMoviePathFromMovieName) == 0x000008, "Wrong alignment on SystemBPFLibrary_GetMoviePathFromMovieName");
static_assert(sizeof(SystemBPFLibrary_GetMoviePathFromMovieName) == 0x000020, "Wrong size on SystemBPFLibrary_GetMoviePathFromMovieName");
static_assert(offsetof(SystemBPFLibrary_GetMoviePathFromMovieName, MovieName) == 0x000000, "Member 'SystemBPFLibrary_GetMoviePathFromMovieName::MovieName' has a wrong offset!");
static_assert(offsetof(SystemBPFLibrary_GetMoviePathFromMovieName, ReturnValue) == 0x000010, "Member 'SystemBPFLibrary_GetMoviePathFromMovieName::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.GetRHIName
// 0x0010 (0x0010 - 0x0000)
struct SystemBPFLibrary_GetRHIName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_GetRHIName) == 0x000008, "Wrong alignment on SystemBPFLibrary_GetRHIName");
static_assert(sizeof(SystemBPFLibrary_GetRHIName) == 0x000010, "Wrong size on SystemBPFLibrary_GetRHIName");
static_assert(offsetof(SystemBPFLibrary_GetRHIName, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_GetRHIName::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.GetRuntimeTextureInfos
// 0x0018 (0x0018 - 0x0000)
struct SystemBPFLibrary_GetRuntimeTextureInfos final
{
public:
	const class UTexture2D*                       Texture2D;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_GetRuntimeTextureInfos) == 0x000008, "Wrong alignment on SystemBPFLibrary_GetRuntimeTextureInfos");
static_assert(sizeof(SystemBPFLibrary_GetRuntimeTextureInfos) == 0x000018, "Wrong size on SystemBPFLibrary_GetRuntimeTextureInfos");
static_assert(offsetof(SystemBPFLibrary_GetRuntimeTextureInfos, Texture2D) == 0x000000, "Member 'SystemBPFLibrary_GetRuntimeTextureInfos::Texture2D' has a wrong offset!");
static_assert(offsetof(SystemBPFLibrary_GetRuntimeTextureInfos, ReturnValue) == 0x000008, "Member 'SystemBPFLibrary_GetRuntimeTextureInfos::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.GetRuntimeTextureInfosFromGroup
// 0x0018 (0x0018 - 0x0000)
struct SystemBPFLibrary_GetRuntimeTextureInfosFromGroup final
{
public:
	ETextureGroup                                 TextureGroup;                                      // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_GetRuntimeTextureInfosFromGroup) == 0x000008, "Wrong alignment on SystemBPFLibrary_GetRuntimeTextureInfosFromGroup");
static_assert(sizeof(SystemBPFLibrary_GetRuntimeTextureInfosFromGroup) == 0x000018, "Wrong size on SystemBPFLibrary_GetRuntimeTextureInfosFromGroup");
static_assert(offsetof(SystemBPFLibrary_GetRuntimeTextureInfosFromGroup, TextureGroup) == 0x000000, "Member 'SystemBPFLibrary_GetRuntimeTextureInfosFromGroup::TextureGroup' has a wrong offset!");
static_assert(offsetof(SystemBPFLibrary_GetRuntimeTextureInfosFromGroup, ReturnValue) == 0x000008, "Member 'SystemBPFLibrary_GetRuntimeTextureInfosFromGroup::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.GetWindowedResolutions
// 0x0018 (0x0018 - 0x0000)
struct SystemBPFLibrary_GetWindowedResolutions final
{
public:
	TArray<struct FIntPoint>                      OutResolutions;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SystemBPFLibrary_GetWindowedResolutions) == 0x000008, "Wrong alignment on SystemBPFLibrary_GetWindowedResolutions");
static_assert(sizeof(SystemBPFLibrary_GetWindowedResolutions) == 0x000018, "Wrong size on SystemBPFLibrary_GetWindowedResolutions");
static_assert(offsetof(SystemBPFLibrary_GetWindowedResolutions, OutResolutions) == 0x000000, "Member 'SystemBPFLibrary_GetWindowedResolutions::OutResolutions' has a wrong offset!");
static_assert(offsetof(SystemBPFLibrary_GetWindowedResolutions, ReturnValue) == 0x000010, "Member 'SystemBPFLibrary_GetWindowedResolutions::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.IsBossRecollectionEnabled
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_IsBossRecollectionEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_IsBossRecollectionEnabled) == 0x000001, "Wrong alignment on SystemBPFLibrary_IsBossRecollectionEnabled");
static_assert(sizeof(SystemBPFLibrary_IsBossRecollectionEnabled) == 0x000001, "Wrong size on SystemBPFLibrary_IsBossRecollectionEnabled");
static_assert(offsetof(SystemBPFLibrary_IsBossRecollectionEnabled, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_IsBossRecollectionEnabled::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.IsCrashReportAllowedBuild
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_IsCrashReportAllowedBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_IsCrashReportAllowedBuild) == 0x000001, "Wrong alignment on SystemBPFLibrary_IsCrashReportAllowedBuild");
static_assert(sizeof(SystemBPFLibrary_IsCrashReportAllowedBuild) == 0x000001, "Wrong size on SystemBPFLibrary_IsCrashReportAllowedBuild");
static_assert(offsetof(SystemBPFLibrary_IsCrashReportAllowedBuild, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_IsCrashReportAllowedBuild::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.IsDemoBuild
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_IsDemoBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_IsDemoBuild) == 0x000001, "Wrong alignment on SystemBPFLibrary_IsDemoBuild");
static_assert(sizeof(SystemBPFLibrary_IsDemoBuild) == 0x000001, "Wrong size on SystemBPFLibrary_IsDemoBuild");
static_assert(offsetof(SystemBPFLibrary_IsDemoBuild, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_IsDemoBuild::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.IsEarlyAccessBuild
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_IsEarlyAccessBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_IsEarlyAccessBuild) == 0x000001, "Wrong alignment on SystemBPFLibrary_IsEarlyAccessBuild");
static_assert(sizeof(SystemBPFLibrary_IsEarlyAccessBuild) == 0x000001, "Wrong size on SystemBPFLibrary_IsEarlyAccessBuild");
static_assert(offsetof(SystemBPFLibrary_IsEarlyAccessBuild, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_IsEarlyAccessBuild::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.IsEditor
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_IsEditor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_IsEditor) == 0x000001, "Wrong alignment on SystemBPFLibrary_IsEditor");
static_assert(sizeof(SystemBPFLibrary_IsEditor) == 0x000001, "Wrong size on SystemBPFLibrary_IsEditor");
static_assert(offsetof(SystemBPFLibrary_IsEditor, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_IsEditor::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.IsNewGamePlusEnabled
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_IsNewGamePlusEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_IsNewGamePlusEnabled) == 0x000001, "Wrong alignment on SystemBPFLibrary_IsNewGamePlusEnabled");
static_assert(sizeof(SystemBPFLibrary_IsNewGamePlusEnabled) == 0x000001, "Wrong size on SystemBPFLibrary_IsNewGamePlusEnabled");
static_assert(offsetof(SystemBPFLibrary_IsNewGamePlusEnabled, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_IsNewGamePlusEnabled::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.IsPCBuild
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_IsPCBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_IsPCBuild) == 0x000001, "Wrong alignment on SystemBPFLibrary_IsPCBuild");
static_assert(sizeof(SystemBPFLibrary_IsPCBuild) == 0x000001, "Wrong size on SystemBPFLibrary_IsPCBuild");
static_assert(offsetof(SystemBPFLibrary_IsPCBuild, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_IsPCBuild::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.IsPlaystation4Build
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_IsPlaystation4Build final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_IsPlaystation4Build) == 0x000001, "Wrong alignment on SystemBPFLibrary_IsPlaystation4Build");
static_assert(sizeof(SystemBPFLibrary_IsPlaystation4Build) == 0x000001, "Wrong size on SystemBPFLibrary_IsPlaystation4Build");
static_assert(offsetof(SystemBPFLibrary_IsPlaystation4Build, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_IsPlaystation4Build::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.IsPlaystation5Build
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_IsPlaystation5Build final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_IsPlaystation5Build) == 0x000001, "Wrong alignment on SystemBPFLibrary_IsPlaystation5Build");
static_assert(sizeof(SystemBPFLibrary_IsPlaystation5Build) == 0x000001, "Wrong size on SystemBPFLibrary_IsPlaystation5Build");
static_assert(offsetof(SystemBPFLibrary_IsPlaystation5Build, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_IsPlaystation5Build::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.IsPlaystationBuild
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_IsPlaystationBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_IsPlaystationBuild) == 0x000001, "Wrong alignment on SystemBPFLibrary_IsPlaystationBuild");
static_assert(sizeof(SystemBPFLibrary_IsPlaystationBuild) == 0x000001, "Wrong size on SystemBPFLibrary_IsPlaystationBuild");
static_assert(offsetof(SystemBPFLibrary_IsPlaystationBuild, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_IsPlaystationBuild::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.IsShippingBuild
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_IsShippingBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_IsShippingBuild) == 0x000001, "Wrong alignment on SystemBPFLibrary_IsShippingBuild");
static_assert(sizeof(SystemBPFLibrary_IsShippingBuild) == 0x000001, "Wrong size on SystemBPFLibrary_IsShippingBuild");
static_assert(offsetof(SystemBPFLibrary_IsShippingBuild, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_IsShippingBuild::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.IsSwitchBuild
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_IsSwitchBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_IsSwitchBuild) == 0x000001, "Wrong alignment on SystemBPFLibrary_IsSwitchBuild");
static_assert(sizeof(SystemBPFLibrary_IsSwitchBuild) == 0x000001, "Wrong size on SystemBPFLibrary_IsSwitchBuild");
static_assert(offsetof(SystemBPFLibrary_IsSwitchBuild, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_IsSwitchBuild::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.IsUsing4KResolution
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_IsUsing4KResolution final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_IsUsing4KResolution) == 0x000001, "Wrong alignment on SystemBPFLibrary_IsUsing4KResolution");
static_assert(sizeof(SystemBPFLibrary_IsUsing4KResolution) == 0x000001, "Wrong size on SystemBPFLibrary_IsUsing4KResolution");
static_assert(offsetof(SystemBPFLibrary_IsUsing4KResolution, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_IsUsing4KResolution::ReturnValue' has a wrong offset!");

// Function Zion.SystemBPFLibrary.IsXboxFamilyBuild
// 0x0001 (0x0001 - 0x0000)
struct SystemBPFLibrary_IsXboxFamilyBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SystemBPFLibrary_IsXboxFamilyBuild) == 0x000001, "Wrong alignment on SystemBPFLibrary_IsXboxFamilyBuild");
static_assert(sizeof(SystemBPFLibrary_IsXboxFamilyBuild) == 0x000001, "Wrong size on SystemBPFLibrary_IsXboxFamilyBuild");
static_assert(offsetof(SystemBPFLibrary_IsXboxFamilyBuild, ReturnValue) == 0x000000, "Member 'SystemBPFLibrary_IsXboxFamilyBuild::ReturnValue' has a wrong offset!");

// Function Zion.TimeDilationAsyncAction.TimeDilation
// 0x0020 (0x0020 - 0x0000)
struct TimeDilationAsyncAction_TimeDilation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimedDilationData                     TimedDilation;                                     // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UTimeDilationAsyncAction*               ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimeDilationAsyncAction_TimeDilation) == 0x000008, "Wrong alignment on TimeDilationAsyncAction_TimeDilation");
static_assert(sizeof(TimeDilationAsyncAction_TimeDilation) == 0x000020, "Wrong size on TimeDilationAsyncAction_TimeDilation");
static_assert(offsetof(TimeDilationAsyncAction_TimeDilation, WorldContextObject) == 0x000000, "Member 'TimeDilationAsyncAction_TimeDilation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(TimeDilationAsyncAction_TimeDilation, TimedDilation) == 0x000008, "Member 'TimeDilationAsyncAction_TimeDilation::TimedDilation' has a wrong offset!");
static_assert(offsetof(TimeDilationAsyncAction_TimeDilation, ReturnValue) == 0x000018, "Member 'TimeDilationAsyncAction_TimeDilation::ReturnValue' has a wrong offset!");

// Function Zion.TimeManagerComponent.Get
// 0x0010 (0x0010 - 0x0000)
struct TimeManagerComponent_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTimeManagerComponent*                  ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimeManagerComponent_Get) == 0x000008, "Wrong alignment on TimeManagerComponent_Get");
static_assert(sizeof(TimeManagerComponent_Get) == 0x000010, "Wrong size on TimeManagerComponent_Get");
static_assert(offsetof(TimeManagerComponent_Get, WorldContextObject) == 0x000000, "Member 'TimeManagerComponent_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(TimeManagerComponent_Get, ReturnValue) == 0x000008, "Member 'TimeManagerComponent_Get::ReturnValue' has a wrong offset!");

// Function Zion.TimeManagerComponent.AddDilation
// 0x000C (0x000C - 0x0000)
struct TimeManagerComponent_AddDilation final
{
public:
	float                                         TimeDilationOverride;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0004(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimeManagerComponent_AddDilation) == 0x000004, "Wrong alignment on TimeManagerComponent_AddDilation");
static_assert(sizeof(TimeManagerComponent_AddDilation) == 0x00000C, "Wrong size on TimeManagerComponent_AddDilation");
static_assert(offsetof(TimeManagerComponent_AddDilation, TimeDilationOverride) == 0x000000, "Member 'TimeManagerComponent_AddDilation::TimeDilationOverride' has a wrong offset!");
static_assert(offsetof(TimeManagerComponent_AddDilation, Tag) == 0x000004, "Member 'TimeManagerComponent_AddDilation::Tag' has a wrong offset!");

// Function Zion.TimeManagerComponent.RemoveDilation
// 0x0008 (0x0008 - 0x0000)
struct TimeManagerComponent_RemoveDilation final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimeManagerComponent_RemoveDilation) == 0x000004, "Wrong alignment on TimeManagerComponent_RemoveDilation");
static_assert(sizeof(TimeManagerComponent_RemoveDilation) == 0x000008, "Wrong size on TimeManagerComponent_RemoveDilation");
static_assert(offsetof(TimeManagerComponent_RemoveDilation, Tag) == 0x000000, "Member 'TimeManagerComponent_RemoveDilation::Tag' has a wrong offset!");

// Function Zion.TimeManagerComponent.IsTimeDilationActive
// 0x000C (0x000C - 0x0000)
struct TimeManagerComponent_IsTimeDilationActive final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TimeManagerComponent_IsTimeDilationActive) == 0x000004, "Wrong alignment on TimeManagerComponent_IsTimeDilationActive");
static_assert(sizeof(TimeManagerComponent_IsTimeDilationActive) == 0x00000C, "Wrong size on TimeManagerComponent_IsTimeDilationActive");
static_assert(offsetof(TimeManagerComponent_IsTimeDilationActive, Tag) == 0x000000, "Member 'TimeManagerComponent_IsTimeDilationActive::Tag' has a wrong offset!");
static_assert(offsetof(TimeManagerComponent_IsTimeDilationActive, ReturnValue) == 0x000008, "Member 'TimeManagerComponent_IsTimeDilationActive::ReturnValue' has a wrong offset!");

// Function Zion.Trigger_RegisterRuntimeCheckpoint.OnPlayerEndOverlap
// 0x0008 (0x0008 - 0x0000)
struct Trigger_RegisterRuntimeCheckpoint_OnPlayerEndOverlap final
{
public:
	class AActor*                                 PlayerActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Trigger_RegisterRuntimeCheckpoint_OnPlayerEndOverlap) == 0x000008, "Wrong alignment on Trigger_RegisterRuntimeCheckpoint_OnPlayerEndOverlap");
static_assert(sizeof(Trigger_RegisterRuntimeCheckpoint_OnPlayerEndOverlap) == 0x000008, "Wrong size on Trigger_RegisterRuntimeCheckpoint_OnPlayerEndOverlap");
static_assert(offsetof(Trigger_RegisterRuntimeCheckpoint_OnPlayerEndOverlap, PlayerActor) == 0x000000, "Member 'Trigger_RegisterRuntimeCheckpoint_OnPlayerEndOverlap::PlayerActor' has a wrong offset!");

// Function Zion.UIComponent.OnReceivedDamage
// 0x0010 (0x0010 - 0x0000)
struct UIComponent_OnReceivedDamage final
{
public:
	class AActor*                                 Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageValue;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIComponent_OnReceivedDamage) == 0x000008, "Wrong alignment on UIComponent_OnReceivedDamage");
static_assert(sizeof(UIComponent_OnReceivedDamage) == 0x000010, "Wrong size on UIComponent_OnReceivedDamage");
static_assert(offsetof(UIComponent_OnReceivedDamage, Source) == 0x000000, "Member 'UIComponent_OnReceivedDamage::Source' has a wrong offset!");
static_assert(offsetof(UIComponent_OnReceivedDamage, DamageValue) == 0x000008, "Member 'UIComponent_OnReceivedDamage::DamageValue' has a wrong offset!");

// Function Zion.UIComponent.OnReceivedDamageData
// 0x0060 (0x0060 - 0x0000)
struct UIComponent_OnReceivedDamageData final
{
public:
	class AActor*                                 Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageData                            DamageData;                                        // 0x0008(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIComponent_OnReceivedDamageData) == 0x000008, "Wrong alignment on UIComponent_OnReceivedDamageData");
static_assert(sizeof(UIComponent_OnReceivedDamageData) == 0x000060, "Wrong size on UIComponent_OnReceivedDamageData");
static_assert(offsetof(UIComponent_OnReceivedDamageData, Source) == 0x000000, "Member 'UIComponent_OnReceivedDamageData::Source' has a wrong offset!");
static_assert(offsetof(UIComponent_OnReceivedDamageData, DamageData) == 0x000008, "Member 'UIComponent_OnReceivedDamageData::DamageData' has a wrong offset!");

// Function Zion.UIComponent.OnReceivedHeal
// 0x0010 (0x0010 - 0x0000)
struct UIComponent_OnReceivedHeal final
{
public:
	class AActor*                                 Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HealValue;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIComponent_OnReceivedHeal) == 0x000008, "Wrong alignment on UIComponent_OnReceivedHeal");
static_assert(sizeof(UIComponent_OnReceivedHeal) == 0x000010, "Wrong size on UIComponent_OnReceivedHeal");
static_assert(offsetof(UIComponent_OnReceivedHeal, Source) == 0x000000, "Member 'UIComponent_OnReceivedHeal::Source' has a wrong offset!");
static_assert(offsetof(UIComponent_OnReceivedHeal, HealValue) == 0x000008, "Member 'UIComponent_OnReceivedHeal::HealValue' has a wrong offset!");

// Function Zion.UMGBPFLibrary.AddToViewportAtLayer
// 0x0010 (0x0010 - 0x0000)
struct UMGBPFLibrary_AddToViewportAtLayer final
{
public:
	class UUserWidget*                            Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUMGLayer                                     UMGLayer;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UMGBPFLibrary_AddToViewportAtLayer) == 0x000008, "Wrong alignment on UMGBPFLibrary_AddToViewportAtLayer");
static_assert(sizeof(UMGBPFLibrary_AddToViewportAtLayer) == 0x000010, "Wrong size on UMGBPFLibrary_AddToViewportAtLayer");
static_assert(offsetof(UMGBPFLibrary_AddToViewportAtLayer, Widget) == 0x000000, "Member 'UMGBPFLibrary_AddToViewportAtLayer::Widget' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_AddToViewportAtLayer, UMGLayer) == 0x000008, "Member 'UMGBPFLibrary_AddToViewportAtLayer::UMGLayer' has a wrong offset!");

// Function Zion.UMGBPFLibrary.GetCompletionPercentageForItemType
// 0x0010 (0x0010 - 0x0000)
struct UMGBPFLibrary_GetCompletionPercentageForItemType final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventoryItemType                            ItemType;                                          // 0x0008(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UMGBPFLibrary_GetCompletionPercentageForItemType) == 0x000008, "Wrong alignment on UMGBPFLibrary_GetCompletionPercentageForItemType");
static_assert(sizeof(UMGBPFLibrary_GetCompletionPercentageForItemType) == 0x000010, "Wrong size on UMGBPFLibrary_GetCompletionPercentageForItemType");
static_assert(offsetof(UMGBPFLibrary_GetCompletionPercentageForItemType, WorldContextObject) == 0x000000, "Member 'UMGBPFLibrary_GetCompletionPercentageForItemType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_GetCompletionPercentageForItemType, ItemType) == 0x000008, "Member 'UMGBPFLibrary_GetCompletionPercentageForItemType::ItemType' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_GetCompletionPercentageForItemType, ReturnValue) == 0x00000C, "Member 'UMGBPFLibrary_GetCompletionPercentageForItemType::ReturnValue' has a wrong offset!");

// Function Zion.UMGBPFLibrary.GetFocusCause
// 0x000C (0x000C - 0x0000)
struct UMGBPFLibrary_GetFocusCause final
{
public:
	struct FFocusEvent                            FocusEvent;                                        // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EFocusCause                                   ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UMGBPFLibrary_GetFocusCause) == 0x000004, "Wrong alignment on UMGBPFLibrary_GetFocusCause");
static_assert(sizeof(UMGBPFLibrary_GetFocusCause) == 0x00000C, "Wrong size on UMGBPFLibrary_GetFocusCause");
static_assert(offsetof(UMGBPFLibrary_GetFocusCause, FocusEvent) == 0x000000, "Member 'UMGBPFLibrary_GetFocusCause::FocusEvent' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_GetFocusCause, ReturnValue) == 0x000008, "Member 'UMGBPFLibrary_GetFocusCause::ReturnValue' has a wrong offset!");

// Function Zion.UMGBPFLibrary.GetUMGZOrder
// 0x0008 (0x0008 - 0x0000)
struct UMGBPFLibrary_GetUMGZOrder final
{
public:
	EUMGLayer                                     UMGLayer;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UMGBPFLibrary_GetUMGZOrder) == 0x000004, "Wrong alignment on UMGBPFLibrary_GetUMGZOrder");
static_assert(sizeof(UMGBPFLibrary_GetUMGZOrder) == 0x000008, "Wrong size on UMGBPFLibrary_GetUMGZOrder");
static_assert(offsetof(UMGBPFLibrary_GetUMGZOrder, UMGLayer) == 0x000000, "Member 'UMGBPFLibrary_GetUMGZOrder::UMGLayer' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_GetUMGZOrder, ReturnValue) == 0x000004, "Member 'UMGBPFLibrary_GetUMGZOrder::ReturnValue' has a wrong offset!");

// Function Zion.UMGBPFLibrary.IsActionInputTypeKey
// 0x0028 (0x0028 - 0x0000)
struct UMGBPFLibrary_IsActionInputTypeKey final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionInputType                              ActionInputType;                                   // 0x0020(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UMGBPFLibrary_IsActionInputTypeKey) == 0x000008, "Wrong alignment on UMGBPFLibrary_IsActionInputTypeKey");
static_assert(sizeof(UMGBPFLibrary_IsActionInputTypeKey) == 0x000028, "Wrong size on UMGBPFLibrary_IsActionInputTypeKey");
static_assert(offsetof(UMGBPFLibrary_IsActionInputTypeKey, WorldContextObject) == 0x000000, "Member 'UMGBPFLibrary_IsActionInputTypeKey::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsActionInputTypeKey, Key) == 0x000008, "Member 'UMGBPFLibrary_IsActionInputTypeKey::Key' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsActionInputTypeKey, ActionInputType) == 0x000020, "Member 'UMGBPFLibrary_IsActionInputTypeKey::ActionInputType' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsActionInputTypeKey, ReturnValue) == 0x000021, "Member 'UMGBPFLibrary_IsActionInputTypeKey::ReturnValue' has a wrong offset!");

// Function Zion.UMGBPFLibrary.IsKeyUIInputType
// 0x0028 (0x0028 - 0x0000)
struct UMGBPFLibrary_IsKeyUIInputType final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIInputType                                  UIInputType;                                       // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UMGBPFLibrary_IsKeyUIInputType) == 0x000008, "Wrong alignment on UMGBPFLibrary_IsKeyUIInputType");
static_assert(sizeof(UMGBPFLibrary_IsKeyUIInputType) == 0x000028, "Wrong size on UMGBPFLibrary_IsKeyUIInputType");
static_assert(offsetof(UMGBPFLibrary_IsKeyUIInputType, WorldContextObject) == 0x000000, "Member 'UMGBPFLibrary_IsKeyUIInputType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsKeyUIInputType, Key) == 0x000008, "Member 'UMGBPFLibrary_IsKeyUIInputType::Key' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsKeyUIInputType, UIInputType) == 0x000020, "Member 'UMGBPFLibrary_IsKeyUIInputType::UIInputType' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsKeyUIInputType, ReturnValue) == 0x000021, "Member 'UMGBPFLibrary_IsKeyUIInputType::ReturnValue' has a wrong offset!");

// Function Zion.UMGBPFLibrary.IsRepeatKeyEvent
// 0x0048 (0x0048 - 0x0000)
struct UMGBPFLibrary_IsRepeatKeyEvent final
{
public:
	struct FKeyEvent                              KeyEvent;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UMGBPFLibrary_IsRepeatKeyEvent) == 0x000008, "Wrong alignment on UMGBPFLibrary_IsRepeatKeyEvent");
static_assert(sizeof(UMGBPFLibrary_IsRepeatKeyEvent) == 0x000048, "Wrong size on UMGBPFLibrary_IsRepeatKeyEvent");
static_assert(offsetof(UMGBPFLibrary_IsRepeatKeyEvent, KeyEvent) == 0x000000, "Member 'UMGBPFLibrary_IsRepeatKeyEvent::KeyEvent' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsRepeatKeyEvent, ReturnValue) == 0x000040, "Member 'UMGBPFLibrary_IsRepeatKeyEvent::ReturnValue' has a wrong offset!");

// Function Zion.UMGBPFLibrary.IsUICancelKey
// 0x0028 (0x0028 - 0x0000)
struct UMGBPFLibrary_IsUICancelKey final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UMGBPFLibrary_IsUICancelKey) == 0x000008, "Wrong alignment on UMGBPFLibrary_IsUICancelKey");
static_assert(sizeof(UMGBPFLibrary_IsUICancelKey) == 0x000028, "Wrong size on UMGBPFLibrary_IsUICancelKey");
static_assert(offsetof(UMGBPFLibrary_IsUICancelKey, WorldContextObject) == 0x000000, "Member 'UMGBPFLibrary_IsUICancelKey::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsUICancelKey, Key) == 0x000008, "Member 'UMGBPFLibrary_IsUICancelKey::Key' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsUICancelKey, ReturnValue) == 0x000020, "Member 'UMGBPFLibrary_IsUICancelKey::ReturnValue' has a wrong offset!");

// Function Zion.UMGBPFLibrary.IsUIConfirmKey
// 0x0028 (0x0028 - 0x0000)
struct UMGBPFLibrary_IsUIConfirmKey final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UMGBPFLibrary_IsUIConfirmKey) == 0x000008, "Wrong alignment on UMGBPFLibrary_IsUIConfirmKey");
static_assert(sizeof(UMGBPFLibrary_IsUIConfirmKey) == 0x000028, "Wrong size on UMGBPFLibrary_IsUIConfirmKey");
static_assert(offsetof(UMGBPFLibrary_IsUIConfirmKey, WorldContextObject) == 0x000000, "Member 'UMGBPFLibrary_IsUIConfirmKey::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsUIConfirmKey, Key) == 0x000008, "Member 'UMGBPFLibrary_IsUIConfirmKey::Key' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsUIConfirmKey, ReturnValue) == 0x000020, "Member 'UMGBPFLibrary_IsUIConfirmKey::ReturnValue' has a wrong offset!");

// Function Zion.UMGBPFLibrary.IsUIContextAltKey
// 0x0028 (0x0028 - 0x0000)
struct UMGBPFLibrary_IsUIContextAltKey final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UMGBPFLibrary_IsUIContextAltKey) == 0x000008, "Wrong alignment on UMGBPFLibrary_IsUIContextAltKey");
static_assert(sizeof(UMGBPFLibrary_IsUIContextAltKey) == 0x000028, "Wrong size on UMGBPFLibrary_IsUIContextAltKey");
static_assert(offsetof(UMGBPFLibrary_IsUIContextAltKey, WorldContextObject) == 0x000000, "Member 'UMGBPFLibrary_IsUIContextAltKey::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsUIContextAltKey, Key) == 0x000008, "Member 'UMGBPFLibrary_IsUIContextAltKey::Key' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsUIContextAltKey, ReturnValue) == 0x000020, "Member 'UMGBPFLibrary_IsUIContextAltKey::ReturnValue' has a wrong offset!");

// Function Zion.UMGBPFLibrary.IsUIContextKey
// 0x0028 (0x0028 - 0x0000)
struct UMGBPFLibrary_IsUIContextKey final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UMGBPFLibrary_IsUIContextKey) == 0x000008, "Wrong alignment on UMGBPFLibrary_IsUIContextKey");
static_assert(sizeof(UMGBPFLibrary_IsUIContextKey) == 0x000028, "Wrong size on UMGBPFLibrary_IsUIContextKey");
static_assert(offsetof(UMGBPFLibrary_IsUIContextKey, WorldContextObject) == 0x000000, "Member 'UMGBPFLibrary_IsUIContextKey::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsUIContextKey, Key) == 0x000008, "Member 'UMGBPFLibrary_IsUIContextKey::Key' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_IsUIContextKey, ReturnValue) == 0x000020, "Member 'UMGBPFLibrary_IsUIContextKey::ReturnValue' has a wrong offset!");

// Function Zion.UMGBPFLibrary.SetBrushFromSoftSprite
// 0x0038 (0x0038 - 0x0000)
struct UMGBPFLibrary_SetBrushFromSoftSprite final
{
public:
	class UImage*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            SoftSprite;                                        // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchSize;                                        // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UMGBPFLibrary_SetBrushFromSoftSprite) == 0x000008, "Wrong alignment on UMGBPFLibrary_SetBrushFromSoftSprite");
static_assert(sizeof(UMGBPFLibrary_SetBrushFromSoftSprite) == 0x000038, "Wrong size on UMGBPFLibrary_SetBrushFromSoftSprite");
static_assert(offsetof(UMGBPFLibrary_SetBrushFromSoftSprite, Target) == 0x000000, "Member 'UMGBPFLibrary_SetBrushFromSoftSprite::Target' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_SetBrushFromSoftSprite, SoftSprite) == 0x000008, "Member 'UMGBPFLibrary_SetBrushFromSoftSprite::SoftSprite' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_SetBrushFromSoftSprite, bMatchSize) == 0x000030, "Member 'UMGBPFLibrary_SetBrushFromSoftSprite::bMatchSize' has a wrong offset!");

// Function Zion.UMGBPFLibrary.SetBrushFromSoftSpriteAsync
// 0x0038 (0x0038 - 0x0000)
struct UMGBPFLibrary_SetBrushFromSoftSpriteAsync final
{
public:
	class UImage*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            SoftSprite;                                        // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchSize;                                        // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UMGBPFLibrary_SetBrushFromSoftSpriteAsync) == 0x000008, "Wrong alignment on UMGBPFLibrary_SetBrushFromSoftSpriteAsync");
static_assert(sizeof(UMGBPFLibrary_SetBrushFromSoftSpriteAsync) == 0x000038, "Wrong size on UMGBPFLibrary_SetBrushFromSoftSpriteAsync");
static_assert(offsetof(UMGBPFLibrary_SetBrushFromSoftSpriteAsync, Target) == 0x000000, "Member 'UMGBPFLibrary_SetBrushFromSoftSpriteAsync::Target' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_SetBrushFromSoftSpriteAsync, SoftSprite) == 0x000008, "Member 'UMGBPFLibrary_SetBrushFromSoftSpriteAsync::SoftSprite' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_SetBrushFromSoftSpriteAsync, bMatchSize) == 0x000030, "Member 'UMGBPFLibrary_SetBrushFromSoftSpriteAsync::bMatchSize' has a wrong offset!");

// Function Zion.UMGBPFLibrary.SetBrushFromSprite
// 0x0018 (0x0018 - 0x0000)
struct UMGBPFLibrary_SetBrushFromSprite final
{
public:
	class UImage*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPaperSprite*                           Sprite;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchSize;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UMGBPFLibrary_SetBrushFromSprite) == 0x000008, "Wrong alignment on UMGBPFLibrary_SetBrushFromSprite");
static_assert(sizeof(UMGBPFLibrary_SetBrushFromSprite) == 0x000018, "Wrong size on UMGBPFLibrary_SetBrushFromSprite");
static_assert(offsetof(UMGBPFLibrary_SetBrushFromSprite, Target) == 0x000000, "Member 'UMGBPFLibrary_SetBrushFromSprite::Target' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_SetBrushFromSprite, Sprite) == 0x000008, "Member 'UMGBPFLibrary_SetBrushFromSprite::Sprite' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_SetBrushFromSprite, bMatchSize) == 0x000010, "Member 'UMGBPFLibrary_SetBrushFromSprite::bMatchSize' has a wrong offset!");

// Function Zion.UMGBPFLibrary.ShouldDisplayCompletionWidget
// 0x0001 (0x0001 - 0x0000)
struct UMGBPFLibrary_ShouldDisplayCompletionWidget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UMGBPFLibrary_ShouldDisplayCompletionWidget) == 0x000001, "Wrong alignment on UMGBPFLibrary_ShouldDisplayCompletionWidget");
static_assert(sizeof(UMGBPFLibrary_ShouldDisplayCompletionWidget) == 0x000001, "Wrong size on UMGBPFLibrary_ShouldDisplayCompletionWidget");
static_assert(offsetof(UMGBPFLibrary_ShouldDisplayCompletionWidget, ReturnValue) == 0x000000, "Member 'UMGBPFLibrary_ShouldDisplayCompletionWidget::ReturnValue' has a wrong offset!");

// Function Zion.UMGBPFLibrary.ShouldDisplayExtraUnavailableCharacters
// 0x0010 (0x0010 - 0x0000)
struct UMGBPFLibrary_ShouldDisplayExtraUnavailableCharacters final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UMGBPFLibrary_ShouldDisplayExtraUnavailableCharacters) == 0x000008, "Wrong alignment on UMGBPFLibrary_ShouldDisplayExtraUnavailableCharacters");
static_assert(sizeof(UMGBPFLibrary_ShouldDisplayExtraUnavailableCharacters) == 0x000010, "Wrong size on UMGBPFLibrary_ShouldDisplayExtraUnavailableCharacters");
static_assert(offsetof(UMGBPFLibrary_ShouldDisplayExtraUnavailableCharacters, WorldContextObject) == 0x000000, "Member 'UMGBPFLibrary_ShouldDisplayExtraUnavailableCharacters::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UMGBPFLibrary_ShouldDisplayExtraUnavailableCharacters, ReturnValue) == 0x000008, "Member 'UMGBPFLibrary_ShouldDisplayExtraUnavailableCharacters::ReturnValue' has a wrong offset!");

// Function Zion.UMGSubsystem.Get
// 0x0010 (0x0010 - 0x0000)
struct UMGSubsystem_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGSubsystem*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UMGSubsystem_Get) == 0x000008, "Wrong alignment on UMGSubsystem_Get");
static_assert(sizeof(UMGSubsystem_Get) == 0x000010, "Wrong size on UMGSubsystem_Get");
static_assert(offsetof(UMGSubsystem_Get, WorldContextObject) == 0x000000, "Member 'UMGSubsystem_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UMGSubsystem_Get, ReturnValue) == 0x000008, "Member 'UMGSubsystem_Get::ReturnValue' has a wrong offset!");

// Function Zion.UMGSubsystem.LockNavigation
// 0x0008 (0x0008 - 0x0000)
struct UMGSubsystem_LockNavigation final
{
public:
	class UUserWidget*                            LockSource;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UMGSubsystem_LockNavigation) == 0x000008, "Wrong alignment on UMGSubsystem_LockNavigation");
static_assert(sizeof(UMGSubsystem_LockNavigation) == 0x000008, "Wrong size on UMGSubsystem_LockNavigation");
static_assert(offsetof(UMGSubsystem_LockNavigation, LockSource) == 0x000000, "Member 'UMGSubsystem_LockNavigation::LockSource' has a wrong offset!");

// Function Zion.UMGSubsystem.RemapKey
// 0x0020 (0x0020 - 0x0000)
struct UMGSubsystem_RemapKey final
{
public:
	EUIInputType                                  UIInputType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UMGSubsystem_RemapKey) == 0x000008, "Wrong alignment on UMGSubsystem_RemapKey");
static_assert(sizeof(UMGSubsystem_RemapKey) == 0x000020, "Wrong size on UMGSubsystem_RemapKey");
static_assert(offsetof(UMGSubsystem_RemapKey, UIInputType) == 0x000000, "Member 'UMGSubsystem_RemapKey::UIInputType' has a wrong offset!");
static_assert(offsetof(UMGSubsystem_RemapKey, Key) == 0x000008, "Member 'UMGSubsystem_RemapKey::Key' has a wrong offset!");

// Function Zion.UMGSubsystem.RestoreDefaultBindings
// 0x0001 (0x0001 - 0x0000)
struct UMGSubsystem_RestoreDefaultBindings final
{
public:
	bool                                          bGamepad;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UMGSubsystem_RestoreDefaultBindings) == 0x000001, "Wrong alignment on UMGSubsystem_RestoreDefaultBindings");
static_assert(sizeof(UMGSubsystem_RestoreDefaultBindings) == 0x000001, "Wrong size on UMGSubsystem_RestoreDefaultBindings");
static_assert(offsetof(UMGSubsystem_RestoreDefaultBindings, bGamepad) == 0x000000, "Member 'UMGSubsystem_RestoreDefaultBindings::bGamepad' has a wrong offset!");

// Function Zion.UMGSubsystem.SetActiveExplanationWidget
// 0x0008 (0x0008 - 0x0000)
struct UMGSubsystem_SetActiveExplanationWidget final
{
public:
	class UUserWidgetExplanation*                 ExplanationWidget;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UMGSubsystem_SetActiveExplanationWidget) == 0x000008, "Wrong alignment on UMGSubsystem_SetActiveExplanationWidget");
static_assert(sizeof(UMGSubsystem_SetActiveExplanationWidget) == 0x000008, "Wrong size on UMGSubsystem_SetActiveExplanationWidget");
static_assert(offsetof(UMGSubsystem_SetActiveExplanationWidget, ExplanationWidget) == 0x000000, "Member 'UMGSubsystem_SetActiveExplanationWidget::ExplanationWidget' has a wrong offset!");

// Function Zion.UMGSubsystem.SetActiveFooter
// 0x0008 (0x0008 - 0x0000)
struct UMGSubsystem_SetActiveFooter final
{
public:
	class UUserWidgetFooter*                      Footer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UMGSubsystem_SetActiveFooter) == 0x000008, "Wrong alignment on UMGSubsystem_SetActiveFooter");
static_assert(sizeof(UMGSubsystem_SetActiveFooter) == 0x000008, "Wrong size on UMGSubsystem_SetActiveFooter");
static_assert(offsetof(UMGSubsystem_SetActiveFooter, Footer) == 0x000000, "Member 'UMGSubsystem_SetActiveFooter::Footer' has a wrong offset!");

// Function Zion.UMGSubsystem.UnlockNavigation
// 0x0008 (0x0008 - 0x0000)
struct UMGSubsystem_UnlockNavigation final
{
public:
	class UUserWidget*                            LockSource;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UMGSubsystem_UnlockNavigation) == 0x000008, "Wrong alignment on UMGSubsystem_UnlockNavigation");
static_assert(sizeof(UMGSubsystem_UnlockNavigation) == 0x000008, "Wrong size on UMGSubsystem_UnlockNavigation");
static_assert(offsetof(UMGSubsystem_UnlockNavigation, LockSource) == 0x000000, "Member 'UMGSubsystem_UnlockNavigation::LockSource' has a wrong offset!");

// Function Zion.UMGSubsystem.GetActiveExplanationWidget
// 0x0008 (0x0008 - 0x0000)
struct UMGSubsystem_GetActiveExplanationWidget final
{
public:
	class UUserWidgetExplanation*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UMGSubsystem_GetActiveExplanationWidget) == 0x000008, "Wrong alignment on UMGSubsystem_GetActiveExplanationWidget");
static_assert(sizeof(UMGSubsystem_GetActiveExplanationWidget) == 0x000008, "Wrong size on UMGSubsystem_GetActiveExplanationWidget");
static_assert(offsetof(UMGSubsystem_GetActiveExplanationWidget, ReturnValue) == 0x000000, "Member 'UMGSubsystem_GetActiveExplanationWidget::ReturnValue' has a wrong offset!");

// Function Zion.UMGSubsystem.GetActiveFooter
// 0x0008 (0x0008 - 0x0000)
struct UMGSubsystem_GetActiveFooter final
{
public:
	class UUserWidgetFooter*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UMGSubsystem_GetActiveFooter) == 0x000008, "Wrong alignment on UMGSubsystem_GetActiveFooter");
static_assert(sizeof(UMGSubsystem_GetActiveFooter) == 0x000008, "Wrong size on UMGSubsystem_GetActiveFooter");
static_assert(offsetof(UMGSubsystem_GetActiveFooter, ReturnValue) == 0x000000, "Member 'UMGSubsystem_GetActiveFooter::ReturnValue' has a wrong offset!");

// Function Zion.UMGSubsystem.IsFocusingFromMouse
// 0x0001 (0x0001 - 0x0000)
struct UMGSubsystem_IsFocusingFromMouse final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UMGSubsystem_IsFocusingFromMouse) == 0x000001, "Wrong alignment on UMGSubsystem_IsFocusingFromMouse");
static_assert(sizeof(UMGSubsystem_IsFocusingFromMouse) == 0x000001, "Wrong size on UMGSubsystem_IsFocusingFromMouse");
static_assert(offsetof(UMGSubsystem_IsFocusingFromMouse, ReturnValue) == 0x000000, "Member 'UMGSubsystem_IsFocusingFromMouse::ReturnValue' has a wrong offset!");

// Function Zion.UMGSubsystem.IsNavigationLocked
// 0x0001 (0x0001 - 0x0000)
struct UMGSubsystem_IsNavigationLocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UMGSubsystem_IsNavigationLocked) == 0x000001, "Wrong alignment on UMGSubsystem_IsNavigationLocked");
static_assert(sizeof(UMGSubsystem_IsNavigationLocked) == 0x000001, "Wrong size on UMGSubsystem_IsNavigationLocked");
static_assert(offsetof(UMGSubsystem_IsNavigationLocked, ReturnValue) == 0x000000, "Member 'UMGSubsystem_IsNavigationLocked::ReturnValue' has a wrong offset!");

// Function Zion.UniformGridPanelZion.AddChildAuto
// 0x0008 (0x0008 - 0x0000)
struct UniformGridPanelZion_AddChildAuto final
{
public:
	class UWidget*                                Content;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UniformGridPanelZion_AddChildAuto) == 0x000008, "Wrong alignment on UniformGridPanelZion_AddChildAuto");
static_assert(sizeof(UniformGridPanelZion_AddChildAuto) == 0x000008, "Wrong size on UniformGridPanelZion_AddChildAuto");
static_assert(offsetof(UniformGridPanelZion_AddChildAuto, Content) == 0x000000, "Member 'UniformGridPanelZion_AddChildAuto::Content' has a wrong offset!");

// Function Zion.UniformGridPanelZion.GetElementCountPerRow
// 0x0004 (0x0004 - 0x0000)
struct UniformGridPanelZion_GetElementCountPerRow final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UniformGridPanelZion_GetElementCountPerRow) == 0x000004, "Wrong alignment on UniformGridPanelZion_GetElementCountPerRow");
static_assert(sizeof(UniformGridPanelZion_GetElementCountPerRow) == 0x000004, "Wrong size on UniformGridPanelZion_GetElementCountPerRow");
static_assert(offsetof(UniformGridPanelZion_GetElementCountPerRow, ReturnValue) == 0x000000, "Member 'UniformGridPanelZion_GetElementCountPerRow::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetAchievementNotificationHolder.OnLaunchAchievementNotification
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetAchievementNotificationHolder_OnLaunchAchievementNotification final
{
public:
	class FName                                   AchievementID;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetAchievementNotificationHolder_OnLaunchAchievementNotification) == 0x000004, "Wrong alignment on UserWidgetAchievementNotificationHolder_OnLaunchAchievementNotification");
static_assert(sizeof(UserWidgetAchievementNotificationHolder_OnLaunchAchievementNotification) == 0x000008, "Wrong size on UserWidgetAchievementNotificationHolder_OnLaunchAchievementNotification");
static_assert(offsetof(UserWidgetAchievementNotificationHolder_OnLaunchAchievementNotification, AchievementID) == 0x000000, "Member 'UserWidgetAchievementNotificationHolder_OnLaunchAchievementNotification::AchievementID' has a wrong offset!");

// Function Zion.UserWidgetAchievementNotificationHolder.OnRefreshVisibility
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetAchievementNotificationHolder_OnRefreshVisibility final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetAchievementNotificationHolder_OnRefreshVisibility) == 0x000001, "Wrong alignment on UserWidgetAchievementNotificationHolder_OnRefreshVisibility");
static_assert(sizeof(UserWidgetAchievementNotificationHolder_OnRefreshVisibility) == 0x000001, "Wrong size on UserWidgetAchievementNotificationHolder_OnRefreshVisibility");
static_assert(offsetof(UserWidgetAchievementNotificationHolder_OnRefreshVisibility, bVisible) == 0x000000, "Member 'UserWidgetAchievementNotificationHolder_OnRefreshVisibility::bVisible' has a wrong offset!");

// Function Zion.UserWidgetAchievementNotificationHolder.QueueAchievementNotification
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetAchievementNotificationHolder_QueueAchievementNotification final
{
public:
	class FName                                   AchievementID;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetAchievementNotificationHolder_QueueAchievementNotification) == 0x000004, "Wrong alignment on UserWidgetAchievementNotificationHolder_QueueAchievementNotification");
static_assert(sizeof(UserWidgetAchievementNotificationHolder_QueueAchievementNotification) == 0x000008, "Wrong size on UserWidgetAchievementNotificationHolder_QueueAchievementNotification");
static_assert(offsetof(UserWidgetAchievementNotificationHolder_QueueAchievementNotification, AchievementID) == 0x000000, "Member 'UserWidgetAchievementNotificationHolder_QueueAchievementNotification::AchievementID' has a wrong offset!");

// Function Zion.UserWidgetButton.OnFocusStateChanged
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetButton_OnFocusStateChanged final
{
public:
	bool                                          bFocused;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetButton_OnFocusStateChanged) == 0x000001, "Wrong alignment on UserWidgetButton_OnFocusStateChanged");
static_assert(sizeof(UserWidgetButton_OnFocusStateChanged) == 0x000001, "Wrong size on UserWidgetButton_OnFocusStateChanged");
static_assert(offsetof(UserWidgetButton_OnFocusStateChanged, bFocused) == 0x000000, "Member 'UserWidgetButton_OnFocusStateChanged::bFocused' has a wrong offset!");

// Function Zion.UserWidgetCurrencyCounter.AddCurrency
// 0x000C (0x000C - 0x0000)
struct UserWidgetCurrencyCounter_AddCurrency final
{
public:
	ECurrencyType                                 InCurrencyType;                                    // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AddedCount;                                        // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviousCount;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetCurrencyCounter_AddCurrency) == 0x000004, "Wrong alignment on UserWidgetCurrencyCounter_AddCurrency");
static_assert(sizeof(UserWidgetCurrencyCounter_AddCurrency) == 0x00000C, "Wrong size on UserWidgetCurrencyCounter_AddCurrency");
static_assert(offsetof(UserWidgetCurrencyCounter_AddCurrency, InCurrencyType) == 0x000000, "Member 'UserWidgetCurrencyCounter_AddCurrency::InCurrencyType' has a wrong offset!");
static_assert(offsetof(UserWidgetCurrencyCounter_AddCurrency, AddedCount) == 0x000004, "Member 'UserWidgetCurrencyCounter_AddCurrency::AddedCount' has a wrong offset!");
static_assert(offsetof(UserWidgetCurrencyCounter_AddCurrency, PreviousCount) == 0x000008, "Member 'UserWidgetCurrencyCounter_AddCurrency::PreviousCount' has a wrong offset!");

// Function Zion.UserWidgetCurrencyCounter.OnSetAccumulatedCurrencyText
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetCurrencyCounter_OnSetAccumulatedCurrencyText final
{
public:
	int32                                         Currency;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetCurrencyCounter_OnSetAccumulatedCurrencyText) == 0x000004, "Wrong alignment on UserWidgetCurrencyCounter_OnSetAccumulatedCurrencyText");
static_assert(sizeof(UserWidgetCurrencyCounter_OnSetAccumulatedCurrencyText) == 0x000004, "Wrong size on UserWidgetCurrencyCounter_OnSetAccumulatedCurrencyText");
static_assert(offsetof(UserWidgetCurrencyCounter_OnSetAccumulatedCurrencyText, Currency) == 0x000000, "Member 'UserWidgetCurrencyCounter_OnSetAccumulatedCurrencyText::Currency' has a wrong offset!");

// Function Zion.UserWidgetCurrencyCounter.OnSetCurrencyText
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetCurrencyCounter_OnSetCurrencyText final
{
public:
	int32                                         Currency;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetCurrencyCounter_OnSetCurrencyText) == 0x000004, "Wrong alignment on UserWidgetCurrencyCounter_OnSetCurrencyText");
static_assert(sizeof(UserWidgetCurrencyCounter_OnSetCurrencyText) == 0x000004, "Wrong size on UserWidgetCurrencyCounter_OnSetCurrencyText");
static_assert(offsetof(UserWidgetCurrencyCounter_OnSetCurrencyText, Currency) == 0x000000, "Member 'UserWidgetCurrencyCounter_OnSetCurrencyText::Currency' has a wrong offset!");

// Function Zion.UserWidgetCurrencyCounter.SetAccumulatedCurrencyText
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetCurrencyCounter_SetAccumulatedCurrencyText final
{
public:
	int32                                         Currency;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetCurrencyCounter_SetAccumulatedCurrencyText) == 0x000004, "Wrong alignment on UserWidgetCurrencyCounter_SetAccumulatedCurrencyText");
static_assert(sizeof(UserWidgetCurrencyCounter_SetAccumulatedCurrencyText) == 0x000004, "Wrong size on UserWidgetCurrencyCounter_SetAccumulatedCurrencyText");
static_assert(offsetof(UserWidgetCurrencyCounter_SetAccumulatedCurrencyText, Currency) == 0x000000, "Member 'UserWidgetCurrencyCounter_SetAccumulatedCurrencyText::Currency' has a wrong offset!");

// Function Zion.UserWidgetCurrencyCounter.SetCurrencyText
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetCurrencyCounter_SetCurrencyText final
{
public:
	int32                                         Currency;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetCurrencyCounter_SetCurrencyText) == 0x000004, "Wrong alignment on UserWidgetCurrencyCounter_SetCurrencyText");
static_assert(sizeof(UserWidgetCurrencyCounter_SetCurrencyText) == 0x000004, "Wrong size on UserWidgetCurrencyCounter_SetCurrencyText");
static_assert(offsetof(UserWidgetCurrencyCounter_SetCurrencyText, Currency) == 0x000000, "Member 'UserWidgetCurrencyCounter_SetCurrencyText::Currency' has a wrong offset!");

// Function Zion.UserWidgetCurrencyCounter.Show
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetCurrencyCounter_Show final
{
public:
	bool                                          bRefreshCurrencyText;                              // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetCurrencyCounter_Show) == 0x000001, "Wrong alignment on UserWidgetCurrencyCounter_Show");
static_assert(sizeof(UserWidgetCurrencyCounter_Show) == 0x000001, "Wrong size on UserWidgetCurrencyCounter_Show");
static_assert(offsetof(UserWidgetCurrencyCounter_Show, bRefreshCurrencyText) == 0x000000, "Member 'UserWidgetCurrencyCounter_Show::bRefreshCurrencyText' has a wrong offset!");

// Function Zion.UserWidgetCurrencyCounter.StartAccumulatingCurrency
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetCurrencyCounter_StartAccumulatingCurrency final
{
public:
	int32                                         InAccumulatedCurrency;                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetCurrencyCounter_StartAccumulatingCurrency) == 0x000004, "Wrong alignment on UserWidgetCurrencyCounter_StartAccumulatingCurrency");
static_assert(sizeof(UserWidgetCurrencyCounter_StartAccumulatingCurrency) == 0x000004, "Wrong size on UserWidgetCurrencyCounter_StartAccumulatingCurrency");
static_assert(offsetof(UserWidgetCurrencyCounter_StartAccumulatingCurrency, InAccumulatedCurrency) == 0x000000, "Member 'UserWidgetCurrencyCounter_StartAccumulatingCurrency::InAccumulatedCurrency' has a wrong offset!");

// Function Zion.UserWidgetCurrencyCounter.GetCurrencyFromInventory
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetCurrencyCounter_GetCurrencyFromInventory final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetCurrencyCounter_GetCurrencyFromInventory) == 0x000004, "Wrong alignment on UserWidgetCurrencyCounter_GetCurrencyFromInventory");
static_assert(sizeof(UserWidgetCurrencyCounter_GetCurrencyFromInventory) == 0x000004, "Wrong size on UserWidgetCurrencyCounter_GetCurrencyFromInventory");
static_assert(offsetof(UserWidgetCurrencyCounter_GetCurrencyFromInventory, ReturnValue) == 0x000000, "Member 'UserWidgetCurrencyCounter_GetCurrencyFromInventory::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetCurrencyCounter.GetCurrencyType
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetCurrencyCounter_GetCurrencyType final
{
public:
	ECurrencyType                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetCurrencyCounter_GetCurrencyType) == 0x000001, "Wrong alignment on UserWidgetCurrencyCounter_GetCurrencyType");
static_assert(sizeof(UserWidgetCurrencyCounter_GetCurrencyType) == 0x000001, "Wrong size on UserWidgetCurrencyCounter_GetCurrencyType");
static_assert(offsetof(UserWidgetCurrencyCounter_GetCurrencyType, ReturnValue) == 0x000000, "Member 'UserWidgetCurrencyCounter_GetCurrencyType::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetCursor.SetVisible
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetCursor_SetVisible final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetCursor_SetVisible) == 0x000001, "Wrong alignment on UserWidgetCursor_SetVisible");
static_assert(sizeof(UserWidgetCursor_SetVisible) == 0x000001, "Wrong size on UserWidgetCursor_SetVisible");
static_assert(offsetof(UserWidgetCursor_SetVisible, bVisible) == 0x000000, "Member 'UserWidgetCursor_SetVisible::bVisible' has a wrong offset!");

// Function Zion.UserWidgetEnemyUI.OnRequestRemoveFromParent
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetEnemyUI_OnRequestRemoveFromParent final
{
public:
	bool                                          bImmediate;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetEnemyUI_OnRequestRemoveFromParent) == 0x000001, "Wrong alignment on UserWidgetEnemyUI_OnRequestRemoveFromParent");
static_assert(sizeof(UserWidgetEnemyUI_OnRequestRemoveFromParent) == 0x000001, "Wrong size on UserWidgetEnemyUI_OnRequestRemoveFromParent");
static_assert(offsetof(UserWidgetEnemyUI_OnRequestRemoveFromParent, bImmediate) == 0x000000, "Member 'UserWidgetEnemyUI_OnRequestRemoveFromParent::bImmediate' has a wrong offset!");

// Function Zion.UserWidgetEnemyUI.GetController
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetEnemyUI_GetController final
{
public:
	class AAIController*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetEnemyUI_GetController) == 0x000008, "Wrong alignment on UserWidgetEnemyUI_GetController");
static_assert(sizeof(UserWidgetEnemyUI_GetController) == 0x000008, "Wrong size on UserWidgetEnemyUI_GetController");
static_assert(offsetof(UserWidgetEnemyUI_GetController, ReturnValue) == 0x000000, "Member 'UserWidgetEnemyUI_GetController::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetEnemyUI.GetEnemyData
// 0x0130 (0x0130 - 0x0000)
struct UserWidgetEnemyUI_GetEnemyData final
{
public:
	struct FEnemyData                             ReturnValue;                                       // 0x0000(0x0130)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetEnemyUI_GetEnemyData) == 0x000008, "Wrong alignment on UserWidgetEnemyUI_GetEnemyData");
static_assert(sizeof(UserWidgetEnemyUI_GetEnemyData) == 0x000130, "Wrong size on UserWidgetEnemyUI_GetEnemyData");
static_assert(offsetof(UserWidgetEnemyUI_GetEnemyData, ReturnValue) == 0x000000, "Member 'UserWidgetEnemyUI_GetEnemyData::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetEnemyUI.GetPawn
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetEnemyUI_GetPawn final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetEnemyUI_GetPawn) == 0x000008, "Wrong alignment on UserWidgetEnemyUI_GetPawn");
static_assert(sizeof(UserWidgetEnemyUI_GetPawn) == 0x000008, "Wrong size on UserWidgetEnemyUI_GetPawn");
static_assert(offsetof(UserWidgetEnemyUI_GetPawn, ReturnValue) == 0x000000, "Member 'UserWidgetEnemyUI_GetPawn::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetExplanation.SetExplanationText
// 0x0030 (0x0030 - 0x0000)
struct UserWidgetExplanation_SetExplanationText final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FRichTextInputElement>          InputElements;                                     // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FString>                         StringElements;                                    // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetExplanation_SetExplanationText) == 0x000008, "Wrong alignment on UserWidgetExplanation_SetExplanationText");
static_assert(sizeof(UserWidgetExplanation_SetExplanationText) == 0x000030, "Wrong size on UserWidgetExplanation_SetExplanationText");
static_assert(offsetof(UserWidgetExplanation_SetExplanationText, Text) == 0x000000, "Member 'UserWidgetExplanation_SetExplanationText::Text' has a wrong offset!");
static_assert(offsetof(UserWidgetExplanation_SetExplanationText, InputElements) == 0x000010, "Member 'UserWidgetExplanation_SetExplanationText::InputElements' has a wrong offset!");
static_assert(offsetof(UserWidgetExplanation_SetExplanationText, StringElements) == 0x000020, "Member 'UserWidgetExplanation_SetExplanationText::StringElements' has a wrong offset!");

// Function Zion.UserWidgetExtraDialogGalleryImage.MoveImage
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetExtraDialogGalleryImage_MoveImage final
{
public:
	struct FVector2D                              InMoveDelta;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetExtraDialogGalleryImage_MoveImage) == 0x000008, "Wrong alignment on UserWidgetExtraDialogGalleryImage_MoveImage");
static_assert(sizeof(UserWidgetExtraDialogGalleryImage_MoveImage) == 0x000010, "Wrong size on UserWidgetExtraDialogGalleryImage_MoveImage");
static_assert(offsetof(UserWidgetExtraDialogGalleryImage_MoveImage, InMoveDelta) == 0x000000, "Member 'UserWidgetExtraDialogGalleryImage_MoveImage::InMoveDelta' has a wrong offset!");

// Function Zion.UserWidgetExtraDialogGalleryImage.PlaceImage
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetExtraDialogGalleryImage_PlaceImage final
{
public:
	struct FVector2D                              NewImagePosition;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetExtraDialogGalleryImage_PlaceImage) == 0x000008, "Wrong alignment on UserWidgetExtraDialogGalleryImage_PlaceImage");
static_assert(sizeof(UserWidgetExtraDialogGalleryImage_PlaceImage) == 0x000010, "Wrong size on UserWidgetExtraDialogGalleryImage_PlaceImage");
static_assert(offsetof(UserWidgetExtraDialogGalleryImage_PlaceImage, NewImagePosition) == 0x000000, "Member 'UserWidgetExtraDialogGalleryImage_PlaceImage::NewImagePosition' has a wrong offset!");

// Function Zion.UserWidgetExtraDialogGalleryImage.GetCurrentScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetExtraDialogGalleryImage_GetCurrentScaleFactor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetExtraDialogGalleryImage_GetCurrentScaleFactor) == 0x000004, "Wrong alignment on UserWidgetExtraDialogGalleryImage_GetCurrentScaleFactor");
static_assert(sizeof(UserWidgetExtraDialogGalleryImage_GetCurrentScaleFactor) == 0x000004, "Wrong size on UserWidgetExtraDialogGalleryImage_GetCurrentScaleFactor");
static_assert(offsetof(UserWidgetExtraDialogGalleryImage_GetCurrentScaleFactor, ReturnValue) == 0x000000, "Member 'UserWidgetExtraDialogGalleryImage_GetCurrentScaleFactor::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetExtraDialogSpineViewer.OnAfterUpdateWorldTransform
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetExtraDialogSpineViewer_OnAfterUpdateWorldTransform final
{
public:
	class USpineWidget*                           Skeleton;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetExtraDialogSpineViewer_OnAfterUpdateWorldTransform) == 0x000008, "Wrong alignment on UserWidgetExtraDialogSpineViewer_OnAfterUpdateWorldTransform");
static_assert(sizeof(UserWidgetExtraDialogSpineViewer_OnAfterUpdateWorldTransform) == 0x000008, "Wrong size on UserWidgetExtraDialogSpineViewer_OnAfterUpdateWorldTransform");
static_assert(offsetof(UserWidgetExtraDialogSpineViewer_OnAfterUpdateWorldTransform, Skeleton) == 0x000000, "Member 'UserWidgetExtraDialogSpineViewer_OnAfterUpdateWorldTransform::Skeleton' has a wrong offset!");

// Function Zion.UserWidgetExtraDialogSpineViewer.OnSpineAnimationFinished
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetExtraDialogSpineViewer_OnSpineAnimationFinished final
{
public:
	class UTrackEntry*                            TrackEntry;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetExtraDialogSpineViewer_OnSpineAnimationFinished) == 0x000008, "Wrong alignment on UserWidgetExtraDialogSpineViewer_OnSpineAnimationFinished");
static_assert(sizeof(UserWidgetExtraDialogSpineViewer_OnSpineAnimationFinished) == 0x000008, "Wrong size on UserWidgetExtraDialogSpineViewer_OnSpineAnimationFinished");
static_assert(offsetof(UserWidgetExtraDialogSpineViewer_OnSpineAnimationFinished, TrackEntry) == 0x000000, "Member 'UserWidgetExtraDialogSpineViewer_OnSpineAnimationFinished::TrackEntry' has a wrong offset!");

// Function Zion.UserWidgetExtraDialogSpineViewer.PlayAdditionalAnimations
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetExtraDialogSpineViewer_PlayAdditionalAnimations final
{
public:
	TArray<class FString>                         AdditionalAnimations;                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetExtraDialogSpineViewer_PlayAdditionalAnimations) == 0x000008, "Wrong alignment on UserWidgetExtraDialogSpineViewer_PlayAdditionalAnimations");
static_assert(sizeof(UserWidgetExtraDialogSpineViewer_PlayAdditionalAnimations) == 0x000010, "Wrong size on UserWidgetExtraDialogSpineViewer_PlayAdditionalAnimations");
static_assert(offsetof(UserWidgetExtraDialogSpineViewer_PlayAdditionalAnimations, AdditionalAnimations) == 0x000000, "Member 'UserWidgetExtraDialogSpineViewer_PlayAdditionalAnimations::AdditionalAnimations' has a wrong offset!");

// Function Zion.UserWidgetExtraDialogSpineViewer.PlaySpineAnimation
// 0x0038 (0x0038 - 0x0000)
struct UserWidgetExtraDialogSpineViewer_PlaySpineAnimation final
{
public:
	struct FAnimationNameData                     AnimationNameData;                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	EExtraAnimationRootMotionMode                 RootMotionMode;                                    // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserWidgetExtraDialogSpineViewer_PlaySpineAnimation) == 0x000008, "Wrong alignment on UserWidgetExtraDialogSpineViewer_PlaySpineAnimation");
static_assert(sizeof(UserWidgetExtraDialogSpineViewer_PlaySpineAnimation) == 0x000038, "Wrong size on UserWidgetExtraDialogSpineViewer_PlaySpineAnimation");
static_assert(offsetof(UserWidgetExtraDialogSpineViewer_PlaySpineAnimation, AnimationNameData) == 0x000000, "Member 'UserWidgetExtraDialogSpineViewer_PlaySpineAnimation::AnimationNameData' has a wrong offset!");
static_assert(offsetof(UserWidgetExtraDialogSpineViewer_PlaySpineAnimation, RootMotionMode) == 0x000030, "Member 'UserWidgetExtraDialogSpineViewer_PlaySpineAnimation::RootMotionMode' has a wrong offset!");

// Function Zion.UserWidgetExtraDialogSpineViewer.SetupMinMaxPositions
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetExtraDialogSpineViewer_SetupMinMaxPositions final
{
public:
	float                                         MinScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetExtraDialogSpineViewer_SetupMinMaxPositions) == 0x000004, "Wrong alignment on UserWidgetExtraDialogSpineViewer_SetupMinMaxPositions");
static_assert(sizeof(UserWidgetExtraDialogSpineViewer_SetupMinMaxPositions) == 0x000004, "Wrong size on UserWidgetExtraDialogSpineViewer_SetupMinMaxPositions");
static_assert(offsetof(UserWidgetExtraDialogSpineViewer_SetupMinMaxPositions, MinScaleFactor) == 0x000000, "Member 'UserWidgetExtraDialogSpineViewer_SetupMinMaxPositions::MinScaleFactor' has a wrong offset!");

// Function Zion.UserWidgetExtraDialogSpineViewer.CanMoveSpineViewer
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetExtraDialogSpineViewer_CanMoveSpineViewer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetExtraDialogSpineViewer_CanMoveSpineViewer) == 0x000001, "Wrong alignment on UserWidgetExtraDialogSpineViewer_CanMoveSpineViewer");
static_assert(sizeof(UserWidgetExtraDialogSpineViewer_CanMoveSpineViewer) == 0x000001, "Wrong size on UserWidgetExtraDialogSpineViewer_CanMoveSpineViewer");
static_assert(offsetof(UserWidgetExtraDialogSpineViewer_CanMoveSpineViewer, ReturnValue) == 0x000000, "Member 'UserWidgetExtraDialogSpineViewer_CanMoveSpineViewer::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetFade.LaunchFadeIn
// 0x0014 (0x0014 - 0x0000)
struct UserWidgetFade_LaunchFadeIn final
{
public:
	struct FFadeParameters                        FadeParameters;                                    // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetFade_LaunchFadeIn) == 0x000004, "Wrong alignment on UserWidgetFade_LaunchFadeIn");
static_assert(sizeof(UserWidgetFade_LaunchFadeIn) == 0x000014, "Wrong size on UserWidgetFade_LaunchFadeIn");
static_assert(offsetof(UserWidgetFade_LaunchFadeIn, FadeParameters) == 0x000000, "Member 'UserWidgetFade_LaunchFadeIn::FadeParameters' has a wrong offset!");

// Function Zion.UserWidgetFade.LaunchFadeOut
// 0x0014 (0x0014 - 0x0000)
struct UserWidgetFade_LaunchFadeOut final
{
public:
	struct FFadeParameters                        FadeParameters;                                    // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetFade_LaunchFadeOut) == 0x000004, "Wrong alignment on UserWidgetFade_LaunchFadeOut");
static_assert(sizeof(UserWidgetFade_LaunchFadeOut) == 0x000014, "Wrong size on UserWidgetFade_LaunchFadeOut");
static_assert(offsetof(UserWidgetFade_LaunchFadeOut, FadeParameters) == 0x000000, "Member 'UserWidgetFade_LaunchFadeOut::FadeParameters' has a wrong offset!");

// Function Zion.UserWidgetFade.SetupFadeIn
// 0x0014 (0x0014 - 0x0000)
struct UserWidgetFade_SetupFadeIn final
{
public:
	struct FFadeParameters                        FadeParameters;                                    // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetFade_SetupFadeIn) == 0x000004, "Wrong alignment on UserWidgetFade_SetupFadeIn");
static_assert(sizeof(UserWidgetFade_SetupFadeIn) == 0x000014, "Wrong size on UserWidgetFade_SetupFadeIn");
static_assert(offsetof(UserWidgetFade_SetupFadeIn, FadeParameters) == 0x000000, "Member 'UserWidgetFade_SetupFadeIn::FadeParameters' has a wrong offset!");

// Function Zion.UserWidgetFieldTalkHolder.OnFinishFieldTalk
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetFieldTalkHolder_OnFinishFieldTalk final
{
public:
	bool                                          bSkipActiveFieldTalk;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetFieldTalkHolder_OnFinishFieldTalk) == 0x000001, "Wrong alignment on UserWidgetFieldTalkHolder_OnFinishFieldTalk");
static_assert(sizeof(UserWidgetFieldTalkHolder_OnFinishFieldTalk) == 0x000001, "Wrong size on UserWidgetFieldTalkHolder_OnFinishFieldTalk");
static_assert(offsetof(UserWidgetFieldTalkHolder_OnFinishFieldTalk, bSkipActiveFieldTalk) == 0x000000, "Member 'UserWidgetFieldTalkHolder_OnFinishFieldTalk::bSkipActiveFieldTalk' has a wrong offset!");

// Function Zion.UserWidgetFieldTalkHolder.OnShowText
// 0x0028 (0x0028 - 0x0000)
struct UserWidgetFieldTalkHolder_OnShowText final
{
public:
	struct FFieldTalkEntry                        FieldTalkEntry;                                    // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetFieldTalkHolder_OnShowText) == 0x000008, "Wrong alignment on UserWidgetFieldTalkHolder_OnShowText");
static_assert(sizeof(UserWidgetFieldTalkHolder_OnShowText) == 0x000028, "Wrong size on UserWidgetFieldTalkHolder_OnShowText");
static_assert(offsetof(UserWidgetFieldTalkHolder_OnShowText, FieldTalkEntry) == 0x000000, "Member 'UserWidgetFieldTalkHolder_OnShowText::FieldTalkEntry' has a wrong offset!");

// Function Zion.UserWidgetFieldTalkHolder.IsUIReady
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetFieldTalkHolder_IsUIReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetFieldTalkHolder_IsUIReady) == 0x000001, "Wrong alignment on UserWidgetFieldTalkHolder_IsUIReady");
static_assert(sizeof(UserWidgetFieldTalkHolder_IsUIReady) == 0x000001, "Wrong size on UserWidgetFieldTalkHolder_IsUIReady");
static_assert(offsetof(UserWidgetFieldTalkHolder_IsUIReady, ReturnValue) == 0x000000, "Member 'UserWidgetFieldTalkHolder_IsUIReady::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetFooter.AddEntries
// 0x0018 (0x0018 - 0x0000)
struct UserWidgetFooter_AddEntries final
{
public:
	TArray<struct FFooterData>                    FooterDataList;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTemporary;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserWidgetFooter_AddEntries) == 0x000008, "Wrong alignment on UserWidgetFooter_AddEntries");
static_assert(sizeof(UserWidgetFooter_AddEntries) == 0x000018, "Wrong size on UserWidgetFooter_AddEntries");
static_assert(offsetof(UserWidgetFooter_AddEntries, FooterDataList) == 0x000000, "Member 'UserWidgetFooter_AddEntries::FooterDataList' has a wrong offset!");
static_assert(offsetof(UserWidgetFooter_AddEntries, bTemporary) == 0x000010, "Member 'UserWidgetFooter_AddEntries::bTemporary' has a wrong offset!");

// Function Zion.UserWidgetFooter.AddEntry
// 0x0060 (0x0060 - 0x0000)
struct UserWidgetFooter_AddEntry final
{
public:
	struct FFooterData                            FooterData;                                        // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTemporary;                                        // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserWidgetFooter_AddEntry) == 0x000008, "Wrong alignment on UserWidgetFooter_AddEntry");
static_assert(sizeof(UserWidgetFooter_AddEntry) == 0x000060, "Wrong size on UserWidgetFooter_AddEntry");
static_assert(offsetof(UserWidgetFooter_AddEntry, FooterData) == 0x000000, "Member 'UserWidgetFooter_AddEntry::FooterData' has a wrong offset!");
static_assert(offsetof(UserWidgetFooter_AddEntry, bTemporary) == 0x000058, "Member 'UserWidgetFooter_AddEntry::bTemporary' has a wrong offset!");

// Function Zion.UserWidgetFooter.ClearEntries
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetFooter_ClearEntries final
{
public:
	bool                                          bTemporaryOnly;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetFooter_ClearEntries) == 0x000001, "Wrong alignment on UserWidgetFooter_ClearEntries");
static_assert(sizeof(UserWidgetFooter_ClearEntries) == 0x000001, "Wrong size on UserWidgetFooter_ClearEntries");
static_assert(offsetof(UserWidgetFooter_ClearEntries, bTemporaryOnly) == 0x000000, "Member 'UserWidgetFooter_ClearEntries::bTemporaryOnly' has a wrong offset!");

// Function Zion.UserWidgetFooter.SetEntriesVisible
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetFooter_SetEntriesVisible final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetFooter_SetEntriesVisible) == 0x000001, "Wrong alignment on UserWidgetFooter_SetEntriesVisible");
static_assert(sizeof(UserWidgetFooter_SetEntriesVisible) == 0x000001, "Wrong size on UserWidgetFooter_SetEntriesVisible");
static_assert(offsetof(UserWidgetFooter_SetEntriesVisible, bVisible) == 0x000000, "Member 'UserWidgetFooter_SetEntriesVisible::bVisible' has a wrong offset!");

// Function Zion.UserWidgetFooter.Setup
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetFooter_Setup final
{
public:
	TArray<struct FFooterData>                    FooterDataList;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetFooter_Setup) == 0x000008, "Wrong alignment on UserWidgetFooter_Setup");
static_assert(sizeof(UserWidgetFooter_Setup) == 0x000010, "Wrong size on UserWidgetFooter_Setup");
static_assert(offsetof(UserWidgetFooter_Setup, FooterDataList) == 0x000000, "Member 'UserWidgetFooter_Setup::FooterDataList' has a wrong offset!");

// Function Zion.UserWidgetGameMenu.GoToPage
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetGameMenu_GoToPage final
{
public:
	int32                                         PageIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetGameMenu_GoToPage) == 0x000004, "Wrong alignment on UserWidgetGameMenu_GoToPage");
static_assert(sizeof(UserWidgetGameMenu_GoToPage) == 0x000004, "Wrong size on UserWidgetGameMenu_GoToPage");
static_assert(offsetof(UserWidgetGameMenu_GoToPage, PageIndex) == 0x000000, "Member 'UserWidgetGameMenu_GoToPage::PageIndex' has a wrong offset!");

// Function Zion.UserWidgetGameMenu.NotifyFastTravelRequested
// 0x0090 (0x0090 - 0x0000)
struct UserWidgetGameMenu_NotifyFastTravelRequested final
{
public:
	class FName                                   RestPointID;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRestPointData                         RestPointData;                                     // 0x0008(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetGameMenu_NotifyFastTravelRequested) == 0x000008, "Wrong alignment on UserWidgetGameMenu_NotifyFastTravelRequested");
static_assert(sizeof(UserWidgetGameMenu_NotifyFastTravelRequested) == 0x000090, "Wrong size on UserWidgetGameMenu_NotifyFastTravelRequested");
static_assert(offsetof(UserWidgetGameMenu_NotifyFastTravelRequested, RestPointID) == 0x000000, "Member 'UserWidgetGameMenu_NotifyFastTravelRequested::RestPointID' has a wrong offset!");
static_assert(offsetof(UserWidgetGameMenu_NotifyFastTravelRequested, RestPointData) == 0x000008, "Member 'UserWidgetGameMenu_NotifyFastTravelRequested::RestPointData' has a wrong offset!");

// Function Zion.UserWidgetGameMenu.OnFastTravelRequested
// 0x0090 (0x0090 - 0x0000)
struct UserWidgetGameMenu_OnFastTravelRequested final
{
public:
	class FName                                   RestPointID;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRestPointData                         RestPointData;                                     // 0x0008(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetGameMenu_OnFastTravelRequested) == 0x000008, "Wrong alignment on UserWidgetGameMenu_OnFastTravelRequested");
static_assert(sizeof(UserWidgetGameMenu_OnFastTravelRequested) == 0x000090, "Wrong size on UserWidgetGameMenu_OnFastTravelRequested");
static_assert(offsetof(UserWidgetGameMenu_OnFastTravelRequested, RestPointID) == 0x000000, "Member 'UserWidgetGameMenu_OnFastTravelRequested::RestPointID' has a wrong offset!");
static_assert(offsetof(UserWidgetGameMenu_OnFastTravelRequested, RestPointData) == 0x000008, "Member 'UserWidgetGameMenu_OnFastTravelRequested::RestPointData' has a wrong offset!");

// Function Zion.UserWidgetGameMenu.OnPageChanged
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetGameMenu_OnPageChanged final
{
public:
	int32                                         NewPageIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetGameMenu_OnPageChanged) == 0x000004, "Wrong alignment on UserWidgetGameMenu_OnPageChanged");
static_assert(sizeof(UserWidgetGameMenu_OnPageChanged) == 0x000004, "Wrong size on UserWidgetGameMenu_OnPageChanged");
static_assert(offsetof(UserWidgetGameMenu_OnPageChanged, NewPageIndex) == 0x000000, "Member 'UserWidgetGameMenu_OnPageChanged::NewPageIndex' has a wrong offset!");

// Function Zion.UserWidgetGameMenu.CanSwitchEquipment
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetGameMenu_CanSwitchEquipment final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetGameMenu_CanSwitchEquipment) == 0x000001, "Wrong alignment on UserWidgetGameMenu_CanSwitchEquipment");
static_assert(sizeof(UserWidgetGameMenu_CanSwitchEquipment) == 0x000001, "Wrong size on UserWidgetGameMenu_CanSwitchEquipment");
static_assert(offsetof(UserWidgetGameMenu_CanSwitchEquipment, ReturnValue) == 0x000000, "Member 'UserWidgetGameMenu_CanSwitchEquipment::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetGameMenu.GetCurrentPageIndex
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetGameMenu_GetCurrentPageIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetGameMenu_GetCurrentPageIndex) == 0x000004, "Wrong alignment on UserWidgetGameMenu_GetCurrentPageIndex");
static_assert(sizeof(UserWidgetGameMenu_GetCurrentPageIndex) == 0x000004, "Wrong size on UserWidgetGameMenu_GetCurrentPageIndex");
static_assert(offsetof(UserWidgetGameMenu_GetCurrentPageIndex, ReturnValue) == 0x000000, "Member 'UserWidgetGameMenu_GetCurrentPageIndex::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetGameMenu.GetFooter
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetGameMenu_GetFooter final
{
public:
	class UUserWidgetFooter*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetGameMenu_GetFooter) == 0x000008, "Wrong alignment on UserWidgetGameMenu_GetFooter");
static_assert(sizeof(UserWidgetGameMenu_GetFooter) == 0x000008, "Wrong size on UserWidgetGameMenu_GetFooter");
static_assert(offsetof(UserWidgetGameMenu_GetFooter, ReturnValue) == 0x000000, "Member 'UserWidgetGameMenu_GetFooter::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetGameMenu.GetPageCount
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetGameMenu_GetPageCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetGameMenu_GetPageCount) == 0x000004, "Wrong alignment on UserWidgetGameMenu_GetPageCount");
static_assert(sizeof(UserWidgetGameMenu_GetPageCount) == 0x000004, "Wrong size on UserWidgetGameMenu_GetPageCount");
static_assert(offsetof(UserWidgetGameMenu_GetPageCount, ReturnValue) == 0x000000, "Member 'UserWidgetGameMenu_GetPageCount::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetGameMenu.IsAtRestPoint
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetGameMenu_IsAtRestPoint final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetGameMenu_IsAtRestPoint) == 0x000001, "Wrong alignment on UserWidgetGameMenu_IsAtRestPoint");
static_assert(sizeof(UserWidgetGameMenu_IsAtRestPoint) == 0x000001, "Wrong size on UserWidgetGameMenu_IsAtRestPoint");
static_assert(offsetof(UserWidgetGameMenu_IsAtRestPoint, ReturnValue) == 0x000000, "Member 'UserWidgetGameMenu_IsAtRestPoint::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetGameMenu_Page.CanSwitchEquipment
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetGameMenu_Page_CanSwitchEquipment final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetGameMenu_Page_CanSwitchEquipment) == 0x000001, "Wrong alignment on UserWidgetGameMenu_Page_CanSwitchEquipment");
static_assert(sizeof(UserWidgetGameMenu_Page_CanSwitchEquipment) == 0x000001, "Wrong size on UserWidgetGameMenu_Page_CanSwitchEquipment");
static_assert(offsetof(UserWidgetGameMenu_Page_CanSwitchEquipment, ReturnValue) == 0x000000, "Member 'UserWidgetGameMenu_Page_CanSwitchEquipment::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetGameMenu_Page.GetDefaultFooterEntries
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetGameMenu_Page_GetDefaultFooterEntries final
{
public:
	TArray<struct FFooterData>                    ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetGameMenu_Page_GetDefaultFooterEntries) == 0x000008, "Wrong alignment on UserWidgetGameMenu_Page_GetDefaultFooterEntries");
static_assert(sizeof(UserWidgetGameMenu_Page_GetDefaultFooterEntries) == 0x000010, "Wrong size on UserWidgetGameMenu_Page_GetDefaultFooterEntries");
static_assert(offsetof(UserWidgetGameMenu_Page_GetDefaultFooterEntries, ReturnValue) == 0x000000, "Member 'UserWidgetGameMenu_Page_GetDefaultFooterEntries::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetGameMenu_Page.GetFooter
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetGameMenu_Page_GetFooter final
{
public:
	class UUserWidgetFooter*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetGameMenu_Page_GetFooter) == 0x000008, "Wrong alignment on UserWidgetGameMenu_Page_GetFooter");
static_assert(sizeof(UserWidgetGameMenu_Page_GetFooter) == 0x000008, "Wrong size on UserWidgetGameMenu_Page_GetFooter");
static_assert(offsetof(UserWidgetGameMenu_Page_GetFooter, ReturnValue) == 0x000000, "Member 'UserWidgetGameMenu_Page_GetFooter::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetGameMenu_Page.GetGameMenu
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetGameMenu_Page_GetGameMenu final
{
public:
	class UUserWidgetGameMenu*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetGameMenu_Page_GetGameMenu) == 0x000008, "Wrong alignment on UserWidgetGameMenu_Page_GetGameMenu");
static_assert(sizeof(UserWidgetGameMenu_Page_GetGameMenu) == 0x000008, "Wrong size on UserWidgetGameMenu_Page_GetGameMenu");
static_assert(offsetof(UserWidgetGameMenu_Page_GetGameMenu, ReturnValue) == 0x000000, "Member 'UserWidgetGameMenu_Page_GetGameMenu::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetGameMenu_Page.IsAtRestPoint
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetGameMenu_Page_IsAtRestPoint final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetGameMenu_Page_IsAtRestPoint) == 0x000001, "Wrong alignment on UserWidgetGameMenu_Page_IsAtRestPoint");
static_assert(sizeof(UserWidgetGameMenu_Page_IsAtRestPoint) == 0x000001, "Wrong size on UserWidgetGameMenu_Page_IsAtRestPoint");
static_assert(offsetof(UserWidgetGameMenu_Page_IsAtRestPoint, ReturnValue) == 0x000000, "Member 'UserWidgetGameMenu_Page_IsAtRestPoint::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetLowHPFeedback.BindToActor
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetLowHPFeedback_BindToActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetLowHPFeedback_BindToActor) == 0x000008, "Wrong alignment on UserWidgetLowHPFeedback_BindToActor");
static_assert(sizeof(UserWidgetLowHPFeedback_BindToActor) == 0x000008, "Wrong size on UserWidgetLowHPFeedback_BindToActor");
static_assert(offsetof(UserWidgetLowHPFeedback_BindToActor, Actor) == 0x000000, "Member 'UserWidgetLowHPFeedback_BindToActor::Actor' has a wrong offset!");

// Function Zion.UserWidgetMap.ForceTargetIcon
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetMap_ForceTargetIcon final
{
public:
	class UUserWidgetMapIcon*                     Icon;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_ForceTargetIcon) == 0x000008, "Wrong alignment on UserWidgetMap_ForceTargetIcon");
static_assert(sizeof(UserWidgetMap_ForceTargetIcon) == 0x000008, "Wrong size on UserWidgetMap_ForceTargetIcon");
static_assert(offsetof(UserWidgetMap_ForceTargetIcon, Icon) == 0x000000, "Member 'UserWidgetMap_ForceTargetIcon::Icon' has a wrong offset!");

// Function Zion.UserWidgetMap.MoveMap
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetMap_MoveMap final
{
public:
	struct FVector2D                              InMoveDelta;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_MoveMap) == 0x000008, "Wrong alignment on UserWidgetMap_MoveMap");
static_assert(sizeof(UserWidgetMap_MoveMap) == 0x000010, "Wrong size on UserWidgetMap_MoveMap");
static_assert(offsetof(UserWidgetMap_MoveMap, InMoveDelta) == 0x000000, "Member 'UserWidgetMap_MoveMap::InMoveDelta' has a wrong offset!");

// Function Zion.UserWidgetMap.OnCalculateMapCompletionPercentage
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetMap_OnCalculateMapCompletionPercentage final
{
public:
	int32                                         Percentage;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_OnCalculateMapCompletionPercentage) == 0x000004, "Wrong alignment on UserWidgetMap_OnCalculateMapCompletionPercentage");
static_assert(sizeof(UserWidgetMap_OnCalculateMapCompletionPercentage) == 0x000004, "Wrong size on UserWidgetMap_OnCalculateMapCompletionPercentage");
static_assert(offsetof(UserWidgetMap_OnCalculateMapCompletionPercentage, Percentage) == 0x000000, "Member 'UserWidgetMap_OnCalculateMapCompletionPercentage::Percentage' has a wrong offset!");

// Function Zion.UserWidgetMap.OnChangeMapAreaUnderCursor
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetMap_OnChangeMapAreaUnderCursor final
{
public:
	class UUserWidgetMapArea*                     MapArea;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_OnChangeMapAreaUnderCursor) == 0x000008, "Wrong alignment on UserWidgetMap_OnChangeMapAreaUnderCursor");
static_assert(sizeof(UserWidgetMap_OnChangeMapAreaUnderCursor) == 0x000008, "Wrong size on UserWidgetMap_OnChangeMapAreaUnderCursor");
static_assert(offsetof(UserWidgetMap_OnChangeMapAreaUnderCursor, MapArea) == 0x000000, "Member 'UserWidgetMap_OnChangeMapAreaUnderCursor::MapArea' has a wrong offset!");

// Function Zion.UserWidgetMap.OnReachedTargetedIcon
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetMap_OnReachedTargetedIcon final
{
public:
	class UUserWidgetMapIcon*                     MapIcon;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_OnReachedTargetedIcon) == 0x000008, "Wrong alignment on UserWidgetMap_OnReachedTargetedIcon");
static_assert(sizeof(UserWidgetMap_OnReachedTargetedIcon) == 0x000008, "Wrong size on UserWidgetMap_OnReachedTargetedIcon");
static_assert(offsetof(UserWidgetMap_OnReachedTargetedIcon, MapIcon) == 0x000000, "Member 'UserWidgetMap_OnReachedTargetedIcon::MapIcon' has a wrong offset!");

// Function Zion.UserWidgetMap.OnRefreshRemoveAllCustomMarkersHoldTime
// 0x000C (0x000C - 0x0000)
struct UserWidgetMap_OnRefreshRemoveAllCustomMarkersHoldTime final
{
public:
	float                                         CurrentHoldingTime;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoldingDuration;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_OnRefreshRemoveAllCustomMarkersHoldTime) == 0x000004, "Wrong alignment on UserWidgetMap_OnRefreshRemoveAllCustomMarkersHoldTime");
static_assert(sizeof(UserWidgetMap_OnRefreshRemoveAllCustomMarkersHoldTime) == 0x00000C, "Wrong size on UserWidgetMap_OnRefreshRemoveAllCustomMarkersHoldTime");
static_assert(offsetof(UserWidgetMap_OnRefreshRemoveAllCustomMarkersHoldTime, CurrentHoldingTime) == 0x000000, "Member 'UserWidgetMap_OnRefreshRemoveAllCustomMarkersHoldTime::CurrentHoldingTime' has a wrong offset!");
static_assert(offsetof(UserWidgetMap_OnRefreshRemoveAllCustomMarkersHoldTime, HoldingDuration) == 0x000004, "Member 'UserWidgetMap_OnRefreshRemoveAllCustomMarkersHoldTime::HoldingDuration' has a wrong offset!");
static_assert(offsetof(UserWidgetMap_OnRefreshRemoveAllCustomMarkersHoldTime, Alpha) == 0x000008, "Member 'UserWidgetMap_OnRefreshRemoveAllCustomMarkersHoldTime::Alpha' has a wrong offset!");

// Function Zion.UserWidgetMap.OnResetMapAreaUnderCursor
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetMap_OnResetMapAreaUnderCursor final
{
public:
	class UUserWidgetMapArea*                     MapArea;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_OnResetMapAreaUnderCursor) == 0x000008, "Wrong alignment on UserWidgetMap_OnResetMapAreaUnderCursor");
static_assert(sizeof(UserWidgetMap_OnResetMapAreaUnderCursor) == 0x000008, "Wrong size on UserWidgetMap_OnResetMapAreaUnderCursor");
static_assert(offsetof(UserWidgetMap_OnResetMapAreaUnderCursor, MapArea) == 0x000000, "Member 'UserWidgetMap_OnResetMapAreaUnderCursor::MapArea' has a wrong offset!");

// Function Zion.UserWidgetMap.OnResetTargetedIcon
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetMap_OnResetTargetedIcon final
{
public:
	class UUserWidgetMapIcon*                     MapIcon;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstant;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserWidgetMap_OnResetTargetedIcon) == 0x000008, "Wrong alignment on UserWidgetMap_OnResetTargetedIcon");
static_assert(sizeof(UserWidgetMap_OnResetTargetedIcon) == 0x000010, "Wrong size on UserWidgetMap_OnResetTargetedIcon");
static_assert(offsetof(UserWidgetMap_OnResetTargetedIcon, MapIcon) == 0x000000, "Member 'UserWidgetMap_OnResetTargetedIcon::MapIcon' has a wrong offset!");
static_assert(offsetof(UserWidgetMap_OnResetTargetedIcon, bInstant) == 0x000008, "Member 'UserWidgetMap_OnResetTargetedIcon::bInstant' has a wrong offset!");

// Function Zion.UserWidgetMap.OnToggleRestPointList
// 0x0002 (0x0002 - 0x0000)
struct UserWidgetMap_OnToggleRestPointList final
{
public:
	bool                                          bRestPointListOpened;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstant;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_OnToggleRestPointList) == 0x000001, "Wrong alignment on UserWidgetMap_OnToggleRestPointList");
static_assert(sizeof(UserWidgetMap_OnToggleRestPointList) == 0x000002, "Wrong size on UserWidgetMap_OnToggleRestPointList");
static_assert(offsetof(UserWidgetMap_OnToggleRestPointList, bRestPointListOpened) == 0x000000, "Member 'UserWidgetMap_OnToggleRestPointList::bRestPointListOpened' has a wrong offset!");
static_assert(offsetof(UserWidgetMap_OnToggleRestPointList, bInstant) == 0x000001, "Member 'UserWidgetMap_OnToggleRestPointList::bInstant' has a wrong offset!");

// Function Zion.UserWidgetMap.RemoveCustomMarkerUnderCursor
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetMap_RemoveCustomMarkerUnderCursor final
{
public:
	class UUserWidgetMapIcon_CustomMarker*        CustomMarkerIcon;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_RemoveCustomMarkerUnderCursor) == 0x000008, "Wrong alignment on UserWidgetMap_RemoveCustomMarkerUnderCursor");
static_assert(sizeof(UserWidgetMap_RemoveCustomMarkerUnderCursor) == 0x000008, "Wrong size on UserWidgetMap_RemoveCustomMarkerUnderCursor");
static_assert(offsetof(UserWidgetMap_RemoveCustomMarkerUnderCursor, CustomMarkerIcon) == 0x000000, "Member 'UserWidgetMap_RemoveCustomMarkerUnderCursor::CustomMarkerIcon' has a wrong offset!");

// Function Zion.UserWidgetMap.SetNewZoomScale
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetMap_SetNewZoomScale final
{
public:
	float                                         NewZoomScale;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_SetNewZoomScale) == 0x000004, "Wrong alignment on UserWidgetMap_SetNewZoomScale");
static_assert(sizeof(UserWidgetMap_SetNewZoomScale) == 0x000004, "Wrong size on UserWidgetMap_SetNewZoomScale");
static_assert(offsetof(UserWidgetMap_SetNewZoomScale, NewZoomScale) == 0x000000, "Member 'UserWidgetMap_SetNewZoomScale::NewZoomScale' has a wrong offset!");

// Function Zion.UserWidgetMap.Zoom
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetMap_Zoom final
{
public:
	float                                         InZoomDelta;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_Zoom) == 0x000004, "Wrong alignment on UserWidgetMap_Zoom");
static_assert(sizeof(UserWidgetMap_Zoom) == 0x000004, "Wrong size on UserWidgetMap_Zoom");
static_assert(offsetof(UserWidgetMap_Zoom, InZoomDelta) == 0x000000, "Member 'UserWidgetMap_Zoom::InZoomDelta' has a wrong offset!");

// Function Zion.UserWidgetMap.GetCustomMarkerAvailableCount
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetMap_GetCustomMarkerAvailableCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_GetCustomMarkerAvailableCount) == 0x000004, "Wrong alignment on UserWidgetMap_GetCustomMarkerAvailableCount");
static_assert(sizeof(UserWidgetMap_GetCustomMarkerAvailableCount) == 0x000004, "Wrong size on UserWidgetMap_GetCustomMarkerAvailableCount");
static_assert(offsetof(UserWidgetMap_GetCustomMarkerAvailableCount, ReturnValue) == 0x000000, "Member 'UserWidgetMap_GetCustomMarkerAvailableCount::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMap.GetMapCompletionPercentage
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetMap_GetMapCompletionPercentage final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_GetMapCompletionPercentage) == 0x000004, "Wrong alignment on UserWidgetMap_GetMapCompletionPercentage");
static_assert(sizeof(UserWidgetMap_GetMapCompletionPercentage) == 0x000004, "Wrong size on UserWidgetMap_GetMapCompletionPercentage");
static_assert(offsetof(UserWidgetMap_GetMapCompletionPercentage, ReturnValue) == 0x000000, "Member 'UserWidgetMap_GetMapCompletionPercentage::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMap.HasValidData
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetMap_HasValidData final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_HasValidData) == 0x000001, "Wrong alignment on UserWidgetMap_HasValidData");
static_assert(sizeof(UserWidgetMap_HasValidData) == 0x000001, "Wrong size on UserWidgetMap_HasValidData");
static_assert(offsetof(UserWidgetMap_HasValidData, ReturnValue) == 0x000000, "Member 'UserWidgetMap_HasValidData::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMap.IsMapAreaVisited
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetMap_IsMapAreaVisited final
{
public:
	const class UUserWidgetMapArea*               MapAreaWidget;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserWidgetMap_IsMapAreaVisited) == 0x000008, "Wrong alignment on UserWidgetMap_IsMapAreaVisited");
static_assert(sizeof(UserWidgetMap_IsMapAreaVisited) == 0x000010, "Wrong size on UserWidgetMap_IsMapAreaVisited");
static_assert(offsetof(UserWidgetMap_IsMapAreaVisited, MapAreaWidget) == 0x000000, "Member 'UserWidgetMap_IsMapAreaVisited::MapAreaWidget' has a wrong offset!");
static_assert(offsetof(UserWidgetMap_IsMapAreaVisited, ReturnValue) == 0x000008, "Member 'UserWidgetMap_IsMapAreaVisited::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMap.IsRestPointListOpened
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetMap_IsRestPointListOpened final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMap_IsRestPointListOpened) == 0x000001, "Wrong alignment on UserWidgetMap_IsRestPointListOpened");
static_assert(sizeof(UserWidgetMap_IsRestPointListOpened) == 0x000001, "Wrong size on UserWidgetMap_IsRestPointListOpened");
static_assert(offsetof(UserWidgetMap_IsRestPointListOpened, ReturnValue) == 0x000000, "Member 'UserWidgetMap_IsRestPointListOpened::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapIconDetails.OnRemoveIconDetails
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetMapIconDetails_OnRemoveIconDetails final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIconDetails_OnRemoveIconDetails) == 0x000001, "Wrong alignment on UserWidgetMapIconDetails_OnRemoveIconDetails");
static_assert(sizeof(UserWidgetMapIconDetails_OnRemoveIconDetails) == 0x000001, "Wrong size on UserWidgetMapIconDetails_OnRemoveIconDetails");
static_assert(offsetof(UserWidgetMapIconDetails_OnRemoveIconDetails, bInstant) == 0x000000, "Member 'UserWidgetMapIconDetails_OnRemoveIconDetails::bInstant' has a wrong offset!");

// Function Zion.UserWidgetMapIconDetails.RemoveIconDetails
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetMapIconDetails_RemoveIconDetails final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIconDetails_RemoveIconDetails) == 0x000001, "Wrong alignment on UserWidgetMapIconDetails_RemoveIconDetails");
static_assert(sizeof(UserWidgetMapIconDetails_RemoveIconDetails) == 0x000001, "Wrong size on UserWidgetMapIconDetails_RemoveIconDetails");
static_assert(offsetof(UserWidgetMapIconDetails_RemoveIconDetails, bInstant) == 0x000000, "Member 'UserWidgetMapIconDetails_RemoveIconDetails::bInstant' has a wrong offset!");

// Function Zion.UserWidgetMapIconDetails.SetIsRestPointListOpened
// 0x0002 (0x0002 - 0x0000)
struct UserWidgetMapIconDetails_SetIsRestPointListOpened final
{
public:
	bool                                          bIsOpened;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIconDetails_SetIsRestPointListOpened) == 0x000001, "Wrong alignment on UserWidgetMapIconDetails_SetIsRestPointListOpened");
static_assert(sizeof(UserWidgetMapIconDetails_SetIsRestPointListOpened) == 0x000002, "Wrong size on UserWidgetMapIconDetails_SetIsRestPointListOpened");
static_assert(offsetof(UserWidgetMapIconDetails_SetIsRestPointListOpened, bIsOpened) == 0x000000, "Member 'UserWidgetMapIconDetails_SetIsRestPointListOpened::bIsOpened' has a wrong offset!");
static_assert(offsetof(UserWidgetMapIconDetails_SetIsRestPointListOpened, ReturnValue) == 0x000001, "Member 'UserWidgetMapIconDetails_SetIsRestPointListOpened::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapIcon.OnItemAdded
// 0x0018 (0x0018 - 0x0000)
struct UserWidgetMapIcon_OnItemAdded final
{
public:
	const class UInventory*                       Inventory;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId;                                            // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddedCount;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserWidgetMapIcon_OnItemAdded) == 0x000008, "Wrong alignment on UserWidgetMapIcon_OnItemAdded");
static_assert(sizeof(UserWidgetMapIcon_OnItemAdded) == 0x000018, "Wrong size on UserWidgetMapIcon_OnItemAdded");
static_assert(offsetof(UserWidgetMapIcon_OnItemAdded, Inventory) == 0x000000, "Member 'UserWidgetMapIcon_OnItemAdded::Inventory' has a wrong offset!");
static_assert(offsetof(UserWidgetMapIcon_OnItemAdded, ItemId) == 0x000008, "Member 'UserWidgetMapIcon_OnItemAdded::ItemId' has a wrong offset!");
static_assert(offsetof(UserWidgetMapIcon_OnItemAdded, AddedCount) == 0x000010, "Member 'UserWidgetMapIcon_OnItemAdded::AddedCount' has a wrong offset!");

// Function Zion.UserWidgetMapIcon.SetIconFromSoftSprite
// 0x0030 (0x0030 - 0x0000)
struct UserWidgetMapIcon_SetIconFromSoftSprite final
{
public:
	TSoftObjectPtr<class UPaperSprite>            NewIcon;                                           // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchSize;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserWidgetMapIcon_SetIconFromSoftSprite) == 0x000008, "Wrong alignment on UserWidgetMapIcon_SetIconFromSoftSprite");
static_assert(sizeof(UserWidgetMapIcon_SetIconFromSoftSprite) == 0x000030, "Wrong size on UserWidgetMapIcon_SetIconFromSoftSprite");
static_assert(offsetof(UserWidgetMapIcon_SetIconFromSoftSprite, NewIcon) == 0x000000, "Member 'UserWidgetMapIcon_SetIconFromSoftSprite::NewIcon' has a wrong offset!");
static_assert(offsetof(UserWidgetMapIcon_SetIconFromSoftSprite, bMatchSize) == 0x000028, "Member 'UserWidgetMapIcon_SetIconFromSoftSprite::bMatchSize' has a wrong offset!");

// Function Zion.UserWidgetMapIcon.GetAptitudeRequired
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetMapIcon_GetAptitudeRequired final
{
public:
	EAptitudeType                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_GetAptitudeRequired) == 0x000001, "Wrong alignment on UserWidgetMapIcon_GetAptitudeRequired");
static_assert(sizeof(UserWidgetMapIcon_GetAptitudeRequired) == 0x000001, "Wrong size on UserWidgetMapIcon_GetAptitudeRequired");
static_assert(offsetof(UserWidgetMapIcon_GetAptitudeRequired, ReturnValue) == 0x000000, "Member 'UserWidgetMapIcon_GetAptitudeRequired::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapIcon.GetItemsRequired
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetMapIcon_GetItemsRequired final
{
public:
	TArray<struct FDataTableRowHandle>            ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_GetItemsRequired) == 0x000008, "Wrong alignment on UserWidgetMapIcon_GetItemsRequired");
static_assert(sizeof(UserWidgetMapIcon_GetItemsRequired) == 0x000010, "Wrong size on UserWidgetMapIcon_GetItemsRequired");
static_assert(offsetof(UserWidgetMapIcon_GetItemsRequired, ReturnValue) == 0x000000, "Member 'UserWidgetMapIcon_GetItemsRequired::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapIcon.GetMapIconType
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetMapIcon_GetMapIconType final
{
public:
	EMapIconType                                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_GetMapIconType) == 0x000001, "Wrong alignment on UserWidgetMapIcon_GetMapIconType");
static_assert(sizeof(UserWidgetMapIcon_GetMapIconType) == 0x000001, "Wrong size on UserWidgetMapIcon_GetMapIconType");
static_assert(offsetof(UserWidgetMapIcon_GetMapIconType, ReturnValue) == 0x000000, "Member 'UserWidgetMapIcon_GetMapIconType::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapIcon.GetWidgetIconDetailsClass
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetMapIcon_GetWidgetIconDetailsClass final
{
public:
	TSubclassOf<class UUserWidgetMapIconDetails>  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_GetWidgetIconDetailsClass) == 0x000008, "Wrong alignment on UserWidgetMapIcon_GetWidgetIconDetailsClass");
static_assert(sizeof(UserWidgetMapIcon_GetWidgetIconDetailsClass) == 0x000008, "Wrong size on UserWidgetMapIcon_GetWidgetIconDetailsClass");
static_assert(offsetof(UserWidgetMapIcon_GetWidgetIconDetailsClass, ReturnValue) == 0x000000, "Member 'UserWidgetMapIcon_GetWidgetIconDetailsClass::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapIcon.GetWidgetIconDisplayName
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetMapIcon_GetWidgetIconDisplayName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_GetWidgetIconDisplayName) == 0x000008, "Wrong alignment on UserWidgetMapIcon_GetWidgetIconDisplayName");
static_assert(sizeof(UserWidgetMapIcon_GetWidgetIconDisplayName) == 0x000010, "Wrong size on UserWidgetMapIcon_GetWidgetIconDisplayName");
static_assert(offsetof(UserWidgetMapIcon_GetWidgetIconDisplayName, ReturnValue) == 0x000000, "Member 'UserWidgetMapIcon_GetWidgetIconDisplayName::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapIcon_CustomMarker.OnSetCustomMarkerData
// 0x0028 (0x0028 - 0x0000)
struct UserWidgetMapIcon_CustomMarker_OnSetCustomMarkerData final
{
public:
	struct FMapCustomMarkerIconData               NewCustomMarkerData;                               // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_CustomMarker_OnSetCustomMarkerData) == 0x000008, "Wrong alignment on UserWidgetMapIcon_CustomMarker_OnSetCustomMarkerData");
static_assert(sizeof(UserWidgetMapIcon_CustomMarker_OnSetCustomMarkerData) == 0x000028, "Wrong size on UserWidgetMapIcon_CustomMarker_OnSetCustomMarkerData");
static_assert(offsetof(UserWidgetMapIcon_CustomMarker_OnSetCustomMarkerData, NewCustomMarkerData) == 0x000000, "Member 'UserWidgetMapIcon_CustomMarker_OnSetCustomMarkerData::NewCustomMarkerData' has a wrong offset!");

// Function Zion.UserWidgetMapIcon_CustomMarker.OnSetScale
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetMapIcon_CustomMarker_OnSetScale final
{
public:
	float                                         NewScale;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_CustomMarker_OnSetScale) == 0x000004, "Wrong alignment on UserWidgetMapIcon_CustomMarker_OnSetScale");
static_assert(sizeof(UserWidgetMapIcon_CustomMarker_OnSetScale) == 0x000004, "Wrong size on UserWidgetMapIcon_CustomMarker_OnSetScale");
static_assert(offsetof(UserWidgetMapIcon_CustomMarker_OnSetScale, NewScale) == 0x000000, "Member 'UserWidgetMapIcon_CustomMarker_OnSetScale::NewScale' has a wrong offset!");

// Function Zion.UserWidgetMapIcon_CustomMarker.SetScale
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetMapIcon_CustomMarker_SetScale final
{
public:
	float                                         NewScale;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_CustomMarker_SetScale) == 0x000004, "Wrong alignment on UserWidgetMapIcon_CustomMarker_SetScale");
static_assert(sizeof(UserWidgetMapIcon_CustomMarker_SetScale) == 0x000004, "Wrong size on UserWidgetMapIcon_CustomMarker_SetScale");
static_assert(offsetof(UserWidgetMapIcon_CustomMarker_SetScale, NewScale) == 0x000000, "Member 'UserWidgetMapIcon_CustomMarker_SetScale::NewScale' has a wrong offset!");

// Function Zion.UserWidgetMapIcon_CustomMarker.GetCustomMarkerDisplayID
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetMapIcon_CustomMarker_GetCustomMarkerDisplayID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_CustomMarker_GetCustomMarkerDisplayID) == 0x000004, "Wrong alignment on UserWidgetMapIcon_CustomMarker_GetCustomMarkerDisplayID");
static_assert(sizeof(UserWidgetMapIcon_CustomMarker_GetCustomMarkerDisplayID) == 0x000004, "Wrong size on UserWidgetMapIcon_CustomMarker_GetCustomMarkerDisplayID");
static_assert(offsetof(UserWidgetMapIcon_CustomMarker_GetCustomMarkerDisplayID, ReturnValue) == 0x000000, "Member 'UserWidgetMapIcon_CustomMarker_GetCustomMarkerDisplayID::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapIcon_CustomMarker.GetCustomMarkerIconData
// 0x0028 (0x0028 - 0x0000)
struct UserWidgetMapIcon_CustomMarker_GetCustomMarkerIconData final
{
public:
	struct FMapCustomMarkerIconData               ReturnValue;                                       // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_CustomMarker_GetCustomMarkerIconData) == 0x000008, "Wrong alignment on UserWidgetMapIcon_CustomMarker_GetCustomMarkerIconData");
static_assert(sizeof(UserWidgetMapIcon_CustomMarker_GetCustomMarkerIconData) == 0x000028, "Wrong size on UserWidgetMapIcon_CustomMarker_GetCustomMarkerIconData");
static_assert(offsetof(UserWidgetMapIcon_CustomMarker_GetCustomMarkerIconData, ReturnValue) == 0x000000, "Member 'UserWidgetMapIcon_CustomMarker_GetCustomMarkerIconData::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapIcon_Actor.SetActorData
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetMapIcon_Actor_SetActorData final
{
public:
	struct FClearActorData                        InActorData;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_Actor_SetActorData) == 0x000004, "Wrong alignment on UserWidgetMapIcon_Actor_SetActorData");
static_assert(sizeof(UserWidgetMapIcon_Actor_SetActorData) == 0x000010, "Wrong size on UserWidgetMapIcon_Actor_SetActorData");
static_assert(offsetof(UserWidgetMapIcon_Actor_SetActorData, InActorData) == 0x000000, "Member 'UserWidgetMapIcon_Actor_SetActorData::InActorData' has a wrong offset!");

// Function Zion.UserWidgetMapIcon_Actor.GetActorData
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetMapIcon_Actor_GetActorData final
{
public:
	struct FClearActorData                        ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_Actor_GetActorData) == 0x000004, "Wrong alignment on UserWidgetMapIcon_Actor_GetActorData");
static_assert(sizeof(UserWidgetMapIcon_Actor_GetActorData) == 0x000010, "Wrong size on UserWidgetMapIcon_Actor_GetActorData");
static_assert(offsetof(UserWidgetMapIcon_Actor_GetActorData, ReturnValue) == 0x000000, "Member 'UserWidgetMapIcon_Actor_GetActorData::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapIcon_RestPoint.SetRestPointData
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetMapIcon_RestPoint_SetRestPointData final
{
public:
	struct FMapRestPointData                      InRestPointData;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_RestPoint_SetRestPointData) == 0x000004, "Wrong alignment on UserWidgetMapIcon_RestPoint_SetRestPointData");
static_assert(sizeof(UserWidgetMapIcon_RestPoint_SetRestPointData) == 0x000008, "Wrong size on UserWidgetMapIcon_RestPoint_SetRestPointData");
static_assert(offsetof(UserWidgetMapIcon_RestPoint_SetRestPointData, InRestPointData) == 0x000000, "Member 'UserWidgetMapIcon_RestPoint_SetRestPointData::InRestPointData' has a wrong offset!");

// Function Zion.UserWidgetMapIcon_RestPoint.GetRestPointData
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetMapIcon_RestPoint_GetRestPointData final
{
public:
	struct FMapRestPointData                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_RestPoint_GetRestPointData) == 0x000004, "Wrong alignment on UserWidgetMapIcon_RestPoint_GetRestPointData");
static_assert(sizeof(UserWidgetMapIcon_RestPoint_GetRestPointData) == 0x000008, "Wrong size on UserWidgetMapIcon_RestPoint_GetRestPointData");
static_assert(offsetof(UserWidgetMapIcon_RestPoint_GetRestPointData, ReturnValue) == 0x000000, "Member 'UserWidgetMapIcon_RestPoint_GetRestPointData::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapIcon_Teleport.GetDestinationWorldLocation
// 0x0018 (0x0018 - 0x0000)
struct UserWidgetMapIcon_Teleport_GetDestinationWorldLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_Teleport_GetDestinationWorldLocation) == 0x000008, "Wrong alignment on UserWidgetMapIcon_Teleport_GetDestinationWorldLocation");
static_assert(sizeof(UserWidgetMapIcon_Teleport_GetDestinationWorldLocation) == 0x000018, "Wrong size on UserWidgetMapIcon_Teleport_GetDestinationWorldLocation");
static_assert(offsetof(UserWidgetMapIcon_Teleport_GetDestinationWorldLocation, ReturnValue) == 0x000000, "Member 'UserWidgetMapIcon_Teleport_GetDestinationWorldLocation::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapIcon_Teleport.GetMapTransitionHandle
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetMapIcon_Teleport_GetMapTransitionHandle final
{
public:
	struct FDataTableRowHandle                    ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_Teleport_GetMapTransitionHandle) == 0x000008, "Wrong alignment on UserWidgetMapIcon_Teleport_GetMapTransitionHandle");
static_assert(sizeof(UserWidgetMapIcon_Teleport_GetMapTransitionHandle) == 0x000010, "Wrong size on UserWidgetMapIcon_Teleport_GetMapTransitionHandle");
static_assert(offsetof(UserWidgetMapIcon_Teleport_GetMapTransitionHandle, ReturnValue) == 0x000000, "Member 'UserWidgetMapIcon_Teleport_GetMapTransitionHandle::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapIcon_Teleport.GetStartWorldLocation
// 0x0018 (0x0018 - 0x0000)
struct UserWidgetMapIcon_Teleport_GetStartWorldLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_Teleport_GetStartWorldLocation) == 0x000008, "Wrong alignment on UserWidgetMapIcon_Teleport_GetStartWorldLocation");
static_assert(sizeof(UserWidgetMapIcon_Teleport_GetStartWorldLocation) == 0x000018, "Wrong size on UserWidgetMapIcon_Teleport_GetStartWorldLocation");
static_assert(offsetof(UserWidgetMapIcon_Teleport_GetStartWorldLocation, ReturnValue) == 0x000000, "Member 'UserWidgetMapIcon_Teleport_GetStartWorldLocation::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapIcon_Teleport.GetToDestination_MapSpace
// 0x0010 (0x0010 - 0x0000)
struct UserWidgetMapIcon_Teleport_GetToDestination_MapSpace final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapIcon_Teleport_GetToDestination_MapSpace) == 0x000008, "Wrong alignment on UserWidgetMapIcon_Teleport_GetToDestination_MapSpace");
static_assert(sizeof(UserWidgetMapIcon_Teleport_GetToDestination_MapSpace) == 0x000010, "Wrong size on UserWidgetMapIcon_Teleport_GetToDestination_MapSpace");
static_assert(offsetof(UserWidgetMapIcon_Teleport_GetToDestination_MapSpace, ReturnValue) == 0x000000, "Member 'UserWidgetMapIcon_Teleport_GetToDestination_MapSpace::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapZone.IsCleared
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetMapZone_IsCleared final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapZone_IsCleared) == 0x000001, "Wrong alignment on UserWidgetMapZone_IsCleared");
static_assert(sizeof(UserWidgetMapZone_IsCleared) == 0x000001, "Wrong size on UserWidgetMapZone_IsCleared");
static_assert(offsetof(UserWidgetMapZone_IsCleared, ReturnValue) == 0x000000, "Member 'UserWidgetMapZone_IsCleared::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapArea.GetClearedZoneCount
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetMapArea_GetClearedZoneCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapArea_GetClearedZoneCount) == 0x000004, "Wrong alignment on UserWidgetMapArea_GetClearedZoneCount");
static_assert(sizeof(UserWidgetMapArea_GetClearedZoneCount) == 0x000004, "Wrong size on UserWidgetMapArea_GetClearedZoneCount");
static_assert(offsetof(UserWidgetMapArea_GetClearedZoneCount, ReturnValue) == 0x000000, "Member 'UserWidgetMapArea_GetClearedZoneCount::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapArea.GetCompletionPercentage
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetMapArea_GetCompletionPercentage final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapArea_GetCompletionPercentage) == 0x000004, "Wrong alignment on UserWidgetMapArea_GetCompletionPercentage");
static_assert(sizeof(UserWidgetMapArea_GetCompletionPercentage) == 0x000004, "Wrong size on UserWidgetMapArea_GetCompletionPercentage");
static_assert(offsetof(UserWidgetMapArea_GetCompletionPercentage, ReturnValue) == 0x000000, "Member 'UserWidgetMapArea_GetCompletionPercentage::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapArea.GetMapName
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetMapArea_GetMapName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapArea_GetMapName) == 0x000004, "Wrong alignment on UserWidgetMapArea_GetMapName");
static_assert(sizeof(UserWidgetMapArea_GetMapName) == 0x000008, "Wrong size on UserWidgetMapArea_GetMapName");
static_assert(offsetof(UserWidgetMapArea_GetMapName, ReturnValue) == 0x000000, "Member 'UserWidgetMapArea_GetMapName::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapArea.GetZoneCount
// 0x0004 (0x0004 - 0x0000)
struct UserWidgetMapArea_GetZoneCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapArea_GetZoneCount) == 0x000004, "Wrong alignment on UserWidgetMapArea_GetZoneCount");
static_assert(sizeof(UserWidgetMapArea_GetZoneCount) == 0x000004, "Wrong size on UserWidgetMapArea_GetZoneCount");
static_assert(offsetof(UserWidgetMapArea_GetZoneCount, ReturnValue) == 0x000000, "Member 'UserWidgetMapArea_GetZoneCount::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetMapArea.OnZoneVisited
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetMapArea_OnZoneVisited final
{
public:
	class AStaticVolume_Zone*                     ZoneVisited;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMapArea_OnZoneVisited) == 0x000008, "Wrong alignment on UserWidgetMapArea_OnZoneVisited");
static_assert(sizeof(UserWidgetMapArea_OnZoneVisited) == 0x000008, "Wrong size on UserWidgetMapArea_OnZoneVisited");
static_assert(offsetof(UserWidgetMapArea_OnZoneVisited, ZoneVisited) == 0x000000, "Member 'UserWidgetMapArea_OnZoneVisited::ZoneVisited' has a wrong offset!");

// Function Zion.UserWidgetMinimap.HasValidData
// 0x0001 (0x0001 - 0x0000)
struct UserWidgetMinimap_HasValidData final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetMinimap_HasValidData) == 0x000001, "Wrong alignment on UserWidgetMinimap_HasValidData");
static_assert(sizeof(UserWidgetMinimap_HasValidData) == 0x000001, "Wrong size on UserWidgetMinimap_HasValidData");
static_assert(offsetof(UserWidgetMinimap_HasValidData, ReturnValue) == 0x000000, "Member 'UserWidgetMinimap_HasValidData::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetStatusEffectIcon.GetCachedStatusEffect
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetStatusEffectIcon_GetCachedStatusEffect final
{
public:
	class UStatusEffect*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetStatusEffectIcon_GetCachedStatusEffect) == 0x000008, "Wrong alignment on UserWidgetStatusEffectIcon_GetCachedStatusEffect");
static_assert(sizeof(UserWidgetStatusEffectIcon_GetCachedStatusEffect) == 0x000008, "Wrong size on UserWidgetStatusEffectIcon_GetCachedStatusEffect");
static_assert(offsetof(UserWidgetStatusEffectIcon_GetCachedStatusEffect, ReturnValue) == 0x000000, "Member 'UserWidgetStatusEffectIcon_GetCachedStatusEffect::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetStatusEffectIcon.GetStatusEffectIconSprite
// 0x0028 (0x0028 - 0x0000)
struct UserWidgetStatusEffectIcon_GetStatusEffectIconSprite final
{
public:
	TSoftObjectPtr<class UPaperSprite>            ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetStatusEffectIcon_GetStatusEffectIconSprite) == 0x000008, "Wrong alignment on UserWidgetStatusEffectIcon_GetStatusEffectIconSprite");
static_assert(sizeof(UserWidgetStatusEffectIcon_GetStatusEffectIconSprite) == 0x000028, "Wrong size on UserWidgetStatusEffectIcon_GetStatusEffectIconSprite");
static_assert(offsetof(UserWidgetStatusEffectIcon_GetStatusEffectIconSprite, ReturnValue) == 0x000000, "Member 'UserWidgetStatusEffectIcon_GetStatusEffectIconSprite::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetStatusEffectIcon.GetStatusEffectIconSpriteFromType
// 0x0030 (0x0030 - 0x0000)
struct UserWidgetStatusEffectIcon_GetStatusEffectIconSpriteFromType final
{
public:
	EStatusEffectType                             StatusEffectType;                                  // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPaperSprite>            ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetStatusEffectIcon_GetStatusEffectIconSpriteFromType) == 0x000008, "Wrong alignment on UserWidgetStatusEffectIcon_GetStatusEffectIconSpriteFromType");
static_assert(sizeof(UserWidgetStatusEffectIcon_GetStatusEffectIconSpriteFromType) == 0x000030, "Wrong size on UserWidgetStatusEffectIcon_GetStatusEffectIconSpriteFromType");
static_assert(offsetof(UserWidgetStatusEffectIcon_GetStatusEffectIconSpriteFromType, StatusEffectType) == 0x000000, "Member 'UserWidgetStatusEffectIcon_GetStatusEffectIconSpriteFromType::StatusEffectType' has a wrong offset!");
static_assert(offsetof(UserWidgetStatusEffectIcon_GetStatusEffectIconSpriteFromType, ReturnValue) == 0x000008, "Member 'UserWidgetStatusEffectIcon_GetStatusEffectIconSpriteFromType::ReturnValue' has a wrong offset!");

// Function Zion.UserWidgetWorldSpaceDebug.ClearTextForTag
// 0x0008 (0x0008 - 0x0000)
struct UserWidgetWorldSpaceDebug_ClearTextForTag final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetWorldSpaceDebug_ClearTextForTag) == 0x000004, "Wrong alignment on UserWidgetWorldSpaceDebug_ClearTextForTag");
static_assert(sizeof(UserWidgetWorldSpaceDebug_ClearTextForTag) == 0x000008, "Wrong size on UserWidgetWorldSpaceDebug_ClearTextForTag");
static_assert(offsetof(UserWidgetWorldSpaceDebug_ClearTextForTag, Tag) == 0x000000, "Member 'UserWidgetWorldSpaceDebug_ClearTextForTag::Tag' has a wrong offset!");

// Function Zion.UserWidgetWorldSpaceDebug.SetTextForTag
// 0x0018 (0x0018 - 0x0000)
struct UserWidgetWorldSpaceDebug_SetTextForTag final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserWidgetWorldSpaceDebug_SetTextForTag) == 0x000008, "Wrong alignment on UserWidgetWorldSpaceDebug_SetTextForTag");
static_assert(sizeof(UserWidgetWorldSpaceDebug_SetTextForTag) == 0x000018, "Wrong size on UserWidgetWorldSpaceDebug_SetTextForTag");
static_assert(offsetof(UserWidgetWorldSpaceDebug_SetTextForTag, Tag) == 0x000000, "Member 'UserWidgetWorldSpaceDebug_SetTextForTag::Tag' has a wrong offset!");
static_assert(offsetof(UserWidgetWorldSpaceDebug_SetTextForTag, Text) == 0x000008, "Member 'UserWidgetWorldSpaceDebug_SetTextForTag::Text' has a wrong offset!");

// Function Zion.WaitGameReadyAsyncAction.WaitGameReady
// 0x0018 (0x0018 - 0x0000)
struct WaitGameReadyAsyncAction_WaitGameReady final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlsoWaitWorldLoading;                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWaitGameReadyAsyncAction*              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WaitGameReadyAsyncAction_WaitGameReady) == 0x000008, "Wrong alignment on WaitGameReadyAsyncAction_WaitGameReady");
static_assert(sizeof(WaitGameReadyAsyncAction_WaitGameReady) == 0x000018, "Wrong size on WaitGameReadyAsyncAction_WaitGameReady");
static_assert(offsetof(WaitGameReadyAsyncAction_WaitGameReady, WorldContextObject) == 0x000000, "Member 'WaitGameReadyAsyncAction_WaitGameReady::WorldContextObject' has a wrong offset!");
static_assert(offsetof(WaitGameReadyAsyncAction_WaitGameReady, bAlsoWaitWorldLoading) == 0x000008, "Member 'WaitGameReadyAsyncAction_WaitGameReady::bAlsoWaitWorldLoading' has a wrong offset!");
static_assert(offsetof(WaitGameReadyAsyncAction_WaitGameReady, ReturnValue) == 0x000010, "Member 'WaitGameReadyAsyncAction_WaitGameReady::ReturnValue' has a wrong offset!");

// Function Zion.WorldLoaderSubsystem.OpenGameMap
// 0x0060 (0x0060 - 0x0000)
struct WorldLoaderSubsystem_OpenGameMap final
{
public:
	struct FDataTableRowHandle                    GameMapHandle;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   PlayerStartTag;                                    // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceReload;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFadeDescriptionData                   FadeOutDescription;                                // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FFadeDescriptionData                   FadeInDescription;                                 // 0x0040(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(WorldLoaderSubsystem_OpenGameMap) == 0x000008, "Wrong alignment on WorldLoaderSubsystem_OpenGameMap");
static_assert(sizeof(WorldLoaderSubsystem_OpenGameMap) == 0x000060, "Wrong size on WorldLoaderSubsystem_OpenGameMap");
static_assert(offsetof(WorldLoaderSubsystem_OpenGameMap, GameMapHandle) == 0x000000, "Member 'WorldLoaderSubsystem_OpenGameMap::GameMapHandle' has a wrong offset!");
static_assert(offsetof(WorldLoaderSubsystem_OpenGameMap, PlayerStartTag) == 0x000010, "Member 'WorldLoaderSubsystem_OpenGameMap::PlayerStartTag' has a wrong offset!");
static_assert(offsetof(WorldLoaderSubsystem_OpenGameMap, bForceReload) == 0x000018, "Member 'WorldLoaderSubsystem_OpenGameMap::bForceReload' has a wrong offset!");
static_assert(offsetof(WorldLoaderSubsystem_OpenGameMap, FadeOutDescription) == 0x000020, "Member 'WorldLoaderSubsystem_OpenGameMap::FadeOutDescription' has a wrong offset!");
static_assert(offsetof(WorldLoaderSubsystem_OpenGameMap, FadeInDescription) == 0x000040, "Member 'WorldLoaderSubsystem_OpenGameMap::FadeInDescription' has a wrong offset!");

// Function Zion.WorldLoaderSubsystem.OpenWorld
// 0x0070 (0x0070 - 0x0000)
struct WorldLoaderSubsystem_OpenWorld final
{
public:
	TSoftObjectPtr<class UWorld>                  WorldToLoad;                                       // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayerStartTag;                                    // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFadeDescriptionData                   FadeOutDescription;                                // 0x0030(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FFadeDescriptionData                   FadeInDescription;                                 // 0x0050(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(WorldLoaderSubsystem_OpenWorld) == 0x000008, "Wrong alignment on WorldLoaderSubsystem_OpenWorld");
static_assert(sizeof(WorldLoaderSubsystem_OpenWorld) == 0x000070, "Wrong size on WorldLoaderSubsystem_OpenWorld");
static_assert(offsetof(WorldLoaderSubsystem_OpenWorld, WorldToLoad) == 0x000000, "Member 'WorldLoaderSubsystem_OpenWorld::WorldToLoad' has a wrong offset!");
static_assert(offsetof(WorldLoaderSubsystem_OpenWorld, PlayerStartTag) == 0x000028, "Member 'WorldLoaderSubsystem_OpenWorld::PlayerStartTag' has a wrong offset!");
static_assert(offsetof(WorldLoaderSubsystem_OpenWorld, FadeOutDescription) == 0x000030, "Member 'WorldLoaderSubsystem_OpenWorld::FadeOutDescription' has a wrong offset!");
static_assert(offsetof(WorldLoaderSubsystem_OpenWorld, FadeInDescription) == 0x000050, "Member 'WorldLoaderSubsystem_OpenWorld::FadeInDescription' has a wrong offset!");

// Function Zion.WorldLoaderSubsystem.GetCurrentGameMapData
// 0x0140 (0x0140 - 0x0000)
struct WorldLoaderSubsystem_GetCurrentGameMapData final
{
public:
	struct FGameMapData                           ReturnValue;                                       // 0x0000(0x0140)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WorldLoaderSubsystem_GetCurrentGameMapData) == 0x000008, "Wrong alignment on WorldLoaderSubsystem_GetCurrentGameMapData");
static_assert(sizeof(WorldLoaderSubsystem_GetCurrentGameMapData) == 0x000140, "Wrong size on WorldLoaderSubsystem_GetCurrentGameMapData");
static_assert(offsetof(WorldLoaderSubsystem_GetCurrentGameMapData, ReturnValue) == 0x000000, "Member 'WorldLoaderSubsystem_GetCurrentGameMapData::ReturnValue' has a wrong offset!");

// Function Zion.WorldLoaderSubsystem.GetCurrentGameMapID
// 0x0008 (0x0008 - 0x0000)
struct WorldLoaderSubsystem_GetCurrentGameMapID final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WorldLoaderSubsystem_GetCurrentGameMapID) == 0x000004, "Wrong alignment on WorldLoaderSubsystem_GetCurrentGameMapID");
static_assert(sizeof(WorldLoaderSubsystem_GetCurrentGameMapID) == 0x000008, "Wrong size on WorldLoaderSubsystem_GetCurrentGameMapID");
static_assert(offsetof(WorldLoaderSubsystem_GetCurrentGameMapID, ReturnValue) == 0x000000, "Member 'WorldLoaderSubsystem_GetCurrentGameMapID::ReturnValue' has a wrong offset!");

// Function Zion.WorldLoaderSubsystem.GetCurrentPlayerStartTag
// 0x0008 (0x0008 - 0x0000)
struct WorldLoaderSubsystem_GetCurrentPlayerStartTag final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WorldLoaderSubsystem_GetCurrentPlayerStartTag) == 0x000004, "Wrong alignment on WorldLoaderSubsystem_GetCurrentPlayerStartTag");
static_assert(sizeof(WorldLoaderSubsystem_GetCurrentPlayerStartTag) == 0x000008, "Wrong size on WorldLoaderSubsystem_GetCurrentPlayerStartTag");
static_assert(offsetof(WorldLoaderSubsystem_GetCurrentPlayerStartTag, ReturnValue) == 0x000000, "Member 'WorldLoaderSubsystem_GetCurrentPlayerStartTag::ReturnValue' has a wrong offset!");

// Function Zion.WorldLoaderSubsystem.IsAvailable
// 0x0001 (0x0001 - 0x0000)
struct WorldLoaderSubsystem_IsAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WorldLoaderSubsystem_IsAvailable) == 0x000001, "Wrong alignment on WorldLoaderSubsystem_IsAvailable");
static_assert(sizeof(WorldLoaderSubsystem_IsAvailable) == 0x000001, "Wrong size on WorldLoaderSubsystem_IsAvailable");
static_assert(offsetof(WorldLoaderSubsystem_IsAvailable, ReturnValue) == 0x000000, "Member 'WorldLoaderSubsystem_IsAvailable::ReturnValue' has a wrong offset!");

// Function Zion.WorldLoaderSubsystem.IsLoading
// 0x0002 (0x0002 - 0x0000)
struct WorldLoaderSubsystem_IsLoading final
{
public:
	bool                                          bConsiderFadeAsLoading;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WorldLoaderSubsystem_IsLoading) == 0x000001, "Wrong alignment on WorldLoaderSubsystem_IsLoading");
static_assert(sizeof(WorldLoaderSubsystem_IsLoading) == 0x000002, "Wrong size on WorldLoaderSubsystem_IsLoading");
static_assert(offsetof(WorldLoaderSubsystem_IsLoading, bConsiderFadeAsLoading) == 0x000000, "Member 'WorldLoaderSubsystem_IsLoading::bConsiderFadeAsLoading' has a wrong offset!");
static_assert(offsetof(WorldLoaderSubsystem_IsLoading, ReturnValue) == 0x000001, "Member 'WorldLoaderSubsystem_IsLoading::ReturnValue' has a wrong offset!");

// Function Zion.ZionInputDeviceSubsystem.GetActiveControllerID
// 0x0004 (0x0004 - 0x0000)
struct ZionInputDeviceSubsystem_GetActiveControllerID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionInputDeviceSubsystem_GetActiveControllerID) == 0x000004, "Wrong alignment on ZionInputDeviceSubsystem_GetActiveControllerID");
static_assert(sizeof(ZionInputDeviceSubsystem_GetActiveControllerID) == 0x000004, "Wrong size on ZionInputDeviceSubsystem_GetActiveControllerID");
static_assert(offsetof(ZionInputDeviceSubsystem_GetActiveControllerID, ReturnValue) == 0x000000, "Member 'ZionInputDeviceSubsystem_GetActiveControllerID::ReturnValue' has a wrong offset!");

// Function Zion.ZionInputDeviceSubsystem.SetInputStyleGamepadOverride
// 0x0001 (0x0001 - 0x0000)
struct ZionInputDeviceSubsystem_SetInputStyleGamepadOverride final
{
public:
	EInputStyle                                   NewInputStyleGamepadOverride;                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionInputDeviceSubsystem_SetInputStyleGamepadOverride) == 0x000001, "Wrong alignment on ZionInputDeviceSubsystem_SetInputStyleGamepadOverride");
static_assert(sizeof(ZionInputDeviceSubsystem_SetInputStyleGamepadOverride) == 0x000001, "Wrong size on ZionInputDeviceSubsystem_SetInputStyleGamepadOverride");
static_assert(offsetof(ZionInputDeviceSubsystem_SetInputStyleGamepadOverride, NewInputStyleGamepadOverride) == 0x000000, "Member 'ZionInputDeviceSubsystem_SetInputStyleGamepadOverride::NewInputStyleGamepadOverride' has a wrong offset!");

// Function Zion.ZionInputDeviceSubsystem.UnlockActiveController
// 0x0001 (0x0001 - 0x0000)
struct ZionInputDeviceSubsystem_UnlockActiveController final
{
public:
	bool                                          bResetLockCount;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionInputDeviceSubsystem_UnlockActiveController) == 0x000001, "Wrong alignment on ZionInputDeviceSubsystem_UnlockActiveController");
static_assert(sizeof(ZionInputDeviceSubsystem_UnlockActiveController) == 0x000001, "Wrong size on ZionInputDeviceSubsystem_UnlockActiveController");
static_assert(offsetof(ZionInputDeviceSubsystem_UnlockActiveController, bResetLockCount) == 0x000000, "Member 'ZionInputDeviceSubsystem_UnlockActiveController::bResetLockCount' has a wrong offset!");

// Function Zion.ZionInputDeviceSubsystem.GetInputStyle
// 0x0001 (0x0001 - 0x0000)
struct ZionInputDeviceSubsystem_GetInputStyle final
{
public:
	EInputStyle                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionInputDeviceSubsystem_GetInputStyle) == 0x000001, "Wrong alignment on ZionInputDeviceSubsystem_GetInputStyle");
static_assert(sizeof(ZionInputDeviceSubsystem_GetInputStyle) == 0x000001, "Wrong size on ZionInputDeviceSubsystem_GetInputStyle");
static_assert(offsetof(ZionInputDeviceSubsystem_GetInputStyle, ReturnValue) == 0x000000, "Member 'ZionInputDeviceSubsystem_GetInputStyle::ReturnValue' has a wrong offset!");

// Function Zion.ZionInputDeviceSubsystem.GetInputStyleGamepadOverride
// 0x0001 (0x0001 - 0x0000)
struct ZionInputDeviceSubsystem_GetInputStyleGamepadOverride final
{
public:
	EInputStyle                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionInputDeviceSubsystem_GetInputStyleGamepadOverride) == 0x000001, "Wrong alignment on ZionInputDeviceSubsystem_GetInputStyleGamepadOverride");
static_assert(sizeof(ZionInputDeviceSubsystem_GetInputStyleGamepadOverride) == 0x000001, "Wrong size on ZionInputDeviceSubsystem_GetInputStyleGamepadOverride");
static_assert(offsetof(ZionInputDeviceSubsystem_GetInputStyleGamepadOverride, ReturnValue) == 0x000000, "Member 'ZionInputDeviceSubsystem_GetInputStyleGamepadOverride::ReturnValue' has a wrong offset!");

// Function Zion.ZionInputDeviceSubsystem.IsActiveControllerLocked
// 0x0001 (0x0001 - 0x0000)
struct ZionInputDeviceSubsystem_IsActiveControllerLocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionInputDeviceSubsystem_IsActiveControllerLocked) == 0x000001, "Wrong alignment on ZionInputDeviceSubsystem_IsActiveControllerLocked");
static_assert(sizeof(ZionInputDeviceSubsystem_IsActiveControllerLocked) == 0x000001, "Wrong size on ZionInputDeviceSubsystem_IsActiveControllerLocked");
static_assert(offsetof(ZionInputDeviceSubsystem_IsActiveControllerLocked, ReturnValue) == 0x000000, "Member 'ZionInputDeviceSubsystem_IsActiveControllerLocked::ReturnValue' has a wrong offset!");

// Function Zion.ZionInputDeviceSubsystem.IsAnyGamepadConnected
// 0x0001 (0x0001 - 0x0000)
struct ZionInputDeviceSubsystem_IsAnyGamepadConnected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionInputDeviceSubsystem_IsAnyGamepadConnected) == 0x000001, "Wrong alignment on ZionInputDeviceSubsystem_IsAnyGamepadConnected");
static_assert(sizeof(ZionInputDeviceSubsystem_IsAnyGamepadConnected) == 0x000001, "Wrong size on ZionInputDeviceSubsystem_IsAnyGamepadConnected");
static_assert(offsetof(ZionInputDeviceSubsystem_IsAnyGamepadConnected, ReturnValue) == 0x000000, "Member 'ZionInputDeviceSubsystem_IsAnyGamepadConnected::ReturnValue' has a wrong offset!");

// Function Zion.ZionInputDeviceSubsystem.IsCursorVisible
// 0x0001 (0x0001 - 0x0000)
struct ZionInputDeviceSubsystem_IsCursorVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionInputDeviceSubsystem_IsCursorVisible) == 0x000001, "Wrong alignment on ZionInputDeviceSubsystem_IsCursorVisible");
static_assert(sizeof(ZionInputDeviceSubsystem_IsCursorVisible) == 0x000001, "Wrong size on ZionInputDeviceSubsystem_IsCursorVisible");
static_assert(offsetof(ZionInputDeviceSubsystem_IsCursorVisible, ReturnValue) == 0x000000, "Member 'ZionInputDeviceSubsystem_IsCursorVisible::ReturnValue' has a wrong offset!");

// Function Zion.ZionInputDeviceSubsystem.IsUsingGamepad
// 0x0001 (0x0001 - 0x0000)
struct ZionInputDeviceSubsystem_IsUsingGamepad final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZionInputDeviceSubsystem_IsUsingGamepad) == 0x000001, "Wrong alignment on ZionInputDeviceSubsystem_IsUsingGamepad");
static_assert(sizeof(ZionInputDeviceSubsystem_IsUsingGamepad) == 0x000001, "Wrong size on ZionInputDeviceSubsystem_IsUsingGamepad");
static_assert(offsetof(ZionInputDeviceSubsystem_IsUsingGamepad, ReturnValue) == 0x000000, "Member 'ZionInputDeviceSubsystem_IsUsingGamepad::ReturnValue' has a wrong offset!");

}

